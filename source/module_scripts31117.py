from header_operations import *
from header_common import *
from header_parties import *
from header_skills import *
from header_troops import *
from header_mission_templates import *
from header_items import *
from header_item_modifiers import *
from header_triggers import *
from header_terrain_types import *
from header_music import *
from header_map_icons import *
from header_presentations import *

from module_constants import *
from module_items import items

from . import economy, enterprise, tournaments, game_start, companions , caravans
import notes
import villages
import diplomacy
import mission_template_triggers
import village_elder.quest_deliver_cattle, \
    village_elder.quest_train_peasants, \
    village_elder.quest_deliver_grain
import battle
import patrols
import constable
import multiplayer
import minister


def get_hrd_weight(y):
  a = (y >> ibf_weight_bits) & ibf_armor_mask
  return int(25 * a)

def set_item_difficulty():
  item_difficulty = []
  for i_item in xrange(len(items)):
    item_difficulty.append((item_set_slot, i_item, "slot_item_difficulty", get_difficulty(items[i_item][6])))
  return item_difficulty[:]
  # #item_score.append((item_set_slot, i_item, "slot_item_needs_two_hands", items[i_item][3] & itp_two_handed))only needed if use equipbestweapon


def initialize_items_slots():
    item_score = []
    for i_item, item in enumerate(items):
        # item_score.append((item_set_slot, i_item, "slot_item_weight", get_hrd_weight(items[i_item][6])))

        type = item[3] & ibf_item_type_mask
        if type == itp_type_two_handed_wpn and item[3] & itp_two_handed == 0:
            item_score += [
                (item_set_slot, i_item, "slot_item_two_hand_one_hand", 1),
            ]
        if type == itp_type_shield:
            item_score += [
                (item_set_slot, i_item, "slot_item_length", get_weapon_length(item[6])),
                (item_set_slot, i_item, "slot_item_body_armor", get_body_armor(item[6])),
                (item_set_slot, i_item, "slot_item_speed", get_speed_rating(item[6])),
            ]
        elif type == itp_type_bow or type == itp_type_crossbow:
            item_score += [
                (item_set_slot, i_item, "slot_item_thrust_damage", get_thrust_damage(item[6])),
                (item_set_slot, i_item, "slot_item_swing_damage", get_swing_damage(item[6])),
                (item_set_slot, i_item, "slot_item_speed", get_speed_rating(item[6])),
            ]

        elif itp_type_one_handed_wpn <= type <= itp_type_thrown:
            item_score += [
                (item_set_slot, i_item, "slot_item_thrust_damage", get_thrust_damage(item[6]) & 0xff),
                (item_set_slot, i_item, "slot_item_swing_damage", get_swing_damage(item[6]) & 0xff),
                (item_set_slot, i_item, "slot_item_speed", get_speed_rating(item[6])),
                (item_set_slot, i_item, "slot_item_length", get_weapon_length(item[6])),
            ]

            # toggleable weapons
            if (item[3] & itp_next_item_as_melee == itp_next_item_as_melee) and type != itp_type_thrown:
                item_score += [
                    (item_set_slot, i_item, "slot_item_alternate", i_item + 1),
                    (item_set_slot, i_item + 1, "slot_item_alternate", i_item),
                ]

        elif itp_type_head_armor <= type <= itp_type_hand_armor:
            item_score += [
                (item_set_slot, i_item, "slot_item_head_armor", get_head_armor(item[6])),
                (item_set_slot, i_item, "slot_item_body_armor", get_body_armor(item[6])),
                (item_set_slot, i_item, "slot_item_leg_armor", get_leg_armor(item[6])),
            ]
        elif type == itp_type_horse:
            item_score += [
                (item_set_slot, i_item, "slot_item_horse_speed", get_missile_speed(item[6])),
                (item_set_slot, i_item, "slot_item_horse_armor", get_body_armor(item[6])),
                (item_set_slot, i_item, "slot_item_horse_charge", get_thrust_damage(item[6])),
            ]
            # construct cross refs for alternate versions of weapons
            # noswing_name = 'noswing_' + items[i_item][0]
            # i_noswing = find_object (items, noswing_name)
            # if i_noswing > -1:
            #  item_score.append((item_set_slot, i_item, "slot_item_alternate", i_noswing))
            #  item_score.append((item_set_slot, i_noswing, "slot_item_alternate", i_item))
            ## item_modifier
    for i_modifier in xrange(len(modifiers)):
        item_score.append((item_set_slot, i_modifier, "slot_item_modifier_multiplier", modifiers[i_modifier][1]))
    return item_score


modifiers = [
 (imod_plain, 100),
 (imod_cracked, 50),
 (imod_rusty, 55),
 (imod_bent, 65),
 (imod_chipped, 72),
 (imod_battered, 75),
 (imod_poor, 80),
 (imod_crude, 83),
 (imod_old, 86),
 (imod_cheap, 90),
 (imod_fine, 190),
 (imod_well_made, 250),
 (imod_sharp, 160),
 (imod_balanced, 300),
 (imod_tempered, 600),
 (imod_deadly, 800),
 (imod_exquisite, 1200),
 (imod_masterwork, 1600),
 (imod_heavy, 190),
 (imod_strong, 490),
 (imod_powerful, 300),
 (imod_tattered, 50),
 (imod_ragged, 70),
 (imod_rough, 60),
 (imod_sturdy, 150),
 (imod_thick, 260),
 (imod_hardened, 360),
 (imod_reinforced, 600),
 (imod_superb, 250),
 (imod_lordly, 950),
 (imod_lame, 40),
 (imod_swaybacked, 60),
 (imod_stubborn, 90),
 (imod_timid, 180),
 (imod_meek, 180),
 (imod_spirited, 600),
 (imod_champion, 1150),
 (imod_fresh, 100),
 (imod_day_old, 100),
 (imod_two_day_old, 90),
 (imod_smelling, 40),
 (imod_rotten, 5),
 (imod_large_bag, 190)
]

# # Autoloot improved by rubik end
#chief motomataru formations end chief    
####################################################################################################################
# scripts is a list of script records.
# Each script record contns the following two fields:
# 1) Script id: The prefix "script_" will be inserted when referencing scripts.
# 2) Operation block: This must be a valid operation block. See header_operations.py for reference.
####################################################################################################################

scripts = [

#sea battles phaiak chief empieza Klabautermann
  # script_calculate_movement_to_pos1
  # for KLABAUTERMANN only
  # This scriptgives the next ship Position and also does some other stuff
  # Input: ":ship_number", pos1
  # Output: pos1
  
  ("calculate_movement_to_pos1",
    [
		### GET DATA
		(try_begin),
		  (store_script_param, ":ship_number", 1),
		  (scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		  #Befehle:
		  (scene_prop_get_slot, ":sail", ":ship_instance", 6),
		  (scene_prop_get_slot, ":rowing", ":ship_instance", 7),
		  (scene_prop_get_slot, ":rudder", ":ship_instance", 8),
		  #Letzter Stand
		  (scene_prop_get_slot, ":last_speed", ":ship_instance", 9),
		  (scene_prop_get_slot, ":last_turn", ":ship_instance", 10),
		(try_end),
	   
		### SAIL CALCULATION
		(try_begin),
		  (assign, ":sail_boost", 0),
		  (eq, ":sail", 1),					# hole function only if sail is set
		  (ge, "$wind_strange", 1),			# only if there is wind
		  (position_get_rotation_around_z, ":angle", pos1),
		  (assign, ":w_angle", "$wind_angle"),
		  (try_begin),
		    (ge, ":angle", ":w_angle"),
			(val_sub, ":angle", ":w_angle"),
			(assign, ":angle_diff", ":angle"),
		  (else_try),
		    (val_sub, ":w_angle", ":angle"),
			(assign, ":angle_diff", ":w_angle"),
		  (end_try),
		  (try_begin),
		    (ge, ":angle_diff", 180),
			(val_add, ":angle_diff", -360),
			(val_mul, ":angle_diff", -1),
		  (end_try),
		  (try_begin),
		    (is_between, ":angle_diff", 0, 30),
			(assign, ":sail_boost", 3),
		  (else_try),
		    (is_between, ":angle_diff", 30, 60),
			(assign, ":sail_boost", 2),
		  (else_try),
		    (is_between, ":angle_diff", 90, 120),
			(assign, ":sail_boost", 0),
		  (else_try),
		    (is_between, ":angle_diff", 120, 150),
			(assign, ":sail_boost", -1),
		  (else_try),
		    (is_between, ":angle_diff", 150, 180),
			(assign, ":sail_boost", -2),
		  (end_try),
		  (val_mul, ":sail_boost", "$wind_strange"), 
        (try_end),		
		
		### SPEED CALCULATION
		(try_begin),
          (assign, ":soll_speed", ":rowing"),
		  (val_add, ":soll_speed", ":sail_boost"),
		  (try_begin),
            (lt, ":last_speed", ":soll_speed"),
		    (val_add, ":last_speed", 1),
		  (else_try),
            (gt, ":last_speed", ":soll_speed"),
		    (val_add, ":last_speed", -1),
          (try_end),
		(try_end),

		### TURN CALCULATION
		(try_begin),
          (lt, ":last_turn", ":rudder"),
		  (val_add, ":last_turn", 1),
		(else_try),
          (gt, ":last_turn", ":rudder"),
		  (val_add, ":last_turn", -1),
        (try_end),
		
		(try_begin),										# Turn slow, when the speed is slow
          (gt, ":last_turn", ":last_speed"),
		  (gt, ":last_speed", 0),
		  (assign, ":last_turn", ":last_speed"),
		(else_try),
		  (le, ":last_speed", 0),							# No Turn if ship dirves backwards
		  (assign, ":last_turn", 0),
        (try_end),

		### HECK WATER
		(try_begin),
		  (gt, ":last_speed", 0),
		  (assign, ":power", ":last_speed"),
		  (val_mul, ":power", 10),
		  (prop_instance_get_position, pos14, ":ship_instance"),
		  (position_move_x, pos14, -900),	
		  (position_rotate_x, pos14, -90),
		  (particle_system_burst, "psys_heck_water", pos14, ":power"),
		(try_end),	
		
		### VALUE CALCULATION
		(try_begin),
		  (assign, ":x_fahrtweite", ":last_speed"),			# here last_speed has the function of the new speed
		  (val_mul, ":x_fahrtweite", 30),					# Speed multkiplikator orig=25
		  (assign, ":y_fahrtweite", ":last_turn"),			# here last_turn has the function of the new turn
		  (val_mul, ":y_fahrtweite", 14),					# turn multkiplikator
		  (assign, ":z_drehung", ":last_turn"),				# here last_turn has the function of the new turn
		  (val_mul, ":z_drehung", 2),						# turn multkiplikator
		  (assign, ":x_drehung", ":last_turn"),				# here last_pitch has the function of the new turn
		  (val_mul, ":x_drehung", -2.8),					# pitch multkiplikator
		  #(val_mul, ":nivellierung", -3),					# has to be the same like the value above!!!
		(try_end),
		
		  ### POSITION CALCULATION		
		(try_begin),	  
		  (position_move_x, pos1, ":x_fahrtweite"),
		  (position_move_y, pos1, ":y_fahrtweite"),
		  (position_rotate_z, pos1, ":z_drehung"),
		  (position_rotate_x, pos1, ":x_drehung"),
		(try_end),
		
		(try_begin),
		  ### OUTPUT  
		  (scene_prop_set_slot, ":ship_instance", 9, ":last_speed"),  
		  (scene_prop_set_slot, ":ship_instance", 10, ":last_turn"),  
		(try_end),			
  ]),

  # script_calculate_wank_to_pos1
  # for KLABAUTERMANN only
  # This scriptgives the next ship Position and also does some other stuff
  # Input: ":ship_number", pos1
  # Output: pos1
  
  ("calculate_wank_to_pos1",
    [
	  (try_begin),
	  
		### GET DATA
		(store_script_param, ":ship_number", 1),
		(scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		(scene_prop_get_slot, ":wank_state", ":ship_instance", 11),#Letzter Stand
		
		### CONDITIONS
		(call_script, "script_check_aground", ":ship_number"),
		(ge, reg12, 450),
		(ge, reg6, 450),
		
		### WANK CALCULATION	     
		(assign, ":wank", 0),
		(try_begin),
		  (eq, ":wank_state", 0),
		  (assign, ":wank", 2),
		(else_try),
		  (eq, ":wank_state", 2),
		  (assign, ":wank", -2),
        (try_end),
		
		(try_begin),
		  (lt, ":wank_state", 3),
		  (val_add, ":wank_state", 1),
		(else_try),
		  (assign, ":wank_state", 0),
		(try_end),

		### WATER SPLASH
		(try_begin),
		  (eq, ":wank_state", 1),
		  (prop_instance_get_position, pos4, ":ship_instance"),
		  (position_move_x, pos4, 1250),
		  (particle_system_burst, "psys_front_water", pos4, 70),
		  (try_begin),
		    (eq, "$player_ship_number", ":ship_number"),
			(play_sound, "snd_front_water", 1),
		  (try_end),
		(try_end),		

		  ### OUTPUT 	
		(try_begin),	  
		  (position_get_rotation_around_y, ":diff", pos1),
		  (val_mul, ":diff", -1),
		  (position_rotate_y, pos1, ":diff"),	# tabula rasa
		  (position_rotate_y, pos1, ":wank"),	# do it!
		  (scene_prop_set_slot, ":ship_instance", 11, ":wank_state"),  
		(try_end),
	  (try_end),
  ]),

  # script_ship_AI
  # for KLABAUTERMANN only
  # This script says the AI ships what to do
  # Input: ":ship1_number",
  # Output:
  
  ("ship_AI",
    [
		(try_begin),
		  ### GET DATA
		  (store_script_param, ":ship1_number", 1),
		  (neg|eq, ":ship1_number", "$player_ship_number"),
		  #(neg|eq, ":ship1_number", -1),
		  (scene_prop_get_instance, ":ship1_instance", "spr_klabautermann_ship1", ":ship1_number"),
		  (prop_instance_get_position, pos11, ":ship1_instance"),
		  (scene_prop_get_team, ":team_ship1", ":ship1_instance"),
		  (ge, ":team_ship1", 0),
		  
		  ### CALCULATE TARGET
		  (assign, ":last_distance", 100000),
		  (assign, ":target_ship", -1),
		  (scene_prop_get_num_instances, ":number_of_ships", "spr_klabautermann_ship1"),
		  (try_for_range,":ship2_number", 0, ":number_of_ships"),
		    (scene_prop_get_instance, ":ship2_instance", "spr_klabautermann_ship1", ":ship2_number"),
			(scene_prop_get_team, ":team_ship2", ":ship2_instance"),
			(neg|eq, ":team_ship2", ":team_ship1"),
			(neg|eq, ":team_ship2", -2),
			(scene_prop_get_slot, ":ship2_left_boardet_ship", ":ship2_instance", 14),
		    (scene_prop_get_slot, ":ship2_right_boardet_ship", ":ship2_instance", 15),
			(this_or_next|eq, ":ship2_left_boardet_ship", 0),
			(eq, ":ship2_right_boardet_ship", 0),
			(prop_instance_get_position, pos12, ":ship2_instance"),
			(get_distance_between_positions, ":distance", pos11, pos12),
			(try_begin),
			  (lt, ":distance", ":last_distance"),
			  (assign, ":last_distance", ":distance"),
			  (assign, ":target_ship", ":ship2_instance"),
			(try_end),
		  (try_end),
		  
		  ### CALCULATE COMMANDS
		  (try_begin),
		    (eq, ":target_ship", -1),
			(assign, ":rudder", 0),
			(assign, ":rowing", 0),
		  (else_try),
		    (prop_instance_get_position, pos12, ":target_ship"),
			(prop_instance_get_position, pos11, ":ship1_instance"),
		    (position_move_y, pos11, 260),
		    (get_distance_between_positions, ":left_dist", pos12, pos11),
			(position_move_y, pos11, -520),		  
			(get_distance_between_positions, ":right_dist", pos12, pos11),
			(assign, ":rowing", 4),
			(try_begin),
			  (lt, ":right_dist", ":left_dist"),
			  (assign, ":rudder", -3),			
			(else_try),
			  (lt, ":left_dist", ":right_dist"),
			  (assign, ":rudder", 3),
		    (else_try),
		      (eq, ":left_dist", ":right_dist"),
			  (assign, ":rudder", 0),
			  #(display_message,"@left_right_equal!"),
		    (end_try),
		  (end_try),
		  
		  ### SAIL CALCULATION
		  (try_begin),
            (assign, ":sail", 0),
		    (position_get_rotation_around_z, ":angle", pos1),
		    (assign, ":w_angle", "$wind_angle"),
		  (end_try),
		  (try_begin),
		    (ge, ":angle", ":w_angle"),
			(val_sub, ":angle", ":w_angle"),
			(assign, ":angle_diff", ":angle"),
		  (else_try),
		    (val_sub, ":w_angle", ":angle"),
			(assign, ":angle_diff", ":w_angle"),
		  (end_try),
		  (try_begin),
		    (ge, ":angle_diff", 180),
			(val_add, ":angle_diff", -360),
			(val_mul, ":angle_diff", -1),
		  (end_try),
		  (try_begin),
		    (ge, "$wind_strange", 1),			# only if there is wind
		    (is_between, ":angle_diff", 0, 60),
			(assign, ":sail", 1),
		  (end_try),	
		  ### OUTPUT
		  (scene_prop_set_slot, ":ship1_instance", 6, ":sail"),  
		  (scene_prop_set_slot, ":ship1_instance", 7, ":rowing"), 
		  (scene_prop_set_slot, ":ship1_instance", 8, ":rudder"), 
		(try_end),
  ]),  
  
  # script_calculate_collisionreaction_to_pos1
  # for KLABAUTERMANN only
  # This script says how to reacht on collisions
  # Input: ":collided_scene_prop_instance", pos1
  # Output: pos1
  
  ("calculate_collisionreaction_to_pos1",
    [
		(try_begin),
		  ### GET DATA
		  (store_script_param, ":collided_scene_prop_instance", 1),
		  (prop_instance_get_position, pos2, ":collided_scene_prop_instance"),	
		  ### CALCULATION	     
		  (position_get_x, ":x1", pos1),
		  (position_get_y, ":y1", pos1),
		  (position_get_x, ":x2", pos2),
		  (position_get_y, ":y2", pos2),
		  (val_sub, ":x1", ":x2"),
		  (val_sub, ":y1", ":y2"),
		  (val_div, ":x1", 7),
		  (val_div, ":y1", 7),
		  (position_move_x, pos1, ":x1", 1),
		  (position_move_y, pos1, ":y1", 1),
		(try_end),		
  ]), 

  # script_calculate_embark_to_pos1
  # for KLABAUTERMANN only
  # This script says how to reacht on collisions
  # Input: ":aground_site", pos1
  # Output: pos1
  
  ("calculate_embark_to_pos1",
    [
		(try_begin),
		  ### GET DATA
		  (store_script_param, ":aground_site", 1),	
		  ### CALCULATION	     
		  (try_begin),
		    (eq, ":aground_site", 12),
			(position_move_x, pos1, -200),
		  (else_try),
		    (eq, ":aground_site", 6),
			(position_move_x, pos1, 200),
		  (else_try),
		    (eq, ":aground_site", 3),
			(position_move_y, pos1, -200),
		  (else_try),
		    (eq, ":aground_site", 9),
			(position_move_y, pos1, 200),
		  (else_try),
		    (eq, ":aground_site", 1),
			(position_move_y, pos1, -80),
			(position_move_x, pos1, -80),
		  (else_try),
		    (eq, ":aground_site", 11),
			(position_move_y, pos1, 80),
			(position_move_x, pos1, -80),
		  (try_end),
		(try_end),		
  ]),   
 
  # script_calculate_meetingpoint_to_pos1
  # for KLABAUTERMANN only
  # This script says how to react on collisions
  # Input: "ship1_number", ":ship2_instance", pos1
  # Output: pos1
  
  ("calculate_meetingpoint_to_pos1",
    [
		(try_begin),
		  ### GET DATA
		  (store_script_param, ":ship1_number", 1),
		  (scene_prop_get_instance, ":ship1_instance", "spr_klabautermann_ship1", ":ship1_number"),
		  (store_script_param, ":ship2_instance", 2),
		  (prop_instance_get_position, pos2, ":ship2_instance"),
		  (scene_prop_get_slot, ":boarding_progress", ":ship1_instance", 16),
		  
		  ### PART 1 ANGLE-CALCULATION	     
		  (position_get_rotation_around_z, ":angle1", pos1),
		  (position_get_rotation_around_z, ":angle2", pos2),
		  (try_begin),
		    (ge, ":angle1", ":angle2"),
			(val_sub, ":angle1", ":angle2"),
			(assign, ":angle_diff", ":angle1"),
			(assign,":flip", -1),				# was negativ
		  (else_try),
		    (val_sub, ":angle2", ":angle1"),
			(assign, ":angle_diff", ":angle2"),
			(assign,":flip", 1),				# was positiv
		  (end_try),
		  (try_begin),
		    (ge, ":angle_diff", 180),
			(val_add, ":angle_diff", -360),
			(val_mul, ":angle_diff", -1),
			(val_mul,":flip", -1),
		  (end_try),
		  (try_begin),
		    (ge, ":angle_diff", 90),
			(val_add, ":angle_diff", -180),
			(val_mul, ":angle_diff", -1),
			(val_mul,":flip", -1),
		  (end_try),		  
		  (val_mul,":angle_diff", ":flip"),
		  (val_div,":angle_diff", 2),
		  (val_div,":angle_diff", ":boarding_progress"),		  

		  ### PART 2 POSITION-CALCULATION
		  (prop_instance_get_position, pos2, ":ship2_instance"),
		  (prop_instance_get_position, pos1, ":ship1_instance"),

		  (position_get_x, ":x1", pos1),
		  (position_get_y, ":y1", pos1),
		  (position_get_x, ":x2", pos2),
		  (position_get_y, ":y2", pos2),
		  (val_sub, ":x1", ":x2"),
		  (val_sub, ":y1", ":y2"),
		  (val_div, ":x1", -2),
		  (val_div, ":y1", -2),
		  
		  (val_div, ":x1", ":boarding_progress"),
		  (val_div, ":y1", ":boarding_progress"),
		  
		  (copy_position, pos3, pos1),
		  (position_move_x, pos3, ":x1", 1),
		  (position_move_y, pos3, ":y1", 1),
		  (position_rotate_z, pos3, ":angle_diff"),
		  (copy_position, pos4, pos3),
		  (position_move_y, pos4, 260),
		  (position_move_y, pos3, -260),		  
		  
		  ### PART 3 POSITION-DECISION
		  (get_distance_between_positions, ":left_dist", pos4, pos1),
		  (get_distance_between_positions, ":right_dist", pos3, pos1),
		  (try_begin),
		    (le, ":right_dist", ":left_dist"),
			(copy_position, pos1, pos3),
			(display_debug_message,"@right_position"),
			(scene_prop_set_slot, ":ship1_instance", 14, ":ship2_instance"),
			(scene_prop_set_slot, ":ship1_instance", 15, 0),		# because it is possible that the position is changing in the three steps		
		  (else_try),
		    (le, ":left_dist", ":right_dist"),
		    (copy_position, pos1, pos4),
			(display_debug_message,"@left_position"),
			(scene_prop_set_slot, ":ship1_instance", 15, ":ship2_instance"),
			(scene_prop_set_slot, ":ship1_instance", 14, 0),		# because it is possible that the position is changing in the three steps
		  (else_try),
		    (display_debug_message,"@ERROR!_KEINE_ENTSCHEIDUNG!"),
		  (end_try),
		  ### OUTPUT
		  (val_sub, ":boarding_progress", 1),
		  (scene_prop_set_slot, ":ship1_instance", 16, ":boarding_progress"),  
		(try_end),		
  ]),  

  # script_calculate_dockingpoint_to_pos1
  # for KLABAUTERMANN only
  # This script says how to react on collisions
  # Input: "ship1_number", ":ship2_instance", pos1
  # Output: pos1
  
  ("calculate_dockingpoint_to_pos1",		# changed!!!
    [
		(try_begin),
		  ### GET DATA
		  (store_script_param, ":ship1_number", 1),
		  (scene_prop_get_instance, ":ship1_instance", "spr_klabautermann_ship1", ":ship1_number"),
		  (scene_prop_get_slot, ":boarding_progress", ":ship1_instance", 16),
		  (store_script_param, ":ship2_instance", 2),
		  (scene_prop_get_slot, ":ship2_left_boardet_ship", ":ship2_instance", 14),
		  (scene_prop_get_slot, ":ship2_right_boardet_ship", ":ship2_instance", 15),
		  (prop_instance_get_position, pos2, ":ship2_instance"),
		  (try_begin),
		    (eq, ":ship1_instance", ":ship2_left_boardet_ship"),
			(position_move_y, pos2, 520),
			(assign, ":side", -1),
		  (else_try),
		    (eq, ":ship1_instance", ":ship2_right_boardet_ship"),
			(position_move_y, pos2, -520),
			(assign, ":side", 1),
		  (else_try),
		     (display_debug_message,"@Error_1_in_calculate_dockingpoint"),
		  (end_try),

		  ### PART 1 ANGLE-CALCULATION	     
		  (position_get_rotation_around_z, ":angle1", pos1),
		  (position_get_rotation_around_z, ":angle2", pos2),
		  (try_begin),
		    (ge, ":angle1", ":angle2"),
			(val_sub, ":angle1", ":angle2"),
			(assign, ":angle_diff", ":angle1"),
			(assign,":flip", -1),								# was negativ
		  (else_try),
		    (val_sub, ":angle2", ":angle1"),
			(assign, ":angle_diff", ":angle2"),
			(assign,":flip", 1),
		  (end_try),
		  (try_begin),
		    (ge, ":angle_diff", 180),
			(val_add, ":angle_diff", -360),
			(val_mul, ":angle_diff", -1),
			(val_mul,":flip", -1),
		  (end_try),
		  (try_begin),
		    (ge, ":angle_diff", 90),
			(val_add, ":angle_diff", -180),
			(val_mul, ":angle_diff", -1),
			(val_mul,":flip", -1),
			(val_mul, ":side", -1),
		  (end_try),		  
		  (val_mul,":angle_diff", ":flip"),
		  (val_div,":angle_diff", ":boarding_progress"),		  

		  ### PART 2 POSITION-CALCULATION
		  (position_get_x, ":x1", pos1),
		  (position_get_y, ":y1", pos1),
		  (position_get_x, ":x2", pos2),
		  (position_get_y, ":y2", pos2),
		  (val_sub, ":x1", ":x2"),
		  (val_sub, ":y1", ":y2"),
		  (val_div, ":x1", -1),
		  (val_div, ":y1", -1),		  
		  (val_div, ":x1", ":boarding_progress"),
		  (val_div, ":y1", ":boarding_progress"),
		  (position_move_x, pos1, ":x1", 1),
		  (position_move_y, pos1, ":y1", 1),
		  (position_rotate_z, pos1, ":angle_diff"),		  	  
		  
		  (try_begin),
            (eq, ":side", 1),	  
			(scene_prop_set_slot, ":ship1_instance", 14, ":ship2_instance"), 
			(scene_prop_set_slot, ":ship1_instance", 15, 0),
		  (else_try),
			(eq, ":side", -1),
			(scene_prop_set_slot, ":ship1_instance", 15, ":ship2_instance"), 
			(scene_prop_set_slot, ":ship1_instance", 14, 0),
		  (end_try),
		  
		  ### OUTPUT
		  (val_sub, ":boarding_progress", 1),
		  (scene_prop_set_slot, ":ship1_instance", 16, ":boarding_progress"),  
		(try_end),		
  ]),    
  
  # script_check_collision
  # for KLABAUTERMANN only
  # This script checks_ship_collisions
  # Input: ":ship_number"
  # Output: ":collided_ship" (reg0)
  
  ("check_collision",
    [
		### GET DATA	
		(try_begin),
		  (store_script_param, ":ship1_number", 1),
		  (scene_prop_get_instance, ":ship1_instance", "spr_klabautermann_ship1", ":ship1_number"),
		  (scene_prop_get_slot, ":ship1_sail_off_instance", ":ship1_instance", 17),
		  (scene_prop_get_num_instances, ":number_of_ships", "spr_klabautermann_ship1"),
		  (assign, reg0, -1),
		(end_try),
		(try_for_range,":ship2_number", 0, ":number_of_ships"),
		  (neg|eq, ":ship1_number", ":ship2_number"),
		  (scene_prop_get_instance, ":ship2_instance", "spr_klabautermann_ship1", ":ship2_number"),
		  (scene_prop_get_slot, ":ship2_sail_off_instance", ":ship2_instance", 17),
		  (prop_instance_intersects_with_prop_instance, ":ship1_sail_off_instance", ":ship2_sail_off_instance"),
		  (assign, reg0, ":ship2_instance"),
		(try_end),
  ]),		

  # script_make_crew
  # for KLABAUTERMANN only
  # This script checks the owner of the ship
  # Input: ":ship_number"
  # Output: ":aground_site" (reg0)
  
  ("make_crew",
    [
		(try_begin),
		  (store_script_param, ":ship_number", 1),
		  (scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
          (try_for_agents,":agent"),
		    (agent_is_alive,":agent"),
		    (agent_is_human,":agent"),
		    (agent_is_non_player, ":agent"),
		    #(agent_get_team  , ":team", ":agent"),
			(scene_prop_has_agent_on_it, ":ship_instance", ":agent"),
			(agent_set_slot, ":agent", 23, ":ship_instance"),
		  (end_try),
		(end_try),
  ]),    
 
  # script_check_player_ship
  # for KLABAUTERMANN only
  # This script checks which is the ship of the player
  # Input: 
  # Output:
  
  ("check_player_ship",
    [
		(try_begin),
		  (get_player_agent_no, ":agent"),
		  (agent_is_alive,":agent"),
		  (agent_get_team, ":agent_team", ":agent"),
		  (scene_prop_get_num_instances, ":number_of_ships", "spr_klabautermann_ship1"),
		  (assign, "$player_ship_number", -1),
		  (try_for_range,":ship_number", 0, ":number_of_ships"),
		    (scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		    (scene_prop_has_agent_on_it, ":ship_instance", ":agent"),
			(scene_prop_get_team, ":team", ":ship_instance"),
			(eq, ":team", ":agent_team"),
			(assign, "$player_ship_number", ":ship_number"),
		  (try_end),
		(try_end),
  ]), 
  
  # script_check_ship_team
  # for KLABAUTERMANN only
  # This script checks the owner of the ship
  # Input: ":ship_number"
  # Output: -
  
  ("check_ship_team",
    [
		(try_begin),
		  (store_script_param, ":ship_number", 1),
		  (scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		  (assign, ":team_counter", 0),
		  (assign, ":agent_counter", 0),
          (try_for_agents,":agent"),
		    (agent_is_alive,":agent"),
		    (agent_is_human,":agent"),
		    #(agent_is_non_player, ":agent"),
			(scene_prop_has_agent_on_it, ":ship_instance", ":agent"),
		    (agent_get_team  , ":team", ":agent"),
		    (val_add, ":team_counter", ":team"),
			(val_add, ":agent_counter", 1),
		  (end_try),
		  (try_begin),
		    (eq, ":team_counter", ":agent_counter"),
			(gt, ":agent_counter", 0),
		    (scene_prop_set_team, ":ship_instance", 1),
		  (else_try),
		    (eq, ":team_counter", 0),
			(gt, ":agent_counter", 0),
		    (scene_prop_set_team, ":ship_instance", 0),
		  (else_try),
		    (eq, ":team_counter", 0),
			(scene_prop_set_team, ":ship_instance", -2),
		  (else_try),
		    (scene_prop_set_team, ":ship_instance", -1),
		  (end_try),
		(end_try),
  ]),  
  
  # script_check_aground
  # for KLABAUTERMANN only
  # This script checks collisions with the terrain
  # Input: ":ship_number"
  # Output: ":aground_site" (reg0) reg12, reg6
  
  ("check_aground",
    [
		(try_begin),
		  (store_script_param, ":ship_number", 1),
		  (scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		  (prop_instance_get_position, pos0, ":ship_instance"),
		  (position_move_x, pos0, 1200),
		  (position_get_distance_to_terrain, ":12Uhr_distance", pos0),
		  (position_move_x, pos0, -2300),
		  (position_get_distance_to_terrain, ":6Uhr_distance", pos0),
		  (position_move_x, pos0, 1100),
		  (position_move_y, pos0, 300),
		  (position_get_distance_to_terrain, ":3Uhr_distance", pos0),
		  (position_move_y, pos0, -600),
		  (position_get_distance_to_terrain, ":9Uhr_distance", pos0),
		  (position_move_y, pos0, 100),
		  (position_move_x, pos0, 700),
		  (position_get_distance_to_terrain, ":11Uhr_distance", pos0),
		  (position_move_y, pos0, 400),
		  (position_get_distance_to_terrain, ":1Uhr_distance", pos0),
		  (assign, reg0, -1),
		  (assign, reg12, ":12Uhr_distance"),
		  (assign, reg6, ":6Uhr_distance"),
		  (try_begin),
		    (this_or_next|le, ":12Uhr_distance", 50),
			(this_or_next|le, ":11Uhr_distance", 50),
			(this_or_next|le, ":9Uhr_distance", 50),
			(this_or_next|le, ":6Uhr_distance", 50),
			(this_or_next|le, ":3Uhr_distance", 50),
			(le, ":1Uhr_distance", 50),

			(try_begin),
			  (le, ":12Uhr_distance", ":11Uhr_distance"),
			  (le, ":12Uhr_distance", ":9Uhr_distance"),
			  (le, ":12Uhr_distance", ":6Uhr_distance"),
			  (le, ":12Uhr_distance", ":3Uhr_distance"),
			  (le, ":12Uhr_distance", ":1Uhr_distance"), 
			  (assign, reg0, 12),
			(else_try),
			  (le, ":6Uhr_distance", ":11Uhr_distance"),
			  (le, ":6Uhr_distance", ":9Uhr_distance"),
			  (le, ":6Uhr_distance", ":3Uhr_distance"),
			  (le, ":6Uhr_distance", ":1Uhr_distance"),
			  (assign, reg0, 6),
			(else_try),
			  (le, ":3Uhr_distance", ":11Uhr_distance"),
			  (le, ":3Uhr_distance", ":9Uhr_distance"),
			  (le, ":3Uhr_distance", ":1Uhr_distance"),
			  (assign, reg0, 3),
			(else_try),
			  (le, ":9Uhr_distance", ":11Uhr_distance"),
			  (le, ":9Uhr_distance", ":1Uhr_distance"),
			  (assign, reg0, 9),
			(else_try),
			  (le, ":11Uhr_distance", ":1Uhr_distance"),
			  (assign, reg0, 11),
			(else_try),
			  (assign, reg0, 1),
			(end_try),
		  (end_try), 
		(end_try),
  ]),  
  
  # script_set_crew_free
  # for KLABAUTERMANN only
  # This script 
  # Input: ":ship_number"
  # Output: -
  
  ("set_crew_free",		
    [
	  (try_begin),
	  	### GET DATA	
		(store_script_param, ":ship_number", 1),
		(scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		### KEEP CREW ON BOARD
        (try_for_agents,":agent"),
		  (agent_is_alive,":agent"),
		  (agent_is_human,":agent"),
		  (agent_is_non_player, ":agent"),
		  (agent_get_slot, ":crewmate_of_ship_instance", ":agent", 23),
		  (eq, ":crewmate_of_ship_instance", ":ship_instance"),
		  (agent_clear_scripted_mode, ":agent"),
		(end_try),
	  (end_try),
  ]),
  
  # script_keep_crew_on_board
  # for KLABAUTERMANN only
  # This script holds a crew on board
  # Input: ":ship_number"
  # Output: -
  
  ("keep_crew_on_board",		
    [
	  (try_begin),
	  	### GET DATA	
		(store_script_param, ":ship_number", 1),
		(scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		### KEEP CREW ON BOARD
		(assign, ":agent_counter", 0),
          (try_for_agents,":agent"),
			(agent_is_alive,":agent"),
			(agent_is_human,":agent"),
		    (agent_is_non_player, ":agent"),
			(agent_get_slot, ":crewmate_of_ship_instance", ":agent", 23),
			(eq, ":crewmate_of_ship_instance", ":ship_instance"),
			(try_begin),
			  (le, ":agent_counter", 0),
			  (prop_instance_get_position, pos4, ":ship_instance"),
			  (position_move_x, pos4, -800),
              #(agent_set_scripted_destination,":agent",pos4,0),
			(else_try), 
			  (eq, ":agent_counter", 1),
			  (prop_instance_get_position, pos4, ":ship_instance"),
			  (position_move_x, pos4, 500),
			  (position_move_y, pos4, 150),
			(else_try), 
			  (eq, ":agent_counter", 8),
			  (prop_instance_get_position, pos4, ":ship_instance"),
			  (position_move_x, pos4, 500),
			  (position_move_y, pos4, -150),
			(else_try), 
			  (eq, ":agent_counter", 15),
			  (prop_instance_get_position, pos4, ":ship_instance"),
			  (position_move_x, pos4, 900),
			  (position_move_y, pos4, 50),
			(else_try), 
			  (eq, ":agent_counter", 26),
			  (prop_instance_get_position, pos4, ":ship_instance"),
			  (position_move_x, pos4, 900),
			  (position_move_y, pos4, -50),
			(else_try),
			  (ge, ":agent_counter", 38),
			  (prop_instance_get_position, pos4, ":ship_instance"),
			(end_try),
			
			(try_begin),
			  (agent_set_scripted_destination,":agent",pos4,0),
			  (position_move_x, pos4, -150),
			  (val_add, ":agent_counter", 1),
			(end_try),
			
		  (end_try),
		(end_try),
  ]),

  # script_set_ships_and_crew
  # for KLABAUTERMANN only
  # This script adds all additional ships and puts the crews on them
  # Input: -
  # Output: -
  
  ("set_ships_and_crew",
    [
	  (try_begin),
		(assign, ":agent_counter", -1),				# Friendly Crew and ships
		(assign, ":actual_team", 1),
		(assign, ":actual_ship_instance", -1),
		(assign, ":ship_x-distance", -2000),
		(entry_point_get_position, pos5,0),			# Entry Point is next spawnpoint
		(try_begin),
		  (eq, "$coastal_assault", 1),				# other entry point for coastal assault
		  (entry_point_get_position, pos5,8),
		(end_try),
		(position_set_z, pos5, -80),				# high of the ship
		(position_rotate_z, pos5, 90),				# correkt angle
		(set_spawn_position, pos5),
		
		(try_for_agents,":agent"),
		  (agent_is_alive,":agent"),
          (agent_is_human,":agent"),
  	      (agent_is_ally,":agent"),
		  (agent_is_non_player, ":agent"),
		  (try_begin),
			(try_begin),
			  (ge, ":agent_counter", 37),		# means one ship is full
			  (neg|eq, "$coastal_assault", 1),
			  (assign, ":agent_counter", 0),				
			  (position_move_y, pos5, 2000),
			  (position_move_x, pos5, ":ship_x-distance"),
			  (val_mul, ":ship_x-distance", -1),
			  (set_spawn_position, pos5),
			(end_try),
			(try_begin),
			  (le, ":agent_counter", 0),
			  (this_or_next|neg|eq, "$coastal_assault", 1),		# onlyone ship for coastal assault
			  (le, ":agent_counter", -1),						# that is no good work...
			  
			  (spawn_scene_prop, "spr_klabautermann_ship1"),
			  (assign, ":actual_ship_instance", reg0),
			  (scene_prop_set_visibility, ":actual_ship_instance", 0),
			  (spawn_scene_prop, "spr_klabautermann_ship1_sail_off"),
			  (scene_prop_set_slot, ":actual_ship_instance", 17, reg0), # assigns sail-off-instance to the other instance			  
			  (spawn_scene_prop, "spr_klabautermann_ship1_planks_a"),
			  (scene_prop_set_slot, ":actual_ship_instance", 18, reg0), # assigns plank-instance to the ship-instance
			  (scene_prop_set_visibility, reg0, 0),
			  (spawn_scene_prop, "spr_klabautermann_ship1_planks_b"),
			  (scene_prop_set_slot, ":actual_ship_instance", 19, reg0), # assigns plank-instance to the ship-instance
			  (scene_prop_set_visibility, reg0, 0),
			  (scene_prop_set_team, ":actual_ship_instance", ":actual_team"),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, -800),
			  (try_begin),
				(le, ":agent_counter", -1),
				(get_player_agent_no, ":player_agent"),					# puts the player on deck of the first ship
				(prop_instance_get_position, pos9, ":actual_ship_instance"),
			    (position_move_x, pos9, -800),
				(position_move_x, pos4, 150),
				(position_set_z, pos4, +80),
				(agent_set_position,":player_agent",pos4,0),
				(agent_set_slot, ":player_agent", 23, ":actual_ship_instance"),	
				(position_move_x, pos4, -150),
			  (end_try),
			  (assign, ":agent_counter", 0),
			(else_try), 
			  (eq, ":agent_counter", 1),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, 500),
			  (position_move_y, pos4, 150),
			(else_try), 
			  (eq, ":agent_counter", 8),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, 500),
			  (position_move_y, pos4, -150),
			(else_try), 
			  (eq, ":agent_counter", 15),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, 900),
			  (position_move_y, pos4, 50),
			(else_try), 
			  (eq, ":agent_counter", 26),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, 900),
			  (position_move_y, pos4, -50),
			#(else_try),
			#  (ge, ":agent_counter", 38),
			#  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			(end_try),
			(try_begin),
			  (le, ":agent_counter", 37),	# for limiting crew if it is coastal assault
			  (position_set_z, pos4, +80),
			  (agent_set_position,":agent",pos4,0),
			  (agent_set_slot, ":agent", 23, ":actual_ship_instance"),
			  (position_move_x, pos4, -150),
			  (val_add, ":agent_counter", 1),
			(end_try),		  
		  (end_try),
		(end_try),
		
		(assign, ":agent_counter", 50),				# Enemy Crew and ships
		(assign, ":actual_team", 0),
		(assign, ":ship_x_distance", -2000),
		(entry_point_get_position, pos5, 10),		# Entry Point is next spawnpoint
		(position_set_z, pos5, -80),				# high of the ship
		(position_rotate_z, pos5, 90),				# correkt angle
		(set_spawn_position, pos5),
		
		(try_for_agents,":agent"),
		  (neg|eq, "$coastal_assault", 1),			# no enemy ship for coastal assault
		  (agent_is_alive,":agent"),
          (agent_is_human,":agent"),
  	      (neg|agent_is_ally,":agent"),
		  (try_begin),
			(try_begin),
			  (ge, ":agent_counter", 37),		# means one ship is full
			  (assign, ":agent_counter", 0),		  
			(end_try),
			(try_begin),
			  (le, ":agent_counter", 0),
			  (neg|eq, "$coastal_assault", 1),		# no ship for coastal assault
			  (assign, ":agent_counter", 0),
			  (spawn_scene_prop, "spr_klabautermann_ship1"),
			  (assign, ":actual_ship_instance", reg0),
			  (scene_prop_set_visibility, reg0, 0),
			  (spawn_scene_prop, "spr_klabautermann_ship1_sail_off"),
			  (scene_prop_set_slot, ":actual_ship_instance", 17, reg0), # assigns sail-off-instance to the other instance
			  (scene_prop_set_team, ":actual_ship_instance", ":actual_team"),
			  (spawn_scene_prop, "spr_klabautermann_ship1_planks_a"),
			  (scene_prop_set_slot, ":actual_ship_instance", 18, reg0), # assigns plank-instance to the ship-instance
			  (scene_prop_set_visibility, reg0, 0),
			  (spawn_scene_prop, "spr_klabautermann_ship1_planks_b"),
			  (scene_prop_set_slot, ":actual_ship_instance", 19, reg0), # assigns plank-instance to the ship-instance
			  (scene_prop_set_visibility, reg0, 0),		  
			  (position_move_y, pos5, -2000),
			  (position_move_x, pos5, ":ship_x_distance"),
			  (val_mul, ":ship_x_distance", -1),
			  (set_spawn_position, pos5),
			  
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, -800),
              #(agent_set_scripted_destination,":agent",pos4,0),
			(else_try), 
			  (eq, ":agent_counter", 1),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, 500),
			  (position_move_y, pos4, 150),
			(else_try), 
			  (eq, ":agent_counter", 8),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, 500),
			  (position_move_y, pos4, -150),
			(else_try), 
			  (eq, ":agent_counter", 15),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, 900),
			  (position_move_y, pos4, 50),
			(else_try), 
			  (eq, ":agent_counter", 26),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			  (position_move_x, pos4, 900),
			  (position_move_y, pos4, -50),
			(else_try),
			  (ge, ":agent_counter", 38),
			  (prop_instance_get_position, pos4, ":actual_ship_instance"),
			(end_try),
			(try_begin),
			  (position_set_z, pos4, +80),
			  (agent_set_position,":agent",pos4,0),
			  (agent_set_slot, ":agent", 23, ":actual_ship_instance"),
			  (position_move_x, pos4, -150),
			  (val_add, ":agent_counter", 1),
			(end_try),	
		  (end_try),
		(end_try),
	  (end_try),
  ]),

  # script_put_the_Klabautermann_into_the_ships
  # for KLABAUTERMANN only
  # This script controls all
  # Input: -
  # Output: all actions
  
  ("put_the_klabautermann_into_the_ships",			# changed!!!
    [
		(call_script, "script_check_player_ship"),
		(scene_prop_get_num_instances, ":number_of_ships", "spr_klabautermann_ship1"),
		(try_for_range,":ship_number", 0, ":number_of_ships"),
		  (scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		  (call_script, "script_check_ship_team", ":ship_number"),
		  (scene_prop_get_team, ":team_ship", ":ship_instance"),
		  (call_script, "script_check_aground", ":ship_number"),
		  (assign, ":aground_side", reg0),
		  (call_script, "script_check_collision", ":ship_number"),
		  (assign, ":ship2_instance", reg0),
		  (scene_prop_get_slot, ":boarding_wanted", ":ship_instance", 12),
		  (scene_prop_get_slot, ":landing_wanted", ":ship_instance", 13),
		  (scene_prop_get_slot, ":left_boardet_ship", ":ship_instance", 14),
		  (scene_prop_get_slot, ":right_boardet_ship", ":ship_instance", 15),
		  (scene_prop_get_slot, ":boarding_progress", ":ship_instance", 16),
		  (prop_instance_get_position, pos1, ":ship_instance"),	  								# pos1 will be the next destination
		  (position_get_rotation_around_x, ":nivellierung", pos1),
		  (val_mul, ":nivellierung", -1),
		  (position_rotate_x, pos1, ":nivellierung"),											# NIVELLIERUNG (modifies pos1)
		  (try_begin),
		    ### FREE MOVE
		    (eq, ":ship2_instance", -1),		# means NO collision
			(eq, ":aground_side", -1),			# means NO aground
			(eq, ":left_boardet_ship", 0),		# v
			(eq, ":right_boardet_ship", 0),		# means NO boarding 
			(eq, ":boarding_progress", 0),		# means NO boarding progress
			(try_begin),
		      (ge, ":team_ship", 0),
			  (call_script, "script_ship_AI", ":ship_number"),
		    (try_end),
			(call_script, "script_ship_AI", ":ship_number"),
		    (call_script, "script_calculate_movement_to_pos1", ":ship_number"),								
		    (call_script, "script_keep_crew_on_board", ":ship_number"),

		  (else_try),
		    ### AGROUND
			(ge, ":aground_side", 0),			# means aground
			(scene_prop_set_slot, ":ship_instance", 9, 0), # sets last_speed wanted to 0
			(try_begin),
			  (eq, ":landing_wanted", 1),
			  (eq, ":boarding_progress", 0),
			  (display_message,"@Aground!"),
			  (call_script, "script_set_crew_free", ":ship_number"),
			  (assign, ":boarding_progress", -1),	
			(else_try),
			  (eq, ":landing_wanted", 0),
			  (display_message,"@Aground!"),
			  (call_script, "script_calculate_embark_to_pos1", ":aground_side"),		
		      (call_script, "script_keep_crew_on_board", ":ship_number"),
			  (try_begin),
			    (eq, ":boarding_progress", -1),
			    #(call_script, "script_delete_planks", ":ship_number"),
				(assign, ":boarding_progress", 0),
			  (try_end),
			(try_end),
			(scene_prop_set_slot, ":ship_instance", 16, ":boarding_progress"),
			
		  (else_try),
		    ### BOARDING
			(this_or_next|neg|eq, ":left_boardet_ship", 0),	# v
			(neg|eq, ":right_boardet_ship", 0),				# means boarding
			(eq, ":boarding_progress", 0),					# means NO boarding progress
			#(scene_prop_get_team, ":team_ship", ":ship_instance"),
			(try_begin),									# Check left ship
			  (eq, ":left_boardet_ship", 0),
			  (assign, ":left_allowed", 1),
			  (scene_prop_set_slot, ":ship_instance", 14, 0),  
			(else_try),
			  (neg|eq, ":left_boardet_ship", 0),
			  (scene_prop_get_slot, ":left_ship_boarding_wanted", ":left_boardet_ship", 12),
			  (scene_prop_get_team, ":team_left_ship", ":left_boardet_ship"),
			  (this_or_next|eq, ":boarding_wanted", -1),
			  (eq, ":left_ship_boarding_wanted", -1),
			  (this_or_next|eq, ":team_left_ship", ":team_ship"),
			  (eq, ":team_left_ship", -1),
			  (assign, ":left_allowed", 1),
			  (scene_prop_set_slot, ":ship_instance", 14, 0),
			(else_try),
			  (assign, ":left_allowed", 0),
			(end_try),
			(try_begin),									# Check right ship
			  (eq, ":right_boardet_ship", 0),
			  (assign, ":right_allowed", 1),
			  (scene_prop_set_slot, ":ship_instance", 15, 0),  
			(else_try),
			  (neg|eq, ":right_boardet_ship", 0),
			  (scene_prop_get_slot, ":right_ship_boarding_wanted", ":right_boardet_ship", 12),
			  (scene_prop_get_team, ":team_right_ship", ":right_boardet_ship"),
			  (this_or_next|eq, ":boarding_wanted", -1),
			  (eq, ":right_ship_boarding_wanted", -1),
			  (this_or_next|eq, ":team_right_ship", ":team_ship"),
			  (eq, ":team_right_ship", -1),
			  (assign, ":right_allowed", 1),
			  (scene_prop_set_slot, ":ship_instance", 15, 0),
			(else_try),
			  (assign, ":right_allowed", 0),
			(end_try),
			(try_begin),	
			  ### BOARDING -> STOP 
			  (eq, ":left_allowed", 1),
			  (eq, ":right_allowed", 1),
			  (call_script, "script_make_crew", ":ship_number"),
			  (call_script, "script_keep_crew_on_board", ":ship_number"),
			  #(call_script, "script_delete_planks", ":ship_number"),
			  (display_debug_message, "@Boarding_Stopt!"),
			(else_try),
			  ### BOARDING -> CONTINUE
			(end_try),

		  (else_try),
		    ### BOARDING IN  PROGRESS
			(gt, ":boarding_progress", 0),		# means boarding is in progress
			(display_debug_message,"@boarding_in_progress!"),
			(try_begin),
		      (gt, ":left_boardet_ship", 0),
			  (assign, ":ship2_instance", ":left_boardet_ship"),
			(else_try),
			  (gt, ":right_boardet_ship", 0),
			  (assign, ":ship2_instance", ":right_boardet_ship"),
			(else_try),
			  (display_debug_message,"@ERROR!_NO_SECOND_SHIP_FOUND!"),
			  (assign, ":ship2_instance", ":ship_instance"),
			(end_try),
			(scene_prop_get_slot, ":ship2_left_boardet_ship", ":ship2_instance", 14),
		    (scene_prop_get_slot, ":ship2_right_boardet_ship", ":ship2_instance", 15),
			(try_begin),
			  (this_or_next|eq, ":ship2_left_boardet_ship", 0),
		      (eq, ":ship2_right_boardet_ship", 0),
			  (try_begin),																		#	||	||	||
			    (prop_instance_get_position, pos2, ":ship2_instance"),							#	\/	\/	\/
				(get_distance_between_positions, ":distance", pos1, pos2),						# Avoid getting same position
				(le, ":distance", 400),															# maybe has to get increased
			    (call_script, "script_calculate_collisionreaction_to_pos1", ":ship2_instance"),	
			  (else_try),
			    (prop_instance_get_position, pos2, ":ship2_instance"),							
				(copy_position, pos11, pos1),
				(position_move_x, pos11, 1000),
				(position_move_x, pos2, 1000),
				(get_distance_between_positions, ":distance", pos11, pos2),						
				(le, ":distance", 500),															
			    (call_script, "script_calculate_collisionreaction_to_pos1", ":ship2_instance"),	#	/\	/\	/\
			  (end_try),																		#	||	||	||
			  (call_script, "script_calculate_meetingpoint_to_pos1", ":ship_number", ":ship2_instance"),
			(else_try),  
			  (call_script, "script_calculate_dockingpoint_to_pos1", ":ship_number", ":ship2_instance"),
			(end_try),					
		    (try_begin),
		      (gt, ":boarding_progress", 1),
			  (call_script, "script_keep_crew_on_board", ":ship_number"),
			(else_try),  
			  (call_script, "script_set_crew_free", ":ship_number"),
			(end_try),

		  (else_try),
		    ### COLLISION
			(neg|eq, ":ship2_instance", -1),	# means collision
			(display_debug_message,"@Collision!"),			
			(try_begin),
			  (eq, ":ship_number", "$player_ship_number"),
			  (play_sound, "snd_crash", 1),
			(end_try),			
			(scene_prop_get_team, ":team_ship", ":ship_instance"),
			(scene_prop_get_team, ":team_ship2", ":ship2_instance"),
			(scene_prop_get_slot, ":ship2_boarding_wanted", ":ship2_instance", 12),
			(scene_prop_get_slot, ":ship2_left_boardet_ship", ":ship2_instance", 14),
			(scene_prop_get_slot, ":ship2_right_boardet_ship", ":ship2_instance", 15),
			(scene_prop_get_slot, ":ship2_boarding_progress", ":ship2_instance", 16),
			
			#(assign, ":enemy_ship_boarding", 0),
			#(assign, ":friendly_ship_boarding", 0),
			(try_begin),											# Ok, this is a bad trick and hard to explain (heuristik)
			  (eq, ":ship2_left_boardet_ship", ":ship_instance"),
			  (assign, ":ship2_left_boardet_ship", 0),
			  (assign, ":ship2_boarding_progress", 0),
			(end_try),
			(try_begin),
			  (eq, ":ship2_right_boardet_ship", ":ship_instance"),
			  (assign, ":ship2_right_boardet_ship", 0),
			  (assign, ":ship2_boarding_progress", 0),
			(end_try),
			
			(try_begin),
			  ### COLLISION -> ASSIGN BOARDING ENEMY SHIP
			  (eq, ":ship2_boarding_progress", 0), 					# to avoid problems
			  (this_or_next|neg|eq, ":team_ship", ":team_ship2"),				# has to be diff team
			  (eq, ":team_ship2", -1), # fights on ship
			  (this_or_next|ge, ":boarding_wanted", 0),				# v
			  (ge, ":ship2_boarding_wanted", 0),					# at least one ship has to want it
			  (this_or_next|eq, ":ship2_left_boardet_ship", 0),		# v
			  (eq, ":ship2_right_boardet_ship", 0),					# at least one side has to be free
			  (display_debug_message, "@Boarding_enemy_ship!"),
			  (assign, ":enemy_ship_boarding", 1),
			(else_try),  
			  ### COLLISION -> ASSIGN BOARDING FRIENDLY SHIP
			  (eq, ":ship2_boarding_progress", 0), 					# to avoid problems
			  (this_or_next|eq, ":team_ship", ":team_ship2"),
			  (eq, ":team_ship2", -2), # nobody on ship
			  (this_or_next|eq, ":boarding_wanted", 1),
			  (eq, ":ship2_boarding_wanted", 1),
			  (this_or_next|eq, ":ship2_left_boardet_ship", 0),		# v
			  (eq, ":ship2_right_boardet_ship", 0),					# at least one side has to be free
			  (display_debug_message, "@Boarding_f_ship!"),
			  (assign, ":friendly_ship_boarding", 1),
			(end_try),  
			
			(try_begin),
			  ### COLLISION -> INIATE BOARDING
			  (this_or_next|eq, ":enemy_ship_boarding", 1),				# v
			  (eq, ":friendly_ship_boarding", 1),					# at least one ship has to want it
			  (scene_prop_set_slot, ":ship_instance", 7, 0), # sets rowing wanted to 0
			  (scene_prop_set_slot, ":ship_instance", 8, 0), # sets rudder wanted to 0
			  (scene_prop_set_slot, ":ship_instance", 9, 0), # sets last_speed wanted to 0
			  (scene_prop_set_slot, ":ship_instance", 10, 0), # sets last_turn wanted to 0
			  (scene_prop_set_slot, ":ship_instance", 12, 0), 	# sets boarding wanted to 0
			  (assign, ":boarding_progress", 5),
			  (scene_prop_set_slot, ":ship_instance", 16, ":boarding_progress"),
			  (try_begin),
			    (eq, ":ship2_left_boardet_ship", 0),
			    (eq, ":ship2_right_boardet_ship", 0),
				(call_script, "script_calculate_meetingpoint_to_pos1", ":ship_number", ":ship2_instance"),
				(display_debug_message, "@Free_Boarding!"),				
			  (else_try),
			    (eq, ":ship2_left_boardet_ship", 0),				# already right side boardet
			    (neg|eq, ":ship2_right_boardet_ship", 0),
				#(scene_prop_set_slot, ":ship_instance", 15, ":ship2_instance"),
				(scene_prop_set_slot, ":ship2_instance", 14, ":ship_instance"),
				(call_script, "script_calculate_dockingpoint_to_pos1", ":ship_number", ":ship2_instance"),
				(display_debug_message, "@Forced_Boarding_left!"),	
			  (else_try),
			    (neg|eq, ":ship2_left_boardet_ship", 0),			# already left side boardet
			    (eq, ":ship2_right_boardet_ship", 0),
				#(scene_prop_set_slot, ":ship_instance", 14, ":ship2_instance"),
				(scene_prop_set_slot, ":ship2_instance", 15, ":ship_instance"),
				(call_script, "script_calculate_dockingpoint_to_pos1", ":ship_number", ":ship2_instance"),
				(display_debug_message, "@Forced_Boarding_right!"),
			  (end_try),			
		      (call_script, "script_keep_crew_on_board", ":ship_number"),
			
			(else_try),  
			  ### COLLISION -> JUST COLLIDE
			  (display_debug_message, "@just_collide!"),
			  (call_script, "script_calculate_collisionreaction_to_pos1", ":ship2_instance"),					
		      (call_script, "script_keep_crew_on_board", ":ship_number"),
			  
			(end_try),   
			
		  (end_try),
		  ### DO IT (get data)
		  (scene_prop_get_instance, ":ship_instance", "spr_klabautermann_ship1", ":ship_number"),
		  (scene_prop_get_slot, ":ship_sail_off_instance", ":ship_instance", 17),
		  (scene_prop_get_slot, ":ship_planks_a", ":ship_instance", 18),
		  (scene_prop_get_slot, ":ship_planks_b", ":ship_instance", 19),
		  ### SAIL
		  (scene_prop_get_slot, ":sail", ":ship_instance", 6),
		  (try_begin),				
			(eq, ":sail", 1),
			(scene_prop_get_visibility, ":visibility", ":ship_instance"),
			(eq, ":visibility", 0),
			(try_begin),
			  (eq, ":ship_number", "$player_ship_number"),
			  (play_sound, "snd_set_sail"),
			(end_try),
		    (scene_prop_set_visibility, ":ship_instance", 100),
		    (scene_prop_set_visibility, ":ship_sail_off_instance", 0),
		  (else_try),
            (eq, ":sail", 0),
		    (scene_prop_set_visibility, ":ship_instance", 0),
		    (scene_prop_set_visibility, ":ship_sail_off_instance", 100),
          (try_end),
		  (call_script, "script_calculate_wank_to_pos1", ":ship_number"),	
		  (position_set_z, pos1, -100),															# high of the ship
		  ### MOVE THE MAIN-INSTANCES
		  (prop_instance_animate_to_position, ":ship_instance", pos1, 130),
		  (prop_instance_animate_to_position, ":ship_sail_off_instance", pos1, 130),
		  ### MOVE THE OTHER INSTANCES
		  (try_begin),				
			(this_or_next|neg|eq, ":left_boardet_ship", 0),	# v
			(neg|eq, ":right_boardet_ship", 0),				# means boarding
			(le, ":boarding_progress", 1),					# means NO boarding progress
			(prop_instance_animate_to_position, ":ship_planks_a", pos1, 130),
			(eq, ":boarding_progress", 0),
			(scene_prop_set_visibility, ":ship_planks_a", 100),
		  (else_try),
			(eq, ":boarding_progress", -1),
			(prop_instance_animate_to_position, ":ship_planks_a", pos1, 130),
		    (prop_instance_animate_to_position, ":ship_planks_b", pos1, 130),
			(scene_prop_set_visibility, ":ship_planks_a", 100),
		  (else_try),
		    (position_move_z, pos1, -2000),
		    (prop_instance_animate_to_position, ":ship_planks_a", pos1, 130),
		    (prop_instance_animate_to_position, ":ship_planks_b", pos1, 130),
			(scene_prop_set_visibility, ":ship_planks_a", 0),
          (try_end),

		(try_end),
  ]),
#Klabautermann phaiak acaba

  #script_game_get_use_string
  # This script is called from the game engine for getting using information text
  # INPUT: used_scene_prop_id  
  # OUTPUT: s0
  ("game_get_use_string",
   [
     (store_script_param, ":instance_id", 1),

     (prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),
     
     (try_begin),
       (this_or_next|eq, ":scene_prop_id", "spr_winch_b"),
       (eq, ":scene_prop_id", "spr_winch"),
       (assign, ":effected_object", "spr_portcullis"),
     (else_try),
       (this_or_next|eq, ":scene_prop_id", "spr_door_destructible"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_b"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_e_sally_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_sally_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),
       (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_right"),
       (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
       (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_right"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_6m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_8m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_10m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_12m"),
       (eq, ":scene_prop_id", "spr_siege_ladder_move_14m"),
       (assign, ":effected_object", ":scene_prop_id"),
     (try_end),   

     (scene_prop_get_slot, ":item_situation", ":instance_id", "slot_scene_prop_open_or_close"),
   
     (try_begin), #opening/closing portcullis
       (eq, ":effected_object", "spr_portcullis"),

       (try_begin),
         (eq, ":item_situation", 0),
         (str_store_string, s0, "str_open_gate"),
       (else_try), 
         (str_store_string, s0, "str_close_gate"),
       (try_end),
     (else_try), #opening/closing door
       (this_or_next|eq, ":effected_object", "spr_door_destructible"),
       (this_or_next|eq, ":effected_object", "spr_castle_f_door_b"),
       (this_or_next|eq, ":effected_object", "spr_castle_e_sally_door_a"),
       (this_or_next|eq, ":effected_object", "spr_castle_f_sally_door_a"),
       (this_or_next|eq, ":effected_object", "spr_earth_sally_gate_left"),
       (this_or_next|eq, ":effected_object", "spr_earth_sally_gate_right"),
       (this_or_next|eq, ":effected_object", "spr_viking_keep_destroy_sally_door_left"),
       (this_or_next|eq, ":effected_object", "spr_viking_keep_destroy_sally_door_right"),
       (eq, ":effected_object", "spr_castle_f_door_a"),

       (try_begin),
         (eq, ":item_situation", 0),
         (str_store_string, s0, "str_open_door"),
       (else_try),
         (str_store_string, s0, "str_close_door"),
       (try_end),
     (else_try), #raising/dropping ladder
       (try_begin),
         (eq, ":item_situation", 0),
         (str_store_string, s0, "str_raise_ladder"),
       (else_try),
         (str_store_string, s0, "str_drop_ladder"),
       (try_end),
     (try_end),
#COOP chief ####################################    
     (try_begin),
       (eq, ":scene_prop_id", "spr_coop_inventory"),
       (str_store_string, s0, "@Access Inventory"),
     (try_end),
################################################
     ]),

  #script_get_army_size_from_slider_value
  # INPUT: arg1 = slider_value
  # OUTPUT: reg0 = army_size
  ("get_army_size_from_slider_value",
    [
     (store_script_param, ":slider_value", 1),
     (assign, ":army_size", ":slider_value"),
     (try_begin),
       (gt, ":slider_value", 25),
       (store_sub, ":adder_value", ":slider_value", 25),
       (val_add, ":army_size", ":adder_value"),
       (try_begin),
         (gt, ":slider_value", 50),
         (store_sub, ":adder_value", ":slider_value", 50),
         (val_mul, ":adder_value", 3),
         (val_add, ":army_size", ":adder_value"),
       (try_end),
     (try_end),
     (assign, reg0, ":army_size"),
  ]),
  
  #script_spawn_quick_battle_army
  # INPUT: arg1 = initial_entry_point, arg2 = faction_no, arg3 = infantry_ratio, arg4 = archers_ratio, arg5 = cavalry_ratio, arg6 = divide_archer_entry_points, arg7 = player_team
  # OUTPUT: none
  ("spawn_quick_battle_army",
   [
     (store_script_param, ":cur_entry_point", 1),
     (store_script_param, ":faction_no", 2),
     (store_script_param, ":infantry_ratio", 3),
     (store_script_param, ":archers_ratio", 4),
     (store_script_param, ":cavalry_ratio", 5),
     (store_script_param, ":divide_archer_entry_points", 6),
     (store_script_param, ":player_team", 7),

     (try_begin),
       (eq, ":player_team", 1),
       (call_script, "script_get_army_size_from_slider_value", "$g_quick_battle_army_1_size"),
      # Dunde's Custom Battle Balancing BEGIN chief
      #(assign, ":army_size", reg0),
      (store_sub, ":army_size", reg0, 1),
      # Dunde's Custom Battle Balancing END
#       (assign, ":army_size", reg0),
       (set_player_troop, "$g_quick_battle_troop"),
       (set_visitor, ":cur_entry_point", "$g_quick_battle_troop"),
       (try_begin),
         (eq, ":cur_entry_point", 0),
         (try_begin),
           (is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
           (faction_get_slot, "$g_quick_battle_team_0_banner", ":faction_no", "slot_faction_banner"),
         (else_try),
           (assign, "$g_quick_battle_team_0_banner", "mesh_banners_default_b"),
         (try_end),
       (else_try),
         (try_begin),
           (is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
           (faction_get_slot, "$g_quick_battle_team_1_banner", ":faction_no", "slot_faction_banner"),
         (else_try),
           (assign, "$g_quick_battle_team_1_banner", "mesh_banners_default_b"),
         (try_end),
       (try_end),
       (val_add, ":cur_entry_point", 1),

     (else_try),
       (call_script, "script_get_army_size_from_slider_value", "$g_quick_battle_army_2_size"),
#dunde somebody custom battle chief
#       (assign, ":army_size", reg0),
(store_sub, ":army_size", reg0, 1),
(try_begin),
  (gt, "$lord_selected", 0),
  (troop_set_health, "$lord_selected", 100),
  (troop_equip_items, "$lord_selected"),
  (set_visitor, ":cur_entry_point", "$lord_selected"),
(try_end),
#dunde somebody custom battle
     (try_begin),
         (eq, ":cur_entry_point", 0),
         (assign, "$g_quick_battle_team_0_banner", "mesh_banners_default_a"),
       (else_try),
         (assign, "$g_quick_battle_team_1_banner", "mesh_banners_default_a"),
       (try_end),
       (val_add, ":cur_entry_point", 1),
     (try_end),

     (store_mul, ":num_infantry", ":infantry_ratio", ":army_size"),
     (val_div, ":num_infantry", 100),
     (store_mul, ":num_archers", ":archers_ratio", ":army_size"),
     (val_div, ":num_archers", 100),
     (store_mul, ":num_cavalry", ":cavalry_ratio", ":army_size"),
     (val_div, ":num_cavalry", 100),

     (try_begin),
       (store_add, ":num_total", ":num_infantry", ":num_archers"),
       (val_add, ":num_total", ":num_cavalry"),
       (neq, ":num_total", ":army_size"),
       (store_sub, ":leftover", ":army_size", ":num_total"),
       (try_begin),
         (gt, ":infantry_ratio", ":archers_ratio"),
         (gt, ":infantry_ratio", ":cavalry_ratio"),
         (val_add, ":num_infantry", ":leftover"),
       (else_try),
         (gt, ":archers_ratio", ":cavalry_ratio"),
         (val_add, ":num_archers", ":leftover"),
       (else_try),
         (val_add, ":num_cavalry", ":leftover"),
       (try_end),
     (try_end),

     (store_mul, ":rand_min", ":num_infantry", 15),
     (val_div, ":rand_min", 100),
     (store_mul, ":rand_max", ":num_infantry", 45),
     (val_div, ":rand_max", 100),
     (store_random_in_range, ":num_tier_2_infantry", ":rand_min", ":rand_max"),
     (store_sub, ":num_tier_1_infantry", ":num_infantry", ":num_tier_2_infantry"),
     (store_mul, ":rand_min", ":num_archers", 15),
     (val_div, ":rand_min", 100),
     (store_mul, ":rand_max", ":num_archers", 45),
     (val_div, ":rand_max", 100),
     (store_random_in_range, ":num_tier_2_archers", ":rand_min", ":rand_max"),
     (store_sub, ":num_tier_1_archers", ":num_archers", ":num_tier_2_archers"),
     (store_mul, ":rand_min", ":num_cavalry", 15),
     (val_div, ":rand_min", 100),
     (store_mul, ":rand_max", ":num_cavalry", 45),
     (val_div, ":rand_max", 100),
     (store_random_in_range, ":num_tier_2_cavalry", ":rand_min", ":rand_max"),
     (store_sub, ":num_tier_1_cavalry", ":num_cavalry", ":num_tier_2_cavalry"),

     (faction_get_slot, ":cur_troop", ":faction_no", "slot_faction_quick_battle_tier_2_infantry"),
     (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_2_infantry"),
     (val_add, ":cur_entry_point", 1),
     (faction_get_slot, ":cur_troop", ":faction_no", "slot_faction_quick_battle_tier_1_infantry"),
     (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_1_infantry"),
     (val_add, ":cur_entry_point", 1),
     (faction_get_slot, ":cur_troop", ":faction_no", "slot_faction_quick_battle_tier_2_cavalry"),
     (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_2_cavalry"),
     (val_add, ":cur_entry_point", 1),
     (faction_get_slot, ":cur_troop", ":faction_no", "slot_faction_quick_battle_tier_1_cavalry"),
     (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_1_cavalry"),
     (val_add, ":cur_entry_point", 1),

     (try_begin),
       (eq, ":divide_archer_entry_points", 0),
       (faction_get_slot, ":cur_troop", ":faction_no", "slot_faction_quick_battle_tier_2_archer"),
       (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_2_archers"),
       (val_add, ":cur_entry_point", 1),
       (faction_get_slot, ":cur_troop", ":faction_no", "slot_faction_quick_battle_tier_1_archer"),
       (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_1_archers"),
       (val_add, ":cur_entry_point", 1),
     (else_try),
       (assign, ":cur_entry_point", 40), #archer positions begin point
       (store_div, ":num_tier_1_archers_ceil_8", ":num_tier_1_archers", 8),
       (val_mul, ":num_tier_1_archers_ceil_8", 8),
       (try_begin),
         (neq, ":num_tier_1_archers_ceil_8", ":num_tier_1_archers"),
         (val_div, ":num_tier_1_archers_ceil_8", 8),
         (val_add, ":num_tier_1_archers_ceil_8", 1),
         (val_mul, ":num_tier_1_archers_ceil_8", 8),
       (try_end),
       (store_div, ":num_tier_2_archers_ceil_8", ":num_tier_2_archers", 8),
       (val_mul, ":num_tier_2_archers_ceil_8", 8),
       (try_begin),
         (neq, ":num_tier_2_archers_ceil_8", ":num_tier_2_archers"),
         (val_div, ":num_tier_2_archers_ceil_8", 8),
         (val_add, ":num_tier_2_archers_ceil_8", 1),
         (val_mul, ":num_tier_2_archers_ceil_8", 8),
       (try_end),
       (store_add, ":num_archers_ceil_8", ":num_tier_1_archers_ceil_8", ":num_tier_2_archers_ceil_8"),
       (store_div, ":num_archers_per_entry_point", ":num_archers_ceil_8", 8),
       (assign, ":left_tier_1_archers", ":num_tier_1_archers"),
       (assign, ":left_tier_2_archers", ":num_tier_2_archers"),
       (assign, ":end_cond", 1000),
       (try_for_range, ":unused", 0, ":end_cond"),
         (try_begin),
           (gt, ":left_tier_2_archers", 0),
           (assign, ":used_tier_2_archers", ":num_archers_per_entry_point"),
           (val_min, ":used_tier_2_archers", ":left_tier_2_archers"),
           (faction_get_slot, ":cur_troop", ":faction_no", "slot_faction_quick_battle_tier_2_archer"),
           (set_visitors, ":cur_entry_point", ":cur_troop", ":used_tier_2_archers"),
           (val_add, ":cur_entry_point", 1),
           (val_sub, ":left_tier_2_archers", ":used_tier_2_archers"),
         (else_try),
           (gt, ":left_tier_1_archers", 0),
           (assign, ":used_tier_1_archers", ":num_archers_per_entry_point"),
           (val_min, ":used_tier_1_archers", ":left_tier_1_archers"),
           (faction_get_slot, ":cur_troop", ":faction_no", "slot_faction_quick_battle_tier_1_archer"),
           (set_visitors, ":cur_entry_point", ":cur_troop", ":used_tier_1_archers"),
           (val_add, ":cur_entry_point", 1),
           (val_sub, ":left_tier_1_archers", ":used_tier_1_archers"),
         (else_try),
           (assign, ":end_cond", 0),
         (try_end),
       (try_end),
     (try_end),
     ]),
  #script_game_enable_cheat_menu
  # This script is called from the game engine when user enters "cheatmenu from command console (ctrl+~).
  # INPUT:
  # none
  # OUTPUT:
  # none
  ("game_enable_cheat_menu",
    [
      (store_script_param, ":input", 1),
      (try_begin),
        (eq, ":input", 0),
        (assign, "$cheat_mode", 0),
      (else_try),
        (eq, ":input", 1),
        (assign, "$cheat_mode", 1),
      (try_end),
      ]),

  # script_game_event_party_encounter:
  # This script is called from the game engine whenever player party encounters another party or a battle on the world map
  # INPUT:
  # param1: encountered_party
  # param2: second encountered_party (if this was a battle
  ("game_event_party_encounter",
   [
       (store_script_param_1, "$g_encountered_party"),
       (store_script_param_2, "$g_encountered_party_2"),# encountered_party2 is set when we come across a battle or siege, otherwise it's a negative value
#       (store_encountered_party, "$g_encountered_party"),
#       (store_encountered_party2,"$g_encountered_party_2"), # encountered_party2 is set when we come across a battle or siege, otherwise it's a minus value
       (store_faction_of_party, "$g_encountered_party_faction","$g_encountered_party"),
       (store_relation, "$g_encountered_party_relation", "$g_encountered_party_faction", "fac_player_faction"),
              
       (party_get_slot, "$g_encountered_party_type", "$g_encountered_party", "slot_party_type"),
       (party_get_template_id,"$g_encountered_party_template","$g_encountered_party"),
#       (try_begin),
#         (gt, "$g_encountered_party_2", 0),
#         (store_faction_of_party, "$g_encountered_party_2_faction","$g_encountered_party_2"),
#         (store_relation, "$g_encountered_party_2_relation", "$g_encountered_party_2_faction", "fac_player_faction"),
#         (party_get_template_id,"$g_encountered_party_2_template","$g_encountered_party_2"),
#       (else_try),
#         (assign, "$g_encountered_party_2_faction",-1),
#         (assign, "$g_encountered_party_2_relation", 0),
#         (assign,"$g_encountered_party_2_template", -1),
#       (try_end),

#NPC companion changes begin
       (call_script, "script_party_count_fit_regulars", "p_main_party"),
       (assign, "$playerparty_prebattle_regulars", reg0),

#        (try_begin),
#            (assign, "$player_party__regulars", 0),
#            (call_script, "script_party_count_fit_regulars", "p_main_party"),
#            (gt, reg0, 0),
#            (assign, "$player_party_contains_regulars", 1),
#        (try_end),
#NPC companion changes end


       (assign, "$g_last_rest_center", -1),
       (assign, "$talk_context", 0),
       (assign,"$g_player_surrenders",0),
       (assign,"$g_enemy_surrenders",0),
       (assign, "$g_leave_encounter",0),
       (assign, "$g_engaged_enemy", 0),
	   (assign,"$loot_wagon_shown",0), #TEMPERED chief ADDED FOR LOOT WAGON
	   (assign,"$force_presentation_shown",0), #TEMPERED chief SHOW FORCE COMPOSITION PRESENTATION
#       (assign,"$waiting_for_arena_fight_result", 0),
#       (assign,"$arena_bet_amount",0),
#       (assign,"$g_player_raiding_village",0),
       (try_begin),
         (neg|is_between, "$g_encountered_party", centers_begin, centers_end),
         (rest_for_hours, 0), #stop waiting
         (assign, "$g_infinite_camping", 0),
       (try_end),
#       (assign, "$g_permitted_to_center",0),
       (assign, "$new_encounter", 1), #check this in the menu.
       (try_begin),
         (lt, "$g_encountered_party_2",0), #Normal encounter. Not battle or siege.
         (try_begin),
           (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_town),
           (jump_to_menu, "mnu_castle_outside"),
         (else_try),
           (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_castle),
           (jump_to_menu, "mnu_castle_outside"),
         (else_try),
           (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_ship),
           (jump_to_menu, "mnu_ship_reembark"),
         (else_try),
           (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_village),
           (jump_to_menu, "mnu_village"),
         (else_try),
           (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_cattle_herd1),
           (jump_to_menu, "mnu_cattle_herd1"),
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#-#-#Hunting chief Mod begin#-#-#-#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
         (else_try),
           (party_get_template_id, ":party_template","$g_encountered_party"),
	   (eq,":party_template","pt_deer_herd"),
           (jump_to_menu, "mnu_deer_herd"),
         (else_try),
           (party_get_template_id, ":party_template","$g_encountered_party"),
	   (eq,":party_template","pt_boar_herd"),
           (jump_to_menu, "mnu_boar_herd"),
         (else_try),
           (party_get_template_id, ":party_template","$g_encountered_party"),
	   (eq,":party_template","pt_wolf_herd"),
           (jump_to_menu, "mnu_wolf_herd"),
         (else_try),
           (party_get_template_id, ":party_template","$g_encountered_party"),
	   (eq,":party_template","pt_coat_herd"),
           (jump_to_menu, "mnu_coat_herd"),
         (else_try),
           (party_get_template_id, ":party_template","$g_encountered_party"),
	   (eq,":party_template","pt_coatb_herd"),
           (jump_to_menu, "mnu_coatb_herd"),
         (else_try),
           (party_get_template_id, ":party_template","$g_encountered_party"),
	   (eq,":party_template","pt_wilddonkey_herd"),
           (jump_to_menu, "mnu_wilddonkey_herd"),
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#-#-#Hunting chief Mod end#-#-#-#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
         (else_try),
           (is_between, "$g_encountered_party", training_grounds_begin, training_grounds_end),
           (jump_to_menu, "mnu_training_ground"),
		 (else_try),  
		   (party_get_template_id, ":template", "$g_encountered_party"),
		   (ge, ":template", "pt_steppe_bandit_lair"),
		   (lt, ":template", "pt_bandit_lair_templates_end"),
		   (assign, "$loot_screen_shown", 0),
#		   (call_script, "script_encounter_init_variables"),
		   (jump_to_menu, "mnu_bandit_lair"),
         (else_try),
           (eq, "$g_encountered_party", "p_zendar"),
           (jump_to_menu, "mnu_zendar"),
         (else_try),
           (eq, "$g_encountered_party", "p_salt_mine"),
           (jump_to_menu, "mnu_salt_mine"),
         (else_try),
           (eq, "$g_encountered_party", "p_four_ways_inn"),
           (jump_to_menu, "mnu_four_ways_inn"),
         (else_try), #chief empieza
           (eq, "$g_encountered_party", "p_celidon_forest"),
           (jump_to_menu, "mnu_celidon_forest"),
       (else_try),
           (eq, "$g_encountered_party", "p_hidden_valley"),
           (jump_to_menu, "mnu_hidden_valley"),
       (else_try),
         (eq, "$g_encountered_party", "p_iniau_hideout"),
           (jump_to_menu, "mnu_iniau_hideout"),
       (else_try),
         (eq, "$g_encountered_party", "p_quarry1"),
           (jump_to_menu, "mnu_quarry1"),
       (else_try),
         (eq, "$g_encountered_party", "p_hadrian_wall"),
           (jump_to_menu, "mnu_hadrian_wall"),
       (else_try),
         (eq, "$g_encountered_party", "p_odin_cave"),
           (jump_to_menu, "mnu_cueva_odin"),
       (else_try),
         (eq, "$g_encountered_party", "p_monasterio1"),
           (jump_to_menu, "mnu_monasterio_visit"),
       (else_try),
         (eq, "$g_encountered_party", "p_monasterio2"),
           (jump_to_menu, "mnu_monasterio_visit"),
       (else_try),
         (eq, "$g_encountered_party", "p_monasterio3"),
           (jump_to_menu, "mnu_monasterio_visit"),
       (else_try),
         (eq, "$g_encountered_party", "p_monasterio4"),
           (jump_to_menu, "mnu_monasterio_visit"),
       (else_try),
         (eq, "$g_encountered_party", "p_monasterio5"),
           (jump_to_menu, "mnu_monasterio_visit"),
       (else_try),
         (eq, "$g_encountered_party", "p_monasterio6"),
           (jump_to_menu, "mnu_monasterio_visit"),
       (else_try),
         (eq, "$g_encountered_party", "p_monasterio7"),
           (jump_to_menu, "mnu_monasterio_visit"),
       (else_try),
         (eq, "$g_encountered_party", "p_monasterio8"),
           (jump_to_menu, "mnu_monasterio_visit"),
       (else_try), #chief acaba
           (eq, "$g_encountered_party", "p_test_scene"),
           (jump_to_menu, "mnu_test_scene"),
         (else_try),
           (eq, "$g_encountered_party", "p_battlefields"),
           (jump_to_menu, "mnu_battlefields"),
         (else_try),
           (eq, "$g_encountered_party", "p_training_ground"),
           (jump_to_menu, "mnu_tutorial"),
         (else_try),
           (eq, "$g_encountered_party", "p_camp_bandits"),           
           (jump_to_menu, "mnu_camp"),
#Tempered chief messenger encounters player party
		(else_try),
			(party_slot_eq, "$g_encountered_party", "slot_party_type", spt_messenger),
			(assign,"$reply_shown",1),
			(call_script,"script_build_reply","$g_encountered_party"),
			(jump_to_menu,"mnu_messenger_return"),
#TEMPERED FUNERAL PYRE
		(else_try),
			(eq,"$g_encountered_party_template","pt_funeral_pyre"),
			(jump_to_menu,"mnu_auto_return_to_map"),
#chief acaba tempered
         (else_try),
           (jump_to_menu, "mnu_simple_encounter"),
         (try_end),
       (else_try), #Battle or siege
         (try_begin),
           (this_or_next|party_slot_eq, "$g_encountered_party", "slot_party_type", spt_town),
           (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_castle),
           (try_begin),
             (eq, "$auto_enter_town", "$g_encountered_party"),
             (jump_to_menu, "mnu_town"),
           (else_try),
             (eq, "$auto_besiege_town", "$g_encountered_party"),
             (jump_to_menu, "mnu_besiegers_camp_with_allies"),
           (else_try),
             (jump_to_menu, "mnu_join_siege_outside"),
           (try_end),
         (else_try),
           (jump_to_menu, "mnu_pre_join"),
         (try_end),
       (try_end),
       (assign,"$auto_enter_town",0),
       (assign,"$auto_besiege_town",0),
      ]),

  #script_game_event_simulate_battle:
  # This script is called whenever the game simulates the battle between two parties on the map.
  # INPUT:
  # param1: Defender Party
  # param2: Attacker Party
  ("game_event_simulate_battle",
    [
      (store_script_param_1, ":root_defender_party"),
      (store_script_param_2, ":root_attacker_party"),
#TEMPERED chief CHANGE SKIRMISHER FACTION UPON ENTERING BATTLE
		(try_begin),
			(eq,"$skirmish_party_no",":root_attacker_party"),
			(party_set_faction,"$skirmish_party_no","fac_player_faction"),
		(try_end),
#TEMPERED END CHANGES

      (assign, "$marshall_defeated_in_battle", -1),

      (store_current_hours, ":hours"),
      

##      ##diplomacy start+ Get campaign AI, used below chief
##      (options_get_campaign_ai, ":reduce_campaign_ai"),
##      ##diplomacy end+

      (try_for_parties, ":party"),
        (party_get_battle_opponent, ":opponent", ":party"),
        (gt, ":opponent", 0),
        (party_set_slot, ":party", "slot_party_last_in_combat", ":hours"),
      (try_end),

     (assign, ":trigger_result", 1),    
      (try_begin),
        (ge, ":root_defender_party", 0),
        (ge, ":root_attacker_party", 0),
        (party_is_active, ":root_defender_party"),
        (party_is_active, ":root_attacker_party"),
        (store_faction_of_party, ":defender_faction", ":root_defender_party"),
        (store_faction_of_party, ":attacker_faction", ":root_attacker_party"),
#        (neq, ":defender_faction", "fac_player_faction"),
#        (neq, ":attacker_faction", "fac_player_faction"),
        (store_relation, ":reln", ":defender_faction", ":attacker_faction"),
        (lt, ":reln", 0),
		 (neq,"$skirmish_party_no",":root_attacker_party"), #Tempered chief let skirmish party fight even though their relation is good with defender party
       (assign, ":trigger_result", 0),
      
        (try_begin),
          (this_or_next|eq, "$g_battle_simulation_cancel_for_party", ":root_defender_party"),
          (eq, "$g_battle_simulation_cancel_for_party", ":root_attacker_party"),
          (assign, "$g_battle_simulation_cancel_for_party", -1),
          (assign, "$auto_enter_town", "$g_battle_simulation_auto_enter_town_after_battle"),
          (assign, ":trigger_result", 1),
        (else_try),
          (try_begin),
            (this_or_next|party_slot_eq, ":root_defender_party", "slot_party_retreat_flag", 1),
            (party_slot_eq, ":root_attacker_party", "slot_party_retreat_flag", 1),
            (assign, ":trigger_result", 1), #End battle!
          (try_end),
          (party_set_slot, ":root_attacker_party", "slot_party_retreat_flag", 0),

          #(assign, ":cancel_attack", 0),

          (party_collect_attachments_to_party, ":root_defender_party", "p_collective_ally"),
          (party_collect_attachments_to_party, ":root_attacker_party", "p_collective_enemy"),

         	      ##diplomacy start+ chief
 		  (assign, ":terrain_code", dplmc_terrain_code_none),#defined in header_terrain.py
          (try_begin),
              (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_ENABLE),
			  (call_script, "script_dplmc_get_terrain_code_for_battle", ":root_attacker_party", ":root_defender_party"),
			  (assign, ":terrain_code", reg0),
			  #
              (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_ally", ":terrain_code", 0, 1),
              (assign, ":defender_strength", reg0),
              (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_enemy", ":terrain_code", 0, 1),
              (assign, ":attacker_strength", reg0),
          (else_try),
             #(call_script, "script_party_count_fit_for_battle", "p_collective_ally"),
          (call_script, "script_party_calculate_strength", "p_collective_ally", 0),
          (assign, ":defender_strength", reg0),
          #(call_script, "script_party_count_fit_for_battle", "p_collective_enemy"),
          (call_script, "script_party_calculate_strength", "p_collective_enemy", 0),
          (assign, ":attacker_strength", reg0),
          (try_end),
          ##diplomacy end+

          (store_div, ":defender_strength", ":defender_strength", 20),
          (val_min, ":defender_strength", 50),
          (val_max, ":defender_strength", 1),
          (store_div, ":attacker_strength", ":attacker_strength", 20),
          (val_min, ":attacker_strength", 50),
          (val_add, ":attacker_strength", 1),
          (try_begin),
            #For sieges increase attacker casualties and reduce defender casualties.
            (this_or_next|party_slot_eq, ":root_defender_party", "slot_party_type", spt_castle),
            (party_slot_eq, ":root_defender_party", "slot_party_type", spt_town),
            (val_mul, ":defender_strength", 123), #it was 1.5 in old version, now it is only 1.23
            (val_div, ":defender_strength", 100),
      
            (val_mul, ":attacker_strength", 100), #it was 0.5 in old version, now it is only 1 / 1.23
            (val_div, ":attacker_strength", 123),
          (try_end),
          ##diplomacy chief  begin
          (assign, ":defender_percent", 100),
          (try_begin),
            (faction_get_slot, ":serfdom", ":defender_faction", "slot_faction_serfdom"),
            (neq, ":serfdom", 0),
            (val_mul, ":serfdom", -2),
            (val_add, ":defender_percent", ":serfdom"),         
          (try_end),
          (try_begin),
            (faction_get_slot, ":quality", ":defender_faction", "slot_faction_quality"),
            (neq, ":quality", 0),
            (val_mul, ":quality", 4),
            (val_add, ":defender_percent", ":quality"),
          (try_end),
          (val_mul, ":defender_strength", ":defender_percent"),
          (val_div, ":defender_strength", 100),
          
          (assign, ":attacker_percent", 100),
          (try_begin),
            (faction_get_slot, ":serfdom", ":attacker_faction", "slot_faction_serfdom"),
            (neq, ":serfdom", 0),
            (val_mul, ":serfdom", -2),
            (val_add, ":attacker_percent", ":serfdom"), 
          (try_end),
          (try_begin),
            (faction_get_slot, ":quality", ":attacker_faction", "slot_faction_quality"),
            (neq, ":quality", 0),
            (val_mul, ":quality", 4),
            (val_add, ":attacker_percent", ":quality"),
          (try_end),
          (val_mul, ":attacker_strength", ":attacker_percent"),
          (val_div, ":attacker_strength", 100),
          ##diplomacy chief end

          (call_script, "script_party_count_fit_for_battle", "p_collective_ally", 0),
          (assign, ":old_defender_strength", reg0),

## CC cambia esto chief
        (val_clamp, "$g_speed_ai_battles", 1, 4),
        (assign, ":num_rounds", "$g_speed_ai_battles"),
        (try_for_range, ":unused", 0, ":num_rounds"), # speed
          (try_begin),
            (neg|is_currently_night), #Don't fight at night
            (inflict_casualties_to_party_group, ":root_attacker_party", ":defender_strength", "p_temp_casualties"),
            (party_collect_attachments_to_party, ":root_attacker_party", "p_collective_enemy"),
          (try_end),
          (call_script, "script_party_count_fit_for_battle", "p_collective_enemy", 0),
          (assign, ":new_attacker_strength", reg0),
          (try_begin),
            (gt, ":new_attacker_strength", 0),
            (neg|is_currently_night), #Don't fight at night
            (inflict_casualties_to_party_group, ":root_defender_party", ":attacker_strength", "p_temp_casualties"),
            (party_collect_attachments_to_party, ":root_defender_party", "p_collective_ally"),
          (try_end),
          (call_script, "script_party_count_fit_for_battle", "p_collective_ally", 0),
          (assign, ":new_defender_strength", reg0),
        (try_end),
## CC termina
#Tempered chief end battle early for skirmisher parties
		   (try_begin),
				(eq,":root_attacker_party","$skirmish_party_no"),
				(party_set_faction,"$skirmish_party_no","fac_apoyoplayer"),
#				(assign,":trigger_result",2),				
		   (try_end),
#Tempered end changes

          (try_begin),
            (this_or_next|eq, ":new_attacker_strength", 0),
            (eq, ":new_defender_strength", 0),
            # Battle concluded! determine winner
            
            (assign, ":do_not_end_battle", 0),
            (try_begin),
              (neg|troop_is_wounded, "trp_player"),
              (eq, ":new_defender_strength", 0),              
              (eq, "$auto_enter_town", "$g_encountered_party"),
              (eq, ":old_defender_strength", ":new_defender_strength"),
              (assign, ":do_not_end_battle", 1),
            (try_end),            
            (eq, ":do_not_end_battle", 0),

            (try_begin),
              (eq, ":new_attacker_strength", 0),
              (eq, ":new_defender_strength", 0),
              (assign, ":root_winner_party", -1),
              (assign, ":root_defeated_party", -1),
              (assign, ":collective_casualties", -1),
            (else_try),
              (eq, ":new_attacker_strength", 0),
              (assign, ":root_winner_party", ":root_defender_party"),
              (assign, ":root_defeated_party", ":root_attacker_party"),
              (assign, ":collective_casualties", "p_collective_enemy"),
            (else_try),
              (assign, ":root_winner_party", ":root_attacker_party"),
              (assign, ":root_defeated_party", ":root_defender_party"),
              (assign, ":collective_casualties", "p_collective_ally"),
            (try_end),
##diplomacy chief  begin
        (try_begin),
          (gt, ":root_defeated_party", -1),

          constable.recruit.consequences_battle_lost,

        (try_begin),
          (party_slot_eq,":root_defeated_party", "slot_party_type", dplmc_spt_gift_caravan),
    
          (party_get_slot, ":target_troop", ":root_defeated_party", "slot_party_orders_object"),
          (party_get_slot, ":target_party", ":root_defeated_party", "slot_party_ai_object"),
          (try_begin),
            (gt, ":target_troop", 0),
            (str_store_troop_name, s13, ":target_troop"),  
          (else_try),
            (str_store_party_name, s13, ":target_party"),
          (end_try),        
          (party_get_slot, ":gift", ":root_defeated_party", "slot_party_mission_diplomacy"),
          (str_store_item_name, s12, ":gift"),
          (display_log_message, "@Your caravan sending {s12} to {s13} has been defeated {s10}!", 0xFF0000), #chief moficiado diplomacy
        (try_end),
        
        (try_begin),
          (party_slot_eq,":root_defeated_party", "slot_party_type", spt_messenger),
          (party_get_slot, ":target_party", ":root_defeated_party", "slot_party_orders_object"),
          (party_stack_get_troop_id, ":party_leader", ":target_party", 0),
          (str_store_troop_name, s13, ":party_leader"),
          (display_log_message, "@Your messenger on the way to {s13} has been defeated {s10}!", 0xFF0000),#chief moficiado diplomacy
        (try_end),
        
         patrols.consequences_battle_lost,
        
        (try_begin),
          (party_slot_eq,":root_defeated_party", "slot_party_type", spt_scout),
          (store_faction_of_party, ":party_faction", ":root_defeated_party"),
          (eq, ":party_faction", "$players_kingdom"), 
          (party_get_slot, ":target_party", ":root_defeated_party", "slot_party_orders_object"),
          (str_store_party_name, s13, ":target_party"),
          (display_log_message, "@A scout trying to gather information about {s13} has been slain {s10}!", 0xFF0000),
        (try_end),
      (try_end),
##diplomacy chief end

            (try_begin),
              (ge, ":root_winner_party", 0),
              (call_script, "script_get_nonempty_party_in_group", ":root_winner_party"),
              (assign, ":nonempty_winner_party", reg0),
              (store_faction_of_party, ":faction_receiving_prisoners", ":nonempty_winner_party"),
              (store_faction_of_party, ":defeated_faction", ":root_defeated_party"),
            (else_try),
              (assign, ":nonempty_winner_party", -1),
            (try_end),

            (try_begin),
              (ge, ":collective_casualties", 0),
              (party_get_num_companion_stacks, ":num_stacks", ":collective_casualties"),
            (else_try),
              (assign, ":num_stacks", 0),
            (try_end),
                                                                         
            (try_for_range, ":troop_iterator", 0, ":num_stacks"),
              (party_stack_get_troop_id, ":cur_troop_id", ":collective_casualties", ":troop_iterator"),
              (troop_is_hero, ":cur_troop_id"),
             
              (try_begin),
                #abort quest if troop loses a battle during rest time
                (check_quest_active, "qst_lend_surgeon"),
                (quest_slot_eq, "qst_lend_surgeon", "slot_quest_giver_troop", ":cur_troop_id"),
                (call_script, "script_abort_quest", "qst_lend_surgeon", 0),
              (try_end),
              
              (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
                              
              (troop_set_slot, ":cur_troop_id", "slot_troop_leaded_party", -1),
               
              (store_random_in_range, ":rand", 0, 100),
              (str_store_troop_name_link, s1, ":cur_troop_id"),
              (str_store_faction_name_link, s2, ":faction_receiving_prisoners"),
              (store_troop_faction, ":defeated_troop_faction", ":cur_troop_id"),
              (str_store_faction_name_link, s3, ":defeated_troop_faction"),
              (try_begin),
         (neq, "$freelancer_state", 1), #+freelancer chief #lord con player en party siempre escapa	
                (ge, ":rand", hero_escape_after_defeat_chance),
                (party_stack_get_troop_id, ":leader_troop_id", ":nonempty_winner_party", 0),
                (is_between, ":leader_troop_id", active_npcs_begin, active_npcs_end), #disable non-kingdom parties capturing enemy lords
                (party_add_prisoners, ":nonempty_winner_party", ":cur_troop_id", 1),
                (gt, reg0, 0),
                #(troop_set_slot, ":cur_troop_id", "slot_troop_is_prisoner", 1),
                (troop_set_slot, ":cur_troop_id", "slot_troop_prisoner_of_party", ":nonempty_winner_party"),
                ## CC chief
                (faction_get_color, ":faction_color", ":defeated_troop_faction"),
                (display_log_message, "str_hero_taken_prisoner", ":faction_color"),
                ## CC
				 
                (try_begin),
                  (call_script, "script_cf_prisoner_offered_parole", ":cur_troop_id"),

                  (try_begin),
                    (eq, "$cheat_mode", 1),
                    (display_message, "@{!}DEBUG : Prisoner granted parole"),
                  (try_end),

                  (call_script, "script_troop_change_relation_with_troop", ":leader_troop_id", ":cur_troop_id", 3),
				  (val_add, "$total_battle_enemy_changes", 3),
                (else_try),			 
                  (try_begin),
                    (eq, "$cheat_mode", 1),
                    (display_message, "@{!}DEBUG : Prisoner not offered parole"),
		          (try_end),

		          (call_script, "script_troop_change_relation_with_troop", ":leader_troop_id", ":cur_troop_id", -5),
				  (val_add, "$total_battle_enemy_changes", -5),
		        (try_end),
				 				 				 				 			
				(store_faction_of_party, ":capturer_faction", ":nonempty_winner_party"),
                (call_script, "script_update_troop_location_notes_prisoned", ":cur_troop_id", ":capturer_faction"),
              (else_try),
                ## CC chief
                (faction_get_color, ":faction_color", ":defeated_troop_faction"), 
                (display_message,"@{s1} of {s3} was defeated in battle but managed to escape.", ":faction_color"),
#                (display_message,"@{s1} of {s3} was defeated in battle but managed to escape."),
                ## CC
              (try_end),
        
              (try_begin),
                (store_troop_faction, ":cur_troop_faction", ":cur_troop_id"),
                (is_between, ":cur_troop_faction", kingdoms_begin, kingdoms_end),
                (faction_slot_eq, ":cur_troop_faction", "slot_faction_marshall", ":cur_troop_id"),
                (is_between, ":cur_troop_faction", kingdoms_begin, kingdoms_end),
                (assign, "$marshall_defeated_in_battle", ":cur_troop_id"),
                #Marshall is defeated, refresh ai.
                (assign, "$g_recalculate_ais", 1),
              (try_end),
			 
              ##diplomacy chief begin
              (try_begin),
                (call_script, "script_dplmc_is_affiliated_family_member", ":cur_troop_id"),
                (eq, reg0, 1),
                (try_for_range, ":family_member", lords_begin, kingdom_ladies_end),
                  (call_script, "script_troop_get_family_relation_to_troop", ":family_member", "$g_player_affiliated_troop"),
                  (gt, reg0, 0),
                 (call_script, "script_change_player_relation_with_troop", ":family_member", -2),
                  (try_end),
              (try_end),
              ##diplomacy chief end
            (try_end),

             (try_begin),
               (ge, ":collective_casualties", 0),
               (party_get_num_prisoner_stacks, ":num_stacks", ":collective_casualties"),
             (else_try),
               (assign, ":num_stacks", 0),
             (try_end),
             (try_for_range, ":troop_iterator", 0, ":num_stacks"),
               (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":collective_casualties", ":troop_iterator"),
               (troop_is_hero, ":cur_troop_id"),
               (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
               (store_troop_faction, ":cur_troop_faction", ":cur_troop_id"),
               (str_store_troop_name_link, s1, ":cur_troop_id"),
               (str_store_faction_name_link, s2, ":faction_receiving_prisoners"),
               (str_store_faction_name_link, s3, ":cur_troop_faction"),
               ## CC chief
               (faction_get_color, ":faction_color", ":cur_troop_faction"),
               (display_log_message,"str_hero_freed", ":faction_color"),
               ## CC
#               (display_log_message,"str_hero_freed"),
             (try_end),

             (try_begin),
               (ge, ":collective_casualties", 0),
               (party_clear, "p_temp_party"),
               (assign, "$g_move_heroes", 0), #heroes are already processed above. Skip them here.
               (call_script, "script_party_add_party_prisoners", "p_temp_party", ":collective_casualties"),
               (call_script, "script_party_prisoners_add_party_companions", "p_temp_party", ":collective_casualties"),
               (distribute_party_among_party_group, "p_temp_party", ":root_winner_party"),
			   
               (call_script, "script_battle_political_consequences", ":root_defeated_party", ":root_winner_party"),
			
               (call_script, "script_clear_party_group", ":root_defeated_party"),
               (call_script,"script_cf_fix_party_size", "p_temp_party",0),#NNY somebody patrullas chief
             (try_end),
           (assign, ":trigger_result", 1), #End battle!

             #Center captured
             (try_begin),
               (ge, ":collective_casualties", 0),
               (party_get_slot, ":cur_party_type", ":root_defeated_party", "slot_party_type"),
               (this_or_next|eq, ":cur_party_type", spt_town),
               (eq, ":cur_party_type", spt_castle),

               (assign, "$g_recalculate_ais", 1),

               (store_faction_of_party, ":winner_faction", ":root_winner_party"),
               (store_faction_of_party, ":defeated_faction", ":root_defeated_party"),

               (str_store_party_name, s1, ":root_defeated_party"),
               (str_store_faction_name, s2, ":winner_faction"),
               (str_store_faction_name, s3, ":defeated_faction"),
               ## CC chief
               (faction_get_color, ":faction_color", ":winner_faction"),
               (display_log_message, "str_center_captured", ":faction_color"),
               ## CC
			
			   (store_current_hours, ":hours"),
			   (faction_set_slot, ":winner_faction", "slot_faction_ai_last_decisive_event", ":hours"),
			
               (try_begin),
                 (eq, "$g_encountered_party", ":root_defeated_party"),
                 (call_script, "script_add_log_entry", logent_player_participated_in_siege, "trp_player",  "$g_encountered_party", 0, "$g_encountered_party_faction"),
               (try_end),

               (try_begin),
                 (party_get_num_companion_stacks, ":num_stacks", ":root_winner_party"),
                 (gt, ":num_stacks", 0),
                 (party_stack_get_troop_id, ":leader_troop_no", ":root_winner_party", 0),
                 (is_between, ":leader_troop_no", active_npcs_begin, active_npcs_end),
                 (party_set_slot, ":root_defeated_party", "slot_center_last_taken_by_troop", ":leader_troop_no"),
               (else_try),
                 (party_set_slot, ":root_defeated_party", "slot_center_last_taken_by_troop", -1),
               (try_end),

               (call_script, "script_lift_siege", ":root_defeated_party", 0),
			   (store_faction_of_party, ":fortress_faction", ":root_defeated_party"),			   
			   (try_begin),
			     (is_between, ":root_defeated_party", towns_begin, towns_end),
			     (assign, ":damage", 40),
			   (else_try),
			     (assign, ":damage", 20),
			   (try_end),
			   (call_script, "script_faction_inflict_war_damage_on_faction", ":winner_faction", ":fortress_faction", ":damage"),
			   
               (call_script, "script_give_center_to_faction", ":root_defeated_party", ":winner_faction"),
               (try_begin),
                 (eq, ":defeated_faction", "fac_player_supporters_faction"),
                 (call_script, "script_add_notification_menu", "mnu_notification_center_lost", ":root_defeated_party", ":winner_faction"),
               (try_end),
               
               (party_get_num_attached_parties, ":num_attached_parties",  ":root_attacker_party"),
                 (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
                 (party_get_attached_party_with_rank, ":attached_party", ":root_attacker_party", ":attached_party_rank"),
                                                                                                       
                 (party_get_num_companion_stacks, ":num_stacks", ":attached_party"),                 
                 (assign, ":total_size", 0),
                 (try_for_range, ":i_stack", 0, ":num_stacks"),
                   (party_stack_get_size, ":stack_size", ":attached_party", ":i_stack"),
                   (val_add, ":total_size", ":stack_size"),
                 (try_end),  
                 
                 (try_begin),
                   (ge, ":total_size", 10),
                   
                   (assign, ":stacks_added", 0),
                   (assign, ":last_random_stack", -1),
                   
                   (assign, ":end_condition", 10),
                   (try_for_range, ":unused", 0, ":end_condition"),
                     (store_random_in_range, ":random_stack", 1, ":num_stacks"),
                     (party_stack_get_troop_id, ":random_stack_troop", ":attached_party", ":random_stack"),
                     (party_stack_get_size, ":stack_size", ":attached_party", ":random_stack"),
                     (ge, ":stack_size", 4),
                     (neq, ":random_stack", ":last_random_stack"),
                   
                     (store_mul, ":total_size_mul_2", ":total_size", 2),
                     (assign, ":percentage", ":total_size_mul_2"),
                     (val_min, ":percentage", 100),                   
                   
                     (val_mul, ":stack_size", ":percentage"),
                     (val_div, ":stack_size", 100),
                   
                     (party_stack_get_troop_id, ":party_leader", ":attached_party", 0),

                     (try_begin),
                       (this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_goodnatured),
                       (this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_upstanding),
                       (troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_martial),
                       (assign, reg2, 0),
                       (store_random_in_range, ":random_percentage", 40, 50), #average 45%
                     (else_try),  
                       (this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_quarrelsome),
                       (troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_cunning),
                       (assign, reg2, 1),
                       (store_random_in_range, ":random_percentage", 30, 40), #average 35%
                     (else_try),  
                       (this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_selfrighteous),
                       (this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_roguish),
                       (troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_debauched),
                       (assign, reg2, 2),
                       (store_random_in_range, ":random_percentage", 20, 30), #average 25%
                     (else_try),  
                       (this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_benefactor),
                       (troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_custodian),
                       (assign, reg2, 3),
                       (store_random_in_range, ":random_percentage", 50, 60), #average 55%
                     (try_end),                   
                   
                     (val_min, ":random_percentage", 100),                   
                     (val_mul, ":stack_size", ":random_percentage"),
                     (val_div, ":stack_size", 100),
                                                    
                     (party_add_members, ":root_defender_party", ":random_stack_troop", ":stack_size"),
                     (party_remove_members, ":attached_party", ":random_stack_troop", ":stack_size"),
                     
                     (val_add, ":stacks_added", 1),
                     (assign, ":last_random_stack", ":random_stack"),
                     
                     (try_begin),
                       #if troops from three different stack is already added then break
                       (eq, ":stacks_added", 3),
                       (assign, ":end_condition", 0),
                     (try_end),
                   (try_end),  
                 (try_end),  
               (try_end),
               
               #Reduce prosperity of the center by 5
			   (try_begin),
			     (neg|is_between, ":root_defeated_party", castles_begin, castles_end),
			     (call_script, "script_change_center_prosperity", ":root_defeated_party", -5),
			     (val_add, "$newglob_total_prosperity_from_townloot", -5),
			   (try_end),
               (call_script, "script_order_best_besieger_party_to_guard_center", ":root_defeated_party", ":winner_faction"),
               (call_script, "script_cf_reinforce_party", ":root_defeated_party"),
               (call_script, "script_cf_reinforce_party", ":root_defeated_party"),			   
             (try_end),
           (try_end),

           #ADD XP
           (try_begin),
             (party_slot_eq, ":root_attacker_party", "slot_party_type", spt_kingdom_hero_party),
                          
             (assign, ":xp_gained_attacker", 200),
             (options_get_campaign_ai, ":reduce_campaign_ai"),
             (store_faction_of_party, ":root_attacker_party_faction", ":root_attacker_party"),
             (try_begin),
               (this_or_next|eq, ":root_attacker_party", "p_main_party"),
               (this_or_next|eq, ":root_attacker_party_faction", "fac_player_supporters_faction"),
               (eq, ":root_attacker_party_faction", "$players_kingdom"),               
               #same
             (else_try),
               (eq, ":reduce_campaign_ai", 0), #hard (1.5x)
               (val_mul, ":xp_gained_attacker", 3),
               (val_div, ":xp_gained_attacker", 2),
             (else_try),
               (eq, ":reduce_campaign_ai", 1), #moderate (1.0x)
               #same
             (else_try),                        
               (eq, ":reduce_campaign_ai", 2), #easy (0.5x)
               (val_div, ":xp_gained_attacker", 2),
             (try_end),           

             (gt, ":new_attacker_strength", 0),             
             (call_script, "script_upgrade_hero_party", ":root_attacker_party", ":xp_gained_attacker"),
           (try_end),
           (try_begin),
             (party_slot_eq, ":root_defender_party", "slot_party_type", spt_kingdom_hero_party),
                          
             (assign, ":xp_gained_defender", 200),
             (store_faction_of_party, ":root_defender_party_faction", ":root_defender_party"),             
             (options_get_campaign_ai, ":reduce_campaign_ai"),
             (try_begin),
               (this_or_next|eq, ":root_defender_party", "p_main_party"),
               (this_or_next|eq, ":root_defender_party_faction", "fac_player_supporters_faction"),
               (eq, ":root_defender_party_faction", "$players_kingdom"),               
               #same
             (else_try),
               (eq, ":reduce_campaign_ai", 0), #hard (1.5x)
               (val_mul, ":xp_gained_defender", 3),
               (val_div, ":xp_gained_defender", 2),
             (else_try),
               (eq, ":reduce_campaign_ai", 1), #moderate (1.0x)
               #same
             (else_try),         
               (eq, ":reduce_campaign_ai", 2), #easy (0.5x)
               (val_div, ":xp_gained_defender", 2),
             (try_end),           

             (gt, ":new_defender_strength", 0),
             (call_script, "script_upgrade_hero_party", ":root_defender_party", ":xp_gained_defender"),
           (try_end),

           (try_begin),         
             #ozan - do not randomly end battles aganist towns or castles.
             (neg|party_slot_eq, ":root_defender_party", "slot_party_type", spt_castle), #added by ozan
             (neg|party_slot_eq, ":root_defender_party", "slot_party_type", spt_town),   #added by ozan        
             #end ozan
                          
             (party_get_slot, ":attacker_root_strength", ":root_attacker_party", "slot_party_cached_strength"),
             (party_get_slot, ":attacker_nearby_friend_strength", ":root_attacker_party", "slot_party_nearby_friend_strength"),
             (party_get_slot, ":strength_of_attacker_followers", ":root_attacker_party", "slot_party_follower_strength"),
             (store_add, ":total_attacker_strength", ":attacker_root_strength", ":attacker_nearby_friend_strength"),
             (val_add, ":total_attacker_strength", ":strength_of_attacker_followers"),

             (party_get_slot, ":defender_root_strength", ":root_defender_party", "slot_party_cached_strength"),
             (party_get_slot, ":defender_nearby_friend_strength", ":root_defender_party", "slot_party_nearby_friend_strength"),
             (party_get_slot, ":strength_of_defender_followers", ":root_defender_party", "slot_party_follower_strength"),
             (store_add, ":total_defender_strength", ":defender_root_strength", ":defender_nearby_friend_strength"),
             (val_add, ":total_attacker_strength", ":strength_of_defender_followers"),

             #Players can make save loads and change history because these random values are not determined from random_slots of troops
             (store_random_in_range, ":random_num", 0, 100),
                          
             (try_begin),
               (lt, ":random_num", 10),
               (assign, ":trigger_result", 1), #End battle!
             (try_end),
           (else_try),
             (party_get_slot, ":attacker_root_strength", ":root_attacker_party", "slot_party_cached_strength"),
             (party_get_slot, ":attacker_nearby_friend_strength", ":root_attacker_party", "slot_party_nearby_friend_strength"),
             (party_get_slot, ":strength_of_followers", ":root_attacker_party", "slot_party_follower_strength"),
             (store_add, ":total_attacker_strength", ":attacker_root_strength", ":attacker_nearby_friend_strength"),
             (val_add, ":total_attacker_strength", ":strength_of_followers"),

             (party_get_slot, ":defender_root_strength", ":root_defender_party", "slot_party_cached_strength"),
             (party_get_slot, ":defender_nearby_friend_strength", ":root_defender_party", "slot_party_nearby_friend_strength"),
             (store_add, ":total_defender_strength", ":defender_root_strength", ":defender_nearby_friend_strength"),

             (val_mul, ":total_defender_strength", 13), #multiply defender strength with 1.3
             (val_div, ":total_defender_strength", 10),

             (gt, ":total_defender_strength", ":total_attacker_strength"),
             (gt, ":total_defender_strength", 3),

             #Players can make save loads and change history because these random values are not determined from random_slots of troops
             (store_random_in_range, ":random_num", 0, 100),

             (try_begin),
               (lt, ":random_num", 15), #15% is a bit higher than 10% (which is open area escape probability)
               (assign, ":trigger_result", 1), #End battle!
                                             
               (assign, "$g_recalculate_ais", 1), #added new
                              
               (try_begin),
                 (eq, "$cheat_mode", 1),
                 (display_message, "@{!}DEBUG : Siege attackers are running away"),
               (try_end),
             (try_end),      
           (try_end),
         (try_end),  
       (try_end),
       (set_trigger_result, ":trigger_result"),
  ]),

  #script_game_event_battle_end:
  # This script is called whenever the game ends the battle between two parties on the map.
  # INPUT:
  # param1: Defender Party
  # param2: Attacker Party
  ("game_event_battle_end",
    [
##      (store_script_param_1, ":root_defender_party"), #activados con tempered chief
##      (store_script_param_2, ":root_attacker_party"), #activados con tempered chief
###Tempered chief skirmish battle changes
##	  (try_begin),
##		(eq,":root_attacker_party","$skirmish_party_no"),
##		(party_set_faction,"$skirmish_party_no","fac_neutral"),
##		(party_set_ai_behavior,"$skirmish_party_no",ai_bhvr_in_town),
##	  (else_try),
##		(eq,":root_defender_party","$skirmish_party_no"),
##		(party_set_faction,"$skirmish_party_no","fac_neutral"),
##		(party_set_ai_behavior,"$skirmish_party_no",ai_bhvr_in_town),
##	  (try_end),
###TEMPERED  END SKIRMISH CHANGES
        
      #Fixing deleted heroes
      (try_for_range, ":cur_troop", active_npcs_begin, active_npcs_end),
		(troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
        (troop_get_slot, ":cur_party", ":cur_troop", "slot_troop_leaded_party"),
        (troop_get_slot, ":cur_prisoner_of_party", ":cur_troop", "slot_troop_prisoner_of_party"),
        (try_begin),
          (ge, ":cur_party", 0),
          (assign, ":continue", 0),
          (try_begin),
            (neg|party_is_active, ":cur_party"),
            (assign, ":continue", 1),
          (else_try),
            (party_count_companions_of_type, ":amount", ":cur_party", ":cur_troop"),
            (le, ":amount", 0),
            (assign, ":continue", 1),
          (try_end),
          (eq, ":continue", 1),
          # (try_begin),
          #   (eq, "$cheat_mode", 1),
          #   (str_store_troop_name, s1, ":cur_troop"),
          #   (display_message, "@{!}DEBUG: {s1} no longer leads a party."),
          # (try_end),
         
          (troop_set_slot, ":cur_troop", "slot_troop_leaded_party", -1),
          #(str_store_troop_name, s5, ":cur_troop"),
          #(display_message, "@{!}DEBUG : {s5}'s troop_leaded_party set to -1"),
        (try_end),
        (try_begin),
          (ge, ":cur_prisoner_of_party", 0),
          (assign, ":continue", 0),
          (try_begin),
            (neg|party_is_active, ":cur_prisoner_of_party"),
            (assign, ":continue", 1),
          (else_try),
            (party_count_prisoners_of_type, ":amount", ":cur_prisoner_of_party", ":cur_troop"),
            (le, ":amount", 0),
            (assign, ":continue", 1),
          (try_end),
          (eq, ":continue", 1),
          (try_begin),
            (eq, "$cheat_mode", 1),
            (str_store_troop_name, s1, ":cur_troop"),
            (display_message, "@{!}DEBUG: {s1} is no longer a prisoner."),
          (try_end),
          (call_script, "script_remove_troop_from_prison", ":cur_troop"),
          #searching player
          (try_begin),
            (party_count_prisoners_of_type, ":amount", "p_main_party", ":cur_troop"),
            (gt, ":amount", 0),
            (troop_set_slot, ":cur_troop", "slot_troop_prisoner_of_party", "p_main_party"),
            (assign, ":continue", 0),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_troop_name, s1, ":cur_troop"),
              (display_message, "@{!}DEBUG: {s1} is now a prisoner of player."),                         
            (try_end),
          (try_end),
          (eq, ":continue", 1),
          #searching kingdom heroes
          (try_for_range, ":cur_troop_2", active_npcs_begin, active_npcs_end),
			(troop_slot_eq, ":cur_troop_2", "slot_troop_occupation", slto_kingdom_hero),
			(eq, ":continue", 1),
            (troop_get_slot, ":cur_prisoner_of_party_2", ":cur_troop_2", "slot_troop_leaded_party"),
            (party_is_active, ":cur_prisoner_of_party_2"),
            (party_count_prisoners_of_type, ":amount", ":cur_prisoner_of_party_2", ":cur_troop"),
            (gt, ":amount", 0),
            (troop_set_slot, ":cur_troop", "slot_troop_prisoner_of_party", ":cur_prisoner_of_party_2"),
            (assign, ":continue", 0),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_troop_name, s1, ":cur_troop"),
              (str_store_party_name, s2, ":cur_prisoner_of_party_2"),
              (display_message, "@{!}DEBUG: {s1} is now a prisoner of {s2}."),
            (try_end),
          (try_end),
          #searching walled centers
          (try_for_range, ":cur_prisoner_of_party_2", walled_centers_begin, walled_centers_end),
            (eq, ":continue", 1),
            (party_count_prisoners_of_type, ":amount", ":cur_prisoner_of_party_2", ":cur_troop"),
            (gt, ":amount", 0),
            (troop_set_slot, ":cur_troop", "slot_troop_prisoner_of_party", ":cur_prisoner_of_party_2"),
            (assign, ":continue", 0),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_troop_name, s1, ":cur_troop"),
              (str_store_party_name, s2, ":cur_prisoner_of_party_2"),
              (display_message, "@{!}DEBUG: {s1} is now a prisoner of {s2}."),
            (try_end),
          (try_end),
        (try_end),
      (try_end),
  ]),   
  
  #script_order_best_besieger_party_to_guard_center:
  # INPUT:
  # param1: defeated_center, param2: winner_faction
  # OUTPUT:
  # none
  ("order_best_besieger_party_to_guard_center",
    [
      (store_script_param, ":defeated_center", 1),
      (store_script_param, ":winner_faction", 2),
      (assign, ":best_party", -1),
      (assign, ":best_party_strength", 0),
      (try_for_range, ":kingdom_hero", active_npcs_begin, active_npcs_end),
        (troop_get_slot, ":kingdom_hero_party", ":kingdom_hero", "slot_troop_leaded_party"),
        (gt, ":kingdom_hero_party", 0),
        (party_is_active, ":kingdom_hero_party"),
        (store_faction_of_party, ":kingdom_hero_party_faction", ":kingdom_hero_party"),
        (eq, ":winner_faction", ":kingdom_hero_party_faction"),
        (store_distance_to_party_from_party, ":dist", ":kingdom_hero_party", ":defeated_center"),
        (lt, ":dist", 5),
        #If marshall has captured the castle, then do not leave him behind.
        (neg|faction_slot_eq, ":winner_faction", "slot_faction_marshall", ":kingdom_hero"),
        (assign, ":has_besiege_ai", 0),
        (try_begin),
          (party_slot_eq, ":kingdom_hero_party", "slot_party_ai_state", spai_besieging_center),
          (party_slot_eq, ":kingdom_hero_party", "slot_party_ai_object", ":defeated_center"),
          (assign, ":has_besiege_ai", 1),
        (else_try),
          (party_slot_eq, ":kingdom_hero_party", "slot_party_ai_state", spai_accompanying_army),
          (party_get_slot, ":kingdom_hero_party_commander_party", ":kingdom_hero_party", "slot_party_ai_object"),
          (party_slot_eq, ":kingdom_hero_party_commander_party", "slot_party_ai_state", spai_besieging_center),
          (party_slot_eq, ":kingdom_hero_party_commander_party", "slot_party_ai_object", ":defeated_center"),
          (assign, ":has_besiege_ai", 1),
        (try_end),
        (eq, ":has_besiege_ai", 1),
        (party_get_slot, ":kingdom_hero_party_strength", ":kingdom_hero_party", "slot_party_cached_strength"),#recently calculated
        (gt, ":kingdom_hero_party_strength", ":best_party_strength"),
        (assign, ":best_party_strength", ":kingdom_hero_party_strength"),
        (assign, ":best_party", ":kingdom_hero_party"),
      (try_end),
      (try_begin),
        (gt, ":best_party", 0),
        (call_script, "script_party_set_ai_state", ":best_party", spai_holding_center, ":defeated_center"),
        #(party_set_slot, ":best_party", "slot_party_commander_party", -1),
        (party_set_flags, ":best_party", pf_default_behavior, 1),
      (try_end),
      ]),

##  #script_new_trade_system
##  #Explicit trade good system, all special trade-good prices are subject to distance between origin and destination.
##  #This is a considerable change from Taleworld's system, so it requires a bit more explanation.
##  #Distance between Centers is taken into account, and Villages no longer have trade goods in supply (because that's all been abstracted out).
##  #If you want to make a given commodity more lucrative, simply change the val_div operation vs. :dist for that commodity.
##  #If you want to set up a new trade resource, pick a town of origin and the itm type, and away you go.
##  #This system makes it very easy to set up trade routes for players.
##  #INPUT:
##  # param1: item_kind_id
##  # param2: price_factor
##  # param3: $g_encountered_party (a center)
##  #OUTPUT: price_factor
##  
##  ("new_trade_system",
##    [
##      (store_script_param, ":item_kind_id", 1),
##      (store_script_param, ":price_factor", 2),
##      (store_script_param, "$g_encountered_party", 3),
##      
##      #SPICE
##      (try_begin),
##        (eq, ":item_kind_id", "itm_spice"),
##        (neq, "$g_encountered_party", "p_town_1"),#Spice comes from Cantwaraburh
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_1"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 200),#Valuable everywhere
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #SALT
##      (try_begin),
##        (eq, ":item_kind_id", "itm_salt"),
##        (neq, "$g_encountered_party", "p_town_23"),#Salt comes from Licidfelt
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_23"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 400),#Bulk cargo, low profit
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #OIL
##      (try_begin),
##        (eq, ":item_kind_id", "itm_oil"),
##        (neq, "$g_encountered_party", "p_town_17"),#Oil comes from Caer Uisc
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_17"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 400),#Bulk cargo, low profit
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #POTTERY
##      (try_begin),
##        (eq, ":item_kind_id", "itm_pottery"),
##        (neq, "$g_encountered_party", "p_town_8"),#Pottery comes from grantheb
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_8"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #RAW FLAX
##      (try_begin),
##        (eq, ":item_kind_id", "itm_raw_flax"),
##        (neq, "$g_encountered_party", "p_town_31"),#comes from temair
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_31"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 400),#Bulk cargo, low profit
##        (val_add, ":price_factor", ":dist"),
##        (try_begin),
##          (eq, "$g_encountered_party", "p_town_1"),#Flax heavily used in Cantwarebrh para vender a los francos to make linen, bonus to price
##          (val_mul, ":price_factor", 3),
##          (val_div, ":price_factor", 2),
##        (try_end),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #LINEN
##      (try_begin),
##        (eq, ":item_kind_id", "itm_linen"),
##        (neq, "$g_encountered_party", "p_town_40"),#Linen comes from emain mancha
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_40"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #WOOL
##      (try_begin),
##        (eq, ":item_kind_id", "itm_wool"),
##        (neq, "$g_encountered_party", "p_town_3"),#Wool comes from Din Eydin
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_3"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 400),#Bulk cargo, low profit
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #WOOL CLOTH
##      (try_begin),
##        (eq, ":item_kind_id", "itm_wool_cloth"),
##        (neq, "$g_encountered_party", "p_town_3"),#Wool cloth comes from Din Eidyn
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_3"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #TILE
##      (try_begin),
##        (eq, ":item_kind_id", "itm_rare_fabric"),
##        (neq, "$g_encountered_party", "p_town_15"),#Raw silk comes from caer luit
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_15"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #RAW DYES
##      (try_begin),
##        (eq, ":item_kind_id", "itm_raw_dyes"),
##        (neq, "$g_encountered_party", "p_town_31"),#Dyes come from temair
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_31"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (try_begin),
##          (eq, "$g_encountered_party", "p_town_14"),#Dyes heavily used in kingdom 4
##          (val_mul, ":price_factor", 3),
##          (val_div, ":price_factor", 2),
##        (try_end),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #VELVET
##      (try_begin),
##        (eq, ":item_kind_id", "itm_velvet"),
##        (neq, "$g_encountered_party", "p_town_12"),#Velvet comes from lunden
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_12"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #IRON
##      (try_begin),
##        (eq, ":item_kind_id", "itm_iron"),
##        (neq, "$g_encountered_party", "p_town_26"),#Iron comes from brychen
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_26"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 400),#Bulk cargo, low profit
##        (val_add, ":price_factor", ":dist"),
##        (try_begin),
##          (eq, "$g_encountered_party", "p_town_14"),#Iron heavily used in kingdom4
##          (val_mul, ":price_factor", 3),
##          (val_div, ":price_factor", 2),
##        (try_end),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #TOOLS
##      (try_begin),
##        (eq, ":item_kind_id", "itm_tools"),
##        (neq, "$g_encountered_party", "p_town_26"),#Tools come from brych
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_26"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 200),#Valuable everywhere
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #RAW LEATHER
##      (try_begin),
##        (eq, ":item_kind_id", "itm_raw_leather"),
##        (neq, "$g_encountered_party", "p_town_3"),#Raw leather comes from din eydin
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_3"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 400),#Bulk cargo, low profit
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #LEATHERWORK
##      (try_begin),
##        (eq, ":item_kind_id", "itm_leatherwork"),
##        (neq, "$g_encountered_party", "p_town_6"),#Raw leather comes from breatan
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_6"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #SILVER
##      (try_begin),
##        (eq, ":item_kind_id", "itm_silver"),
##        (neq, "$g_encountered_party", "p_town_29"),#Raw dates come from caer fryddin
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_29"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #FURS
##      (try_begin),
##        (eq, ":item_kind_id", "itm_furs"),
##        (neq, "$g_encountered_party", "p_town_39"),#Furs come from dun tauro
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_39"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##      
##      #WINE
##      (try_begin),
##        (eq, ":item_kind_id", "itm_wine"),
##        (neq, "$g_encountered_party", "p_town_1"),#Wine comes from centwareburh
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_1"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg1, ":price_factor"),
##      (try_end),
##      
##      #ALE
##      (try_begin),
##        (eq, ":item_kind_id", "itm_ale"),
##        (neq, "$g_encountered_party", "p_town_4"),#Ale comes from 9
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_4"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##
##      #STONE
##      (try_begin),
##        (eq, ":item_kind_id", "itm_ale"),
##        (neq, "$g_encountered_party", "p_town_31"),#Ale comes from temair
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_31"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##
##      #MEAD
##      (try_begin),
##        (eq, ":item_kind_id", "itm_ale"),
##        (neq, "$g_encountered_party", "p_town_22"),#Ale comes from 22
##        (party_get_position, pos1, "$g_encountered_party"),
##        (party_get_position, pos2, "p_town_22"),
##        (get_distance_between_positions, ":dist", pos1, pos2),
##        (val_div, ":dist", 300),
##        (val_add, ":price_factor", ":dist"),
##        (assign, reg0, ":price_factor"),
##      (try_end),
##  ]),
#####xenoargh improve trade system chief no lo usamos por ahora

  #script_game_get_item_buy_price_factor:
  # This script is called from the game engine for calculating the buying price of any item.
  # INPUT:
  # param1: item_kind_id
  # OUTPUT:
  # trigger_result and reg0 = price_factor
  ("game_get_item_buy_price_factor",
    [
      (store_script_param_1, ":item_kind_id"),
      (assign, ":price_factor", 100),

      (call_script, "script_get_trade_penalty", ":item_kind_id"),
      (assign, ":trade_penalty", reg0),

      (try_begin),
        (is_between, "$g_encountered_party", centers_begin, centers_end),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
        (val_add, ":item_slot_no", "slot_town_trade_good_prices_begin"),
        (party_get_slot, ":price_factor", "$g_encountered_party", ":item_slot_no"),
		
		#new
		#(try_begin),
		#	(is_between, "$g_encountered_party", villages_begin, villages_end),
		#	(party_get_slot, ":market_town", "$g_encountered_party", "slot_village_market_town"),
		#	(party_get_slot, ":price_in_market_town", ":market_town", ":item_slot_no"),
		#	(val_max, ":price_factor", ":price_in_market_town"),
		#(try_end),
		
		#For villages, the good will be sold no cheaper than in the market town
		#This represents the absence of a permanent market -- ie, the peasants retain goods to sell on their journeys to town, and are not about to do giveaway deals with passing adventurers
		
		
        (val_mul, ":price_factor", 100), #normalize price factor to range 0..100
        (val_div, ":price_factor", average_price_factor),
      (try_end),
      
      (store_add, ":penalty_factor", 100, ":trade_penalty"), #ajm chief controla el precio de compra
      
      (val_mul, ":price_factor", ":penalty_factor"),
      (val_div, ":price_factor", 100),

      (assign, reg0, ":price_factor"),
      (set_trigger_result, reg0),
  ]),
  
  #script_game_get_item_sell_price_factor:
  # This script is called from the game engine for calculating the selling price of any item.
  # INPUT:
  # param1: item_kind_id
  # OUTPUT:
  # trigger_result and reg0 = price_factor
  ("game_get_item_sell_price_factor",
    [
      (store_script_param_1, ":item_kind_id"),
      (assign, ":price_factor", 100),

      (call_script, "script_get_trade_penalty", ":item_kind_id"),
      (assign, ":trade_penalty", reg0),

      (try_begin),
        (is_between, "$g_encountered_party", centers_begin, centers_end),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
        (val_add, ":item_slot_no", "slot_town_trade_good_prices_begin"),
        (party_get_slot, ":price_factor", "$g_encountered_party", ":item_slot_no"),
        (val_mul, ":price_factor", 100),#normalize price factor to range 0..100
        (val_div, ":price_factor", average_price_factor),
      (else_try),
        #increase trade penalty while selling weapons, armor, and horses
        (val_mul, ":trade_penalty", 4),#gdwleftunchanged reduce to ease
      (try_end),
            
      (store_add, ":penalty_divisor", 100, ":trade_penalty"),
      
      (val_mul, ":price_factor", 100),
      (val_div, ":price_factor", ":penalty_divisor"),
      
      (assign, reg0, ":price_factor"),
      (set_trigger_result, reg0),
  ]),
  
  # script_get_trade_penalty
  #
  # Input:
  # param1: troop_id,
  # Output: reg0

  ("get_trade_penalty",
    [
      (store_script_param_1, ":item_kind_id"),
      (assign, ":penalty",0),
      
      (party_get_skill_level, ":trade_skill", "p_main_party", skl_trade),
      (try_begin),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (assign, ":penalty", 22),  #Changed to 20 TML. F123 - Submod -> 1.41 (penalty - skill bonus will be neg unless raise to 24gdw
              (store_mul, ":skill_bonus", ":trade_skill", 2),    #MOTO   chief   affect more with merchant skill, increase from 1
      #(assign, ":penalty", 12), #reduced slightly 20-15-12
      #  (store_mul, ":skill_bonus", ":trade_skill", 1),
        (val_sub, ":penalty", ":skill_bonus"),
		(val_max, ":penalty", 4), ##gdw was at 3		
      (else_try),
        (assign, ":penalty",85),    #MOTO chief make non-trade items      more #tradeable, reduce from 100 to 80 GDWback85   (85 -6*tradeskill)
      (store_mul, ":skill_bonus", ":trade_skill", 6), #gdw5
        (val_sub, ":penalty", ":skill_bonus"),
      (try_end),

      (assign, ":penalty_multiplier", 1000),
##       # Apply penalty if player is hostile to merchants faction
##      (store_relation, ":merchants_reln", "fac_merchants", "fac_player_supporters_faction"),
##      (try_begin),
##        (lt, ":merchants_reln", 0),
##        (store_sub, ":merchants_reln_dif", 10, ":merchants_reln"),
##        (store_mul, ":merchants_relation_penalty", ":merchants_reln_dif", 20),
##        (val_add, ":penalty_multiplier", ":merchants_relation_penalty"),
##      (try_end),

       # Apply penalty if player is on bad terms with the town
      (try_begin),
        (is_between, "$g_encountered_party", centers_begin, centers_end),
        (party_get_slot, ":center_relation", "$g_encountered_party", "slot_center_player_relation"),
        (store_mul, ":center_relation_penalty", ":center_relation", -3),
        (val_add, ":penalty_multiplier", ":center_relation_penalty"),
        (try_begin),
          (lt, ":center_relation", 0),
          (store_sub, ":center_penalty_multiplier", 100, ":center_relation"),
          (val_mul, ":penalty_multiplier", ":center_penalty_multiplier"),
          (val_div, ":penalty_multiplier", 100),
        (try_end),
      (try_end),

       # Apply penalty if player is on bad terms with the merchant (not currently used)
      (call_script, "script_troop_get_player_relation", "$g_talk_troop"),
      (assign, ":troop_reln", reg0),
      #(troop_get_slot, ":troop_reln", "$g_talk_troop", "slot_troop_player_relation"),
      (try_begin),
        (lt, ":troop_reln", 0),
        (store_sub, ":troop_reln_dif", 0, ":troop_reln"),
        (store_mul, ":troop_relation_penalty", ":troop_reln_dif", 20),
        (val_add, ":penalty_multiplier", ":troop_relation_penalty"),
      (try_end),
      
      
     # (try_begin),
     #   (is_between, "$g_encountered_party", villages_begin, villages_end),
	 #   (val_mul, ":penalty", 4), #1.25x trade penalty in villages.##gdw 
	#	(val_div, ":penalty", 4),
     # (try_end),
      
	  #(try_begin),
            #(is_between, "$g_encountered_party", centers_begin, centers_end),
	    ##Double trade penalty if no local production or consumption
	    #(is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
	    #(call_script, "script_center_get_production", "$g_encountered_party", ":item_kind_id"),
	    #(eq, reg0, 0),
	    #(call_script, "script_center_get_consumption", "$g_encountered_party", ":item_kind_id"),
	    #(eq, reg0, 0),
	    #(val_mul, ":penalty", 2),
	  #(try_end),
      
      (val_mul, ":penalty",  ":penalty_multiplier"),
      (val_div, ":penalty", 1000),
      (val_max, ":penalty", 1),
      (assign, reg0, ":penalty"),
  ]),
  
  #script_game_event_buy_item:
  # This script is called from the game engine when player buys an item.
  # INPUT:
  # param1: item_kind_id
  ("game_event_buy_item",
    [
      (store_script_param_1, ":item_kind_id"),
      (store_script_param_2, ":reclaim_mode"),
      (try_begin),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
        (val_add, ":item_slot_no", "slot_town_trade_good_prices_begin"),
        (party_get_slot, ":multiplier", "$g_encountered_party", ":item_slot_no"),
        (try_begin),
          (eq, ":reclaim_mode", 0),
          (val_add, ":multiplier", 16),##gdw was at 20
        (else_try),
          (val_add, ":multiplier", 24),##gdw was at 30
        (try_end),

		(store_item_value, ":item_value", ":item_kind_id"),
		(try_begin),
		  (ge, ":item_value", 100),
		  (store_sub, ":item_value_sub_100", ":item_value", 100),
		  (store_div, ":item_value_sub_100_div_8", ":item_value_sub_100", 8),
		  (val_add, ":multiplier", ":item_value_sub_100_div_8"),
		(try_end),
        (val_min, ":multiplier", maximum_price_factor),
        (party_set_slot, "$g_encountered_party", ":item_slot_no", ":multiplier"),
      (try_end),
  ]),
  
  #script_game_event_sell_item:
  # This script is called from the game engine when player sells an item.
  # INPUT:
  # param1: item_kind_id
  ("game_event_sell_item",
    [
      (store_script_param_1, ":item_kind_id"),
      (store_script_param_2, ":return_mode"),
      (try_begin),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
        (val_add, ":item_slot_no", "slot_town_trade_good_prices_begin"),
        (party_get_slot, ":multiplier", "$g_encountered_party", ":item_slot_no"),
        (try_begin),
          (eq, ":return_mode", 0),
          (val_sub, ":multiplier", 24),##gdw was at 30
        (else_try),
          (val_sub, ":multiplier", 16),##gdw was at 20
        (try_end),

		(store_item_value, ":item_value", ":item_kind_id"),
		(try_begin),
		  (ge, ":item_value", 100),
		  (store_sub, ":item_value_sub_100", ":item_value", 100),
		  (store_div, ":item_value_sub_100_div_8", ":item_value_sub_100", 8),
		  (val_sub, ":multiplier", ":item_value_sub_100_div_8"),
		(try_end),
        (val_max, ":multiplier", minimum_price_factor),
        (party_set_slot, "$g_encountered_party", ":item_slot_no", ":multiplier"),
      (try_end),
  ]),
  
  #script_start_wedding_cutscene
  # INPUT: arg1 = groom_troop, arg2 = bride_troop
  # OUTPUT: none
  ("start_wedding_cutscene",
   [
     (store_script_param, "$g_wedding_groom_troop", 1),
     (store_script_param, "$g_wedding_bride_troop", 2),

     (assign, "$g_wedding_bishop_troop", "trp_temporary_minister"),
     (try_begin),
       (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
       (neg|faction_slot_eq, "$players_kingdom", "slot_faction_leader", "$g_wedding_groom_troop"),
       (neg|faction_slot_eq, "$players_kingdom", "slot_faction_leader", "$g_wedding_bride_troop"),
       (faction_get_slot, ":players_king", "$players_kingdom", "slot_faction_leader"),
       (troop_get_type, ":troop_type", ":players_king"),
###gender fix chief
       (this_or_next|eq, ":troop_type", 0), #male
       (this_or_next|eq, ":troop_type", 2), #male
       (this_or_next|eq, ":troop_type", 4), #male
       (eq, ":troop_type", 6), #male
#gender fix chief acaba
       (neq, ":players_king", "$g_wedding_groom_troop"),
       (assign, "$g_wedding_bishop_troop", ":players_king"),
     (else_try),
       (eq, "$players_kingdom", "fac_player_supporters_faction"),
       (faction_slot_eq, "$players_kingdom", "slot_faction_leader", "trp_player"),
       (gt, "$g_player_minister", 0),
       (troop_get_type, ":troop_type", "$g_player_minister"),
###gender fix chief
       (this_or_next|eq, ":troop_type", 0), #male
       (this_or_next|eq, ":troop_type", 2), #male
       (this_or_next|eq, ":troop_type", 4), #male
       (eq, ":troop_type", 6), #male
#gender fix chief acaba
       (neq, "$g_player_minister", "$g_wedding_groom_troop"),
       (assign, "$g_wedding_bishop_troop", "$g_player_minister"),
     (try_end),

     (assign, "$g_wedding_brides_dad_troop", "trp_temporary_minister"),
     (try_begin),
       (neq, "$g_wedding_bride_troop", "trp_player"),
       (try_begin),
         (troop_get_slot, ":father", "$g_wedding_bride_troop", "slot_troop_father"),
         (gt, ":father", 0),
         (troop_get_type, ":troop_type", ":father"), #just to make sure
###gender fix chief
       (this_or_next|eq, ":troop_type", 0), #male
       (this_or_next|eq, ":troop_type", 2), #male
       (this_or_next|eq, ":troop_type", 4), #male
       (eq, ":troop_type", 6), #male
#gender fix chief acaba
         (neq, ":father", "$g_wedding_groom_troop"), #this might be 0 due to an error
         (neq, ":father", "$g_wedding_bishop_troop"),
         (assign, "$g_wedding_brides_dad_troop", ":father"),
       (else_try),
         (troop_get_slot, ":guardian", "$g_wedding_bride_troop", "slot_troop_guardian"),
         (gt, ":guardian", 0),
         (troop_get_type, ":troop_type", ":guardian"), #just to make sure
###gender fix chief
       (this_or_next|eq, ":troop_type", 0), #male
       (this_or_next|eq, ":troop_type", 2), #male
       (this_or_next|eq, ":troop_type", 4), #male
       (eq, ":troop_type", 6), #male
#gender fix chief acaba
         (neq, ":guardian", "$g_wedding_groom_troop"), #this might be 0 due to an error
         (neq, ":guardian", "$g_wedding_bishop_troop"),
         (assign, "$g_wedding_brides_dad_troop", ":guardian"),
       (try_end),
     (else_try),
       (try_for_range, ":cur_companion", companions_begin, companions_end),
         (this_or_next|troop_slot_eq, ":cur_companion", "slot_troop_occupation", slto_player_companion),
         (troop_slot_eq, ":cur_companion", "slot_troop_occupation", slto_kingdom_hero),
         (troop_get_type, ":troop_type", ":cur_companion"), #just to make sure
###gender fix chief
       (this_or_next|eq, ":troop_type", 0), #male
       (this_or_next|eq, ":troop_type", 2), #male
       (this_or_next|eq, ":troop_type", 4), #male
       (eq, ":troop_type", 6), #male
#gender fix chief acaba
         (neq, ":cur_companion", "$g_wedding_groom_troop"),
         (neq, ":cur_companion", "$g_wedding_bishop_troop"),
         (assign, "$g_wedding_brides_dad_troop", ":cur_companion"),
       (try_end),
     (try_end),

     (modify_visitors_at_site,"scn_wedding"),
     (reset_visitors,0),
     (set_visitor, 0, "$g_wedding_groom_troop"),
     (set_visitor, 1, "$g_wedding_bride_troop"),
     (set_visitor, 2, "$g_wedding_brides_dad_troop"),
     (set_visitor, 3, "$g_wedding_bishop_troop"),
     (assign, ":num_visitors", 4),
     (assign, ":num_male_visitors", 0),
     (try_for_range, ":cur_npc", active_npcs_begin, kingdom_ladies_end),
       (lt, ":num_visitors", 32),
       (neq, ":cur_npc", "$g_wedding_groom_troop"),
       (neq, ":cur_npc", "$g_wedding_bride_troop"),
       (neq, ":cur_npc", "$g_wedding_brides_dad_troop"),
       (neq, ":cur_npc", "$g_wedding_bishop_troop"),
       (store_troop_faction, ":npc_faction", ":cur_npc"),
       (is_between, ":npc_faction", kingdoms_begin, kingdoms_end),
       (eq, ":npc_faction", "$players_kingdom"),
       (this_or_next|troop_slot_eq, ":cur_npc", "slot_troop_occupation", slto_player_companion),
       (this_or_next|troop_slot_eq, ":cur_npc", "slot_troop_occupation", slto_kingdom_hero),
       (troop_slot_eq, ":cur_npc", "slot_troop_occupation", slto_kingdom_lady),
       (troop_get_type, ":troop_type", ":cur_npc"),
       (assign, ":continue_adding", 1),
       (try_begin),
###gender fix chief
       (this_or_next|eq, ":troop_type", 0), #male
       (this_or_next|eq, ":troop_type", 2), #male
       (this_or_next|eq, ":troop_type", 4), #male
       (eq, ":troop_type", 6), #male
#gender fix chief acaba
         (assign, ":continue_adding", 0),
         (lt, ":num_male_visitors", 16), #limit number of male visitors
         (assign, ":continue_adding", 1),
         (val_add, ":num_male_visitors", 1),
       (try_end),
       (eq, ":continue_adding", 1),
       (set_visitor, ":num_visitors", ":cur_npc"),
       (val_add, ":num_visitors", 1),
     (try_end),
     (set_jump_mission,"mt_wedding"),
     (jump_to_scene,"scn_wedding"),
     (change_screen_mission),
    ]),
	
  
  # script_game_get_troop_wage
  # This script is called from the game engine for calculating troop wages.
  # Input:
  # param1: troop_id, param2: party-id
  # Output: reg0: weekly wage sueldos
  
  ("game_get_troop_wage",
    [
      (store_script_param_1, ":troop_id"),
      (store_script_param_2, ":unused"), #party id
      
      (assign,":wage", 0),
      (try_begin),
        (this_or_next|eq, ":troop_id", "trp_player"),
        (eq, ":troop_id", "trp_kidnapped_girl"),
      (else_try),
        (is_between, ":troop_id", pretenders_begin, pretenders_end),
      (else_try),
        (store_character_level, ":troop_level", ":troop_id"),
        (assign, ":wage", ":troop_level"),
		(val_add, ":wage", 3),#tml and f123 Getting base wage
        (val_mul, ":wage", ":wage"),
		(val_div, ":wage", 21),#TMLchoseNativewages.gdw30-24?greatwagedropfrmLdrshp
	  (try_end), 
        
      #(else_try), #chief cambia sueldos de tropas, produces wage =  (troop_level + 20)  * (troop_level + 20) / 20
      #  (store_character_level, ":troop_level", ":troop_id"), #produces wage chief =  (troop_level * 20)  + (troop_level * 20) / 25
      #  (assign, ":wage", ":troop_level"),
      #  (val_mul, ":wage", ":wage"), #chief cambiado
       # (val_add, ":wage", ":wage"), #chief cambia
      #  (val_div, ":wage", 25), #chief cambiado
      #(try_begin),
      # (lt, ":troop_level", 25),
      #  (val_mul, ":wage", 2), 
      #  (val_div, ":wage", 4), #chief cambiado divido entre dos si la tropa es inferior a nivel 20 y suma 20 si es superior
      #(val_add, ":wage", 10), #chief cambia
##      (else_try),
##       (gt, ":troop_level", 22),
##       (lt, ":troop_level", 26),
##      (val_add, ":wage", 1), #chief cambia
      #(else_try),
#       (gt, ":troop_level", 26),
      #(val_add, ":wage", 40), #chief cambia
      #(try_end),
      #(val_max, ":wage", 1),
      #(try_end),#TMLchanges end

      (try_begin), #mounted troops cost 50% more than the normal cost#must be a #mistake if it was 7/3gdw Now 100% more
       (neg|is_between, ":troop_id", companions_begin, companions_end),
         (troop_is_mounted, ":troop_id"),
        (val_mul, ":wage", 3),#chief cambiado##gdw was at 7/3
        (val_div, ":wage", 2), 
        #(val_mul, ":wage", 2), #chief cambiado##gdw was at 7/3
      #  (val_div, ":wage", 3), #chief cambiado#gdwGavenative values.5/3
      (try_end),

      (try_begin), #mercenaries cost %50 more than the normal cost
        (this_or_next|is_between, ":troop_id", mercenary_troops_begin, mercenary_troops_end),
        (is_between, ":troop_id", mercenary_troops2_begin, mercenary_troops2_end),
        (val_mul, ":wage", 5), ##gdw was at 4/2
        (val_div, ":wage", 3), #chief cambiado
      (try_end),

      # (try_begin), #mercenaries cost %50 more than the normal cost ##gdw temporary increase for locals from taverns 
      #   (this_or_next|is_between, 
      #   #(is_between, ":item_no", estandartes_begin, estandartes_end),
      #   (val_mul, ":wage", 5), ##gdw was at 4/2
      #   (val_div, ":wage", 3), #chief cambiado
      # (try_end),

      (try_begin), # aun mas para espias chief
        (eq, ":troop_id", "trp_merc_spy"),
        (val_add, ":wage", 60), #chief cambia gdw100raisedactivation120%
      (try_end),

      (try_begin),
        (is_between, ":troop_id", companions_begin, companions_end),
        (val_mul, ":wage", 3), ##gdw was at 4
        (val_div, ":wage", 2), 
      (try_end),

      (try_begin), #aumenta bandidos
        (is_between, ":troop_id", bandits_begin, bandits_end),
        (val_mul, ":wage", 4), #gdwpirates deserve more was at 100%tml:noraise
        (val_div, ":wage", 3), #chief cambiado
      (try_end),
      
##      ## CC chief sueldos 
##      (try_begin),
##        (is_between, ":troop_id", kingdom_troops_begin, kingdom_troops_end),
##        (store_troop_faction, ":troop_faction", ":troop_id"),
##        (try_begin),
##          (is_between, "$players_kingdom", commom_kingdoms_begin, commom_kingdoms_end),
##          (assign, ":player_cur_faction", "$players_kingdom"),
##        (else_try),
##          (is_between, "$supported_pretender", pretenders_begin, pretenders_end),
##          (assign, ":player_cur_faction", "$supported_pretender_old_faction"),
##        (else_try),
##          (assign, ":player_cur_faction", -1),
##        (try_end),
##        (try_begin),
##          (eq, ":troop_faction", ":player_cur_faction"), # wage = wage*1
##        (else_try),
##          (store_relation, ":cur_relation", "fac_player_supporters_faction", ":troop_faction"),
##          (try_begin),
##            (ge, ":cur_relation", 0),
##            (val_mul, ":wage", 3),
##            (val_div, ":wage", 2),
##          (else_try),
##            (val_mul, ":wage", 2),
##          (try_end),
##        (try_end),
##      (try_end),
##      ## CC 

      (store_skill_level, ":leadership_level", "skl_leadership", "trp_player"),
      (store_mul, ":leadership_bonus", 7, ":leadership_level"), #gdw was at 5
      (store_sub, ":leadership_factor", 100, ":leadership_bonus"), 
      (val_mul, ":wage", ":leadership_factor"),  #original:wage = wage * (100 - 5*leadership)/100
      (val_div, ":wage", 75),#gdwwas100 OriginalIf L=5 and wage-40 #(old: 40*(100-5*5)/75=40 New: 40(100-7*5)/75=34.7
#   old L=7 60*(100-5*7)/75=52 New: 60(100-7*7)/75=40.8
      (try_begin),
        (neq, ":troop_id", "trp_player"),
        (neq, ":troop_id", "trp_kidnapped_girl"),
        (neg|is_between, ":troop_id", pretenders_begin, pretenders_end),
        (val_max, ":wage", 1),
      (try_end),
       
      (assign, reg0, ":wage"),
      (set_trigger_result, reg0),
  ]),

  # script_game_get_total_wage
  # This script is called from the game engine for calculating total wage of the player party which is shown at the party window.
  # Input: none
  # Output: reg0: weekly wage
  
  ("game_get_total_wage",
    [
      (assign, ":total_wage", 0),
      (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", "p_main_party", ":i_stack"),
        (party_stack_get_size, ":stack_size", "p_main_party", ":i_stack"),
        (call_script, "script_game_get_troop_wage", ":stack_troop", 0),
        (val_mul, reg0, ":stack_size"),
        (val_add, ":total_wage", reg0),
      (try_end),
	  ##diplomacy start+ chief
	  #If the player leads a kingdom, take into account centralization.
	  (faction_get_slot, ":centralization", "$players_kingdom", "slot_faction_centralization"),
	  (try_begin),
		  (neq, ":centralization", 0),

		  (assign, reg0, 0),
	     (try_begin),
		     (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
		     (faction_get_slot, ":faction_leader", "$players_kingdom", "slot_faction_leader"),
		     (ge, ":faction_leader", 0),
		     (this_or_next|eq, ":faction_leader", "trp_player"),
		     (this_or_next|troop_slot_eq, ":faction_leader", "slot_troop_spouse", "trp_player"),
              (troop_slot_eq, "trp_player", "slot_troop_spouse", reg0),
           (assign, reg0, 1),
        (try_end),

		  (this_or_next|eq, reg0, 1),
		     (eq, "$players_kingdom", "fac_player_supporters_faction"),
		  (faction_slot_eq, "$players_kingdom", "slot_faction_state", sfs_active),

		  #Apply centralization, but limit it for nascent kingdoms
        (val_clamp, ":centralization", -3, 4),
	     (faction_get_slot, ":policy_limit", "$players_kingdom", "slot_faction_num_towns"),
	     (faction_get_slot, reg0, "$players_kingdom", "slot_faction_num_castles"),
	     (val_add, ":policy_limit", reg0),

	     (val_max, ":policy_limit", 0),
	     (val_min, ":centralization", ":policy_limit"),
	     (val_mul, ":policy_limit", -1),
	     (val_max, ":centralization", ":policy_limit"),

		  #Now reg0 is going to be the result again
		  (store_mul, reg0, ":centralization", -5),
		  (val_add, reg0, 100),
		  (val_mul, reg0, ":total_wage"),
		  (val_add, reg0, 50),#rounding
		  (val_div, reg0, 100),
	  (try_end),
    ##diplomacy end+
 #Tempered  chief       ############################    WAGES FOR SPIES IN TOWNS  ###############################################
	  (assign,":spy_count",0),
		(try_for_range,":cur_center",centers_begin,centers_end),
			(party_get_slot,":spy_days",":cur_center","slot_spy_in_town"),
			(try_begin),
				(ge,":spy_days",1),
				(val_add,":spy_count",1),
			(try_end),
		(try_end),
	  (try_begin),
		(ge,":spy_count",1),
		(val_mul,":spy_count",220), #Tempered pay is 2x normal for troop type, dead spies earn no pay##gdw was at 128
		(val_add,":total_wage",":spy_count"),
	  (try_end),
      #Tempered chief end spy wages
      (assign, reg0, ":total_wage"),
      (set_trigger_result, reg0),
  ]),
  
  # script_game_get_join_cost
  # This script is called from the game engine for calculating troop join cost.
  # Input:
  # param1: troop_id,
  # Output: reg0: weekly wage
  
  ("game_get_join_cost", ###gdw 41016 revert this back to jan version after finish testing
    [
      (store_script_param_1, ":troop_id"),
      (try_begin),
                        (ge, "$cheat_mode", 1),
                        (display_message, "@{!}DEBUG: calling gamegetjoincost"),
                       (try_end),
      (assign,":join_cost", 0),
      (try_begin),
        (troop_is_hero, ":troop_id"),
      (else_try),
        (store_character_level, ":troop_level", ":troop_id"),
        (assign, ":join_cost", ":troop_level"),
        (val_add, ":join_cost", 10), #chief cambia
        (val_mul, ":join_cost", ":join_cost"),
        (val_add, ":join_cost", 50), #chief cambia
        (val_div, ":join_cost", 5),
        (try_begin), #mounted troops cost %200 more than the normal cost chief cambia
          (troop_is_mounted, ":troop_id"),
          (val_mul, ":join_cost", 3),
        (else_try), #mercenaries cost %50 more than the normal cost ##gdw temporary increase for locals from taverns 
	        (is_between, ":troop_id", mercenary_troops2_begin, mercenary_troops2_end), ##gdw this makes native mercs more expensive up front even though bargain down the road
	        #(is_between, ":item_no", estandartes_begin, estandartes_end),
	        (val_mul, ":join_cost", 5), ##gdw was at 4/2
	        (val_div, ":join_cost", 3), #chief cambiado
      	(try_end),
      (try_end),
      (assign, reg0, ":join_cost"),
      (set_trigger_result, reg0),
  ]),
  # (try_begin), #mercenaries cost %50 more than the normal cost
  #       (this_or_next|is_between, ":troop_id", mercenary_troops_begin, mercenary_troops_end),
  #       #(is_between, ":item_no", estandartes_begin, estandartes_end),
  #       (val_mul, ":wage", 4), ##gdw was at 4/2
  #       (val_div, ":wage", 3), #chief cambiado
  #     (try_end),


  # script_game_get_upgrade_xp
  # This script is called from game engine for calculating needed troop upgrade exp
  # Input:
  # param1: troop_id,
  # Output: reg0 = needed exp for upgrade 
  ("game_get_upgrade_xp",
    [
      (store_script_param_1, ":troop_id"),
      
      (assign, ":needed_upgrade_xp", 0),
      #formula : int needed_upgrade_xp = 2 * (30 + 0.006f * level_boundaries[troops[troop_id].level * 2]); # CC chief
      (store_character_level, ":troop_level", ":troop_id"),
      ## CC cambia chief, si multiplica en vez de sumar, elite troops son mas caras.
      ## CC chief por nivel
      (store_mul, ":needed_upgrade_xp", ":troop_level", 3),
      (val_div, ":needed_upgrade_xp", 2),
      ## CC

##      (try_begin),
##      (eq, "$g_realism_upgrade", 1),
##      (store_mul, ":needed_upgrade_xp", ":troop_level", 3),
##      (val_div, ":needed_upgrade_xp", 2),
##      (else_try),
##      (eq, "$g_realism_upgrade", 0),
##      (store_mul, ":needed_upgrade_xp", ":troop_level", 2),
##      (try_end),
      ## CC
#####por niveles
##      (try_begin),
##       (lt, ":troop_level", 20),
##      (val_add, ":needed_upgrade_xp", 500), #chief cambia
##      (else_try),
##       (gt, ":troop_level", 20),
##       (lt, ":troop_level", 26),
##      (val_add, ":needed_upgrade_xp", 2000), #chief cambia
##      (else_try),
##       (gt, ":troop_level", 26),
##       (lt, ":troop_level", 28),
##      (val_add, ":needed_upgrade_xp", 4000), #chief cambia
##      (else_try),
##       (gt, ":troop_level", 28),
##      (val_add, ":needed_upgrade_xp", 6000), #chief cambia
##      (try_end),
#####por niveles
      (get_level_boundary, reg0, ":needed_upgrade_xp"),        
      (val_mul, reg0, 6),#gdw ripe place for mod
      (val_div, reg0, 1000),
      (val_add, reg0, 30),

      (try_begin),               
        (ge, ":troop_id", bandits_begin),
        (lt, ":troop_id", bandits_end),
        (val_mul, reg0, 2),
      (try_end),

      ##chief, mas upgrade xp en nivel avanzado
      (try_begin),
      (eq, "$g_realism_upgrade", 0),
         (store_troop_faction, ":faction_no", ":troop_id"),
      (try_begin),
      (this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
      (eq, ":faction_no", "fac_player_faction"),
         (gt, ":troop_level", 24),
#        (this_or_next|troop_is_guarantee_horse, ":troop_id"),
        (val_mul, reg0, 3), 
        (val_div, reg0, 2), 
      (try_end),
      (try_end),
      ## chief acaba

      (set_trigger_result, reg0),
  ]),
  
#xp upgrade para freelancer chief
  # Input:
  # param1: troop_id,
  # Output: reg0 = needed exp for upgrade 
  ("game_get_upgrade_xp_freelancer",
    [
      (store_script_param_1, ":troop_id"),
      
      (assign, ":needed_upgrade_xp", 0),
      #formula : int needed_upgrade_xp = 2 * (30 + 0.006f * level_boundaries[troops[troop_id].level + 3]);
      (store_character_level, ":troop_level", ":troop_id"),
      (store_add, ":needed_upgrade_xp", ":troop_level", 3),
      (get_level_boundary, reg0, ":needed_upgrade_xp"),        
      (val_mul, reg0, 6),
      (val_div, reg0, 1000),
      (val_add, reg0, 30),
        (val_mul, reg0, 4),

      (set_trigger_result, reg0),
  ]),


  # script_game_get_upgrade_cost
  # This script is called from game engine for calculating needed troop upgrade exp
  # Input:
  # param1: troop_id,
  # Output: reg0 = needed cost for upgrade
  ("game_get_upgrade_cost",
    [
      (store_script_param_1, ":troop_id"),
      
      (store_character_level, ":troop_level", ":troop_id"),
#chief cambia costes de upgrade      
      (try_begin),
        (is_between, ":troop_level", 0, 16),#gdw50#gdw4%included some tml
        (assign, reg0, 30),
      (else_try),  
        (is_between, ":troop_level", 16, 20),#gdw100
        (assign, reg0, 60),
      (else_try),  
        (is_between, ":troop_level", 20, 24),#gdw300
        (assign, reg0, 200),
      (else_try),  
        (is_between, ":troop_level", 24, 26),#gdw700 
        (assign, reg0, 420),
      (else_try),  
        (is_between, ":troop_level", 26,28),#2000gdwlowerhereifremovelootbostscript 
        (assign, reg0, 750),
      (else_try),  
        (is_between, ":troop_level", 28, 30),#gdwelitearmorinBW3000
        (assign, reg0, 1000),#gdwlowerhereifremovelootbostscript 33%
      (else_try),  
        (is_between, ":troop_level", 30, 34),#gdwgetveryelitearmorinBW
        (assign, reg0, 1400),#gdwlowerhereifremovelootbostscript 33%
      (else_try),  
        (assign, reg0, 1700),#gdwthiswillrarelyhappenwithtroops33%
      (try_end),  
##      ## CC chief cambia coste de upgrade troops
##      (assign, ":cost", ":troop_level"),
##      (val_add, ":cost", 6),
##      (val_mul, ":cost", ":cost"),
##      (val_div, ":cost", 3),
##      (try_begin), #mounted troops cost 50% more than the normal cost
##        (troop_is_mounted, ":troop_id"),
##        (val_mul, ":cost", 6),
##        (val_div, ":cost", 1),
##      (try_end),
##      (assign, reg0, ":cost"),
##      ## CC
   
      (set_trigger_result, reg0),
  ]),

  # script_game_get_prisoner_price
  # This script is called from the game engine for calculating prisoner price
  # Input:
  # param1: troop_id,
  # Output: reg0
  #cambiado chief para que siempre sea importante el nivel
  ("game_get_prisoner_price",
    [
      (store_script_param_1, ":troop_id"),

      (try_begin),
        (is_between, "$g_talk_troop", ransom_brokers_begin, ransom_brokers_end),
        (store_character_level, ":troop_level", ":troop_id"),
        (assign, ":ransom_amount", ":troop_level"),
        (val_add, ":ransom_amount", 12),
        (val_mul, ":ransom_amount", ":ransom_amount"),
        (val_div, ":ransom_amount", 5),## gdw was 6
      (else_try),#is this for yourng warriors?
        (store_character_level, ":troop_level", ":troop_id"),
        (assign, ":ransom_amount", ":troop_level"),
        (val_add, ":ransom_amount", 10),
        (val_mul, ":ransom_amount", ":ransom_amount"),
        (val_div, ":ransom_amount", 6),## gdw was 10 It's too hard to find a ransom broker all the time
      (else_try),  ## gdw from native not sure what this is for
        (assign, ":ransom_amount", 100),#gdw50
      (try_end),
      
      (assign, reg0, ":ransom_amount"),
      (set_trigger_result, reg0),
	 ]),

  # script_game_check_prisoner_can_be_sold
  # This script is called from the game engine for checking if a given troop can be sold.
  # Input: 
  # param1: troop_id,
  # Output: reg0: 1= can be sold; 0= cannot be sold.
  ("game_check_prisoner_can_be_sold",
    [
      (store_script_param_1, ":troop_id"),
      (assign, reg0, 0),
      (try_begin),
        (neg|troop_is_hero, ":troop_id"),
        (assign, reg0, 1),
      (try_end),
      (set_trigger_result, reg0),
  ]),
  
  # script_game_get_morale_of_troops_from_faction
  # This script is called from the game engine 
  # Input: 
  # param1: faction_no,
  # Output: reg0: extra morale x 100
  
  ("game_get_morale_of_troops_from_faction",
    [
      (store_script_param_1, ":troop_no"),            
      
      (store_troop_faction, ":faction_no", ":troop_no"),
      
      (try_begin),
        (ge, ":faction_no", npc_kingdoms_begin),
        (lt, ":faction_no", npc_kingdoms_end),
        
        (faction_get_slot, reg0, ":faction_no",  "slot_faction_morale_of_player_troops"),

        #(assign, reg1, ":faction_no"),
        #(assign, reg2, ":troop_no"),
        #(assign, reg3, reg0),
        #(display_message, "@extra morale for troop {reg2} of faction {reg1} is {reg3}"),
      (else_try),
        (assign, reg0, 0),
      (try_end),
         ##diplomacy start+ chief
      #If there is no current morale penalty, then there will be a minor morale bonus
		#if the player has his own faction and his culture matches the source kingdom.
		(try_begin),
		   (eq, reg0, 0),
			(is_between,"$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
			(eq, "$g_player_culture", ":faction_no"),
			#xxx TODO: pick a number less arbitrarily
			(assign, reg0, 100),
		(try_end),
      ##diplomacy end+
         
      (val_div, reg0, 100),
      
      (party_get_morale, reg1, "p_main_party"),
      
      (val_add, reg0, reg1),
      
      (set_trigger_result, reg0),
  ]),
  
  #script_game_event_detect_party:
  # This script is called from the game engine when player party inspects another party.
  # INPUT:
  # param1: Party-id
  ("game_event_detect_party",
    [
        (store_script_param_1, ":party_id"),
        (try_begin),
          (party_slot_eq, ":party_id", "slot_party_type", spt_kingdom_hero_party),
          (party_stack_get_troop_id, ":leader", ":party_id", 0),
          (is_between, ":leader", active_npcs_begin, active_npcs_end),
          (call_script, "script_update_troop_location_notes", ":leader", 0),
        (else_try),
          (is_between, ":party_id", walled_centers_begin, walled_centers_end),
          (party_get_num_attached_parties, ":num_attached_parties",  ":party_id"),
          (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
            (party_get_attached_party_with_rank, ":attached_party", ":party_id", ":attached_party_rank"),
            (party_stack_get_troop_id, ":leader", ":attached_party", 0),
            (is_between, ":leader", active_npcs_begin, active_npcs_end),
            (call_script, "script_update_troop_location_notes", ":leader", 0),
          (try_end),
        (try_end),
  ]),

  #script_game_event_undetect_party:
  # This script is called from the game engine when player party inspects another party.
  # INPUT:
  # param1: Party-id
  ("game_event_undetect_party",
    [
        (store_script_param_1, ":party_id"),
        (try_begin),
          (party_slot_eq, ":party_id", "slot_party_type", spt_kingdom_hero_party),
          (party_stack_get_troop_id, ":leader", ":party_id", 0),
          (is_between, ":leader", active_npcs_begin, active_npcs_end),
          (call_script, "script_update_troop_location_notes", ":leader", 0),
        (try_end),
  ]),

  #script_game_get_statistics_line:
  # This script is called from the game engine when statistics page is opened.
  # INPUT:
  # param1: line_no
  ("game_get_statistics_line",
    [
      (store_script_param_1, ":line_no"),
      (try_begin),
        (eq, ":line_no", 0),
        (get_player_agent_kill_count, reg1),
        (str_store_string, s1, "str_number_of_troops_killed_reg1"),
        (set_result_string, s1),
      (else_try),
        (eq, ":line_no", 1),
        (get_player_agent_kill_count, reg1, 1),
        (str_store_string, s1, "str_number_of_troops_wounded_reg1"),
        (set_result_string, s1),
      (else_try),
        (eq, ":line_no", 2),
        (get_player_agent_own_troop_kill_count, reg1),
        (str_store_string, s1, "str_number_of_own_troops_killed_reg1"),
        (set_result_string, s1),
      (else_try),
        (eq, ":line_no", 3),
        (get_player_agent_own_troop_kill_count, reg1, 1),
        (str_store_string, s1, "str_number_of_own_troops_wounded_reg1"),
        (set_result_string, s1),
      (try_end),
  ]),

  #script_game_get_date_text:
  # This script is called from the game engine when the date needs to be displayed.
  # INPUT: arg1 = number of days passed since the beginning of the game
  # OUTPUT: result string = date
  ("game_get_date_text",
    [
		(store_script_param_1, ":version"), #duh moneylenders and buy land
      (store_script_param_2, ":num_hours"),
      (store_div, ":num_days", ":num_hours", 24),
      (store_add, ":cur_day", ":num_days", 23),
      (assign, ":cur_month", 2), #cambiado mes chief
      (assign, ":cur_year", 636), #cambiado fecha de inicio chief
      (assign, ":try_range", 99999),
      (try_for_range, ":unused", 0, ":try_range"),
        (try_begin),
          (this_or_next|eq, ":cur_month", 1),
          (this_or_next|eq, ":cur_month", 3),
          (this_or_next|eq, ":cur_month", 5),
          (this_or_next|eq, ":cur_month", 7),
          (this_or_next|eq, ":cur_month", 8),
          (this_or_next|eq, ":cur_month", 10),
          (eq, ":cur_month", 12),
          (assign, ":month_day_limit", 31),
        (else_try),
          (this_or_next|eq, ":cur_month", 4),
          (this_or_next|eq, ":cur_month", 6),
          (this_or_next|eq, ":cur_month", 9),
          (eq, ":cur_month", 11),
          (assign, ":month_day_limit", 30),
        (else_try),
          (try_begin),
            (store_div, ":cur_year_div_4", ":cur_year", 4),
            (val_mul, ":cur_year_div_4", 4),
            (eq, ":cur_year_div_4", ":cur_year"),
            (assign, ":month_day_limit", 29),
          (else_try),
            (assign, ":month_day_limit", 28),      
          (try_end),
        (try_end),
        (try_begin),
          (gt, ":cur_day", ":month_day_limit"),
          (val_sub, ":cur_day", ":month_day_limit"),
          (val_add, ":cur_month", 1),
          (try_begin),
            (gt, ":cur_month", 12),
            (val_sub, ":cur_month", 12),
            (val_add, ":cur_year", 1),
          (try_end),
        (else_try),
          (assign, ":try_range", 0),
        (try_end),
      (try_end),
      (assign, reg1, ":cur_day"),
      (assign, reg2, ":cur_year"),
     (store_time_of_day, reg3), ## CC chief
  (try_begin), #duh chief
	#	(this_or_next|eq, ":version", 1), #duh chief
		(eq, ":version", 1), #duh chief
      (try_begin),
        (eq, ":cur_month", 1),
        (str_store_string, s1, "str_january_reg1_reg2_v2"),
(assign, "$g_cur_month", 1), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 2),
        (str_store_string, s1, "str_february_reg1_reg2_v2"),
(assign, "$g_cur_month", 2), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 3),
        (str_store_string, s1, "str_march_reg1_reg2_v2"),
(assign, "$g_cur_month", 3), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 4),
        (str_store_string, s1, "str_april_reg1_reg2_v2"),
(assign, "$g_cur_month", 4), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 5),
        (str_store_string, s1, "str_may_reg1_reg2_v2"),
(assign, "$g_cur_month", 5), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 6),
        (str_store_string, s1, "str_june_reg1_reg2_v2"),
(assign, "$g_cur_month", 6), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 7),
        (str_store_string, s1, "str_july_reg1_reg2_v2"),
(assign, "$g_cur_month", 7), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 8),
        (str_store_string, s1, "str_august_reg1_reg2_v2"),
(assign, "$g_cur_month", 8), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 9),
        (str_store_string, s1, "str_september_reg1_reg2_v2"),
(assign, "$g_cur_month", 9), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 10),
        (str_store_string, s1, "str_october_reg1_reg2_v2"),
(assign, "$g_cur_month", 10), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 11),
        (str_store_string, s1, "str_november_reg1_reg2_v2"),
(assign, "$g_cur_month", 11), ###chief siege warfare
      (else_try),
        (eq, ":cur_month", 12),
        (str_store_string, s1, "str_december_reg1_reg2_v2"),
(assign, "$g_cur_month", 12), ###chief siege warfare
      (try_end),
		(else_try),	#duh chief empieza  
		  (try_begin),
			(eq, ":cur_month", 1),
			(str_store_string, s1, "str_january_reg1_reg2"),
(assign, "$g_cur_month", 1), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 2),
			(str_store_string, s1, "str_february_reg1_reg2"),
(assign, "$g_cur_month", 2), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 3),
			(str_store_string, s1, "str_march_reg1_reg2"),
(assign, "$g_cur_month", 3), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 4),
			(str_store_string, s1, "str_april_reg1_reg2"),
(assign, "$g_cur_month", 4), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 5),
			(str_store_string, s1, "str_may_reg1_reg2"),
(assign, "$g_cur_month", 5), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 6),
			(str_store_string, s1, "str_june_reg1_reg2"),
(assign, "$g_cur_month", 6), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 7),
			(str_store_string, s1, "str_july_reg1_reg2"),
(assign, "$g_cur_month", 7), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 8),
			(str_store_string, s1, "str_august_reg1_reg2"),
(assign, "$g_cur_month", 8), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 9),
			(str_store_string, s1, "str_september_reg1_reg2"),
(assign, "$g_cur_month", 9), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 10),
			(str_store_string, s1, "str_october_reg1_reg2"),
(assign, "$g_cur_month", 10), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 11),
			(str_store_string, s1, "str_november_reg1_reg2"),
(assign, "$g_cur_month", 11), ###chief siege warfare
		  (else_try),
			(eq, ":cur_month", 12),
			(str_store_string, s1, "str_december_reg1_reg2"),
(assign, "$g_cur_month", 12), ###chief siege warfare
		  (try_end),
		(try_end),
#duh acaba chief
      (set_result_string, s1),
    ]),  
  
  #script_game_get_money_text:
  # This script is called from the game engine when an amount of money needs to be displayed.
  # INPUT: arg1 = amount in units
  # OUTPUT: result string = money in text
  ("game_get_money_text",
    [
      (store_script_param_1, ":amount"),
      (try_begin),
        (eq, ":amount", 1),
        (str_store_string, s1, "str_1_denar"),
      (else_try),
        (assign, reg1, ":amount"),
        (str_store_string, s1, "str_reg1_denars"),
      (try_end),
      (set_result_string, s1),
  ]),
#usamos chief para patrullas somebody
  #script_game_get_party_companion_limit: version native
  # This script is called from the game engine when the companion limit is needed for a party.
  # INPUT: arg1 = none
  # OUTPUT: reg0 = companion_limit
  ("game_get_party_companion_limit2",
    [
      (assign, ":troop_no", "trp_player"),

      (assign, ":limit", 15), #chief cambiado tamano base party gdw was 5; it is 30 in native
      (store_skill_level, ":skill", "skl_leadership", ":troop_no"),
      (store_attribute_level, ":charisma", ":troop_no", ca_charisma),
      (val_mul, ":charisma", 2),#gdw new since lowered limit default
      (val_mul, ":skill", 7), #chief cambiado tamano party por cada punto liderazgo#gdwwas5
      (val_add, ":limit", ":skill"),
      (val_add, ":limit", ":charisma"),

#	  (troop_get_slot, ":troop_renown", ":troop_no", "slot_troop_renown"),   ##gdw #this section disabled in bryten
#      (store_div, ":renown_bonus", ":troop_renown", 4), #chief cambiado. renombre #necesario para recibir mas tropas, antes era 25
#      (val_add, ":limit", ":renown_bonus"),

      (assign, reg0, ":limit"),
      (set_trigger_result, reg0),
  ]),


 #script_game_get_party_companion_limit: Version motomataru
 # This script is called from the game engine when the companion limit is needed for a party.
 # INPUT: arg1 = none
 # OUTPUT: reg0 = companion_limit, reg31 = base, reg32= leadership contribution, reg33 = charisma contribution, reg34 = renown contribution
 ("game_get_party_companion_limit", [
   (assign, reg31, 0),
   (assign, reg0, reg31),

   (assign, reg32, 0),
   (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
   (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
       (troop_is_hero, ":stack_troop"),
       (store_skill_level, ":hero_leadership", "skl_leadership", ":stack_troop"),
       (val_add, reg32, ":hero_leadership"),
   (try_end),
   (val_add, reg0, reg32),

   (store_attribute_level, reg33, "trp_player", ca_charisma),
   (val_add, reg0, reg33),

   (troop_get_slot, reg34, "trp_player", "slot_troop_renown"),
   (val_div, reg34, 3),
   (val_add, reg0, reg34),

   (set_trigger_result, reg0),
 ]),
  
  #script_game_reset_player_party_name:
  # This script is called from the game engine when the player name is changed.
  # INPUT: none
  # OUTPUT: none
  ("game_reset_player_party_name",
    [(try_begin),                             ##ADD THIS LINE caba'drin chief custom name party
     (party_slot_eq, 0, 1, 0),                ##ADD THIS LINE caba'drin chief custom name party
      (str_store_troop_name, s5, "trp_player"),
     (party_set_name, "p_main_party", s5),
	 	(str_clear,s5), #TEMPERED chief CLEARING STRING ADDED
     (try_end),                               ##ADD THIS LINE caba'drin chief custom name party
     ]),

  #script_game_get_troop_note
  # This script is called from the game engine when the notes of a troop is needed.
  # INPUT: arg1 = troop_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_troop_note",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":note_index"),
      (set_trigger_result, 0),

      (str_store_troop_name, s54, ":troop_no"),
      (try_begin),
        (eq, ":troop_no", "trp_player"),
        (this_or_next|eq, "$player_has_homage", 1),
        (eq, "$players_kingdom", "fac_player_supporters_faction"),
        (assign, ":troop_faction", "$players_kingdom"),
      (else_try),
        (store_troop_faction, ":troop_faction", ":troop_no"),



      (try_end),
      (str_clear, s49),
	  
	  #Family notes
      (try_begin),
        (this_or_next|is_between, ":troop_no", lords_begin, kingdom_ladies_end),
        (eq, ":troop_no", "trp_player"),
        (neg|is_between, ":troop_no", pretenders_begin, pretenders_end),
        (assign, ":num_relations", 0),

        (try_begin),
          (call_script, "script_troop_get_family_relation_to_troop", "trp_player", ":troop_no"),
          (gt, reg0, 0),
          (val_add, ":num_relations", 1),
        (try_end),
        (try_for_range, ":aristocrat", lords_begin, kingdom_ladies_end),
          (call_script, "script_troop_get_family_relation_to_troop", ":aristocrat", ":troop_no"),
          (gt, reg0, 0),
          (val_add, ":num_relations", 1),
        (try_end),
        (try_begin),
          (gt, ":num_relations", 0),
          (try_begin),
            (eq, ":troop_no", "trp_player"),
            (str_store_string, s49, "@^Family:"),
          (else_try),
            (troop_get_slot, reg1, ":troop_no", "slot_troop_age"),
            (str_store_string, s49, "str__age_reg1_family_"),
          (try_end),
          (try_begin),
            (call_script, "script_troop_get_family_relation_to_troop", "trp_player", ":troop_no"),
            (gt, reg0, 0),
            (str_store_troop_name_link, s12, "trp_player"),
            (val_sub, ":num_relations", 1),
            (try_begin),
              (eq, ":num_relations", 0),
              (str_store_string, s49, "str_s49_s12_s11_end"),
            (else_try),
              (str_store_string, s49, "str_s49_s12_s11"),
            (try_end),
          (try_end),
          (try_for_range, ":aristocrat", lords_begin, kingdom_ladies_end),
            (call_script, "script_troop_get_family_relation_to_troop", ":aristocrat", ":troop_no"),
            (gt, reg0, 0),
            (try_begin),
              (neg|is_between, ":aristocrat", kingdom_ladies_begin, kingdom_ladies_end),
              (eq, "$cheat_mode", 1),
              (str_store_troop_name_link, s12, ":aristocrat"),
              (call_script, "script_troop_get_relation_with_troop", ":aristocrat", ":troop_no"),
              (str_store_string, s49, "str_s49_s12_s11_rel_reg0"),
            (else_try),
              (str_store_troop_name_link, s12, ":aristocrat"),
              (val_sub, ":num_relations", 1),
              (try_begin),
                (eq, ":num_relations", 0),
                (str_store_string, s49, "str_s49_s12_s11_end"),
              (else_try),
                (str_store_string, s49, "str_s49_s12_s11"),
              (try_end),
            (try_end),
          (try_end),
        (try_end),
      (try_end),
      
      (try_begin),
        (neq, ":troop_no", "trp_player"),
        (neq, ":troop_no", "trp_especiales_3"),#gdw
        (neq, ":troop_no", "trp_iniau"),#gdw
        (neg|is_between, ":troop_faction", kingdoms_begin, kingdoms_end),
        (neg|is_between, ":troop_no", companions_begin, companions_end),
        (neg|is_between, ":troop_no", pretenders_begin, pretenders_end),

        (try_begin),
          (eq, ":note_index", 0),
          (str_store_string, s0, "str_s54_has_left_the_realm"),
          (set_trigger_result, 1),
        (else_try),
          (str_clear, s0),
          (this_or_next|eq, ":note_index", 1),
          (eq, ":note_index", 2),
          (set_trigger_result, 1),
        (try_end),

      (else_try),
        (is_between, ":troop_no", companions_begin, companions_end),
        (neg|troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
        (eq, ":note_index", 0),
        (set_trigger_result, 1),
        (str_clear, s0),
        (assign, ":companion", ":troop_no"),
        (str_store_troop_name, s4, ":companion"),
        (try_begin),
			(troop_get_slot, ":days_left", ":companion", "slot_troop_days_on_mission"),

			(this_or_next|main_party_has_troop, ":companion"),
			(this_or_next|troop_slot_ge, ":companion", "slot_troop_current_mission", 1),
				(eq, "$g_player_minister", ":companion"),

			(try_begin),
				(troop_slot_eq, ":companion", "slot_troop_current_mission", npc_mission_kingsupport),
				(str_store_string, s8, "str_gathering_support"),
				(try_begin),
					(eq, ":days_left", 1),
					(str_store_string, s5, "str_expected_back_imminently"),
				(else_try),	
					(assign, reg3, ":days_left"),
					(str_store_string, s5, "str_expected_back_in_approximately_reg3_days"),
				(try_end),
			(else_try),
				(troop_slot_eq, ":companion", "slot_troop_current_mission", npc_mission_gather_intel),
				(troop_get_slot, ":town_with_contacts", ":companion", "slot_troop_town_with_contacts"),
				(str_store_party_name, s11, ":town_with_contacts"),
				
				(str_store_string, s8, "str_gathering_intelligence"),
				(try_begin),
					(eq, ":days_left", 1),
					(str_store_string, s5, "str_expected_back_imminently"),
				(else_try),	
					(assign, reg3, ":days_left"),
					(str_store_string, s5, "str_expected_back_in_approximately_reg3_days"),
				(try_end),
			(else_try),	
				
				(troop_slot_ge, ":companion", "slot_troop_current_mission", npc_mission_peace_request),
				(neg|troop_slot_ge, ":companion", "slot_troop_current_mission", 8),

				(troop_get_slot, ":faction", ":companion", "slot_troop_mission_object"),
				(str_store_faction_name, s9, ":faction"),
				(str_store_string, s8, "str_diplomatic_embassy_to_s9"),
				(try_begin),
					(eq, ":days_left", 1),
					(str_store_string, s5, "str_expected_back_imminently"),
				(else_try),	
					(assign, reg3, ":days_left"),
					(str_store_string, s5, "str_expected_back_in_approximately_reg3_days"),
				(try_end),
			(else_try),
				(eq, ":companion", "$g_player_minister"),
				(str_store_string, s8, "str_serving_as_minister"),
				(str_store_party_name, s9, "$g_player_court"),
				(is_between, "$g_player_court", centers_begin, centers_end),
				(str_store_string, s5, "str_in_your_court_at_s9"),
			(else_try),
				(eq, ":companion", "$g_player_minister"),
				(str_store_string, s8, "str_serving_as_minister"),
				(str_store_string, s5, "str_awaiting_the_capture_of_a_fortress_which_can_serve_as_your_court"),
			(else_try),
				(main_party_has_troop, ":companion"),
				(str_store_string, s8, "str_under_arms"),
				(str_store_string, s5, "str_in_your_party"),
			(try_end),	
			
			(str_store_string, s0, "str_s4_s8_s5"),
			
		(else_try),
			(str_store_string, s0, "str_whereabouts_unknown"),
		(try_end),
		
	  
	  (else_try),
        (is_between, ":troop_no", pretenders_begin, pretenders_end),
        (neg|troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
        (neq, ":troop_no", "$supported_pretender"),

		
        (troop_get_slot, ":orig_faction", ":troop_no", "slot_troop_original_faction"),
        (try_begin),
          (faction_slot_eq, ":orig_faction", "slot_faction_state", sfs_active),
          (faction_slot_eq, ":orig_faction", "slot_faction_has_rebellion_chance", 1),
          (try_begin),
            (eq, ":note_index", 0),
            (str_store_faction_name_link, s56, ":orig_faction"),
            (str_store_string, s0, "@{s54} is a claimant to the throne of {s56}.", 0),
            (set_trigger_result, 1),
          (try_end),
        (else_try),
          (try_begin),
            (str_clear, s0),
            (this_or_next|eq, ":note_index", 0),
            (this_or_next|eq, ":note_index", 1),
            (eq, ":note_index", 2),
            (set_trigger_result, 1),
          (try_end),
        (try_end),
		
      (else_try),
        (try_begin),
          (eq, ":note_index", 0),
          (faction_get_slot, ":faction_leader", ":troop_faction", "slot_faction_leader"),
          (str_store_troop_name_link, s55, ":faction_leader"),
          (str_store_faction_name_link, s56, ":troop_faction"),
          (assign, ":troop_is_player_faction", 0),
          (assign, ":troop_is_faction_leader", 0),
          (try_begin),
            (eq, ":troop_faction", "fac_player_faction"),
            (assign, ":troop_is_player_faction", 1),
          (else_try),
            (eq, ":faction_leader", ":troop_no"),
            (assign, ":troop_is_faction_leader", 1),
          (try_end),
          (assign, ":num_centers", 0),
          (str_store_string, s58, "@nowhere"),
          (try_for_range_backwards, ":cur_center", centers_begin, centers_end),                     
            (party_slot_eq, ":cur_center", "slot_town_lord", ":troop_no"),
            (try_begin),
              (eq, ":num_centers", 0),
              (str_store_party_name_link, s58, ":cur_center"),
            (else_try),
              (eq, ":num_centers", 1),
              (str_store_party_name_link, s57, ":cur_center"),
              (str_store_string, s58, "@{s57} and {s58}"),
            (else_try),
              (str_store_party_name_link, s57, ":cur_center"),
              (str_store_string, s58, "@{!}{s57}, {s58}"),
            (try_end),
            (val_add, ":num_centers", 1),
          (try_end),
## Gender fix chief altura	                   
       (troop_get_type, reg3, ":troop_no"),
## Gender fix
(val_mod, reg3, 2),
      ###gender fix chief

          (troop_get_slot, reg5, ":troop_no", "slot_troop_renown"),
          (troop_get_slot, reg15, ":troop_no", "slot_troop_controversy"),
		  
          (str_clear, s59),
          (try_begin),   
            (call_script, "script_troop_get_player_relation", ":troop_no"),
            (assign, ":relation", reg0),
            (store_add, ":normalized_relation", ":relation", 100),
            (val_add, ":normalized_relation", 5),
            (store_div, ":str_offset", ":normalized_relation", 10),
            (val_clamp, ":str_offset", 0, 20),
            (store_add, ":str_id", "str_relation_mnus_100_ns",  ":str_offset"),
            (neq, ":str_id", "str_relation_plus_0_ns"),
            (str_store_string, s60, "@{reg3?She:He}"),
            (str_store_string, s59, ":str_id"),
            (str_store_string, s59, "@{!}^{s59}"),
          (try_end),
          #lord recruitment changes begin
          #This sends a bunch of political information to s47.
    
          #refresh registers
          (assign, reg9, ":num_centers"),
## Gender fix chief altura	                   
       (troop_get_type, reg3, ":troop_no"),
## Gender fix
(val_mod, reg3, 2),
###gender fix chief
          (troop_get_slot, reg5, ":troop_no", "slot_troop_renown"),
          (assign, reg4, ":troop_is_faction_leader"),
          (assign, reg6, ":troop_is_player_faction"),
          
          (troop_get_slot, reg17, ":troop_no", "slot_troop_wealth"), #DEBUGS
          ## CC chief
          (try_begin),
            (eq, ":troop_no", "trp_player"),
            (store_troop_gold, reg17, "trp_player"),
          (try_end),
          ## CC
          (str_store_string, s0, "str_lord_info_string", 0),
          #lord recruitment changes end
          (add_troop_note_tableau_mesh, ":troop_no", "tableau_troop_note_mesh"),
          (set_trigger_result, 1),
        (try_end),
      (try_end),
     ]),
  
  #script_game_get_center_note
  # This script is called from the game engine when the notes of a center is needed.
  # INPUT: arg1 = center_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_center_note",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":note_index"),

      (set_trigger_result, 0),
      (try_begin),
        (eq, ":note_index", 0),
        (party_get_slot, ":lord_troop", ":center_no", "slot_town_lord"),
        (try_begin),
          (ge, ":lord_troop", 0),
          (store_troop_faction, ":lord_faction", ":lord_troop"),
          (str_store_troop_name_link, s1, ":lord_troop"),
          (try_begin),
            (eq, ":lord_troop", "trp_player"),
            (gt, "$players_kingdom", 0),
            (str_store_faction_name_link, s2, "$players_kingdom"),
          (else_try),
            (str_store_faction_name_link, s2, ":lord_faction"),
          (try_end),
          (str_store_party_name, s50, ":center_no"),
          (try_begin),
            (party_slot_eq, ":center_no", "slot_party_type", spt_town),
            (str_store_string, s51, "@The town of {s50}"),
          (else_try),
            (party_slot_eq, ":center_no", "slot_party_type", spt_village),
            (party_get_slot, ":bound_center", ":center_no", "slot_village_bound_center"),
            (str_store_party_name_link, s52, ":bound_center"),
            (str_store_string, s51, "@The village of {s50} near {s52}"),
          (else_try),
            (str_store_string, s51, "@{!}{s50}"),
          (try_end),
          (str_store_string, s2, "@{s51} belongs to {s1} of {s2}.^"),
        (else_try),
          (str_clear, s2),
        (try_end),
        (try_begin),
          (is_between, ":center_no", villages_begin, villages_end),
        (else_try),
          (assign, ":num_villages", 0),
          (try_for_range_backwards, ":village_no", villages_begin, villages_end),
            (party_slot_eq, ":village_no", "slot_village_bound_center", ":center_no"),
            (try_begin),
              (eq, ":num_villages", 0),
              (str_store_party_name_link, s8, ":village_no"),
            (else_try),
              (eq, ":num_villages", 1),
              (str_store_party_name_link, s7, ":village_no"),
              (str_store_string, s8, "@{s7} and {s8}"),
            (else_try),
              (str_store_party_name_link, s7, ":village_no"),
              (str_store_string, s8, "@{!}{s7}, {s8}"),
            (try_end),
            (val_add, ":num_villages", 1),
          (try_end),
          (try_begin),
            (eq, ":num_villages", 0),
            (str_store_string, s2, "@{s2}It has no villages.^"),
          (else_try),
            (store_sub, reg0, ":num_villages", 1),
            (str_store_string, s2, "@{s2}{reg0?Its villages are:Its village is} {s8}.^"),
          (try_end),
        (try_end),
        (call_script, "script_get_prosperity_text_to_s50", ":center_no"),
        #(party_get_slot, reg7, ":center_no", "slot_town_prosperity"),
        (str_store_string, s0, "@{s2}Its prosperity is: {s50}", 0),
      
        (set_trigger_result, 1),
      (try_end),
     ]),

  #script_game_get_faction_note
  # This script is called from the game engine when the notes of a faction is needed.
  # INPUT: arg1 = faction_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_faction_note",
    [
      (set_background_mesh, "mesh_pic_extra_intro1"),
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":note_index"),
      (set_trigger_result, 0),
      
##      (try_begin),
##        (eq, 2, 1),
##        (str_store_faction_name, s14, ":faction_no"),
##        (assign, reg4, "$temp"),
##        (display_message, "str_updating_faction_notes_for_s14_temp_=_reg4"),
##      (try_end),

      (try_begin),
        (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
        #conditions end
        (try_begin),
            (eq, ":note_index", 0),
          (faction_get_slot, ":faction_leader", ":faction_no", "slot_faction_leader"),
          (str_store_faction_name, s5, ":faction_no"),
          (str_store_troop_name_link, s6, ":faction_leader"),
          (assign, ":num_centers", 0),
          (str_store_string, s8, "@nowhere"),
          (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
            (store_faction_of_party, ":center_faction", ":cur_center"),
            (eq, ":center_faction", ":faction_no"),
            (try_begin),
              (eq, ":num_centers", 0),
              (str_store_party_name_link, s8, ":cur_center"),
            (else_try),
              (eq, ":num_centers", 1),
              (str_store_party_name_link, s7, ":cur_center"),
              (str_store_string, s8, "@{s7} and {s8}"),
            (else_try),
              (str_store_party_name_link, s7, ":cur_center"),
              (str_store_string, s8, "@{!}{s7}, {s8}"),
            (try_end),
            (val_add, ":num_centers", 1),
          (try_end),
          (assign, ":num_members", 0),
          (str_store_string, s10, "@noone"),
          (try_for_range_backwards, ":loop_var", "trp_kingdom_heroes_including_player_begin", active_npcs_end),
            (assign, ":cur_troop", ":loop_var"),
            (try_begin),
              (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
              (assign, ":cur_troop", "trp_player"),
              (assign, ":troop_faction", "$players_kingdom"),
            (else_try),
              (store_troop_faction, ":troop_faction", ":cur_troop"),
            (try_end),
            (eq, ":troop_faction", ":faction_no"),
            (neq, ":cur_troop", ":faction_leader"),
            (troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
            (try_begin),
              (eq, ":num_members", 0),
              (str_store_troop_name_link, s10, ":cur_troop"),
            (else_try),
              (eq, ":num_members", 1),
              (str_store_troop_name_link, s9, ":cur_troop"),
              (str_store_string, s10, "@{s9} and {s10}"),
            (else_try),
              (str_store_troop_name_link, s9, ":cur_troop"),
              (str_store_string, s10, "@{!}{s9}, {s10}"),
            (try_end),
            (val_add, ":num_members", 1),
          (try_end),
              
              #wars
          (str_store_string, s12, "@noone"),
   #       (assign, ":num_enemies", 0),
   #       (try_for_range_backwards, ":cur_faction", kingdoms_begin, kingdoms_end),
   #         (faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
   #         (store_relation, ":cur_relation", ":cur_faction", ":faction_no"),
   #         (lt, ":cur_relation", 0),
   #         (try_begin),
   #           (eq, ":num_enemies", 0),
   #           (str_store_faction_name_link, s12, ":cur_faction"),
   #         (else_try),
   #           (eq, ":num_enemies", 1),
   #           (str_store_faction_name_link, s11, ":cur_faction"),
   #           (str_store_string, s12, "@the {s11} and the {s12}"),
   #         (else_try),
   #           (str_store_faction_name_link, s11, ":cur_faction"),
   #           (str_store_string, s12, "@the {s11}, the {s12}"),
   #         (try_end),
   #         (val_add, ":num_enemies", 1),
   #       (try_end),
              
          (str_store_string, s21, "str_foreign_relations__"),
              
              #other foreign relations
          (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
            (faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
            (neq, ":faction_no", ":cur_faction"),
            (str_store_faction_name_link, s14, ":cur_faction"),
            (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":faction_no", ":cur_faction"),
            (assign, ":diplomatic_status", reg0),
			(assign, ":duration_of_status", reg1),
			
            (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":cur_faction", ":faction_no"),
            (assign, ":reverse_diplomatic_status", reg0),
#			(assign, ":reverse_diplomatic_duration", reg1),

            (try_begin),
              (eq, ":diplomatic_status", -2),
              (str_store_string, s21, "str_s21__the_s5_is_at_war_with_the_s14"),
              (store_add, ":slot_war_damage_inflicted", ":cur_faction", "slot_faction_war_damage_inflicted_on_factions_begin"),
              (val_sub, ":slot_war_damage_inflicted", kingdoms_begin),
              (faction_get_slot, ":war_damage_inflicted", ":faction_no", ":slot_war_damage_inflicted"),
              (store_mul, ":war_damage_inflicted_x_2", ":war_damage_inflicted", 2),

              (store_add, ":slot_war_damage_suffered", ":faction_no", "slot_faction_war_damage_inflicted_on_factions_begin"),
              (val_sub, ":slot_war_damage_suffered", kingdoms_begin),
              (faction_get_slot, ":war_damage_suffered", ":cur_faction", ":slot_war_damage_suffered"),
              (store_mul, ":war_damage_suffered_x_2", ":war_damage_suffered", 2),
			  
			  
			  (assign, ":war_cause", 0),
			  (assign, ":attacker", 0),
			  (try_for_range, ":log_entry", 0, "$num_log_entries"),
				(troop_get_slot, ":type", "trp_log_array_entry_type", ":log_entry"),
				(is_between, ":type", logent_faction_declares_war_out_of_personal_enmity, logent_war_declaration_types_end),
				(troop_get_slot, ":actor", "trp_log_array_actor", ":log_entry"),
				(troop_get_slot, ":object", "trp_log_array_faction_object", ":log_entry"),

				(try_begin),
					(eq, ":actor", ":cur_faction"),
					(eq, ":object", ":faction_no"),
					(assign, ":war_cause", ":type"),
					(assign, ":attacker", ":actor"),
				(else_try),	
					(eq, ":actor", ":faction_no"),
					(eq, ":object", ":cur_faction"),
					(assign, ":war_cause", ":type"),
					(assign, ":attacker", ":actor"),
				(try_end),
			  (try_end),	

			  #bug fix! backing up s8 to somewhere else
                          (str_store_string, s25, s8),
			  (try_begin),
			    (gt, ":war_cause", 0),
				(str_store_faction_name, s8, ":attacker"),
				(try_begin),
					(eq, ":war_cause", logent_faction_declares_war_out_of_personal_enmity),
					(str_store_string, s21, "str_s21_the_s8_declared_war_out_of_personal_enmity"),
				(else_try),			
					(eq, ":war_cause", logent_faction_declares_war_to_respond_to_provocation),
					(str_store_string, s21, "str_s21_the_s8_declared_war_in_response_to_border_provocations"),
				(else_try),			
					(eq, ":war_cause", logent_faction_declares_war_to_curb_power),
					(str_store_string, s21, "str_s21_the_s8_declared_war_to_curb_the_other_realms_power"),
				(else_try),	
					(eq, ":war_cause", logent_faction_declares_war_to_regain_territory),
					(str_store_string, s21, "str_s21_the_s8_declared_war_to_regain_lost_territory"),
			  ##diplomacy chief begin
				(else_try),
					(eq, ":war_cause", logent_faction_declares_war_to_fulfil_pact),
					(str_store_string, s21, "str_dplmc_s21_the_s8_declared_war_to_fulfil_pact"),        
        ##diplomacy end
				(else_try),
					(eq, ":war_cause", logent_player_faction_declares_war),
					(neq, ":attacker", "fac_player_supporters_faction"),
					(str_store_string, s21, "str_s21_the_s8_declared_war_as_part_of_a_bid_to_conquer_all_calradia"),
				(try_end),
			  (try_end),
			  #bug fix! restoring the back up to s8
                          (str_store_string, s8, s25),

              (try_begin),
                (gt, ":war_damage_inflicted", ":war_damage_suffered_x_2"),
                (str_store_string, s21, "str_s21_the_s5_has_had_the_upper_hand_in_the_fighting"),
              (else_try),
                (gt, ":war_damage_suffered", ":war_damage_inflicted_x_2"),
                (str_store_string, s21, "str_s21_the_s5_has_gotten_the_worst_of_the_fighting"),
              (else_try),
                (gt, ":war_damage_inflicted", 100),
                (gt, ":war_damage_inflicted", 100),
                (str_store_string, s21, "str_s21_the_fighting_has_gone_on_for_some_time_and_the_war_may_end_soon_with_a_truce"),
              (else_try),
                (str_store_string, s21, "str_s21_the_fighting_has_begun_relatively_recently_and_the_war_may_continue_for_some_time"),
              (try_end),
              (try_begin),
                (eq, "$cheat_mode", 1),
                (assign, reg4, ":war_damage_inflicted"),
                (assign, reg5, ":war_damage_suffered"),
                (str_store_string, s21, "str_s21_reg4reg5"),
              (try_end),
            (else_try),
              (eq, ":diplomatic_status", 1),
              (str_clear, s18),
              (try_begin),
                (neq, ":reverse_diplomatic_status", 1),
                (str_store_string, s18, "str__however_the_truce_is_no_longer_binding_on_the_s14"),
              (try_end),
			  (assign, reg1, ":duration_of_status"),
			  ##diplomacy begin chief
              (try_begin),
			    ##nested diplomacy start+ Use named variables for truce lengths
                #(is_between, ":duration_of_status", 1, 21),
				(is_between, ":duration_of_status", dplmc_treaty_truce_days_expire + 1, dplmc_treaty_truce_days_initial + 1),
				##nested diplomacy end+
              ##diplomacy end
              (str_store_string, s21, "str_s21__the_s5_is_bound_by_truce_not_to_attack_the_s14s18_the_truce_will_expire_in_reg1_days"),
              ##diplomacy begin
			  ##nested diplomacy start+ Use named variables for truce lengths
              (else_try),
                #(is_between, ":duration_of_status", 21, 41),
                #(val_sub, reg1, 20),
                (is_between, ":duration_of_status", dplmc_treaty_trade_days_expire + 1, dplmc_treaty_trade_days_initial + 1),
                (val_sub, reg1, dplmc_treaty_trade_days_expire),
                (str_store_string, s21, "str_dplmc_s21__the_s5_is_bound_by_trade_not_to_attack_the_s14s18_it_will_expire_in_reg1_days"),
              (else_try),
                #(is_between, ":duration_of_status", 41, 61),
                #(val_sub, reg1, 40),
                (is_between, ":duration_of_status", dplmc_treaty_defense_days_expire + 1, dplmc_treaty_defense_days_initial + 1),
                (val_sub, reg1, dplmc_treaty_defense_days_expire),
                (str_store_string, s21, "str_dplmc_s21__the_s5_is_bound_by_defensive_not_to_attack_the_s14s18_it_will_expire_in_reg1_days"),
              (else_try),
                #(is_between, ":duration_of_status", 61, 81),
                #(val_sub, reg1, 60),
                (is_between, ":duration_of_status", dplmc_treaty_alliance_days_expire + 1, dplmc_treaty_alliance_days_initial + 1),
                (val_sub, reg1, dplmc_treaty_alliance_days_expire),
                (str_store_string, s21, "str_dplmc_s21__the_s5_is_bound_by_alliance_not_to_attack_the_s14s18_it_will_expire_in_reg1_days"),
              (try_end),
			  ##nested diplomacy end+ (Use named variables for truce lengths)
               ##diplomacy end
            (else_try),
              (eq, ":diplomatic_status", -1),
              (str_store_string, s21, "str_s21__the_s5_has_recently_suffered_provocation_by_subjects_of_the_s14_and_there_is_a_risk_of_war"),
            (else_try),
              (eq, ":diplomatic_status", 0),
              (str_store_string, s21, "str_s21__the_s5_has_no_outstanding_issues_with_the_s14"),
            (try_end),
            (try_begin),
              (eq, ":reverse_diplomatic_status", -1),
              (str_store_string, s21, "str_s21_the_s14_was_recently_provoked_by_subjects_of_the_s5_and_there_is_a_risk_of_war_"),
            (try_end),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (call_script, "script_npc_decision_checklist_peace_or_war", ":faction_no", ":cur_faction", -1),
			  (str_store_string, s21, "@{!}DEBUG : {s21}.^CHEAT MODE ASSESSMENT: {s14}^"), 
            (try_end),
          (try_end),
          (str_store_string, s0, "str_the_s5_is_ruled_by_s6_it_occupies_s8_its_vassals_are_s10__s21", 0),
          (set_trigger_result, 1),
        (try_end),
      (else_try),
        (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_defeated),
        (try_begin),
          (eq, ":note_index", 0),
          (str_store_faction_name, s5, ":faction_no"),
          (str_store_string, s0, "@{s5} has been defeated!", 0),
          (set_trigger_result, 1),
        (else_try),
          (eq, ":note_index", 1),
          (str_clear, s0),
          (set_trigger_result, 1),
        (try_end),
      (else_try),
        (try_begin),
          (this_or_next|eq, ":note_index", 0),
          (eq, ":note_index", 1),
          (str_clear, s0),
          (set_trigger_result, 1),
        (try_end),
      (try_end),
     ]),

  #script_game_get_quest_note
  # This script is called from the game engine when the notes of a quest is needed.
  # INPUT: arg1 = quest_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_quest_note",
    [
##      (store_script_param_1, ":quest_no"),
##      (store_script_param_2, ":note_index"),
      (set_trigger_result, 0), # set it to 1 if this script is wanted to be used rather than static notes
     ]),

  #script_game_get_info_page_note
  # This script is called from the game engine when the notes of a info_page is needed.
  # INPUT: arg1 = info_page_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_info_page_note",
    [
##      (store_script_param_1, ":info_page_no"),
##      (store_script_param_2, ":note_index"),
      (set_trigger_result, 0), # set it to 1 if this script is wanted to be used rather than static notes
     ]),

  #script_check_creating_ladder_dust_effect
  # INPUT: arg1 = instance_id, arg2 = remaining_time
  # OUTPUT: none
  ("check_creating_ladder_dust_effect",
   [
      (store_trigger_param_1, ":instance_id"),
      (store_trigger_param_2, ":remaining_time"),

      (try_begin),
        (lt, ":remaining_time", 15), #less then 0.15 seconds
        (gt, ":remaining_time", 3), #more than 0.03 seconds
      
        (scene_prop_get_slot, ":smoke_effect_done", ":instance_id", "slot_scene_prop_smoke_effect_done"),
        (scene_prop_get_slot, ":opened_or_closed", ":instance_id", "slot_scene_prop_open_or_close"),

        (try_begin),
          (eq, ":smoke_effect_done", 0),
          (eq, ":opened_or_closed", 0),
      
          (prop_instance_get_position, pos0, ":instance_id"),

          (assign, ":smallest_dist", -1),
          (try_for_range, ":entry_point_no", multi_entry_points_for_usable_items_start, multi_entry_points_for_usable_items_end),
            (entry_point_get_position, pos1, ":entry_point_no"),
            (get_sq_distance_between_positions, ":dist", pos0, pos1),
            (this_or_next|eq, ":smallest_dist", -1),
            (lt, ":dist", ":smallest_dist"),
            (assign, ":smallest_dist", ":dist"),
            (assign, ":nearest_entry_point", ":entry_point_no"),
          (try_end),

          (try_begin),
            (set_fixed_point_multiplier, 100),

            (ge, ":smallest_dist", 0),
            (lt, ":smallest_dist", 22500), #max 15m distance
      
            (entry_point_get_position, pos1, ":nearest_entry_point"),
            (position_rotate_x, pos1, -90),

            (prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
            (try_begin),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_6m"),              
              (init_position, pos2),
              (position_set_z, pos2, 300),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_6m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_6m", pos3, 100),
            (else_try),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_8m"),
              (init_position, pos2),
              (position_set_z, pos2, 400),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_8m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_8m", pos3, 100),
            (else_try),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_10m"),
              (init_position, pos2),
              (position_set_z, pos2, 500),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_10m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_10m", pos3, 100),
            (else_try),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_12m"),
              (init_position, pos2),
              (position_set_z, pos2, 600),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_12m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_12m", pos3, 100),
            (else_try),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_14m"),
              (init_position, pos2),
              (position_set_z, pos2, 700),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_14m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_14m", pos3, 100),
            (try_end),

            (scene_prop_set_slot, ":instance_id", "slot_scene_prop_smoke_effect_done", 1),
          (try_end),
        (try_end),
      (try_end),
      ]),

  #script_use_item
  # INPUT: arg1 = agent_id, arg2 = instance_id
  # OUTPUT: none
  ("use_item",
   [
     (store_script_param, ":instance_id", 1),
     (store_script_param, ":user_id", 2),

     (try_begin),
       (game_in_multiplayer_mode),
       (prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),
       (eq, ":scene_prop_id", "spr_winch_b"),
                      
       (multiplayer_get_my_player, ":my_player_no"),

       (this_or_next|gt, ":my_player_no", 0),
       (neg|multiplayer_is_dedicated_server),

       (ge, ":my_player_no", 0),
       (player_get_agent_id, ":my_agent_id", ":my_player_no"),
       (ge, ":my_agent_id", 0),
       (agent_is_active, ":my_agent_id"),
       (agent_get_team, ":my_team_no", ":my_agent_id"),
       (eq, ":my_team_no", 0),
                             
       (scene_prop_get_slot, ":opened_or_closed", ":instance_id", "slot_scene_prop_open_or_close"),
       (ge, ":user_id", 0),
       (agent_is_active, ":user_id"),
       (agent_get_player_id, ":user_player", ":user_id"),
       (str_store_player_username, s7, ":user_player"),
            
       (try_begin),
         (eq, ":opened_or_closed", 0),
         (display_message, "@{s7} opened the gate"),
       (else_try),  
         (display_message, "@{s7} closed the gate"),
       (try_end),
     (try_end),  

     (prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),
     
     (try_begin),
       (this_or_next|eq, ":scene_prop_id", "spr_winch_b"),
       (eq, ":scene_prop_id", "spr_winch"),
       (assign, ":effected_object", "spr_portcullis"),
     (else_try),
       (this_or_next|eq, ":scene_prop_id", "spr_door_destructible"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_b"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_e_sally_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_sally_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),
       (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_right"),
       (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
       (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_right"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_6m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_8m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_10m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_12m"),
       (eq, ":scene_prop_id", "spr_siege_ladder_move_14m"),
       (assign, ":effected_object", ":scene_prop_id"),
     (try_end),

     (assign, ":smallest_dist", -1),
     (prop_instance_get_position, pos0, ":instance_id"),
     (scene_prop_get_num_instances, ":num_instances_of_effected_object", ":effected_object"),     
     (try_for_range, ":cur_instance", 0, ":num_instances_of_effected_object"),
       (scene_prop_get_instance, ":cur_instance_id", ":effected_object", ":cur_instance"),
       (prop_instance_get_position, pos1, ":cur_instance_id"),
       (get_sq_distance_between_positions, ":dist", pos0, pos1),
       (this_or_next|eq, ":smallest_dist", -1),
       (lt, ":dist", ":smallest_dist"),
       (assign, ":smallest_dist", ":dist"),
       (assign, ":effected_object_instance_id", ":cur_instance_id"),
     (try_end),

     (try_begin),
       (ge, ":instance_id", 0),
       (ge, ":smallest_dist", 0),

       (try_begin),     
         (eq, ":effected_object", "spr_portcullis"),
         (scene_prop_get_slot, ":opened_or_closed", ":instance_id", "slot_scene_prop_open_or_close"),

         (try_begin),
           (eq, ":opened_or_closed", 0), #open gate
     
           (scene_prop_enable_after_time, ":instance_id", 400), #4 seconds
           (try_begin),
             (this_or_next|multiplayer_is_server),
             (neg|game_in_multiplayer_mode),
             (prop_instance_get_position, pos0, ":effected_object_instance_id"),
             (position_move_z, pos0, 375),
             (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 400),
           (try_end),
           (scene_prop_set_slot, ":instance_id", "slot_scene_prop_open_or_close", 1),

           (try_begin),
             (eq, ":scene_prop_id", "spr_winch_b"),
             (this_or_next|multiplayer_is_server),
             (neg|game_in_multiplayer_mode),
             (prop_instance_get_position, pos1, ":instance_id"),
             (prop_instance_rotate_to_position, ":instance_id", pos1, 400, 72000),
           (try_end),
         (else_try), #close gate     
           (scene_prop_enable_after_time, ":instance_id", 400), #4 seconds
           (try_begin),
             (this_or_next|multiplayer_is_server),
             (neg|game_in_multiplayer_mode),
             (prop_instance_get_position, pos0, ":effected_object_instance_id"),
             (position_move_z, pos0, -375),
             (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 400),
           (try_end),
           (scene_prop_set_slot, ":instance_id", "slot_scene_prop_open_or_close", 0),

           (try_begin),
             (eq, ":scene_prop_id", "spr_winch_b"),
             (this_or_next|multiplayer_is_server),
             (neg|game_in_multiplayer_mode),
             (prop_instance_get_position, pos1, ":instance_id"),
             (prop_instance_rotate_to_position, ":instance_id", pos1, 400, -72000),
           (try_end),
         (try_end),
       (else_try),
         (this_or_next|eq, ":effected_object", "spr_siege_ladder_move_6m"),
         (this_or_next|eq, ":effected_object", "spr_siege_ladder_move_8m"),
         (this_or_next|eq, ":effected_object", "spr_siege_ladder_move_10m"),
         (this_or_next|eq, ":effected_object", "spr_siege_ladder_move_12m"),
         (eq, ":effected_object", "spr_siege_ladder_move_14m"),

         (try_begin),
           (eq, ":effected_object", "spr_siege_ladder_move_6m"),
           (assign, ":animation_time_drop", 120),
           (assign, ":animation_time_elevate", 240),
         (else_try),
           (eq, ":effected_object", "spr_siege_ladder_move_8m"),
           (assign, ":animation_time_drop", 140),
           (assign, ":animation_time_elevate", 280),
         (else_try),
           (eq, ":effected_object", "spr_siege_ladder_move_10m"),
           (assign, ":animation_time_drop", 160),
           (assign, ":animation_time_elevate", 320),
         (else_try),
           (eq, ":effected_object", "spr_siege_ladder_move_12m"),
           (assign, ":animation_time_drop", 190),
           (assign, ":animation_time_elevate", 360),
         (else_try),
           (eq, ":effected_object", "spr_siege_ladder_move_14m"),
           (assign, ":animation_time_drop", 230),
           (assign, ":animation_time_elevate", 400),
         (try_end),
     
         (scene_prop_get_slot, ":opened_or_closed", ":instance_id", "slot_scene_prop_open_or_close"),

         (try_begin),
           (scene_prop_enable_after_time, ":effected_object_instance_id", ":animation_time_elevate"), #3 seconds in average
           (eq, ":opened_or_closed", 0), #ladder at ground           
           (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),
           (prop_instance_enable_physics, ":effected_object_instance_id", 0),
           (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 300),
           (scene_prop_set_slot, ":effected_object_instance_id", "slot_scene_prop_open_or_close", 1),
         (else_try), #ladder at wall
           (scene_prop_enable_after_time, ":effected_object_instance_id", ":animation_time_drop"), #1.5 seconds in average
           (prop_instance_get_position, pos0, ":instance_id"),

           (assign, ":smallest_dist", -1),
           (try_for_range, ":entry_point_no", multi_entry_points_for_usable_items_start, multi_entry_points_for_usable_items_end),
             (entry_point_get_position, pos1, ":entry_point_no"),
             (get_sq_distance_between_positions, ":dist", pos0, pos1),
             (this_or_next|eq, ":smallest_dist", -1),
             (lt, ":dist", ":smallest_dist"),
             (assign, ":smallest_dist", ":dist"),
             (assign, ":nearest_entry_point", ":entry_point_no"),
           (try_end),

           (try_begin),
             (ge, ":smallest_dist", 0),
             (lt, ":smallest_dist", 22500), #max 15m distance
             (entry_point_get_position, pos1, ":nearest_entry_point"),
             (position_rotate_x, pos1, -90),
             (scene_prop_set_slot, ":effected_object_instance_id", "slot_scene_prop_smoke_effect_done", 0),
             (prop_instance_enable_physics, ":effected_object_instance_id", 0),
             (prop_instance_animate_to_position, ":effected_object_instance_id", pos1, 130),
           (try_end),

           (scene_prop_set_slot, ":effected_object_instance_id", "slot_scene_prop_open_or_close", 0),
         (try_end),
       (else_try),
         (this_or_next|eq, ":effected_object", "spr_door_destructible"),
         (this_or_next|eq, ":effected_object", "spr_castle_f_door_b"),
         (this_or_next|eq, ":scene_prop_id", "spr_castle_e_sally_door_a"),     
         (this_or_next|eq, ":scene_prop_id", "spr_castle_f_sally_door_a"),     
         (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),     
         (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_right"),     
         (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),     
         (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_right"),     
         (eq, ":scene_prop_id", "spr_castle_f_door_a"),
     
         (assign, ":effected_object_instance_id", ":instance_id"),
         (scene_prop_get_slot, ":opened_or_closed", ":effected_object_instance_id", "slot_scene_prop_open_or_close"),

         (try_begin),
           (eq, ":opened_or_closed", 0),

           (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),

           (scene_prop_enable_after_time, ":effected_object_instance_id", 100),

           (try_begin),
             (neg|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
             (neg|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),
             
             (position_rotate_z, pos0, -85),
           (else_try),  
             (position_rotate_z, pos0, 85),
           (try_end),
           
           (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 100),
          
           (scene_prop_set_slot, ":effected_object_instance_id", "slot_scene_prop_open_or_close", 1),
         (else_try),          
           (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),

           (scene_prop_enable_after_time, ":effected_object_instance_id", 100),

           (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 100),

           (scene_prop_set_slot, ":effected_object_instance_id", "slot_scene_prop_open_or_close", 0),
         (try_end),
       (try_end),
     (try_end),
     ]),

  # script_party_get_ideal_size @used for NPC parties.
  # Input: arg1 = party_no
  # Output: reg0: ideal size 
  ("party_get_ideal_size",
    [
      (store_script_param_1, ":party_no"),
      (assign, ":limit", 40),#this chief is base limit for bandit type parties
      (try_begin),
        (party_slot_eq, ":party_no", "slot_party_type", spt_kingdom_hero_party),
        (party_stack_get_troop_id, ":party_leader", ":party_no", 0),
        (store_faction_of_party, ":faction_id", ":party_no"),
        (assign, ":limit", 20),#base limit chief for hero parties

        (store_skill_level, ":skill", "skl_leadership", ":party_leader"),
        (store_attribute_level, ":charisma", ":party_leader", ca_charisma),
        (val_mul, ":skill", 6),#gdw5
        (val_add, ":limit", ":skill"),
        (val_add, ":limit", ":charisma"),

        (troop_get_slot, ":troop_renown", ":party_leader", "slot_troop_renown"),
        (store_div, ":renown_bonus", ":troop_renown", 5), #chief cambiado a 5
        (val_add, ":limit", ":renown_bonus"),
        ##diplomacy chief begin
        (assign, ":percent", 100),
        ##diplomacy end
		##diplomacy start+ chief
		#Limit effects of policies for nascent kingdoms.
		(assign, ":policy_min", -3),
		(assign, ":policy_max", 4),#one greater than the maximum
		
		(try_begin),
			(this_or_next|eq, ":faction_id", "fac_player_supporters_faction"),
				(faction_slot_eq, ":faction_id", "slot_faction_leader", "trp_player"),
			(faction_get_slot, ":policy_max", ":faction_id", "slot_faction_num_towns"),
			(faction_get_slot, reg0, ":faction_id", "slot_faction_num_castles"),
			(val_add, ":policy_max", reg0),
			(val_clamp, ":policy_max", 0, 4),#0, 1, 2, 3
			(store_mul, ":policy_min", ":policy_max", -1),
			(val_add, ":policy_max", 1),#one greater than the maximum
		(try_end),
		##diplomacy end+

        (try_begin),
          (faction_slot_eq, ":faction_id", "slot_faction_leader", ":party_leader"),
#tempered chief cambia para dar tropas segun posesiones
		  (faction_get_slot,":num_castles",":faction_id","slot_faction_num_castles"),
		  (faction_get_slot,":num_towns",":faction_id","slot_faction_num_towns"),
		  (val_mul,":num_castles",15),
		  (val_mul,":num_towns",30),
		  (val_add,":num_towns",":num_castles"),
		  (val_add, ":limit", ":num_towns"),
#          (val_add, ":limit", 200), #chief aumentado a 200
#tempered cambia acbaa chief
          ##diplomacy begin
          (try_begin),
            (faction_get_slot, ":centralization", ":faction_id", "slot_faction_centralization"),
            (neq, ":centralization", 0),
			##diplomacy start+ Apply constraint
			(val_clamp, ":centralization", ":policy_min", ":policy_max"),
			##diplomacy end+
            (val_mul, ":centralization", 10),
            (val_add, ":percent", ":centralization"),
          (try_end),

        (else_try),
          (try_begin),
            (faction_get_slot, ":centralization", ":faction_id", "slot_faction_centralization"),
            (neq, ":centralization", 0),
			##diplomacy start+ Apply constraint
			(val_clamp, ":centralization", ":policy_min", ":policy_max"),
			##diplomacy end+
            (val_mul, ":centralization", -2),#gdw
            (val_add, ":percent", ":centralization"),
          (try_end),
          (try_begin),
            (faction_get_slot, ":aristocraty", ":faction_id", "slot_faction_aristocracy"),
            (neq, ":aristocraty", 0),
			##diplomacy start+ Apply constraint
			(val_clamp, ":aristocraty", ":policy_min", ":policy_max"),
			##diplomacy end+
            (val_mul, ":aristocraty", 3),
            (val_add, ":percent", ":aristocraty"),
          (try_end),
          (try_begin),
            (faction_get_slot, ":quality", ":faction_id", "slot_faction_quality"),
            (neq, ":quality", 0),
			##diplomacy start+ Apply constraint
			(val_clamp, ":quality", ":policy_min", ":policy_max"),
			##diplomacy end+
            (val_mul, ":quality", -3),#gdw
            (val_add, ":percent", ":quality"),
          (try_end),
          ##diplomacy end
          ##diplomacy chief end
        (try_end),
        ##diplomacy begin chief
        (try_begin),
          (faction_get_slot, ":serfdom", ":faction_id", "slot_faction_serfdom"),
          (neq, ":serfdom", 0),
		  ##diplomacy start+ Apply constraint
		  (val_clamp, ":serfdom", ":policy_min", ":policy_max"),
		  ##diplomacy end+
          (val_mul, ":serfdom", 3),
          (val_add, ":percent", ":serfdom"),
        (try_end),

        (val_mul, ":limit", ":percent"),
		##nested diplomacy start+ Round correctly
		(val_add, ":limit", 50),
		##nested diplomacy end+
        (val_div, ":limit", 100),
        ##diplomacy end

        (try_begin),
          (faction_slot_eq, ":faction_id", "slot_faction_marshall", ":party_leader"),
          (val_add, ":limit", 100), #chief aumentado para marshall#gdwunchanged
        (try_end),        

#tempered chief changes begin  changed from castles_begin to walled_centers_begin  to include town ownership
#        (try_for_range, ":cur_center", castles_begin, castles_end),
		(try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
#Tempered changes end
          (party_slot_eq, ":cur_center", "slot_town_lord", ":party_leader"),
          (val_add, ":limit", 40), #chief aumentado lores
        (try_end),        
      ##diplomacy start+
      ##Extend this script so it will also work with garrisons 
      (else_try),
         (this_or_next|is_between, ":party_no", walled_centers_begin, walled_centers_end),
         (this_or_next|party_slot_eq, ":party_no", "slot_party_type", spt_castle),
            (party_slot_eq, ":party_no", "slot_party_type", spt_town),
			(assign, ":limit", 142),#average starting castle garrison size
			(try_begin),
			   (party_slot_eq, ":party_no", "slot_party_type", spt_town),
				(assign, ":limit", 380),#average starting town garrison size
			(try_end),
         #(store_faction_of_party, ":faction_id", ":party_no"),
      ##diplomacy end+
      (try_end),
            
      #if player has level of 0 then ideal limit will be exactly same, if player has level of 80 then ideal limit will be multiplied by 2 ((80 + 80) / 80)
      #below code will increase limits a little as the game progresses and player gains level
      (store_character_level, ":level", "trp_player"),
      (val_min, ":level", 80),#gdw levels in native see tml criticism of 160
      (store_add, ":level_factor", 80, ":level"),#gdw
      (val_mul, ":limit", ":level_factor"),
      (val_div, ":limit", 94),#gdw best place to reduce party size
      (assign, reg0, ":limit"),
  ]),


  #script_game_get_party_prisoner_limit:
  # This script is called from the game engine when the prisoner limit is needed for a party.
  # INPUT: arg1 = party_no
  # OUTPUT: reg0 = prisoner_limit
 #("get_max_skill_of_player_party",
#    [(store_script_param, ":skill_no", 1),
#     (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
 #    (store_skill_level, ":party_skill", "skl_prisoner_management", ":trp_player"),
#     (assign, ":skill_owner", "trp_player"),
#     (try_for_range, ":i_stack", 0, ":num_stacks"),
#       (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
#       (troop_is_hero, ":stack_troop"),
#       (neg|troop_is_wounded, ":stack_troop"),
#       (store_skill_level, ":cur_skill", "skl_prisoner_management", ":stack_troop"),
 #      (gt, ":cur_skill", ":max_skill"),
#       (assign, ":max_skill", ":cur_skill"),
##    (try_end),
#     (party_get_skill_level, reg0, "p_main_party", ":skill_no"),
##     (assign, reg0, ":max_skill"),
 #    (assign, reg1, ":skill_owner"),
 #    ]),
  
  ("game_get_party_prisoner_limit",
    [
    #(assign, ":limit", 0),
    (assign, ":npc_skill", 0),
    #(assign, ":skill", 0),
    (assign, ":max_skill", 0),
 	  (store_skill_level, ":player_skill", "skl_prisoner_management", "trp_player"),  # party_skill = 6
      (assign, ":npc_bonus", 0),
     # (assign, ":skill_owner", "trp_player"),
      #(assign, ":skill," ":player_skill"),
      (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
       (troop_is_hero, ":stack_troop"),
       (neg|troop_is_wounded, ":stack_troop"),
       (store_skill_level, ":npc_skill", "skl_prisoner_management", ":stack_troop"),
       #(gt, ":npc_skill", ":max_skill"),
       #(assign, ":max_skill", ":npc_skill"),
       #(assign, ":skill_owner", ":stack_troop"),
      (try_end),
      #(store_div, ":npc_bonus", ":max_skill", 2),
      #(store_div, ":player_bonus", ":player_skill", 2),
      (try_begin),
      	(ge, ":player_skill", ":npc_skill"),
        (store_div, ":npc_bonus", ":npc_skill", 2),
      	(val_add, ":player_skill", ":npc_bonus"),
        (assign, ":max_skill", ":player_skill"),
      (else_try),
        (store_div, ":player_bonus", ":player_skill", 2),
        (val_add, ":npc_skill", ":player_bonus"),
        (assign, ":max_skill", ":npc_skill"),
      (try_end),      
      (store_mul, ":limit", ":max_skill", 7), #AJM chief 10 per levelgdw
      (val_add, ":limit", 3),
      (assign, reg0, ":limit"),
      #(assign, reg1, ":skill_owner"),
     #  (try_begin),
     #   (gt, "$cheat_mode", 0),
     #   #(display_message, "@{!}DEBUG -- game_get_party_prisoner_limit: {reg0}"),
     #   #(assign, reg10, ":player_bonus"),
     #   #(assign, reg11, ":npc_bonus"),
     #   (assign, reg12, ":max_skill"),
     #   # (display_message, "@{!}DEBUG -- skillowner: {reg1}"), 
     #   #(display_message, "@{!}DEBUG -- player_bonus: {reg10}"), 
     #          #(display_message, "@{!}DEBUG -- player_skill: {reg12}"),   
    	# (try_end),
      (set_trigger_result, reg0),
	]),
   #("game_get_party_prisoner_limit",
 #   [
 #   (assign, ":troop_no", "trp_player"),
 #     (assign, ":limit", 0),
 #    (store_skill_level, ":party_skill", "skl_prisoner_management", "trp_player"),
 #     (try_for_range,":npc", companions_begin, companions_end),  # change here to Brytenwalda companions
 #      (main_party_has_troop, ":npc"), # checks if is in the party. Could add a check for wounded companions too
 #       (store_skill_level, ":npc_skill" , skl_prisoner_management, ":npc" ), # npc_skill = 8. Next loop (npc_2) it will be npc_skill = 2
 ##    (end_try),
 #     (store_div, ":player_bonus", ":party_skill", 2),
  #    (val_add, ":party_skill", ":player_bonus"),  # party_skill = 11 -> 8 + 3
 #     (val_min, ":party_skill", 15), # makes sure it wont be more than 15. party_skill = 11

  #    (store_mul, ":limit", ":party_skill", 7), #AJM chief 10 per levelgdw
  #    (val_add, ":limit", 3), #ajm chief you can have 5 prisoners even w/o ranks #in management#gdwTMLmade this 10 for "no reason" with new prisoner skill back in,unneed
  #    (assign, reg0, ":limit"),
  #    (display_debug_message, "@game_get_party_prisoner_limit: {reg0}"),#per kalarhan forge
  #    (set_trigger_result, reg0),
		#(assign, ":troop_no", "trp_player"),]),
  #script_game_get_item_extra_text:
  # This script is called from the game engine when an item's properties are displayed.
  # INPUT: arg1 = item_no, arg2 = extra_text_id (this can be between 0-7 (7 included)), arg3 = item_modifier
  # OUTPUT: result_string = item extra text, trigger_result = text color (0 for default)
  ("game_get_item_extra_text",
    [
      (store_script_param, ":item_no", 1),
      (store_script_param, ":extra_text_id", 2),
      (store_script_param, ":item_modifier", 3),
		(item_get_type, ":type", ":item_no"), ## CC chief
    
      (try_begin),
        

        (this_or_next|is_between, ":item_no", food_begin, food_end),
            (this_or_next|eq, ":item_no", "itm_wine"),
            (this_or_next|eq, ":item_no", "itm_ale"),
				(eq, ":item_no", "itm_mead"),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (assign, ":continue", 1),
          (try_begin),
            (this_or_next|eq, ":item_no", "itm_cattle_meat"),
            (this_or_next|eq, ":item_no", "itm_pork"),
            (this_or_next|eq, ":item_no", "itm_deer_meat"),
            (this_or_next|eq, ":item_no", "itm_boar_meat"),
            (this_or_next|eq, ":item_no", "itm_wolf_meat"),
            (this_or_next|eq, ":item_no", "itm_goat_meat"),
            (this_or_next|eq, ":item_no", "itm_goatb_meat"),
            (this_or_next|eq, ":item_no", "itm_wilddonkey_meat"),
				(eq, ":item_no", "itm_chicken"),
				
            (eq, ":item_modifier", imod_rotten),
            (assign, ":continue", 0),
          (try_end),
          (eq, ":continue", 1),
          (item_get_slot, ":food_bonus", ":item_no", "slot_item_food_bonus"),
          (assign, reg1, ":food_bonus"),
          (set_result_string, "@+{reg1} to party morale"),
          (set_trigger_result, 0x4444FF),
        (try_end),
      (else_try),
#anadido chief para estandartes
        (this_or_next|is_between, ":item_no", coronas_begin, coronas_end),
        (is_between, ":item_no", estandartes_begin, estandartes_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (assign, ":continue", 1),
          (try_begin),
            (this_or_next|eq, ":item_no", "itm_cattle_meat"),
            (this_or_next|eq, ":item_no", "itm_pork"),
				(eq, ":item_no", "itm_chicken"),
				
            (eq, ":item_modifier", imod_rotten),
            (assign, ":continue", 0),
          (try_end),
          (eq, ":continue", 1),
          (item_get_slot, ":food_bonus", ":item_no", "slot_item_food_bonus"),
          (assign, reg1, ":food_bonus"),
          (set_result_string, "@ Increases party morale and improves leadership and tactics skills."),
          (set_trigger_result, 0x4444FF),
        (try_end),
      (else_try),
#anadido chief para estandartes
#anadido chief para armaduras y yelmos
      (eq, "$g_armor_penalties", 1),
        (this_or_next|is_between, ":item_no", armadura_pesada_begin, armadura_pesada_end),
        (this_or_next|is_between, ":item_no", armadura_pesada2_begin, armadura_pesada2_end),
        (this_or_next|is_between, ":item_no", armadura_pesada3_begin, armadura_pesada3_end),
        (is_between, ":item_no", armadura_pesada4_begin, armadura_pesada4_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@Heavy Armour: High Penalties in certain skills"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
      (eq, "$g_armor_penalties", 1),
        (this_or_next|is_between, ":item_no", armadura_media_begin, armadura_media_end),
        (is_between, ":item_no", armadura_media2_begin, armadura_media2_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@Medium Armour: Penalties in certain skills"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
      (eq, "$g_armor_penalties", 1),
        (this_or_next|is_between, ":item_no", escudos_pesados_begin, escudos_pesados_end),
        (this_or_next|is_between, ":item_no", escudos_pesados2_begin, escudos_pesados2_end),
        (this_or_next|is_between, ":item_no", calzado_pesados_begin, calzado_pesados_end),
        (this_or_next|is_between, ":item_no", yelmos_pesados_begin, yelmos_pesados_end),
        (is_between, ":item_no", yelmos_pesados2_begin, yelmos_pesados2_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@Heavy Equipment: Penalties in certain skills"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
#anadido chief para desnudos
      (eq, "$g_armor_penalties", 1),
        (is_between, ":item_no", desnudos_begin, desnudos_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@Ritual Equipment: Advantages in certain skills"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
#anadido chief para armaduras y yelmos
###espada descripcion
				(eq, ":item_no", "itm_espada_quest2"),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@The sword of Rhydderch Hael, one of the thirteen treasures of Britain."),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
				(eq, ":item_no", "itm_espada_beowulf"),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@This is the sword which Unferth gives to Beowulf before the fight with Grendel's mother."),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
#espada chief
#otros
      (eq, "$g_armor_penalties", 1),
        (this_or_next|is_between, ":item_no", coronas_begin, coronas_end),
        (this_or_next|is_between, ":item_no", mercaderes_begin, mercaderes_end),
        (this_or_next|is_between, ":item_no", nobleclothes2_begin, nobleclothes2_end),
        (is_between, ":item_no", nobleclothes1_begin, nobleclothes1_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@Advantages in certain skills"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
#burros chief
            #(eq, "$g_armor_penalties", 1),
        (is_between, ":item_no", burro_begin, burro_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@ Donkeys: Improve foraging skill."),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
#burros chief end
        (is_between, ":item_no", readable_books_begin, readable_books_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (item_get_slot, reg1, ":item_no", "slot_item_intelligence_requirement"),
          (set_result_string, "@Requires {reg1} intelligence to read"),
          (set_trigger_result, 0xFFEEDD),
        (else_try),
          (eq, ":extra_text_id", 1),
          (item_get_slot, ":progress", ":item_no", "slot_item_book_reading_progress"),
          (val_div, ":progress", 10),
          (assign, reg1, ":progress"),
          (set_result_string, "@Reading Progress: {reg1}%"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
        (is_between, ":item_no", reference_books_begin, reference_books_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (try_begin),
            (eq, ":item_no", "itm_book_wound_treatment_reference"),
            (str_store_string, s1, "@wound treament"),
          (else_try),
            (eq, ":item_no", "itm_book_firstaid_reference"),
            (str_store_string, s1, "@first-aid"),
          (else_try),
            (eq, ":item_no", "itm_book_trade_reference"),
            (str_store_string, s1, "@trade-skill"),
          (else_try),
            (eq, ":item_no", "itm_book_looting_reference"),
            (str_store_string, s1, "@looting"),
          (else_try), #anadido chief relic
            (eq, ":item_no", "itm_relic1"),
            (str_store_string, s1, "@persuasion+2"),#gdw temp fix
          (else_try), #anadido chief relic
            (eq, ":item_no", "itm_book_slot"),
            (str_store_string, s1, "@You can read now. Just sell this."),#gdw temp fix
          (try_end),
          (set_result_string, "@+1 to {s1} while in inventory"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
        ## CC chief
      (else_try),
      (neq, ":item_modifier", imod_plain),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (set_result_string, "@ ^"),
          (set_trigger_result, 0xFFFFFF),
        (else_try),
          (eq, ":extra_text_id", 2),
          (try_begin),
            (eq, ":type", itp_type_horse),
            (try_begin),
              (eq, ":item_modifier", imod_swaybacked),
              (set_result_string, "@-2 speed^-2 maneuver"),
            (else_try),
              (eq, ":item_modifier", imod_lame),
              (set_result_string, "@-5 speed^-5 maneuver"),
            (else_try),
              (eq, ":item_modifier", imod_heavy),
              (set_result_string, "@+3 armor^+4 charge^+10 hit points"),
            (else_try),
              (eq, ":item_modifier", imod_timid),
              (set_result_string, "@-1 requirement of riding"),
            (else_try),
              (eq, ":item_modifier", imod_stubborn),
              (set_result_string, "@+1 requirement of riding^+5 hit points"),
            (else_try),
              (eq, ":item_modifier", imod_spirited),
              (set_result_string, "@+1 speed^+1 armor^+1 charge"),
            (else_try),
              (eq, ":item_modifier", imod_champion),
              (set_result_string, "@+2 requirement of riding^+2 speed^+2 armor^+2 charge"),
            (try_end),
          (else_try),
            (eq, ":type", itp_type_shield),
            (try_begin),
              (eq, ":item_modifier", imod_cracked),
              (set_result_string, "@-56 hit points^-4 resistance"),
            (else_try),
              (eq, ":item_modifier", imod_battered),
              (set_result_string, "@-26 hit points^-2 resistance"),
            (else_try),
              (eq, ":item_modifier", imod_thick),
              (set_result_string, "@+47 hit points^+2 resistance"),
            (else_try),
              (eq, ":item_modifier", imod_reinforced),
              (set_result_string, "@+83 hit points^+4 resistance"),
            (try_end),
          (else_try),
            (this_or_next|eq, ":type", itp_type_head_armor),
            (this_or_next|eq, ":type", itp_type_body_armor),
            (this_or_next|eq, ":type", itp_type_foot_armor),
            (eq, ":type", itp_type_hand_armor),
            
            (item_get_slot, ":head_armor", ":item_no", "slot_item_head_armor"),
            (item_get_slot, ":body_armor", ":item_no", "slot_item_body_armor"),
            (item_get_slot, ":leg_armor", ":item_no", "slot_item_leg_armor"),
            
            (assign, reg1, 0),
            (assign, reg2, 0),
            (assign, reg3, 0),
            (try_begin),
              (gt, ":head_armor", 0),
              (assign, reg1, 1),
            (try_end),
            (try_begin),
              (gt, ":body_armor", 0),
              (assign, reg2, 1),
            (try_end),
            (try_begin),
              (gt, ":leg_armor", 0),
              (assign, reg3, 1),
            (try_end),
            
            (try_begin),
              (eq, ":item_modifier", imod_cracked),
              (str_store_string, s1, "@ -"),
              (assign, reg4, 4),
            (else_try),
              (eq, ":item_modifier", imod_rusty),
              (str_store_string, s1, "@ -"),
              (assign, reg4, 3),
            (else_try),
              (eq, ":item_modifier", imod_battered),
              (str_store_string, s1, "@ -"),
              (assign, reg4, 2),
            (else_try),
              (eq, ":item_modifier", imod_crude),
              (str_store_string, s1, "@ -"),
              (assign, reg4, 1),
            (else_try),
              (eq, ":item_modifier", imod_tattered),
              (str_store_string, s1, "@ -"),
              (assign, reg4, 3),
            (else_try),
              (eq, ":item_modifier", imod_ragged),
              (str_store_string, s1, "@ -"),
              (assign, reg4, 2),
            (else_try),
              (eq, ":item_modifier", imod_sturdy),
              (str_store_string, s1, "@ +"),
              (assign, reg4, 1),
            (else_try),
              (eq, ":item_modifier", imod_thick),
              (str_store_string, s1, "@ +"),
              (assign, reg4, 2),
            (else_try),
              (eq, ":item_modifier", imod_hardened),
              (str_store_string, s1, "@ +"),
              (assign, reg4, 3),
            (else_try),
              (eq, ":item_modifier", imod_reinforced),
              (str_store_string, s1, "@ +"),
              (assign, reg4, 4),
            (else_try),
              (eq, ":item_modifier", imod_lordly),
              (str_store_string, s1, "@ +"),
              (assign, reg4, 6),
            (try_end),
            (set_result_string, "@{reg1?{s1}{reg4} to head armor^:}{reg2?{s1}{reg4} to body armor^:}{reg3?{s1}{reg4} to leg armor:}"),
          (else_try),
            (this_or_next|eq, ":type", itp_type_one_handed_wpn),
            (this_or_next|eq, ":type", itp_type_two_handed_wpn),
            (this_or_next|eq, ":type", itp_type_polearm),
            (eq, ":type", itp_type_crossbow),
            
            (item_get_slot, ":swing_damage", ":item_no", "slot_item_swing_damage"),
            (item_get_slot, ":thrust_damage", ":item_no", "slot_item_thrust_damage"),
            (store_mod, reg1, ":swing_damage", 256),
            (store_mod, reg2, ":thrust_damage", 256),
            (item_get_slot, reg3, ":item_no", "slot_item_difficulty"),
            
            (try_begin),
              (eq, ":item_modifier", imod_cracked),
              (set_result_string, "@{reg1?-5 swing damage^:}{reg2?-5 thrust damage^:}"),
            (else_try),
              (eq, ":item_modifier", imod_rusty),
              (set_result_string, "@{reg1?-3 swing damage^:}{reg2?-3 thrust damage^:}"),
            (else_try),
              (eq, ":item_modifier", imod_bent),
              (set_result_string, "@{reg1?-3 swing damage^:}{reg2?-3 thrust damage^:}-3 speed"),
            (else_try),
              (eq, ":item_modifier", imod_chipped),
              (set_result_string, "@{reg1?-1 swing damage^:}{reg2?-1 thrust damage^:}"),
            (else_try),
              (eq, ":item_modifier", imod_balanced),
              (set_result_string, "@{reg1?+3 swing damage^:}{reg2?+3 thrust damage^:}+3 speed"),
            (else_try),
              (eq, ":item_modifier", imod_tempered),
              (set_result_string, "@{reg1?+4 swing damage^:}{reg2?+4 thrust damage^:}"),
            (else_try),
              (eq, ":item_modifier", imod_masterwork),
              (set_result_string, "@{reg1?+5 swing damage^:}{reg2?+5 thrust damage^:}+1 speed{reg3?^+4 requirement of strength:}"),
            (else_try),
              (eq, ":item_modifier", imod_heavy),
              (set_result_string, "@{reg1?+2 swing damage^:}{reg2?+2 thrust damage^:}-2 speed{reg3?^+1 requirement of strength:}"),
            (try_end),
          (else_try),
            (eq, ":type", itp_type_bow),
            (item_get_slot, reg3, ":item_no", "slot_item_difficulty"),
            
            (try_begin),
              (eq, ":item_modifier", imod_cracked),
              (set_result_string, "@-5 damage"),
            (else_try),
              (eq, ":item_modifier", imod_bent),
              (set_result_string, "@-3 damage^-3 speed"),
            (else_try),
              (eq, ":item_modifier", imod_strong),
              (set_result_string, "@+3 damage^-3 speed{reg3?^+2 requirement of power draw:}"),
            (else_try),
              (eq, ":item_modifier", imod_masterwork),
              (set_result_string, "@+5 damage^+1 speed{reg3?^+4 requirement of power draw:}"),
            (try_end),
          (else_try),
            (eq, ":type", itp_type_thrown),
            (item_get_slot, reg3, ":item_no", "slot_item_difficulty"),
            
            (try_begin),
              (eq, ":item_modifier", imod_large_bag),
              (set_result_string, "@+13% max ammo"),
            (else_try),
              (eq, ":item_modifier", imod_bent),
              (set_result_string, "@-3 damage^-3 speed"),
            (else_try),
              (eq, ":item_modifier", imod_heavy),
              (set_result_string, "@+2 damage^-2 speed{reg3?^+1 requirement of power throw:}"),
            (else_try),
              (eq, ":item_modifier", imod_balanced),
              (set_result_string, "@+3 damage^+3 speed"),
            (try_end),
          (else_try),
            (this_or_next|eq, ":type", itp_type_arrows),
            (eq, ":type", itp_type_bolts),
            (try_begin),
              (eq, ":item_modifier", imod_large_bag),
              (set_result_string, "@+13% max ammo"),
            (else_try),
              (eq, ":item_modifier", imod_bent),
              (set_result_string, "@-3 damage"),
            (try_end),
          (try_end),
          (set_trigger_result, 0x8080FF),
        ## CC chief
        (try_end),
#COOP chief#####################################################################
      (else_try),
        (eq, ":extra_text_id", 0),
        (is_presentation_active, "prsnt_coop_item_select"),
        (set_result_string, s58),
        (try_begin),
          (eq, reg1, 1),
          (set_trigger_result, 0x10C600),
        (else_try),
          (set_trigger_result, 0xC90200),
        (try_end),
###############################################################Somebody toggleable  gdw
      (else_try),
        (item_get_slot, ":swap_no", ":item_no", "slot_item_alternate"),
        (gt, ":swap_no", 0),
        #this condition checks if it's already displayed engine-side
        (store_sub, ":damage", ":swap_no", ":item_no"),
        (neq, ":damage", 1),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (str_store_item_name, s1, ":swap_no"),
          (set_result_string, "@Alternate version: {s1}"),
          (set_trigger_result, 0xADA2C2),
        (else_try),
          (eq, ":extra_text_id", 1),
          (item_get_slot, ":damage", ":swap_no", "slot_item_swing_damage"),
          #add damage from item modifiers here
          (try_begin),
            (is_between, ":damage", 0, 256),
            (assign, reg1, ":damage"),
            (str_store_string, s1, "@{reg1}c"),
          (else_try),
            (is_between, ":damage", 256, 512),
            (store_sub, reg1, ":damage", 256),
            (str_store_string, s1, "@{reg1}p"),
          (else_try),
            (ge, ":damage", 512),
            (store_sub, reg1, ":damage", 512),
            (str_store_string, s1, "@{reg1}b"),
          (try_end),
          (str_store_string, s1, "@Swing: {s1}"),
          (item_get_slot, ":damage", ":swap_no", "slot_item_thrust_damage"),
          (try_begin), #some weapons do not have thrust, most should have swing
            (neq, ":damage", 0),
            (neq, ":damage", 256),
            (neq, ":damage", 512),
            (try_begin),
              (is_between, ":damage", 0, 256),
              (assign, reg1, ":damage"),
              (str_store_string, s2, "@{reg1}c"),
            (else_try),
              (is_between, ":damage", 256, 512),
              (store_sub, reg1, ":damage", 256),
              (str_store_string, s2, "@{reg1}p"),
            (else_try),
              (ge, ":damage", 512),
              (store_sub, reg1, ":damage", 512),
              (str_store_string, s2, "@{reg1}b"),
            (try_end),
            (str_store_string, s1, "@{s1}^Thrust {s2}"),
          (try_end),
          (set_result_string, s1),
          (set_trigger_result, 0xEBC8C8),
        (try_end),
      (try_end),
  ]),
  
  #script_game_on_disembark:
  # This script is called from the game engine when the player reaches the shore with a ship.
  # INPUT: pos0 = disembark position
  # OUTPUT: none
  ("game_on_disembark",
   [(jump_to_menu, "mnu_disembark"),
  ]),


  #script_game_context_menu_get_buttons:
  # This script is called from the game engine when the player clicks the right mouse button over a party on the map.
  # INPUT: arg1 = party_no
  # OUTPUT: none, fills the menu buttons
#tempered chief menu cambiado entero
  ("game_context_menu_get_buttons",
   [(store_script_param, ":party_no", 1),
	(party_get_template_id,":party_template_id",":party_no"),
	(party_get_slot,":p_type",":party_no","slot_party_type"),
	(assign,":is_town",0),
	(assign,":training_ground",0),
	(party_get_battle_opponent, ":is_battle", ":party_no"),
	(try_begin),
		(is_between,":party_no",training_grounds_begin,training_grounds_end),
		(assign,":training_ground",1),
	(try_end),
	(try_begin),
		(is_between, ":party_no", centers_begin, centers_end),
		(assign,":is_town",1),
	(try_end),
	(try_begin),
		(eq,"$party_picker_active",0),
		(assign,":skirmish_parties",0),
		(assign,":max_spies",0),		
		(store_num_parties_of_template,":skirmish_parties","pt_skirmish_party"), #Tempered, chief get number of skirmisher parties deployed
		(party_get_slot,":spies_deployed","p_main_party","slot_spies_deployed"), #Tempered chief  number of spy parties deployed, cannot exceed 2x leadership,
		(store_skill_level,":cur_leadership",skl_leadership,"trp_player"),
		(store_mul,":max_spies",":cur_leadership",2),
		(store_faction_of_party, ":party_faction", ":party_no"), 
		(store_relation, ":cur_relation", "fac_player_faction", ":party_faction"),
		(try_begin),
			(neq, ":party_no", "p_main_party"),
			(context_menu_add_item, "@Move here", cmenu_move),
		(try_end),
		(try_begin),#town options begin
			(eq,":is_town",1),
			(party_get_slot,":spy_days",":party_no","slot_spy_in_town"), #Tempered chief get spy info
			(store_current_hours,":cur_hour"),
			(store_sub,":total_time",":cur_hour",":spy_days"),
			(try_begin),
				(eq,":total_time",":cur_hour"),
				(assign,":total_time",0),
			(try_end),
			(context_menu_add_item, "@View notes", 1),
			(try_begin), #Tempered begin spy items
				(le,":spy_days",0),
				(lt,":spies_deployed",":max_spies"),
				(is_between,":p_type",2,5),
				(main_party_has_troop,"trp_merc_spy"),
				(context_menu_add_item, "@Send Spy",5),
			(else_try),
				(ge,":total_time",1),
				(party_get_slot,":sabotage_order",":party_no","slot_spy_sabotage"),
				(context_menu_add_item,"@Retrieve Spy",6),
				(try_begin),
					(ge,":total_time",24),
					(eq,":sabotage_order",0),
					(context_menu_add_item,"@Order Sabotage",7),
				(try_end),	
			(try_end),
		(else_try),# kingdom hero options begin
			(party_slot_eq,":party_no","slot_party_type",spt_kingdom_hero_party),
			(context_menu_add_item, "@View notes", 2),	  
# Lav modifications start (custom lord notes) chief
                       (context_menu_add_item, "@Add custom note", 12),
# Lav modifications end (custom lord notes)
			(try_begin), #send messenger to kingdom hero party
				(le,":is_battle",0),		
				(main_party_has_troop,"trp_merc_spy"),
				(context_menu_add_item, "@Send messenger", 4), 
			(try_end),
		(try_end),
     (try_begin),
       (neq, ":party_no", "p_main_party"),       
       (store_faction_of_party, ":party_faction", ":party_no"),
                     
       (this_or_next|eq, ":party_faction", "$players_kingdom"),
       (this_or_next|eq, ":party_faction", "fac_player_supporters_faction"),
       (party_slot_eq, ":party_no", "slot_party_type", spt_kingdom_caravan),
       
       (neg|is_between, ":party_no", centers_begin, centers_end),
       
       (context_menu_add_item, "@Accompany", cmenu_follow), 
     (try_end),    
		(try_begin), #Tempered skirmish test conditions, add to context menu.
			(eq,":is_town",0), #Tempered make sure we don't skirmish towns,villages,castles, or training grounds
			(eq,":training_ground",0),
			(neq, ":p_type", spt_messenger), #do not consider messengers
			(neq,":party_template_id","pt_spy_party"),  #do not consider spy parties
			(neq,":party_template_id","pt_deer_herd"),  #no se permite con caza chief
			(neq,":party_template_id","pt_boar_herd"),  #no se permite con caza
			(neq,":party_template_id","pt_wolf_herd"),  #no se permite con caza
			(neq,":party_template_id","pt_coat_herd"),  #no se permite con caza
			(neq,":party_template_id","pt_coatb_herd"),  #no se permite con caza
			(neq,":party_template_id","pt_wilddonkey_herd"),  #no se permite con caza
			(neq, ":p_type", spt_cattle_herd1),
			(neq, ":party_no", "p_main_party"),
			(le,":is_battle",0),		
			(main_party_has_troop,"trp_merc_spy"), #Tempered check to see if player has skirmisher troops
			(le, ":cur_relation", 0), #Tempered check that relation is neutral or worse with party to send skirmishers 
			(party_count_members_of_type,":skirmish_count","p_main_party","trp_merc_spy"),  # Tempered store number of troops 
			(ge,":skirmish_count",5), #Tempered make sure minimum number of skirmishers is available
			(eq,":skirmish_parties",0), #Make sure skirmishers are not already deployed
			(context_menu_add_item,"@Skirmish", 3), #Tempered add skirmish option to context menu
		(try_end),
		(try_begin),
			(eq,":party_no","p_main_party"),
			(gt,"$wagon_attached",0),
			(context_menu_add_item,"@Manage Supply Wagon", 8),
		(try_end),
	(else_try),#party picker variables
		(eq,"$party_picker_active",1),
		(eq,":training_ground",0),
		(neq,":party_no","$message_target"),
		(neq,":party_no","p_main_party"),
		(neq, ":p_type", spt_messenger),
		(neq,":party_template_id","pt_spy_party"),  #do not consider spy parties
		(neq, ":p_type", spt_cattle_herd1),
		(neq,":party_template_id","pt_skirmish_party"),
		(context_menu_add_item, "@Select as target",1),
#tempered chief acaba
    ## mejor IA chief
      (try_begin),
        (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
        (party_slot_eq, ":party_no", "slot_party_ai_object", "p_main_party"),
        (try_begin),
          (party_slot_eq, ":party_no", "slot_party_blind_to_other_parties", 0),
          (context_menu_add_item, "@Blind to other parties(Disabled)", 3),
        (else_try),
          (party_slot_eq, ":party_no", "slot_party_blind_to_other_parties", 1),
          (context_menu_add_item, "@Blind to other parties(Enabled)", 3),
        (try_end),
        (context_menu_add_item, "@Force all lords followed to blind to other parties", 4),
        (context_menu_add_item, "@Force all lords followed not to blind to other parties", 5),
      (try_end),
      ## mejor ia acaba
    (try_end),
  ]),

  #script_game_event_context_menu_button_clicked:
  # This script is called from the game engine when the player clicks on a button at the right mouse menu.
  # INPUT: arg1 = party_no, arg2 = button_value
  # OUTPUT: none
#tempered chief menu cambiado entero
  ("game_event_context_menu_button_clicked",
   [(store_script_param, ":party_no", 1),
    (store_script_param, ":button_value", 2),
	(try_begin),
		(eq,"$party_picker_active",0),
		(assign,"$skirmish_target",":party_no"),
		(try_begin),
			(eq, ":button_value", 1),
			(change_screen_notes, 3, ":party_no"),
		(else_try),
			(eq, ":button_value", 2),
			(party_stack_get_troop_id, ":troop_no", ":party_no", 0),
			(change_screen_notes, 1, ":troop_no"),
		(else_try), #Tempered send skirmishers code
			(eq,":button_value",3),
			(start_presentation,"prsnt_skirmishers"),
		(else_try), #Tempered send messenger to kingdom hero party
			(eq,":button_value",4),
			(assign,"$message_target",":party_no"),		
			(call_script,"script_describe_player_relations",":party_no"),		
			(start_presentation,"prsnt_compose_message_hero"),
		(else_try), #Tempered send spy to town/village/castle
			(eq,":button_value",5),
			(party_get_slot,":cur_spy_count","p_main_party","slot_spies_deployed"),
			(val_add,":cur_spy_count",1),		
			(set_spawn_radius,0),
			(spawn_around_party,"p_main_party","pt_spy_party"),
			(assign,":spy_party_id",reg(0)),
			(party_set_faction,":spy_party_id","fac_neutral"),
			(party_remove_members,"p_main_party","trp_merc_spy",1),
			(party_set_ai_behavior, ":spy_party_id", ai_bhvr_travel_to_party),
			(party_set_ai_object,":spy_party_id",":party_no"),
			(party_set_slot,":spy_party_id","slot_spy_target_town",":party_no"),
			(party_set_slot,"p_main_party","slot_spies_deployed",":cur_spy_count"),
		(else_try), #Tempered retrieve spy
			(eq,":button_value",6),
			(set_spawn_radius,0),
			(spawn_around_party,":party_no","pt_spy_party"),
			(assign,":spy_party_id",reg(0)),
			(party_set_faction,":spy_party_id","fac_neutral"),
			(party_set_ai_behavior, ":spy_party_id", ai_bhvr_attack_party),
			(party_set_ai_object,":spy_party_id","p_main_party"),
			(party_set_slot,":party_no","slot_spy_in_town",0),
			(party_set_slot,":party_no","slot_spy_sabotage",0),
			(party_get_slot,":cur_spy_count","p_main_party","slot_spies_deployed"),
			(party_set_slot,":spy_party_id","slot_spy_target_town",-1),
			(val_sub,":cur_spy_count",1),
			(party_set_slot,"p_main_party","slot_spies_deployed",":cur_spy_count"),
			(call_script, "script_update_center_recon_notes", ":party_no"),
		(else_try), #Tempered spy sabotage request
			(eq,":button_value",7),
			(assign,"$spy_target",":party_no"),
			(str_clear,s4),
			(assign,"$cur_choice",0),
			(jump_to_menu,"mnu_spy_sabotage"),
		(else_try),#Tempered loot wagon management
			(eq,":button_value",8),
			(assign,"$next_screen",0),
			(jump_to_menu,"mnu_loot_wagon"),
# Lav modifications start (custom lord notes) chief
    (else_try),
      (eq, ":button_value", 12),
      (party_stack_get_troop_id, "$g_cln_troop", ":party_no", 0),
      (start_presentation, "prsnt_custom_lord_notes"),
# Lav modifications end (custom lord notes)
		(try_end),
	(else_try),#party picker variables
		(eq,"$party_picker_active",1),
		(eq,":button_value",1),
		(neq,":party_no","$message_target"),
		(neq,":party_no","p_main_party"),
		(assign,"$message_party_target",":party_no"),		
#chief tempered end
    ## mejor IA chief empieza
    (else_try),
      (eq, ":button_value", 9),
      (party_get_slot, ":follow_state", ":party_no", "slot_party_blind_to_other_parties"),
      (val_add, ":follow_state", 1),
      (val_mod, ":follow_state", 2),
      (party_set_slot, ":party_no", "slot_party_blind_to_other_parties", ":follow_state"),
    (else_try),
      (eq, ":button_value", 10),
      (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
        (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
        (ge, ":party_no", 1),
        (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
        (party_slot_eq, ":party_no", "slot_party_ai_object", "p_main_party"),
        (party_set_slot, ":party_no", "slot_party_blind_to_other_parties", 1),
      (try_end),
    (else_try),
      (eq, ":button_value", 11),
      (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
        (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
        (ge, ":party_no", 1),
        (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
        (party_slot_eq, ":party_no", "slot_party_ai_object", "p_main_party"),
        (party_set_slot, ":party_no", "slot_party_blind_to_other_parties", 0),
      (try_end),
    ## Mejor IA Chief acaba
    (try_end),
  ]),

  #script_game_get_skill_modifier_for_troop
  # This script is called from the game engine when a skill's modifiers are needed
  # INPUT: arg1 = troop_no, arg2 = skill_no
  # OUTPUT: trigger_result = modifier_value
  ("game_get_skill_modifier_for_troop",
   [(store_script_param, ":troop_no", 1),
    (store_script_param, ":skill_no", 2),
    (assign, ":modifier_value", 0),
    (try_begin),
      (eq, ":skill_no", "skl_wound_treatment"),
      (call_script, "script_get_troop_item_amount", ":troop_no", "itm_book_wound_treatment_reference"),
      (gt, reg0, 0),
      (val_add, ":modifier_value", 1),
     (else_try),
      (eq, ":skill_no", "skl_first_aid"),
      (call_script, "script_get_troop_item_amount", ":troop_no", "itm_book_firstaid_reference"),
      (gt, reg0, 0),
      (val_add, ":modifier_value", 1),
    (else_try),
      (eq, ":skill_no", "skl_looting"),
      (call_script, "script_get_troop_item_amount", ":troop_no", "itm_book_looting_reference"),
      (gt, reg0, 0),
      (val_add, ":modifier_value", 1),
   (else_try),
      (eq, ":skill_no", "skl_trade"),
      (call_script, "script_get_troop_item_amount", ":troop_no", "itm_book_trade_reference"),
      (gt, reg0, 0),
      (val_add, ":modifier_value", 1),
   (else_try), #anadido persuasion a biblia vulgata
      (eq, ":skill_no", "skl_persuasion"),
      (call_script, "script_get_troop_item_amount", ":troop_no", "itm_relic1"),
      (gt, reg0, 0),
      (val_add, ":modifier_value", 2),#gdw extra bonus for vulgata bible due to harder quest
   (else_try), #entretenimientos bardos chief
          (eq, ":skill_no", "skl_entertain"),
		  (try_for_range, ":instrument", instruments_begin, instruments_end),
            (call_script, "script_get_troop_item_amount", ":troop_no", ":instrument"),
            (gt, reg0, 0),
            (val_add, ":modifier_value", 1),
		  (try_end),
   (else_try), #pictos desnudos
#(eq, "$g_armor_penalties", 1),
      (this_or_next|eq, ":skill_no", "skl_athletics"),
      (this_or_next|eq, ":skill_no", "skl_ironflesh"),
      (eq, ":skill_no", "skl_power_strike"),
      (troop_get_inventory_slot,":cur_item1",":troop_no",ek_body),#Here we are getting items from slots 0,1,2,3
      (is_between, ":cur_item1", desnudos_begin, desnudos_end),
      (val_add, ":modifier_value", 2),#suma 1
   (else_try), #burros
#(eq, "$g_armor_penalties", 0),
      (eq, ":skill_no", "skl_inventory_management"),
          (call_script, "script_get_troop_item_amount", ":troop_no", "itm_donkey_horse1"),
          (gt, reg0, 0),
      (val_add, ":modifier_value", 1),#suma 1
   (else_try), #burros
      #(eq, "$g_armor_penalties", 0),
      (eq, ":skill_no", "skl_foraging"),
          (call_script, "script_get_troop_item_amount", ":troop_no", "itm_donkey_horse1"),
          (gt, reg0, 0),
      (val_add, ":modifier_value", 1),#suma 1
   (else_try), #burros
      #(eq, "$g_armor_penalties", 0),
        (eq, ":skill_no", "skl_inventory_management"),
            (call_script, "script_get_troop_item_amount", ":troop_no", "itm_mulehorse"),
            (gt, reg0, 0),
        (val_add, ":modifier_value", 1),#suma 1
   # (else_try), #mercaderes  ##testpurposes only gdw  ##this worked proving that can have multiple calls on one item category
   #    #(eq, "$g_armor_penalties", 0),
   #    (this_or_next|eq, ":skill_no", "skl_ironflesh"),
   #    (eq, ":skill_no", "skl_trade"),
   #    (troop_get_inventory_slot,":cur_item1",":troop_no",ek_body),#Here we are getting items from slots 0,1,2,3
   #    (is_between, ":cur_item1", mercaderes_begin, mercaderes_end),
   #    (val_add, ":modifier_value", 1),#And suma 1  
  (else_try), #ropa noble
      (eq, "$g_armor_penalties", 1),
        (eq, ":skill_no", "skl_persuasion"),
        (troop_get_inventory_slot,":cur_item1",":troop_no",ek_body),#Here we are getting items from slots 0,1,2,3
        (is_between, ":cur_item1", nobleclothes1_begin, nobleclothes1_end),
        (val_add, ":modifier_value", 1),#And suma 1   gdw
  (else_try), #ropa noble
      (eq, "$g_armor_penalties", 1),
      (eq, ":skill_no", "skl_persuasion"),
      (troop_get_inventory_slot,":cur_item1",":troop_no",ek_body),#Here we are getting items from slots 0,1,2,3
      (is_between, ":cur_item1", nobleclothes2_begin, nobleclothes2_end),
      (val_add, ":modifier_value", 2),#And suma 1   gdw
  # (try_end),
  # (try_begin), 
  (else_try),#armadura pesada, heavy armor
   	(this_or_next|eq, ":skill_no", "skl_power_draw"),
      (this_or_next|eq, ":skill_no", "skl_horse_archery"),
      (this_or_next|eq, ":skill_no", "skl_athletics"),#deal with athletic fatigue separately in misstion templates
      (this_or_next|eq, ":skill_no", "skl_power_throw"),
      (this_or_next|eq, ":skill_no", "skl_ironflesh"),
      (eq, ":skill_no", "skl_power_strike"),
      (eq, "$g_armor_penalties", 1),
      (eq, "$g_encumbrance_penalty", 1),
#And suma 1   gdw# (eq, "$g_armor_penalties", 0),
      (this_or_next|eq, ":troop_no", "trp_player"),
      (is_between, ":troop_no", companions_begin, companions_end),

      (main_party_has_troop, ":troop_no"), ##Floris fix so companions-as-lords aren't affected
      (store_attribute_level, ":strength", ":troop_no", ca_strength),
    
      (call_script, "script_get_total_equipment_weight", ":troop_no"),
         #(assign, reg1, reg0),
         (try_begin),
            (gt, "$cheat_mode", 2),
  				(display_message, "@equipment e1a  weight is {reg0}"),
   		  (try_end),
          (assign, ":total_weight", reg0),
      #     (try_begin), ##both debugs work
      #       (eq, "$cheat_mode", 1),
  				# (display_message, "@equipment e1b  weight is {reg0}"),
   		 #  (try_end),
   		 (val_div, ":total_weight", 100),
          (val_sub, ":total_weight", ":strength"),
          #  (val_add, ":strength", 2),
          (val_div, ":total_weight", 8),
          (store_sub, ":modifier_value", 0, ":total_weight"),
          (val_clamp, ":modifier_value", -4,1),
 #           equipment e1a  weight is 0
 # equipment e1b  weight is 0
   (else_try), #armadura media, medium armor
      (eq, "$g_armor_penalties", 1),
      (eq, "$g_encumbrance_penalty", 2),
#And suma 1   gdw# (eq, "$g_armor_penalties", 0),
      (this_or_next|eq, ":skill_no", "skl_power_draw"),
      (this_or_next|eq, ":skill_no", "skl_horse_archery"),
      (this_or_next|eq, ":skill_no", "skl_athletics"),#deal with athletic fatigue separately in misstion templates
      (this_or_next|eq, ":skill_no", "skl_power_throw"),
      (this_or_next|eq, ":skill_no", "skl_ironflesh"),
      (eq, ":skill_no", "skl_power_strike"),
      (this_or_next|eq, ":troop_no", "trp_player"),
      (is_between, ":troop_no", companions_begin, companions_end),
      (main_party_has_troop, ":troop_no"), ##Floris fix so companions-as-lords aren't affected
      (store_attribute_level, ":strength", ":troop_no", ca_strength),
     
      (call_script, "script_get_total_equipment_weight", ":troop_no"),
       	(assign, reg1, reg0),
          (try_begin),
            (gt, "$cheat_mode", 2),
  				(display_message, "@equipment e2 weight is {reg1}"),
   		  (try_end),
          (assign, ":total_weight", reg1),
           (val_div, ":total_weight", 100),
           (val_add, ":strength", 3),
          (val_sub, ":total_weight", ":strength"),
          (val_div, ":total_weight", 6),
          (store_sub, ":modifier_value", 0, ":total_weight"),
          (val_clamp, ":modifier_value", -5,1),
    (else_try), #armadura media, medium armor
      (eq, "$g_armor_penalties", 1),
      (eq, "$g_encumbrance_penalty", 3),
#And suma 1   gdw# (eq, "$g_armor_penalties", 0),
      (this_or_next|eq, ":skill_no", "skl_power_draw"),
      (this_or_next|eq, ":skill_no", "skl_horse_archery"),
      (this_or_next|eq, ":skill_no", "skl_athletics"),#deal with athletic fatigue separately in misstion templates
      (this_or_next|eq, ":skill_no", "skl_power_throw"),
      (this_or_next|eq, ":skill_no", "skl_ironflesh"),
      (eq, ":skill_no", "skl_power_strike"),
      (this_or_next|eq, ":troop_no", "trp_player"),
      (is_between, ":troop_no", companions_begin, companions_end),
      (main_party_has_troop, ":troop_no"), ##Floris fix so companions-as-lords aren't affected
      (store_attribute_level, ":strength", ":troop_no", ca_strength),
      (call_script, "script_get_total_equipment_weight", ":troop_no"),
       (val_sub, ":total_weight", 4),
       (val_sub, ":total_weight", ":strength"),
       (val_div, ":total_weight", 5),
       (store_sub, ":modifier_value", 0, ":total_weight"),
       (val_clamp, ":modifier_value", -5,1),
   

    (else_try), #estandartes, cuernos
		  (this_or_next|eq, ":skill_no", "skl_leadership"),
		  (eq, ":skill_no", "skl_tactics"),
		  (troop_get_inventory_slot,":cur_item1",":troop_no",ek_item_0),#Here we are getting items from slots 0,1,2,3
		  (troop_get_inventory_slot,":cur_item1",":troop_no",ek_item_1),#Those slots are where weapons are placed.
		  (troop_get_inventory_slot,":cur_item1",":troop_no",ek_item_2),#We get them all to a different :local. Now all those :local variables are equal to one of the items in slots.
		  (troop_get_inventory_slot,":cur_item1",":troop_no",ek_item_3),#Then we check each item, if it is the one we want.
		  (troop_get_inventory_slot,":cur_item2",":troop_no",ek_item_0),#Here we are getting items from slots 0,1,2,3
		  (troop_get_inventory_slot,":cur_item2",":troop_no",ek_item_1),#Those slots are where weapons are placed.
		  (troop_get_inventory_slot,":cur_item2",":troop_no",ek_item_2),#We get them all to a different :local. Now all those :local variables are equal to one of the items in slots.
		  (troop_get_inventory_slot,":cur_item2",":troop_no",ek_item_3),#Then we check each item, if it is the one we want.
		  (this_or_next|is_between, ":cur_item1", coronas_begin, coronas_end),
		  (is_between, ":cur_item2", estandartes_begin, estandartes_end),
		  (val_add, ":modifier_value", 1),#And suma 1
#chief acaba
    (try_end),
 #floris habilidades aumentadas por tropa chief
		#Floris Stat Bonus Begins
		(try_begin),
			(troop_is_hero, ":troop_no"),
			(assign, ":party", -1),
			(try_begin),
				(neg|main_party_has_troop, ":troop_no"),
				(troop_get_slot, ":leaded_party", ":troop_no", "slot_troop_leaded_party"),
				(ge, ":leaded_party", 1), #it needs to be 1, not 0. 0 means the troop doesn't lead a party
				(assign, ":party", ":leaded_party"),
			(else_try),
				(main_party_has_troop, ":troop_no"), #add this to take into account the player and hero companions
				(assign, ":party", "p_main_party"),
			(try_end),
			(ge, ":party", 0),
			(party_is_active, ":party"),
			(try_begin),
				(eq, ":skill_no", "skl_trade"),
				(call_script, "script_get_party_troop_count", ":party", "trp_caravan_master"),
				(try_begin),
					(gt, reg0, 5),#gdw
					(val_add, ":modifier_value", 3),
				(else_try),
					(gt, reg0, 2),#gdw
					(val_add, ":modifier_value", 2),	
				(else_try),
					(gt, reg0, 0),#gdw
					(val_add, ":modifier_value", 1),
				(try_end),
			(else_try),
				(eq, ":skill_no", "skl_prisoner_management"),
				#(store_party_size_wo_prisoners , reg0, "p_main_party"),
				(store_party_size_wo_prisoners , ":num_troops", "p_main_party"),#gdw credits to Kalarhan
				#(party_stack_get_size, ":stack_size","p_main_party"),#,":i_stack"gdw-didn't work
				#(call_script, "script_get_party_troop_count", ":party", "trp_caravan_master"),#see additional script in simp triggr gdw starts at 169
				(try_begin),
					(gt, ":num_troops", 469),#gdw
					(val_add, ":modifier_value", 13),
				(else_try),
					(gt, ":num_troops", 429),#gdw
					(val_add, ":modifier_value", 12),
				(else_try),
					(gt, ":num_troops", 389),#gdw
					(val_add, ":modifier_value", 11),
				(else_try),
					(gt, ":num_troops", 349),#gdw
					(val_add, ":modifier_value", 10),
				(else_try),
					(gt, ":num_troops", 309),#gdw
					(val_add, ":modifier_value", 9),
				(else_try),
					(gt, ":num_troops", 269),#gdw
					(val_add, ":modifier_value", 8),
				(else_try),
					(gt, ":num_troops", 229),#gdw
					(val_add, ":modifier_value", 7),
				(else_try),
					(gt, ":num_troops", 189),#gdw
					(val_add, ":modifier_value", 6),
				(else_try),
					(gt, ":num_troops", 154),#gdw
					(val_add, ":modifier_value", 5),
				(else_try),
					(gt, ":num_troops", 119),#gdw
					(val_add, ":modifier_value", 4),					
				(else_try),
					(gt, ":num_troops", 84),#gdw
					(val_add, ":modifier_value", 3),
				(else_try),
					(gt, ":num_troops", 49),#gdw
					(val_add, ":modifier_value", 2),
				(else_try),
					(gt, ":num_troops", 24),#gdw
					(val_add, ":modifier_value", 1),
				(try_end),
			(else_try),
				(eq, ":skill_no", "skl_tactics"),
				(call_script, "script_get_party_troop_count", ":party", "trp_todos_cuerno"),
				(assign, ":count", reg0),
				(call_script, "script_get_party_troop_count", ":party", "trp_picto_cuerno"),
				(val_add, ":count", reg0),
				(try_begin),
					(gt, ":count", 19),#gdw
					(val_add, ":modifier_value", 3),
				(else_try),
					(gt, ":count", 7),#gdw
					(val_add, ":modifier_value", 2),	
				(else_try),
					(gt, ":count", 0),#gdw
					(val_add, ":modifier_value", 1),
				(try_end),				
			(else_try),
				(eq, ":skill_no", "skl_looting"),
				(call_script, "script_get_party_troop_count", ":party", "trp_slaver_chief"),
				(try_begin),
					(gt, reg0, 7),#gdw 
					(val_add, ":modifier_value", 3),
				(else_try),
					(gt, reg0, 3),#gdw 
					(val_add, ":modifier_value", 2),	
				(else_try),
					(gt, reg0, 0),#gdw 
					(val_add, ":modifier_value", 1),
				(try_end),				
			(else_try),
				(eq, ":skill_no", "skl_foraging"),
				(call_script, "script_get_party_troop_count", ":party", "trp_shepherd"),
				(gt, reg0, 0),
				(try_begin),
					(gt, reg0, 15),#gdw 
					(val_add, ":modifier_value", 3),
				(else_try),
					(gt, reg0, 8),#gdw 
					(val_add, ":modifier_value", 2),	
				(else_try),
					(gt, reg0, 0),#gdw 
					(val_add, ":modifier_value", 1),
				(try_end),					
			(else_try),
				(eq, ":skill_no", "skl_tracking"),
				(call_script, "script_get_party_troop_count", ":party", "trp_cantaber_iuventus"),
				(try_begin),
					(gt, reg0, 17),#gdw 
					(val_add, ":modifier_value", 5),
				(else_try),
					(gt, reg0, 10),#gdw 
					(val_add, ":modifier_value", 4),
				(else_try),
					(gt, reg0, 5),#gdw 
					(val_add, ":modifier_value", 3),	
				(else_try),
					(gt, reg0, 1),#gdw greater than 1
					(val_add, ":modifier_value", 2),
				(try_end),
			(else_try),
				(eq, ":skill_no", "skl_spotting"),
				(call_script, "script_get_party_troop_count", ":party", "trp_merc_spy"),
				#(gt, reg0, 10),#TMLthinks this is bug.gdw agrees
				(try_begin),
					(gt, reg0, 11),#gdw 
					(val_add, ":modifier_value", 3),
				(else_try),
					(gt, reg0, 7),#gdw 
					(val_add, ":modifier_value", 2),
				(else_try),
					(gt, reg0, 3),#gdw 
					(val_add, ":modifier_value", 1),	
				(try_end),	
			(else_try),			
				(eq, ":skill_no", "skl_leadership"),
				(call_script, "script_get_party_troop_count", ":party", "trp_jute_portaestandarte"),#flagbearers
				(assign, ":count_1", reg0),
				(call_script, "script_get_party_troop_count", ":party", "trp_briton_bannerman"),
				(assign, ":count_2", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_saxon_bannerman"),
				(assign, ":count_3", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_picto_portaestandarte"),
				(assign, ":count_4", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_engle_bannerman"),
				(assign, ":count_5", reg0),
				(call_script, "script_get_party_troop_count", ":party", "trp_irish_bannerman"),
				(assign, ":count_6", reg0),
				(assign, ":count", 0),#does this mean only 1pt/culture?
				(val_add, ":count", ":count_1"),
				(val_add, ":count", ":count_2"),		
				(val_add, ":count", ":count_3"),			
				(val_add, ":count", ":count_4"),			
				(val_add, ":count", ":count_5"),			
				(val_add, ":count", ":count_6"),			
				(try_begin),
					(gt, ":count", 17),#gdwraionale:wont need this bonus abovelv25
					(val_add, ":modifier_value", 3),	
				(else_try),		
					(gt, ":count", 11),#gdw
					(val_add, ":modifier_value", 2),	
				(else_try),
					(gt, ":count", 5),#gdw
					(val_add, ":modifier_value", 1),
				(try_end),			
			(else_try),			
				(eq, ":skill_no", "skl_first_aid"),
				(call_script, "script_get_party_troop_count", ":party", "trp_jute_cleric"),
				(assign, ":count_1", reg0),
				(call_script, "script_get_party_troop_count", ":party", "trp_briton_sacerdote"),
				(assign, ":count_2", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_saxon_sacerdote"),
				(assign, ":count_3", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_picto_sacerdote"),
				(assign, ":count_4", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_engle_rxpriest"),
				(assign, ":count_5", reg0),
				(call_script, "script_get_party_troop_count", ":party", "trp_irish_priest"),
				(assign, ":count_6", reg0),
				(assign, ":count", 0),
				(val_add, ":count", ":count_1"),
				(val_add, ":count", ":count_2"),		
				(val_add, ":count", ":count_3"),			
				(val_add, ":count", ":count_4"),			
				(val_add, ":count", ":count_5"),			
				(val_add, ":count", ":count_6"),			
				(try_begin),
					(gt, ":count", 18),#gdwraionale:wont need this bonus abovelv25
					(val_add, ":modifier_value", 3),	
				(else_try),		
					(gt, ":count", 11),#gdwraionale:wont need this bonus abovelv25
					(val_add, ":modifier_value", 2),	
				(else_try),
					(gt, ":count", 5),#gdwraionale:wont need this bonus abovelv25
					(val_add, ":modifier_value", 1),
				(try_end),			
			(else_try),			
				(eq, ":skill_no", "skl_wound_treatment"),
				(call_script, "script_get_party_troop_count", ":party", "trp_pagan_priest"),
				(assign, ":count_1", reg0),
				(call_script, "script_get_party_troop_count", ":party", "trp_fighter_woman"),
				(assign, ":count_2", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_sword_sister"),
				(assign, ":count_3", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_follower_woman"),
				(assign, ":count_4", reg0),				
				(call_script, "script_get_party_troop_count", ":party", "trp_hunter_woman"),
				(assign, ":count_5", reg0),
				(call_script, "script_get_party_troop_count", ":party", "trp_pict_woman"),
				(assign, ":count_6", reg0),
				(assign, ":count", 0),
				(val_add, ":count", ":count_1"),
				(val_add, ":count", ":count_2"),		
				(val_add, ":count", ":count_3"),			
				(val_add, ":count", ":count_4"),			
				(val_add, ":count", ":count_5"),			
				(val_add, ":count", ":count_6"),			
				(try_begin),
					(gt, ":count", 38),#gdwraionale:wont need this bonus abovelv25
					(val_add, ":modifier_value", 3),	
				(else_try),		
					(gt, ":count", 20),#gdw
					(val_add, ":modifier_value", 2),	
				(else_try),
					(gt, ":count", 9),#gdw
					(val_add, ":modifier_value", 1),
				(try_end),			
			(try_end),
      (try_end),
#floris chief acaba
    (set_trigger_result, ":modifier_value"),
    ]),

# Note to modders: Uncomment these if you'd like to use the following.
  
  #script_game_check_party_sees_party
  # This script is called from the game engine when a party is inside the range of another party
  # INPUT: arg1 = party_no_seer, arg2 = party_no_seen
  # OUTPUT: trigger_result = true or false (1 = true, 0 = false)
## Mejor IA chief empieza usamos mejor la de abajo
##  ("game_check_party_sees_party",
##   [
##     (store_script_param, ":party_no_seer", 1),
##     (store_script_param, ":party_no_seen", 2),
##     (assign, ":seen_result", 1),
##     (try_begin),
##       (party_slot_eq, ":party_no_seer", "slot_party_blind_to_other_parties", 1),
##       (this_or_next|party_slot_eq, ":party_no_seer", "slot_party_ai_state", spai_accompanying_army),
##       (party_slot_eq, ":party_no_seer", "slot_party_ai_state", spai_besieging_center),
##       (party_get_slot, ":dest_ai_party", ":party_no_seer", "slot_party_ai_object"),
##       (neq, ":party_no_seen", ":dest_ai_party"),
##       (assign, ":seen_result", 0),
##     (try_end),
##     (set_trigger_result, ":seen_result"),
##    ]),
## mejor IA chief acaba

  	##diplomacy start+ chief
	#Enable script_game_check_party_sees_party to prevent compassionate lords from
	#attacking villagers and merchant caravans.

	#script_game_check_party_sees_party
	# This script is called from the game engine when a party is inside the range of another party
	# INPUT: arg1 = party_no_seer, arg2 = party_no_seen
	# OUTPUT: trigger_result = true or false (1 = true, 0 = false)
		("game_check_party_sees_party",	
		[
		(store_script_param_1, ":party_no_seer"),
		(store_script_param_2, ":party_no_seen"),
		
		(assign, ":trigger_result", 1),
		(assign, ":save_reg0", reg0),
#mejor ai chief		
     (try_begin),
       (party_slot_eq, ":party_no_seer", "slot_party_blind_to_other_parties", 1),
       (this_or_next|party_slot_eq, ":party_no_seer", "slot_party_ai_state", spai_accompanying_army),
       (party_slot_eq, ":party_no_seer", "slot_party_ai_state", spai_besieging_center),
       (party_get_slot, ":dest_ai_party", ":party_no_seer", "slot_party_ai_object"),
       (neq, ":party_no_seen", ":dest_ai_party"),
       (assign, ":trigger_result", 0),
       (else_try),		
#mejor ai chief acaba
		#Lords who dislike raiding caravans should not attack village_farmer or kingdom_caravan
		#parties.  Achieve this by stopping them from seeing them.
		(gt, ":party_no_seer", spawn_points_end),
		(gt, ":party_no_seen", spawn_points_end),
			
			#Only apply this when the "seer" is a kingdom hero party
			(party_slot_eq, ":party_no_seer", "slot_party_type", spt_kingdom_hero_party),
			
			#Only needed if the seen party is of a hostile faction
			(call_script, "script_get_relation_between_parties", ":party_no_seer", ":party_no_seen"),
			(lt, reg0, 0),
			
			#Only apply this when the seen party is a merchant caravan or villagers
			#(party_get_template_id, ":template", ":party_no_seen"),
			(this_or_next|party_slot_eq, ":party_no_seen", "slot_party_type", spt_kingdom_caravan),
			(this_or_next|party_slot_eq,":party_no_seen", "slot_party_type", dplmc_spt_gift_caravan),#custom diplomacy caravan
				(party_slot_eq, ":party_no_seen", "slot_party_type", spt_village_farmer),
				
			#Never apply this when the seen party is engaging in hostile actions
			(party_get_battle_opponent, reg0, ":party_no_seen"),
			(lt, reg0, 0),
			(neg|party_slot_eq, ":party_no_seen", "slot_party_ai_state", spai_besieging_center),
			(neg|party_slot_eq, ":party_no_seen", "slot_party_ai_state", spai_raiding_around_center),
			(neg|party_slot_eq, ":party_no_seen", "slot_party_ai_state", spai_engaging_army),
			(neg|party_slot_eq, ":party_no_seen", "slot_party_ai_state", spai_accompanying_army),
			(neg|party_slot_eq, ":party_no_seen", "slot_party_ai_state", spai_screening_army),
			
			
			#Only apply this when the leader is tmt_humanitarian, lrep_benefactor, or lrep_moralist
			(party_get_num_companion_stacks, ":num_stacks", ":party_no_seer"),
			(ge, ":num_stacks", 1),
			(party_stack_get_troop_id, ":leader", ":party_no_seer", 0),
			(ge, ":leader", 1),
			(troop_is_hero, ":leader"),
			(call_script, "script_dplmc_get_troop_morality_value", ":leader", tmt_humanitarian),
			(ge, reg0, 0),# (never apply for leaders who like raiding caravans and attacking villagers)
			(this_or_next|ge, reg0, 1),
			(this_or_next|troop_slot_eq, ":leader", "slot_lord_reputation_type", lrep_benefactor),
				(troop_slot_eq, ":leader", "slot_lord_reputation_type", lrep_moralist),
			(assign, ":trigger_result", 0),
		(try_end),
		
		(assign, reg0, ":save_reg0"),
		(set_trigger_result, ":trigger_result"),
		]),
	##diplomacy end+


#TEMPERED chief UNCOMMENTED AND CHANGED TO ADJUST SPEED OF VARIOUS PARTIES
  #script_game_get_party_speed_multiplier
  # This script is called from the game engine when a skill's modifiers are needed
  # INPUT: arg1 = party_no
  # OUTPUT: trigger_result = multiplier (scaled by 100, meaning that giving 100 as the trigger result does not change the party speed)
 ("game_get_party_speed_multiplier",
	[
    (store_script_param_1, ":party_no"),
    (assign,":speed_multiplier",100),
  ###larger speed multiplier is faster. use add subtract and debugging
   (party_get_template_id,":party_template",":party_no"),
   (try_begin),
     (eq,":party_template","pt_player_loot_wagon"),
      (val_sub,":speed_multiplier", 4),#gdw wagon partry separate from main. give boost due to danger and given extra horse
   (else_try),
     (eq,":party_template","pt_kingdom_caravan_party"),
      (val_add,":speed_multiplier", 20),#gdw20quest carav too slow
   (else_try),
     (eq,":party_template","pt_merchant_caravan"),
      (val_add,":speed_multiplier", 11),#gdw20quest carav too slow
    (else_try),
     (eq,":party_template","pt_oim_merchant_caravan2"),
      (val_add,":speed_multiplier", 33),#gdw20quest carav too slow
   (else_try),
     # (this_or_next|eq,":party_template","pt_neko"),
     # (this_or_next|eq,":party_template","pt_eadfrith"),
     # (this_or_next|eq,":party_template","pt_arrians"),
     # (this_or_next|eq,":party_template","pt_iniau"),
     # (this_or_next|eq,":party_template","pt_zamoshie_bandits"),
     (eq,":party_template","pt_skirmish_party"),
     (val_add,":speed_multiplier", 29),
   (else_try),
    (eq,":party_template","pt_personal_messenger"),
                    (val_add,":speed_multiplier", 70),
   (else_try), #anadido chief mas abajo para limitar velocidad de barcos ships
    (eq,":party_template","pt_sea_raiders_ships"),
                    (val_sub,":speed_multiplier", 50),
   (else_try),
    (eq,":party_template","pt_sea_raiders_ships2"),
                    (val_sub,":speed_multiplier", 50),
   (else_try),
    (eq,":party_template","pt_sea_raiders_ships3"),
                    (val_sub,":speed_multiplier", 50),
   (else_try), #anadido chief mas abajo para limitar velocidad de dena
    (eq,":party_template","pt_sea_raiders2"),
                    (val_sub,":speed_multiplier", 20),#gdw10armortoofast
   (else_try), #anadido chief mas abajo para limitar velocidad de franks.
    (eq,":party_template","pt_sea_raiders"),
                    (val_sub,":speed_multiplier", 25),#gdw10armortoofast
   (else_try), #anadido chief mas abajo para limitar velocidad de franks.
    (eq,":party_template","pt_village_farmers"),
                    (val_sub,":speed_multiplier", 25),#gdw10armortoofast
   (try_end),
   # (try_begin),
   #  (neq,":party_no","p_main_party"),
   #  (party_slot_eq, ":party_no", "slot_party_type", spt_kingdom_hero_party),
   #  (party_get_skill_level, ":pathfinding_skill", ":party_no", skl_pathfinding),
   #  #(party_get_skill_level, ":riding_skill", ":party_no", skl_riding),
   #  (assign, reg7, ":pathfinding_skill"),
   #  (val_mul,":pathfinding_skill",3),
   #  #(val_add, ":riding_skill", 3),
   #  # (party_get_skill_level, ":riding_skill", ":party_no", skl_riding)
   #  (val_add,":speed_multiplier",":pathfinding_skill"),
   #  #(assign, reg8,  ":pathfspeed"),
   #  (assign, reg8, ":speed_multiplier"),
   #  (try_begin),
   #   (gt, "$cheat_mode", 0),
   #   (display_message, "@{!}DEBUG -- Heropartypathfinding: {reg7}"), 
   #   (display_message, "@{!}DEBUG -- Heropathfinding speedmultiplier: {reg8}"),     
   #  (try_end),
   # (try_end),
   (try_begin),
     (neq,":party_no","p_main_party"),
     (val_clamp, ":speed_multiplier", 39,174),
     (assign,reg0,":speed_multiplier"),
     (set_trigger_result, reg0),
    #  (try_begin),
    #    (gt, "$cheat_mode", 0),
    #    (display_message, "@{!}DEBUG -- others final speed multiplier: {reg0}"),     
    # (try_end),
  (try_end),
   
################################################gdw new
  (assign, ":party_speed_multiplier", 100),
  (try_begin),
    (eq,":party_no","p_main_party"),
    (party_get_skill_level, ":pathfinding_skill", ":party_no", skl_pathfinding),
    (party_get_skill_level, ":riding_skill", ":party_no", skl_riding),
    
    #(assign, reg7, ":pathfinding_skill"),
    (val_mul,":pathfinding_skill",3),
    (val_mul, ":riding_skill", 4),
    (val_div, ":riding_skill", 3),
    # (party_get_skill_level, ":riding_skill", ":party_no", skl_riding)
    (val_add,":party_speed_multiplier",":pathfinding_skill"),
    (val_add,":party_speed_multiplier",":riding_skill"),
    #(val_max, ":party_speed_multiplier", 0),
    (assign, reg9, ":party_speed_multiplier"),
     (try_begin),
     (gt, "$cheat_mode", 2),
    # (display_message, "@{!}DEBUG -- partypathfinding: {reg7}"), 
     (display_message, "@{!}DEBUG -- Urpathfindingriding speedmultiplier: {reg9}"),     
    (try_end),
    (try_begin),
      (store_num_regular_prisoners,reg0),
      (try_begin),
         (gt, "$cheat_mode",2),
         (display_message, "@{!}DEBUG -- prisoners: {reg0}"),
      (try_end),
      (gt,reg0,1),
      (assign,reg3, reg0),
      (val_mul, reg3, 3),
      #(val_div, reg3,2),
      (party_get_skill_level, ":prisonerskill", ":party_no", skl_prisoner_management),
      (val_mul,":prisonerskill",2),
      #(val_div,":prisonerskill",3),
      (val_max,":prisonerskill",1),
      (val_div, reg3,":prisonerskill"),
      (val_sub, reg9,reg3),
      (try_begin),
         (gt, "$cheat_mode", 2),
         (display_message, "@{!}DEBUG -- prisonerpenalty: {reg3}"),
         (display_message, "@{!}DEBUG -speed with prisoners {reg9}"), 
      (try_end),
     (try_end),
    (try_end),

    # (try_begin),
    #   (eq,":party_no","p_main_party"),
    #  (call_script, "script_get_inventory_weight_of_whole_party"),###gdw this reduced by having loot wagon
    #  (assign, reg1, reg0),##reg0 gets inherited from script inventory
    #  (try_begin),
    #    (gt, "$cheat_mode", 0),
    #    (display_message, "@{!}DEBUG -- :weight2: {reg1}"), 
    #  (try_end),
    #  (val_div, reg1, 100),
    #  (val_clamp, reg1, 1,70),
    #  (try_begin),
    #    (gt, "$cheat_mode", 0),
    #    (display_message, "@{!}DEBUG -- :weight2/100 {reg1}"), 
    #  (try_end),
    #  (val_sub, reg9, reg1),
    #  (try_begin),
    #    (gt, "$cheat_mode", 0),
    #    (display_message, "@{!}DEBUG -- partyspeed-wt {reg9}"), 
    #  (try_end),
    #  (val_clamp, reg9, 22,175),
    #  # (assign, reg10,":party_speed_multiplier"),
    #   (try_begin),
    #    (gt, "$cheat_mode", 0),
    #    (display_message, "@{!}DEBUG -- new weight speedmultipliervalclamp: {reg9}"),     
    #   (try_end),
    #   (try_begin),
    #    (gt,"$wagon_attached",0),
    #    (val_sub,reg9, 20),#gdw this is when your wagon is on a trade run
    #    (try_begin),
    #     (gt, "$cheat_mode", 0),
    #     (display_message, "@{!}DEBUG --party speed with wagon {reg9}"),     
    #   (try_end),
    #  (try_end),
    # (try_end),
   (try_begin),
    (eq,":party_no","p_main_party"),
    (try_begin),
      (eq,"$g_move_fast", 3),
      (val_add,reg9,200),
      (assign,"$g_move_fast", 0),
    (else_try),
      (eq,"$g_move_fast", 2),
      (val_add,reg9,200),
      (assign,"$g_move_fast", 3),
    (else_try),
      (eq,"$g_move_fast", 1),
      (val_add,reg9,200),
      (assign,"$g_move_fast", 2),
    (else_try),
      (eq,"$g_move_slow", 1),
      (val_sub,reg9,77),
      (try_begin),
       (ge, "$cheat_mode", 1),
       (display_message, "@{!}DEBUG g_move_slow {reg9}"), 
      (try_end),
      (assign,"$g_move_slow", 0),
    (else_try),
       (eq,"$sneaking_set_by_player",1),
       (val_sub,reg9,35),
    (try_end),
    (try_begin),
      (ge, "$cheat_mode", 2),
      (display_message, "@{!}DEBUG --party speed after special cases {reg9}"),     
    (try_end),   
   (try_end),
   
   (try_begin),
     (eq,":party_no","p_main_party"),
     (try_begin),
         (gt, "$cheat_mode", 2),
         (display_message, "@{!}DEBUG -- speed preclamp: {reg9}"),     
     (try_end),
     (val_clamp, reg9, 9,200),
     (assign,reg0, reg9),
     (set_trigger_result, reg0),
     (try_begin),
      (ge, "$cheat_mode", 2),
      (display_message, "@{!}DEBUG -- final triggered party speed multiplier: {reg0}"),
     (try_end),
   (try_end),
 ]),
# item_get_weight
 ("get_inventory_weight_of_whole_party",
   [
    (assign, ":total_weight", 0),
	
    (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
    (try_for_range, ":i_stack", 0, ":num_stacks"),
      (party_stack_get_troop_id,":stack_troop","p_main_party",":i_stack"),
      (this_or_next|is_between, ":stack_troop", companions_begin, companions_end),
      #(is_between, ":stack_troop", companions_begin, companions_end),
      (eq,":stack_troop","trp_player"),
      (troop_get_inventory_capacity, ":inv_cap", ":stack_troop"),
      (try_for_range, ":cur_slot", 10, ":inv_cap"),#inventory slots
        (troop_get_inventory_slot, ":cur_item", ":stack_troop", ":cur_slot"),
        (ge, ":cur_item", 0),
        (item_get_weight, ":cur_item_weight", ":cur_item"),
        #(item_get_slot, ":cur_item_weight", ":cur_item", "slot_item_weight"),
        (val_add, ":total_weight", ":cur_item_weight"),
        #assign, reg3, ":total_weight"),
      #(try_end),
        
       #  (try_begin),#gdw to compensate for slower wagon
       #    (party_get_slot,":loot_wagon","p_main_party","slot_party_loot_wagon"),
       #    (gt,"$wagon_attached",0),
      	# #(eq,":loot_wagon"),
       #    (val_mul, ":total_weight", 4),#gdw
      	#  (val_div, ":total_weight", 5),
       #  (try_end),
      (try_end),
    (try_end),
    (assign, reg0, ":total_weight"),
    (set_trigger_result, reg0),
    #(val_div, ":total_weight", 10),
    #(assign, reg0, ":total_weight"),
    (try_begin),
      (gt, "$cheat_mode", 0),
      #(display_message, "@{!}DEBUG -- actual weight before div20: {reg3}"),
      (display_message, "@{!}DEBUG -- final PARTY weight {reg0}"),   
    (try_end),
  ]), 
  # script_npc_get_troop_wage
  # This script is called from module system to calculate troop wages for npc parties.
  # Input:
  # param1: troop_id
  # Output: reg0: weekly wage
  
  ("npc_get_troop_wage",
    [
      (store_script_param_1, ":troop_id"),
      (assign,":wage", 0),
      (try_begin),
        (troop_is_hero, ":troop_id"),
      (else_try),
      ## CC chief
        (store_character_level, ":troop_level", ":troop_id"),
        (assign, ":wage", ":troop_level"),
        (val_add, ":wage", 3),
        (val_mul, ":wage", ":wage"),
        (val_div, ":wage", 22),#gdw was at 25
      ## CC
        (troop_is_mounted, ":troop_id"),
        (val_mul, ":wage", 5),
        (val_div, ":wage", 3),
      (try_end),
      (assign, reg0, ":wage"),
  ]),

  #script_setup_talk_info
  # INPUT: $g_talk_troop, $g_talk_troop_relation
  ("setup_talk_info",
    [
      (talk_info_set_relation_bar, "$g_talk_troop_relation"),
      (str_store_troop_name, s61, "$g_talk_troop"),
      (str_store_string, s61, "@{!} {s61}"),
      (assign, reg1, "$g_talk_troop_relation"),
      (str_store_string, s62, "str_relation_reg1"),
      (talk_info_set_line, 0, s61),
      (talk_info_set_line, 1, s62),
      (call_script, "script_describe_relation_to_s63", "$g_talk_troop_relation"),
      (talk_info_set_line, 3, s63),
  ]),

## CC chief commander cambiado entero para mas datos de companeros
#NPC companion changes begin
  #script_setup_talk_info_companions
  ("setup_talk_info_companions",
    [
      (call_script, "script_npc_morale", "$g_talk_troop"),
      (assign, ":troop_morale", reg0),
  
      (talk_info_set_relation_bar, ":troop_morale"),
  
      (str_store_troop_name, s61, "$g_talk_troop"),
      (assign, reg1, ":troop_morale"),
      (str_store_string, s62, "str_morale_reg1"),
      (str_store_string, s61, "@ {s61}({s62})"),
      
      (troop_get_slot, reg1, "$g_talk_troop", "slot_troop_kill_count"),
      (str_store_string, s11, "str_number_of_troops_killed_reg1"),
      (troop_get_slot, reg1, "$g_talk_troop", "slot_troop_wound_count"),
      (str_store_string, s12, "str_number_of_troops_wounded_reg1"),
      
      (talk_info_set_line, 0, s61),
      (talk_info_set_line, 1, s11),
      (talk_info_set_line, 2, s12),
      (talk_info_set_line, 3, s63),
  ]),
#NPC companion changes end
## CC

  #script_update_party_creation_random_limits
  # INPUT: none
  ("update_party_creation_random_limits",
    [
      (store_character_level, ":player_level", "trp_player"),
      (store_mul, ":upper_limit", ":player_level", 3),
      (val_add, ":upper_limit", 25),
      (val_min, ":upper_limit", 100),
      (set_party_creation_random_limits, 0, ":upper_limit"),
      (assign, reg0, ":upper_limit"),
  ]),

  #script_set_trade_route_between_centers
  # INPUT:
  # param1: center_no_1
  # param1: center_no_2
  ("set_trade_route_between_centers",
    [(store_script_param, ":center_no_1", 1),
     (store_script_param, ":center_no_2", 2),
     (assign, ":center_1_added", 0),
     (assign, ":center_2_added", 0),
     (try_for_range, ":cur_slot", "slot_town_trade_routes_begin", "slot_town_trade_routes_end"),
       (try_begin),
         (eq, ":center_1_added", 0),
         (party_slot_eq, ":center_no_1", ":cur_slot", 0),
         (party_set_slot, ":center_no_1", ":cur_slot", ":center_no_2"),
         (assign, ":center_1_added", 1),
       (try_end),
       (try_begin),
         (eq, ":center_2_added", 0),
         (party_slot_eq, ":center_no_2", ":cur_slot", 0),
         (party_set_slot, ":center_no_2", ":cur_slot", ":center_no_1"),
         (assign, ":center_2_added", 1),
       (try_end),
     (try_end),
     (try_begin),
       (eq, ":center_1_added", 0),
       (str_store_party_name, s1, ":center_no_1"),
       (display_message, "@{!}DEBUG -- ERROR: More than 15 trade routes are given for {s1}."),
     (try_end),
     (try_begin),
       (eq, ":center_2_added", 0),
       (str_store_party_name, s1, ":center_no_2"),
       (display_message, "@{!}DEBUG -- ERROR: More than 15 trade routes are given for {s1}."),
     (try_end),
     ]),

  #script_party_calculate_regular_strength:
  # INPUT:
  # param1: Party-id
  ("party_calculate_regular_strength",
    [
      (store_script_param_1, ":party"), #Party_id
      
      (assign, reg0,0),
      (party_get_num_companion_stacks, ":num_stacks",":party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", ":party", ":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (store_character_level, ":stack_strength", ":stack_troop"),
#TEMPERED# chief  ADD BONUS FOR MOUNTED TROOPS
			(try_begin),
				(troop_is_mounted, ":stack_troop"),
				(val_add, ":stack_strength", 5),
			(try_end),
#TEMPERED#    ADD BONUS FOR HIGH LEVEL TROOPS
			(store_div,":strength_bonus",":stack_strength",4),
			(val_add, ":stack_strength",":strength_bonus"),
#TEMPERED#    BONUSES END 		
        (val_add, ":stack_strength", 12),
        (val_mul, ":stack_strength", ":stack_strength"),
        (val_div, ":stack_strength", 100),
        (party_stack_get_size, ":stack_size",":party",":i_stack"),
        (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
        (val_sub, ":stack_size", ":num_wounded"),
        (val_mul, ":stack_strength", ":stack_size"),
        (val_add,reg0, ":stack_strength"),
      (try_end),
  ]),
  
  
  
  
  #script_party_calculate_strength:
  # INPUT: arg1 = party_id, arg2 = exclude leader
  # OUTPUT: reg0 = strength
  
  ("party_calculate_strength",
    [
      (store_script_param_1, ":party"), #Party_id
      (store_script_param_2, ":exclude_leader"), #Party_id
      
      (assign, reg0,0),
      (party_get_num_companion_stacks, ":num_stacks", ":party"),
      (assign, ":first_stack", 0),
#TEMPERED chief CAMP ENTRENCH CHANGES BEGIN
	  (assign,":entrench",0),
	  (try_begin),
		(eq,":party","p_main_party"),
        (party_get_slot,":entrench","p_main_party","slot_party_entrenched"),
	  (try_end),
#TEMPERED CHANGES END      

      (try_begin),
        (neq, ":exclude_leader", 0),
        (assign, ":first_stack", 1),
      (try_end),
      (try_for_range, ":i_stack", ":first_stack", ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party", ":i_stack"),
        (store_character_level, ":stack_strength", ":stack_troop"),
#TEMPERED# chief ADDED BONUS FOR HEROES, BONUSES ARE FOR MORE REALISTIC AUTOCALC BATTLE RESULTS
			(try_begin),
				(troop_is_hero, ":stack_troop"),
				(val_add, ":stack_strength", 2),
			(try_end),			
#TEMPERED#   ADD BONUS FOR MOUNTED TROOPS
			(try_begin),
				(troop_is_mounted, ":stack_troop"),
				(val_add, ":stack_strength", 4),#gdw 5
			(try_end),
#TEMPERED#    ADD BONUS FOR HIGH LEVEL TROOPS
			(store_div,":strength_bonus",":stack_strength",4),
			(val_add, ":stack_strength",":strength_bonus"),
#TEMPERED    ADDED BONUS FOR ENTRENCHMENT
			(try_begin),
				(eq,":entrench",1),
				(val_add,":stack_strength",2),
			(try_end),
#TEMPERED#    BONUSES END 		
        (val_add, ":stack_strength", 4), #new was 12 (patch 1.125)
        (val_mul, ":stack_strength", ":stack_strength"),
        (val_mul, ":stack_strength", 2), #new (patch 1.125)
        (val_div, ":stack_strength", 100),
        (val_max, ":stack_strength", 1), #new (patch 1.125)
#influencia terreno en batallas simuladas chief############
      ##AotE chief terrain advantages
      (party_get_current_terrain, ":terrain_type", ":party"),
      (try_begin),
        (eq, ":terrain_type", rt_steppe),
        (troop_is_guarantee_horse, ":stack_troop"),
        (val_mul, ":stack_strength", 1.5),
      (else_try),
        (eq, ":terrain_type", rt_plain),
        (troop_is_guarantee_horse, ":stack_troop"),
        (val_mul, ":stack_strength", 1.1),
      (else_try),
        (eq, ":terrain_type", rt_snow),
#        (try_for_range,":items","itm_zrak_wildman_chest","itm_zrak_berserker_chest"),
#          (troop_has_item_equipped,":stack_troop",":items"),
#          (val_mul, ":stack_strength", 1.4),
#        (try_end),
#        (try_for_range,":items","itm_vaegir_woodcutter_coat","itm_vaegir_woodcutter_helmet"),
#          (troop_has_item_equipped,":stack_troop",":items"),
#          (val_mul, ":stack_strength", 1.5),
#        (try_end),
        (val_mul, ":stack_strength", 0.95),
      (else_try),
        (eq, ":terrain_type", rt_desert),
#        (try_for_range,":items","itm_kabiel_villager_chest","itm_kabiel_villager_helmet"),
#          (troop_is_guarantee_horse, ":stack_troop"),
#          (troop_has_item_equipped,":stack_troop",":items"),
#          (val_mul, ":stack_strength", 1.8 ),
#        (else_try),
#          (troop_is_guarantee_horse, ":stack_troop"),
#          (val_mul, ":stack_strength", 1.4),
#        (try_end),
        (val_mul, ":stack_strength", 0.95),
      (else_try),
        (eq, ":terrain_type", rt_steppe_forest),
        (troop_is_guarantee_horse, ":stack_troop"),
        (val_mul, ":stack_strength", 1.2),
      (else_try),
        (eq, ":terrain_type", rt_forest),
        (neg|troop_is_guarantee_horse, ":stack_troop"),
        (neg|troop_is_guarantee_ranged, ":stack_troop"),
        (val_mul, ":stack_strength", 1.2),
      (else_try),
        (eq, ":terrain_type", rt_snow_forest),
#        (try_for_range,":items","itm_zrak_wildman_chest","itm_zrak_berserker_chest"),
#          (troop_has_item_equipped,":stack_troop",":items"),
#          (val_mul, ":stack_strength", 1.2),
#        (try_end),
#        (try_for_range,":items","itm_vaegir_woodcutter_coat","itm_vaegir_woodcutter_helmet"),
#          (troop_has_item_equipped,":stack_troop",":items"),
#          (val_mul, ":stack_strength", 1.2),
#        (try_end),
        (neg|troop_is_guarantee_horse, ":stack_troop"),
        (neg|troop_is_guarantee_ranged, ":stack_troop"),
        (val_mul, ":stack_strength", 1.2),
      (try_end),
##AotE chief terrain advantages acaba############

        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size",":party",":i_stack"),
          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),                    
          (val_sub, ":stack_size", ":num_wounded"),
          (val_mul, ":stack_strength", ":stack_size"),
        (else_try),
          (troop_is_wounded, ":stack_troop"), #hero & wounded
          (assign, ":stack_strength", 0),
        (try_end),
        (val_add, reg0, ":stack_strength"),
      (try_end),
      (party_set_slot, ":party", "slot_party_cached_strength", reg0),
  ]),


  #script_loot_player_items:
  # INPUT: arg1 = enemy_party_no
  # Output: none
  ("loot_player_items",
    [
      (store_script_param, ":enemy_party_no", 1),
	  ##diplomacy start+ some enemy lords will not loot the personal equipment of a player who surrendered chief
	  (assign, ":save_reg0", reg0),
	  (assign, ":extra_gold", 0),
	  #I am not sure if this is historical or not, but it gives the player a reason to
	  #surrender (rather than fight to the end) even before permanent attribute loss is
	  #a possibility (or even if it is disabled outright).
	  #
	  #This also adds another layer of interaction, and makes different lords feel
	  #different from each other.
	  #
	  #Other changes:
	  # Enemy lords will receive gold they loot from the player,
	  # Books will not be looted from the player (it turns out a bug was responsible for this being possible)
	  # The enemy leader's looting skill will affect the amount of gold lootable.
	  (assign, ":merciful", 0),
	  (assign, ":party_leader", -1),
	  (options_get_campaign_ai, ":reduce_campaign_ai"),
	  (try_begin),
 	    (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#only use this if it is explicitly enabled
	    #Possibility the player's personal equipment will be untouched if he surrendered
  	    (ge, "$g_player_surrenders", 1),
   	    (gt, ":enemy_party_no", 0),
		(party_stack_get_troop_id, ":party_leader", ":enemy_party_no", 0),		
	    (party_slot_eq, ":enemy_party_no", "slot_party_type", spt_kingdom_hero_party),
		(is_between, ":party_leader", heroes_begin, heroes_end),
		(troop_is_hero, ":party_leader"),
		(call_script, "script_troop_get_player_relation", ":party_leader"),
		(assign, ":relation", reg0),
		(assign, ":probability_modifier", 0),
		(try_begin),
			#Upstanding lords are inclined to honor deals in general, and will automatically
			#do so with honorable lords they do not extremely dislike.  However, this does not
			#extend to commoners.
			(troop_slot_ge, "trp_player", "slot_troop_banner_scene_prop", 1),# the player has a coat of arms
			(troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_upstanding),
			(val_max, ":probability_modifier", 10),#set to +10 unless already higher
			#They will automatically honor deals with the honorable, if they do not
			#excessively dislike them.
			(ge, "$player_honor", 1),
			(val_add, reg0, 10),
			(val_clamp, reg0, 11, 21),
			(val_max, ":probability_modifier", reg0),#set somewhere from +11 to +20 unless already higher
			(ge, ":relation", -10),
			(assign, ":merciful", 1),
		(else_try),
			#Martial lords are inclined to honor deals with lords who likewise follow the rules of war,
			#and will do so as long as they are neutral or friendly towards them.  This does not extend
			#to commoners.
			(troop_slot_ge, "trp_player", "slot_troop_banner_scene_prop", 1),# the player has a coat of arms
			(this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_moralist),
			(troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_martial),
			(ge, "$player_honor", 1),
			(assign, reg0, "$player_honor"),
			(val_clamp, reg0, 1, 6),
			(val_max, ":probability_modifier", reg0),#set somewhere from +1 to +5 unless already higher
			(ge, ":relation", 0),
			(assign, ":merciful", 1),
		(else_try),
			#Good-natured lords are inclined to honor deals with everyone, commoner or not.
			#They will do so automatically unless they particularly dislike someone.
			#This also goes for Moralist ladies if they someone end up accepting your surrender.
			(this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_goodnatured),
			(troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_moralist),
			(val_max, ":probability_modifier", 21),#set to +20 unless already higher
			(ge, ":relation", -10),
			(assign, ":merciful", 1),
		(else_try),
			#Honest lords are inclined honor deals with everyone, commoner or not.
			#They will do so automatically unless they particularly dislike someone.
			(call_script, "script_dplmc_get_troop_morality_value", ":party_leader", tmt_honest),
			(assign, ":honest_val", reg0),
			(ge, ":honest_val", 1),
			(store_add, reg0, ":honest_val", 14),
			(val_max, ":probability_modifier", reg0),#set to (14 + honesty ) unless already higher
			(ge, "$player_honor", 1),
			(val_mul, reg0, -1),
			(ge, ":relation", reg0),
			(assign, ":merciful", 1),
		(else_try),
			(try_begin),
				#Penalty instead of bonus for vicious lord personalities, unless they are
				#explicitly set as honest.  (None are by default.)
				(lt, ":honest_val", 1),#Must either be negative or not given
				(this_or_next|lt, ":honest_val", 0),
				(this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_debauched),
				(this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_selfrighteous),
				(this_or_next|troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_cunning),
				(troop_slot_eq, ":party_leader", "slot_lord_reputation_type", lrep_quarrelsome),
				(val_min, ":probability_modifier", -10),#set to -10 unless already lower
			(try_end),
			#Now store into reg0 the percent chance of mercy
			(try_begin),
				(le, ":reduce_campaign_ai", 0),#Hard: base chance 25% + relation
				(store_add, reg0, ":relation", 25),
			(else_try),
				(eq, ":reduce_campaign_ai", 1),#Medium: base chance 50% + relation
				(store_add, reg0, ":relation", 50),
			(else_try),
				(ge, ":reduce_campaign_ai", 2),#Easy: base chance 75% + relation
				(store_add, reg0, ":relation", 75),
			(try_end),
			(val_add, reg0, ":probability_modifier"),#modify the chance based on the captor's personality
			(val_max, reg0, ":probability_modifier"),#at least this much of a chance
			(val_max, reg0, 5),#at least a 5% chance
			(store_random_in_range, ":probability_modifier", 1, 101),
			(lt, reg0, ":probability_modifier"),
			(assign, ":merciful", 1),
		(try_end),
	  (else_try),
  	    (ge, "$g_dplmc_gold_changes", 1),#only use this if it is explicitly enabled
		#Surrendered to a non-hero party
		(gt, ":enemy_party_no", 0),
		(ge, "$g_player_surrenders", 1),
		(store_random_in_range, reg0, 1, 101),
		(this_or_next|lt, reg0, 20),#Hard: 25% chance#gdw
			(ge, ":reduce_campaign_ai", 1),
		(this_or_next|lt, reg0, 50),#Medium: 50% chance#gdw
			(ge, ":reduce_campaign_ai", 2),
		(lt, reg0, 85),#Easy: 75% chance#gdw
		(assign, ":merciful", 1),
	  (try_end),
	  (try_begin),
		(ge, "$cheat_mode", 1),
		(assign, ":save_reg1", reg1),
		(assign, reg0, "$g_player_surrenders"),
		(assign, reg1, ":merciful"),
		(display_message, "@{!} DEBUG loot_player_items: g_player_surrenders = {reg0}, merciful = {reg1}"),
        (assign, reg1, ":save_reg1"),
	  (try_end),
	  ##diplomacy end+
      (troop_get_inventory_capacity, ":inv_cap", "trp_player"),
      (try_for_range, ":i_slot", 0, ":inv_cap"),
        (troop_get_inventory_slot, ":item_id", "trp_player", ":i_slot"),
        (ge, ":item_id", 0),
		##diplomacy start+ looting changes
		(neg|is_between, ":item_id", books_begin, books_end),#shouldn't be necessary, but just in case
		(assign, ":randomness", 0),#properly initialize variables
		##diplomacy end+
        (troop_get_inventory_slot_modifier, ":item_modifier", "trp_player", ":i_slot"),
        (try_begin),
          (is_between, ":item_id", trade_goods_begin, trade_goods_end),
          (assign, ":randomness", 20),
        (else_try),
          (this_or_next|is_between, ":item_id", horses_begin, horses_end),
          (this_or_next|eq, ":item_id", "itm_horsecourser1"),
          (eq, ":item_id", "itm_fastwarhorset3"),
          (assign, ":randomness", 15),
        (else_try),
          (this_or_next|is_between, ":item_id", weapons_begin, weapons_end),
          (is_between, ":item_id", ranged_weapons_begin, ranged_weapons_end),
          (assign, ":randomness", 5),
        (else_try),
          (this_or_next|is_between, ":item_id", armors_begin, armors_end),
		  (this_or_next|eq, ":item_id", "itm_sledgehammer"), #added to the end because of not breaking the save games
          (is_between, ":item_id", shields_begin, shields_end),
          (assign, ":randomness", 5),
        (try_end),
        (store_random_in_range, ":random_no", 0, 100),
        (lt, ":random_no", ":randomness"),
		##diplomacy start+ changes
		(try_begin),
			#If this option is enabled, personal items may be spared, and instead
			#sligthly more gold is taken (but not as much as the thing's worth).
			(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
			(ge, ":merciful", 1),
			(is_between, ":i_slot", ek_item_0, ek_horse + 1),
			(assign, ":random_no", 101),
			(store_item_value, reg0, ":item_id"),#don't bother with imods
			(val_div, reg0, 2),
			(ge, reg0, 1),
			#(val_add, ":extra_gold", reg0),##disable, as it defeats the point!
		(try_end),
		(lt, ":random_no", ":randomness"),
		##diplomacy end+
        (troop_remove_item, "trp_player", ":item_id"),

        (try_begin),
          (gt, ":enemy_party_no", 0),
          (party_get_slot, ":cur_loot_slot", ":enemy_party_no", "slot_party_next_looted_item_slot"),
          (val_add, ":cur_loot_slot", "slot_party_looted_item_1"),
          (party_set_slot, ":enemy_party_no", ":cur_loot_slot", ":item_id"),
          (val_sub, ":cur_loot_slot", "slot_party_looted_item_1"),
          (val_add, ":cur_loot_slot", "slot_party_looted_item_1_modifier"),
          (party_set_slot, ":enemy_party_no", ":cur_loot_slot", ":item_modifier"),
          (val_sub, ":cur_loot_slot", "slot_party_looted_item_1_modifier"),
          (val_add, ":cur_loot_slot", 1),
          (val_mod, ":cur_loot_slot", num_party_loot_slots),
          (party_set_slot, ":enemy_party_no", "slot_party_next_looted_item_slot", ":cur_loot_slot"),
        (try_end),
      (try_end),
      (store_troop_gold, ":cur_gold", "trp_player"),
      (store_div, ":max_lost", ":cur_gold", 4),
      (store_div, ":min_lost", ":cur_gold", 10),
      (store_random_in_range, ":lost_gold", ":min_lost", ":max_lost"),
	  ##diplomacy start+
	  (try_begin),
		#This does nothing unless the option is enabled.
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		#add extra gold from enemy's looting skill
		(gt, ":enemy_party_no", 0),
		(party_get_skill_level, reg0, ":enemy_party_no", "skl_looting"),
		(val_clamp, reg0, 0, 11),#allow range +0 to +10
		(val_add, reg0, 10),
		(val_mul, ":lost_gold", reg0),
		(val_div, ":lost_gold", 10),
		#Add any gold from items not looted.
		(val_add, ":lost_gold", ":extra_gold"),
		#gold looted can't exceed player's actual gold
		(val_min, ":lost_gold", ":cur_gold"),
		(val_max, ":lost_gold", 0),
      (try_end),
	  #diplomacy end+
      (troop_remove_gold, "trp_player", ":lost_gold"),
	  ##diplomacy start+
	  (try_begin),
	    #add looted gold to the enemy, if he's a valid hero
		(is_between, ":party_leader", heroes_begin, heroes_end),
		(troop_is_hero, ":party_leader"),
		(neq, ":party_leader", "trp_player"),
		(neq, ":party_leader", "trp_kingdom_heroes_including_player_begin"),
		(ge, ":lost_gold", 1),
		#(call_script, "script_troop_add_gold", ":party_leader", ":lost_gold"),#add looted gold to enemy
		(troop_get_slot, reg0, ":party_leader", "slot_troop_wealth"),
		(val_add, reg0, ":lost_gold"),
		(val_max, reg0, 0),
		(troop_set_slot, ":party_leader", "slot_troop_wealth", reg0),#add looted gold to enemy
	  (try_end),
	  (assign, reg0, ":save_reg0"),#revert register
	  ##diplomacy end+
      ]),

  
  #script_party_calculate_loot:
  # INPUT:
  # param1: Party-id
 # Returns num looted items in reg0
  ("party_calculate_loot",
    [
      (store_script_param_1, ":enemy_party"), #Enemy Party_id
            
      (call_script, "script_calculate_main_party_shares"),
      (assign, ":num_player_party_shares", reg0),
      
      (try_for_range, ":i_loot", 0, num_party_loot_slots),
        (store_add, ":cur_loot_slot", ":i_loot", "slot_party_looted_item_1"),
        (party_get_slot, ":item_no", "$g_enemy_party", ":cur_loot_slot"),
        (gt, ":item_no", 0),
        (party_set_slot, "$g_enemy_party", ":cur_loot_slot", 0),
        (val_sub, ":cur_loot_slot", "slot_party_looted_item_1"),
        (val_add, ":cur_loot_slot", "slot_party_looted_item_1_modifier"),
        (party_get_slot, ":item_modifier", "$g_enemy_party", ":cur_loot_slot"),
        (troop_add_item, "trp_temp_troop", ":item_no", ":item_modifier"),
      (try_end),
      (party_set_slot, "$g_enemy_party", "slot_party_next_looted_item_slot", 0),
      
      (assign, ":num_looted_items",0),
      (try_begin),
        (this_or_next|party_slot_eq, "$g_enemy_party", "slot_party_type", spt_kingdom_caravan),
	  (this_or_next|party_slot_eq, "$g_enemy_party", "slot_party_type", spt_merchant_caravan), #Floris Seafaring / Seatrade chief
      (this_or_next|party_slot_eq, "$g_enemy_party", "slot_party_type", spt_bandit_lair),
        (party_slot_eq, "$g_enemy_party", "slot_party_type", spt_village_farmer),
        (store_mul, ":plunder_amount", player_loot_share, 40),#gdw30
        (val_mul, ":plunder_amount", "$g_strength_contribution_of_player"),
        (val_div, ":plunder_amount", 100),
        (val_div, ":plunder_amount", ":num_player_party_shares"),
        (try_begin),
 			(this_or_next|party_slot_eq, "$g_enemy_party", "slot_party_type", spt_merchant_caravan), #seatrade chief
         (party_slot_eq, "$g_enemy_party", "slot_party_type", spt_kingdom_caravan),
          (reset_item_probabilities, 100),
          (assign, ":range_min", trade_goods_begin),
          (assign, ":range_max", trade_goods_end),
        (else_try),
          (party_slot_eq, "$g_enemy_party", "slot_party_type", spt_bandit_lair),
          (val_div, ":plunder_amount", 2),
          (reset_item_probabilities, 1),
          (assign, ":range_min", food_begin),
          (assign, ":range_max", food_end),
        (else_try),
          (val_div, ":plunder_amount", 5),
          (reset_item_probabilities, 1),
          (assign, ":range_min", food_begin),
          (assign, ":range_max", food_end),
        (try_end),
        (store_sub, ":item_to_price_slot", "slot_town_trade_good_prices_begin", trade_goods_begin),
        (try_for_range, ":cur_goods", ":range_min", ":range_max"),
          (try_begin),
            (neg|party_slot_eq, "$g_enemy_party", "slot_party_type", spt_bandit_lair),
            (store_add, ":cur_price_slot", ":cur_goods", ":item_to_price_slot"),
            (party_get_slot, ":cur_price", "$g_enemy_party", ":cur_price_slot"),                    
          (else_try),
            (assign, ":cur_price", maximum_price_factor),
            (val_add, ":cur_price", average_price_factor),
            (val_div, ":cur_price", 3),
          (try_end),  

          (gt, ":cur_price", 0),                    
          (assign, ":cur_probability", 100),
          (val_mul, ":cur_probability", average_price_factor),
          (val_div, ":cur_probability", ":cur_price"),
          (assign, reg0, ":cur_probability"),
          (set_item_probability_in_merchandise, ":cur_goods", ":cur_probability"),
        (try_end),
        (troop_add_merchandise, "trp_temp_troop", itp_type_goods, ":plunder_amount"),
        (val_add, ":num_looted_items", ":plunder_amount"),
      (try_end),
      
      #Now loot the defeated party
      (store_mul, ":loot_probability", player_loot_share, 8),#gdw3
      (val_mul, ":loot_probability", "$g_strength_contribution_of_player"),
      (party_get_skill_level, ":player_party_looting", "p_main_party", "skl_looting"),
      (val_mul, ":player_party_looting", 6),#gdwneed to use the skill somehow was (val_add, ":player_party_looting", 10),
      (val_mul, ":loot_probability", ":player_party_looting"),
      (val_div, ":loot_probability", 10),
      (val_div, ":loot_probability", ":num_player_party_shares"),
	##Trophies calculation: (50% base chance + loot skill * 4) for every 10 enemies
	(store_party_size_wo_prisoners, ":enemies_count", ":enemy_party"),
	(val_div, ":enemies_count", 10),
	(party_get_skill_level, ":player_party_looting", "p_main_party", "skl_looting"),
	(val_mul, "player_party_looting", 4),
	(assign, ":trophy_chance", 50),
	(val_add, ":trophy_chance", ":player_party_looting"),
	(try_for_range, ":i_try", 0, ":enemies_count"),
	  (store_random_in_range, ":roll", 0, 100),
	  (try_begin),
	    (gt, ":trophy_chance", ":roll"),
	    (val_add, ":num_looted_items", 1),
	    (troop_add_item, "trp_temp_troop", "trophy_a"),
	  (try_end),
	(try_end),
##End trophies calculation
## CC chief
      (store_add, ":temp_array_c_plus_one", "trp_temp_array_c", 1),
      (try_for_range, ":cur_troop", "trp_temp_array_a", ":temp_array_c_plus_one"),
        (troop_clear_inventory, ":cur_troop"), # clear_inventory
        # raise skl_inventory_management level to 10 
        (store_skill_level, ":cur_level", skl_inventory_management, ":cur_troop"),
        (store_sub, ":dest_level", 10, ":cur_level"),
        (troop_raise_skill, ":cur_troop", skl_inventory_management, ":dest_level"),
      (try_end),
      
      (call_script, "script_copy_inventory", "trp_temp_troop", "trp_temp_array_a"),

## CC chief acaba
      
      (party_get_num_companion_stacks, ":num_stacks",":enemy_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":enemy_party",":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (party_stack_get_size, ":stack_size",":enemy_party",":i_stack"),
        (try_for_range, ":unused", 0, ":stack_size"),
### CC chief loot
          (try_begin),
            (store_free_inventory_capacity, ":inv_cap_a", "trp_temp_array_a"),
            (gt, ":inv_cap_a", 0),
            (troop_loot_troop, "trp_temp_array_a", ":stack_troop", ":loot_probability"),
          (else_try),
            (store_free_inventory_capacity, ":inv_cap_b", "trp_temp_array_b"),
            (gt, ":inv_cap_b", 0),
            (troop_loot_troop, "trp_temp_array_b", ":stack_troop", ":loot_probability"),
          (else_try),
            (troop_loot_troop, "trp_temp_array_c", ":stack_troop", ":loot_probability"),
#          (troop_loot_troop, "trp_temp_troop", ":stack_troop", ":loot_probability"),
####CC chief loot acab
        (try_end),
      (try_end),
### CC chief
      (try_end),

      (troop_clear_inventory, "trp_temp_troop"),
      (try_for_range, ":unused", 0, 96), # for 96 times
        # find the best item
        (assign, ":best_score", 0),
        (assign, ":best_troop", -1),
        (assign, ":best_slot", -1),
        (try_for_range, ":cur_troop", "trp_temp_array_a", ":temp_array_c_plus_one"),
          (troop_get_inventory_capacity, ":inv_cap", ":cur_troop"),
          (try_for_range, ":i_slot", 10, ":inv_cap"),
            (troop_get_inventory_slot, ":item", ":cur_troop", ":i_slot"),
            (troop_get_inventory_slot_modifier, ":imod", ":cur_troop", ":i_slot"),
            (gt, ":item", -1),
            (call_script, "script_get_item_value_with_imod", ":item", ":imod"),
            (assign, ":score", reg0),
            (val_div, ":score", 100),
            (val_max, ":score",1),
            (gt, ":score", ":best_score"),
            (assign, ":best_score", ":score"),
            (assign, ":best_troop", ":cur_troop"),
            (assign, ":best_slot", ":i_slot"),
          (try_end),
        (try_end),
        (gt, ":best_score", 0),
        # already found
        (troop_get_inventory_slot, ":item", ":best_troop", ":best_slot"),
        (troop_get_inventory_slot_modifier, ":imod", ":best_troop", ":best_slot"),
        (troop_add_item, "trp_temp_troop", ":item", ":imod"), # add to trp_temp_troop
        (troop_set_inventory_slot, ":best_troop", ":best_slot", -1), # remove it 
      (try_end),
## CC chief acaba

      #(troop_get_inventory_capacity, ":inv_cap", "trp_temp_troop"),
      #(try_for_range, ":i_slot", 0, ":inv_cap"),
      #  (troop_get_inventory_slot, ":item_id", "trp_temp_troop", ":i_slot"),
      #  (is_between, ":item_id", horses_begin, horses_end),
      #  (troop_set_inventory_slot, "trp_temp_troop", ":i_slot", -1),
      #(try_end),

      (troop_get_inventory_capacity, ":inv_cap", "trp_temp_troop"),
      (try_for_range, ":i_slot", 0, ":inv_cap"),
        (troop_get_inventory_slot, ":item_id", "trp_temp_troop", ":i_slot"),
        (ge, ":item_id", 0),
        (val_add, ":num_looted_items", 1),
      (try_end),

      (assign, reg0, ":num_looted_items"),
  ]),
  
  #script_calculate_main_party_shares:
  # INPUT:
  # Returns number of player party shares in reg0  
  ("calculate_main_party_shares",
    [
      (assign, ":num_player_party_shares", player_loot_share),
      # Add shares for player's party
      (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
      (try_for_range, ":i_stack", 1, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", "p_main_party", ":i_stack"),
        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size","p_main_party",":i_stack"),
          (val_add, ":num_player_party_shares", ":stack_size"),
        (else_try),
          (val_add, ":num_player_party_shares", hero_loot_share),
        (try_end),
      (try_end),
      
      (assign, reg0, ":num_player_party_shares"),
  ]),
  
  #script_party_give_xp_and_gold:
  # INPUT:
  # param1: destroyed Party-id
  # calculates and gives player paty's share of gold and xp.
  
  ("party_give_xp_and_gold",
    [
      (store_script_param_1, ":enemy_party"), #Party_id
      
      (call_script, "script_calculate_main_party_shares"),
      (assign, ":num_player_party_shares", reg0),
            
      (assign, ":total_gain", 0),
      (party_get_num_companion_stacks, ":num_stacks",":enemy_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id,     ":stack_troop",":enemy_party",":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (party_stack_get_size, ":stack_size",":enemy_party",":i_stack"),
        (store_character_level, ":level", ":stack_troop"),
        (store_add, ":gain", ":level", 10),
        (val_mul, ":gain", ":gain"),
        (val_div, ":gain", 10),
        (store_mul, ":stack_gain", ":gain", ":stack_size"),
        (val_add, ":total_gain", ":stack_gain"),
      (try_end),
      (val_mul, ":total_gain", "$g_strength_contribution_of_player"),
      (val_div, ":total_gain", 100),

      (val_min, ":total_gain", 40000), #eliminate negative results
                  
      (assign, ":player_party_xp_gain", ":total_gain"),
      
      (store_random_in_range, ":r", 50, 100),
      (val_mul, ":player_party_xp_gain", ":r"),
      (val_div, ":player_party_xp_gain", 86),#gdw100
      
      (party_add_xp, "p_main_party", ":player_party_xp_gain"),
      
      (store_mul, ":player_gold_gain", ":total_gain", player_loot_share),
      (val_min, ":player_gold_gain", 60000), #eliminate negative results
      (store_random_in_range, ":r", 50, 100),
      (val_mul, ":player_gold_gain", ":r"),
      (val_div, ":player_gold_gain", 100),
		## Floris chief - Trade with Merchant Caravans
	    (try_begin),
	        (party_slot_eq, ":enemy_party", "slot_party_type", spt_kingdom_caravan),
		    (party_get_slot, ":wealth", ":enemy_party", "slot_town_wealth"),
		    (val_add, ":player_gold_gain", ":wealth"),
	    (try_end),
	    ## Floris - Trade with Merchant Caravans
      (val_div, ":player_gold_gain", ":num_player_party_shares"),
      
      #add gold now
      (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (call_script, "script_troop_add_gold", ":stack_troop", ":player_gold_gain"),
        (try_end),
      (try_end),
  ]),
  
  
  #script_setup_troop_meeting:
  # INPUT:
  # param1: troop_id with which meeting will be made.
  # param2: troop_dna (optional)
  
  ("setup_troop_meeting",
    [
      (store_script_param_1, ":meeting_troop"),
      (store_script_param_2, ":troop_dna"),
      (call_script, "script_get_meeting_scene"), 
      (assign, ":meeting_scene", reg0),
      (modify_visitors_at_site,":meeting_scene"),
      (reset_visitors),
      (set_visitor,0,"trp_player"),
	  (try_begin),
		(gt, ":troop_dna", -1),
        (set_visitor,17,":meeting_troop",":troop_dna"),
	  (else_try),
        (set_visitor,17,":meeting_troop"),
	  (try_end),	
      (set_jump_mission,"mt_conversation_encounter"),
      (jump_to_scene,":meeting_scene"),
      (change_screen_map_conversation, ":meeting_troop"),
  ]),
  
  #script_setup_party_meeting:
  # INPUT:
  # param1: Party-id with which meeting will be made.
  
  ("setup_party_meeting",
    [
      (store_script_param_1, ":meeting_party"),
      (try_begin),
        (lt, "$g_encountered_party_relation", 0), #hostile
#        (call_script, "script_music_set_situation_with_culture", mtf_sit_encounter_hostile),
      (try_end),
      (call_script, "script_get_meeting_scene"), (assign, ":meeting_scene", reg0),
      (modify_visitors_at_site,":meeting_scene"),(reset_visitors),
      (set_visitor,0,"trp_player"),
      (party_stack_get_troop_id, ":meeting_troop",":meeting_party",0),
      (party_stack_get_troop_dna,":troop_dna",":meeting_party",0),
      (set_visitor,17,":meeting_troop",":troop_dna"),
      (set_jump_mission,"mt_conversation_encounter"),
      (jump_to_scene,":meeting_scene"),
      (change_screen_map_conversation, ":meeting_troop"),
  ]),
  
  #script_get_meeting_scene:
  # INPUT: none
  # OUTPUT: reg0 contain suitable scene_no
  
  ("get_meeting_scene",
    [
      (party_get_current_terrain, ":terrain_type", "p_main_party"),
      (assign, ":scene_to_use", "scn_random_scene"),
      (try_begin),
        (eq, ":terrain_type", rt_steppe),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_plain),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_snow),
        (assign, ":scene_to_use", "scn_meeting_scene_snow"),
      (else_try),
        (eq, ":terrain_type", rt_desert),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_steppe_forest),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_forest),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_snow_forest),
        (assign, ":scene_to_use", "scn_meeting_scene_snow"),
      (else_try),
        (eq, ":terrain_type", rt_desert_forest),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (else_try),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (try_end),
      (assign, reg0, ":scene_to_use"),
  ]),

  
  #script_party_remove_all_companions:
  # INPUT:
  # param1: Party-id from which  companions will be removed.
  # "$g_move_heroes" : controls if heroes will also be removed.
  
  ("party_remove_all_companions",
    [
      (store_script_param_1, ":party"), #Source Party_id
      (party_get_num_companion_stacks, ":num_companion_stacks",":party"),
      (try_for_range_backwards, ":stack_no", 0, ":num_companion_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party",":stack_no"),
       
        (party_stack_get_size, ":stack_size", ":party", ":stack_no"),
        
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (neg|is_between, ":stack_troop", pretenders_begin, pretenders_end),
          (neq, ":stack_troop", "trp_player"),
          (eq, "$g_prison_heroes", 1),
          (eq, ":party", "p_main_party"),
          (store_random_in_range, ":succeed_escaping", 0, 2),
          (neq, ":succeed_escaping", 0), #50% chance companion stays with us.
          (troop_set_health, ":stack_troop", 100), #heal before leaving
          (store_faction_of_party, ":enemy_faction", "$g_enemy_party"),
          (assign, ":minimum_distance", 99999),
          (assign, ":prison_center", -1),
          (try_for_range, ":center", walled_centers_begin, walled_centers_end),
            (store_faction_of_party, ":center_faction", ":center"),
            (eq, ":center_faction", ":enemy_faction"),
            (store_distance_to_party_from_party, ":dist", ":center", "p_main_party"),
            (lt, ":dist", ":minimum_distance"),
            (assign, ":minimum_distance", ":dist"),
            (assign, ":prison_center", ":center"),
          (try_end),          
          (assign, reg1, ":prison_center"),
          #(display_message, "@{!}DEBUG : prison center is {reg1}"),
          (try_begin),
            (ge, ":prison_center", 0),
            (store_random_in_range, ":succeed_escaping", 0, 3),#gdw
            (neq, ":succeed_escaping", 0), #25% chance companion escapes to a tavern.
            (party_add_prisoners, ":prison_center", ":stack_troop", ":stack_size"),          
            (troop_set_slot, ":stack_troop", "slot_troop_prisoner_of_party", ":prison_center"),
            (troop_set_slot, ":stack_troop", "slot_troop_playerparty_history", pp_history_scattered),
            (troop_set_slot, ":stack_troop", "slot_troop_turned_down_twice", 0),
            (troop_set_slot, ":stack_troop", "slot_troop_occupation", 0),
            (party_remove_members, ":party", ":stack_troop", ":stack_size"),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_party_name, s1, ":prison_center"),
              (display_message, "str_your_hero_prisoned_at_s1"),
            (try_end),
          (else_try),
            #bandits or deserters won and captured companion. So place it randomly in a town's tavern.
            (assign, ":end_condition", 1000),
            (try_for_range, ":unused", 0, ":end_condition"),
              (store_random_in_range, ":town_no", towns_begin, towns_end),
              (neg|troop_slot_eq, ":stack_troop", "slot_troop_home", ":town_no"),
              (neg|troop_slot_eq, ":stack_troop", "slot_troop_first_encountered", ":town_no"),
              (assign, ":end_condition", -1),
            (try_end),  
            (troop_set_slot, ":stack_troop", "slot_troop_cur_center", ":town_no"),
            (troop_set_slot, ":stack_troop", "slot_troop_playerparty_history", pp_history_scattered),
            (troop_set_slot, ":stack_troop", "slot_troop_turned_down_twice", 0),
            (troop_set_slot, ":stack_troop", "slot_troop_occupation", 0),
            (party_remove_members, ":party", ":stack_troop", ":stack_size"),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_troop_name, 4, ":stack_troop"),
              (str_store_party_name, 5, ":town_no"),
              (display_message, "@{!}{s4} is sent to {s5} after defeat"),
            (try_end),
          (try_end),
        (else_try),        
          (this_or_next|neg|troop_is_hero, ":stack_troop"),
          (eq, "$g_move_heroes", 1),
          (party_remove_members, ":party", ":stack_troop", ":stack_size"),
        (try_end),
      (try_end),
  ]),
  
  #script_party_remove_all_prisoners:
  # INPUT:
  # param1: Party-id from which  prisoners will be removed.
  # "$g_move_heroes" : controls if heroes will also be removed.
  
  ("party_remove_all_prisoners",
    [
      (store_script_param_1, ":party"), #Source Party_id
      (party_get_num_prisoner_stacks, ":num_prisoner_stacks",":party"),
      (try_for_range_backwards, ":stack_no", 0, ":num_prisoner_stacks"),
        (party_prisoner_stack_get_troop_id, ":stack_troop",":party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_prisoner_stack_get_size, ":stack_size",":party",":stack_no"),
        (party_remove_prisoners, ":party", ":stack_troop", ":stack_size"),
      (try_end),
  ]),
  
  #script_party_add_party_companions:
  # INPUT:
  # param1: Party-id to add the second part
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.
  
  ("party_add_party_companions",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_companion_stacks, ":num_stacks",":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":source_party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_members, ":target_party", ":stack_troop", ":stack_size"),
        (party_stack_get_num_wounded, ":num_wounded", ":source_party", ":stack_no"),
        (party_wound_members, ":target_party", ":stack_troop", ":num_wounded"),
      (try_end),
  ]),
  
  #script_party_add_party_prisoners:
  # INPUT:
  # param1: Party-id to add the second party
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.
  
  ("party_add_party_prisoners",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_prisoner_stacks, ":num_stacks",":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_prisoner_stack_get_troop_id, ":stack_troop",":source_party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_prisoner_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_members, ":target_party", ":stack_troop", ":stack_size"),
      (try_end),
  ]),
  
  #script_party_prisoners_add_party_companions:
  # INPUT:
  # param1: Party-id to add the second part
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.
  
  ("party_prisoners_add_party_companions",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_companion_stacks, ":num_stacks",":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":source_party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_prisoners, ":target_party", ":stack_troop", ":stack_size"),
      (try_end),
  ]),
  
  #script_party_prisoners_add_party_prisoners:
  # INPUT:
  # param1: Party-id to add the second part
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.
  
  ("party_prisoners_add_party_prisoners",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_prisoner_stacks, ":num_stacks",":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_prisoner_stack_get_troop_id, ":stack_troop",":source_party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_prisoner_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_prisoners, ":target_party", ":stack_troop", ":stack_size"),
      (try_end),
  ]),
  
  # script_party_add_party:
  # INPUT:
  # param1: Party-id to add the second part
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.
  
  ("party_add_party",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (call_script, "script_party_add_party_companions",          ":target_party", ":source_party"),
      (call_script, "script_party_prisoners_add_party_prisoners", ":target_party", ":source_party"),
  ]),
  
  
  #script_party_copy:
  # INPUT:
  # param1: Party-id to copy the second party
  # param2: Party-id which will be copied to the first one.
  
  ("party_copy",
    [
      (assign, "$g_move_heroes", 1),
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_clear, ":target_party"),
      (call_script, "script_party_add_party", ":target_party", ":source_party"),
  ]),
  
  
  #script_clear_party_group:
  # INPUT:
  # param1: Party-id of the root of the group.
  # This script will clear the root party and all parties attached to it recursively.
  
  ("clear_party_group",
    [
      (store_script_param_1, ":root_party"),
	  
      (party_clear, ":root_party"),
      (party_get_num_attached_parties, ":num_attached_parties", ":root_party"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":root_party", ":attached_party_rank"),
        (call_script, "script_clear_party_group", ":attached_party"),
      (try_end),
  ]),
  

  #script_party_add_wounded_members_as_prisoners:
  # INPUT:
  # param1: Party-id to add the second party
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.
  
  ("party_add_wounded_members_as_prisoners",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_companion_stacks, ":num_stacks", ":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_num_wounded, ":num_wounded", ":source_party", ":stack_no"),
        (ge, ":num_wounded", 1),
        (party_stack_get_troop_id, ":stack_troop", ":source_party", ":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        #(party_prisoner_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_prisoners, ":target_party", ":stack_troop", ":num_wounded"),
      (try_end),
  ]),


  #script_get_nonempty_party_in_group:
  # INPUT:
  # param1: Party-id of the root of the group.
  # OUTPUT: reg0: nonempy party-id
  
  ("get_nonempty_party_in_group",
    [
      (store_script_param_1, ":party_no"),
      (party_get_num_companion_stacks, ":num_companion_stacks", ":party_no"),
      (try_begin),
        (gt, ":num_companion_stacks", 0),
        (assign, reg0, ":party_no"),
      (else_try),
        (assign, reg0, -1),
        
        (party_get_num_attached_parties, ":num_attached_parties", ":party_no"),
        (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
          (lt, reg0, 0),
          (party_get_attached_party_with_rank, ":attached_party", ":party_no", ":attached_party_rank"),
          (call_script, "script_get_nonempty_party_in_group", ":attached_party"),
        (try_end),
      (try_end),
  ]),
  
  #script_collect_prisoners_from_empty_parties:
  # INPUT:
  # param1: Party-id of the root of the group.
  # param2: Party to collect prisoners in.
  # make sure collection party is cleared before calling this.
  
  ("collect_prisoners_from_empty_parties",
    [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":collection_party"),
      
      (party_get_num_companions, ":num_companions", ":party_no"),
      (try_begin),
        (eq, ":num_companions", 0), #party is empty (has no companions). Collect its prisoners.
        (party_get_num_prisoner_stacks, ":num_stacks",":party_no"),
        (try_for_range, ":stack_no", 0, ":num_stacks"),
          (party_prisoner_stack_get_troop_id, ":stack_troop", ":party_no", ":stack_no"),
          (troop_is_hero, ":stack_troop"),
          (party_add_members, ":collection_party", ":stack_troop", 1),
        (try_end),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":party_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":party_no", ":attached_party_rank"),
        (call_script, "script_collect_prisoners_from_empty_parties", ":attached_party", ":collection_party"),
      (try_end),
  ]),
    
  #script_change_party_morale:
  # INPUT: party_no, morale_gained
  # OUTPUT: none

  ("change_party_morale",
   [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":morale_dif"),

      (party_get_morale, ":cur_morale", ":party_no"),
      (store_add, ":new_morale", ":cur_morale", ":morale_dif"),
      (val_clamp, ":new_morale", 0, 100),
      (party_set_morale, ":party_no", ":new_morale"),
      (str_store_party_name, s1, ":party_no"),
      
      (try_begin),
        (lt, ":new_morale", ":cur_morale"),
        (store_sub, reg1, ":cur_morale", ":new_morale"),
      (else_try),
        (gt, ":new_morale", ":cur_morale"),
        (store_sub, reg1, ":new_morale", ":cur_morale"),        
      (try_end),
  ]),

  #script_count_casualties_and_adjust_morale:
  # INPUT: none
  # OUTPUT: none

  ("count_casualties_and_adjust_morale",
   [             
			(try_begin), #xenoarg chief
			(ge, "$g_enemy_party", 0), ##xenoarg chief change enemy morale if and only if there is a valid enemy party (with party_id >= 0)
    (call_script, "script_calculate_main_party_shares"),
    (assign, ":num_player_party_shares", reg0),
    
    (assign, ":our_loss_score", 0),
    (party_get_num_companion_stacks, ":num_stacks","p_player_casualties"),
    (try_for_range, ":i_stack", 0, ":num_stacks"),
      (party_stack_get_troop_id, ":stack_troop", "p_player_casualties", ":i_stack"),
      (party_stack_get_size, ":stack_size", "p_player_casualties", ":i_stack"),
      
      (party_stack_get_num_wounded, ":num_wounded", "p_player_casualties", ":i_stack"),
      (store_mul, ":stack_size_mul_2", ":stack_size", 2),
      (store_sub, ":stack_size_mul_2_sub_wounded", ":num_wounded"),
      
      (store_character_level, ":level", ":stack_troop"),    
      (store_add, ":gain", ":level", 3),
      
      #if died/wounded troop is player troop then give its level +30 while calculating troop die effect on morale
      (try_begin),
        (eq, ":stack_troop", "trp_player"),
        (val_add, ":level", 75),
      (else_try),
        (troop_is_hero, ":stack_troop"),
        (val_add, ":level", 50),
      (try_end),
      
      (val_mul, ":gain", ":gain"),
      (val_div, ":gain", 10),
      (assign, reg0, ":gain"),
      (val_mul, ":gain", ":stack_size"),
      
      (try_begin),
        (neg|troop_is_hero, ":stack_troop"),
        (val_mul, ":gain", ":stack_size_mul_2_sub_wounded"),
        (val_div, ":gain", ":stack_size_mul_2"),
      (try_end),  
      
      (try_begin),
        (eq, "$cheat_mode", 1),
        (assign, reg1, ":stack_size"),
        (assign, reg2, ":gain"),
        (display_message, "str_our_per_person__reg0_num_people__reg1_total_gain__reg2"),
      (try_end),  
      (val_add, ":our_loss_score", ":gain"),
    (try_end),
    
    (assign, ":died_enemy_population", 0),
    (assign, ":enemy_loss_score", 0),
    (party_get_num_companion_stacks, ":num_stacks","p_enemy_casualties"),
    (try_for_range, ":i_stack", 0, ":num_stacks"),
      (party_stack_get_troop_id, ":stack_troop", "p_enemy_casualties", ":i_stack"),
      (party_stack_get_size, ":stack_size", "p_enemy_casualties", ":i_stack"),

      (party_stack_get_num_wounded, ":num_wounded", "p_enemy_casualties", ":i_stack"),
      (store_mul, ":stack_size_mul_2", ":stack_size", 2),
      (store_sub, ":stack_size_mul_2_sub_wounded", ":stack_size_mul_2", ":num_wounded"),

      (store_character_level, ":level", ":stack_troop"),      
      (store_add, ":gain", ":level", 3),

      #if troop is hero give extra +15 level while calculating troop die effect on morale 
      (try_begin),
        (troop_is_hero, ":stack_troop"),
        (val_add, ":level", 50),
      (try_end),

      (val_mul, ":gain", ":gain"),
      (val_div, ":gain", 10),      
      (assign, reg0, ":gain"),
      (val_mul, ":gain", ":stack_size"),
      
      (try_begin),
        (neg|troop_is_hero, ":stack_troop"),
        (val_mul, ":gain", ":stack_size_mul_2_sub_wounded"),
        (val_div, ":gain", ":stack_size_mul_2"),
      (try_end),  

      (try_begin),
        (eq, "$cheat_mode", 1),
        (assign, reg1, ":stack_size"),
        (assign, reg2, ":gain"),
        (display_message, "str_ene_per_person__reg0_num_people__reg1_total_gain__reg2"),
      (try_end),  
      (val_add, ":enemy_loss_score", ":gain"),
      (val_add, ":died_enemy_population", ":stack_size"),
    (try_end),

    (assign, ":ally_loss_score", 0),
    (try_begin),
      (eq, "$any_allies_at_the_last_battle", 1),
      (party_get_num_companion_stacks, ":num_stacks","p_ally_casualties"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", "p_ally_casualties", ":i_stack"),
        (party_stack_get_size, ":stack_size", "p_ally_casualties", ":i_stack"),
        
        (party_stack_get_num_wounded, ":num_wounded", "p_ally_casualties", ":i_stack"),
        (store_mul, ":stack_size_mul_2", ":stack_size", 2),
        (store_sub, ":stack_size_mul_2_sub_wounded", ":num_wounded"),

        (store_character_level, ":level", ":stack_troop"),    
        (store_add, ":gain", ":level", 3),

        #if troop is hero give extra +15 level while calculating troop die effect on morale 
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (val_add, ":level", 50),
        (try_end),

        (val_mul, ":gain", ":gain"),
        (val_div, ":gain", 10),      
        (assign, reg0, ":gain"),
        (val_mul, ":gain", ":stack_size"),

        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (val_mul, ":gain", ":stack_size_mul_2_sub_wounded"),
          (val_div, ":gain", ":stack_size_mul_2"),
        (try_end),  

        (try_begin),
          (eq, "$cheat_mode", 1),
          (assign, reg1, ":stack_size"),
          (assign, reg2, ":gain"),
          (display_message, "str_all_per_person__reg0_num_people__reg1_total_gain__reg2"),
        (try_end),  
        (val_add, ":ally_loss_score", ":gain"),
      (try_end),
    (try_end),
    
    (store_add, ":our_losses", ":our_loss_score", ":ally_loss_score"), 
    (assign, ":enemy_losses", ":enemy_loss_score"),
    (val_mul, ":our_losses", 100),
    
    (try_begin), 
      (eq, "$cheat_mode", 1),
      (assign, reg0, ":enemy_losses"),
      (display_message, "@{!}DEBUGS : enemy_loses : {reg0}"),
    (try_end),  
    
    (try_begin),
      (gt, ":enemy_losses", 0),
      (store_div, ":loss_ratio", ":our_losses", ":enemy_losses"),
    (else_try),
      (assign, ":loss_ratio", 1000),
    (try_end),

    (try_begin),
      (eq, "$cheat_mode", 1),
      (assign, reg1, ":loss_ratio"),
      (display_message, "str_loss_ratio_is_reg1"),
    (try_end),
     
    (try_begin),       
      (neg|is_between, "$g_enemy_party", centers_begin, centers_end),
      (store_sub, ":total_gain", 60, ":loss_ratio"),
    (else_try),
      (store_sub, ":total_gain", 100, ":loss_ratio"),
    (try_end),    

    (try_begin),
      (lt, ":total_gain", 0),
      (val_div, ":total_gain", 2),
    (try_end),

    (try_begin), 
      (eq, "$cheat_mode", 1),
      (assign, reg0, ":total_gain"),
      (display_message, "@{!}DEBUGS1 : total_gain : {reg0}"),
    (try_end),

    (val_max, ":total_gain", -60), #total gain changes between -60(1.8+ loss ratio) and 60(0 loss ratio). We assumed average loss ratio is 0.6
    (val_mul, ":total_gain", ":enemy_losses"),
    (val_div, ":total_gain", 100),

    (store_mul, ":total_enemy_morale_gain", ":total_gain", -1), #enemies get totally negative of the morale we get
    (val_mul, ":total_gain", "$g_strength_contribution_of_player"),
    (val_div, ":total_gain", 100),

    (try_begin), 
      (eq, "$cheat_mode", 1),
      (assign, reg0, ":total_gain"),
      (display_message, "@{!}DEBUGS2 : total_gain : {reg0}"),
    (try_end),  

    (try_begin),
      (party_is_active, "$g_enemy_party"), #change enemy morale if and only if there is a valid enemy party
      
      #main enemy party    
      (assign, ":total_enemy_population", 0),        
      (val_add, ":total_enemy_population", 10), #every part effect total population by number of agents they have plus 10
      (party_get_num_companion_stacks, ":num_stacks", "$g_enemy_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", "$g_enemy_party", ":i_stack"),
        (party_stack_get_size, ":stack_size", "$g_enemy_party", ":i_stack"),
        (val_add, ":total_enemy_population", ":stack_size"),
      (try_end),
      (assign, ":main_enemy_party_population", ":total_enemy_population"),

      #enemy attachers
      (party_get_num_attached_parties, ":num_attached_parties", "$g_enemy_party"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (val_add, ":total_enemy_population", 10), #every part effect total population by number of agents they have plus 10
        (party_get_attached_party_with_rank, ":attached_party", "$g_enemy_party", ":attached_party_rank"),
        (party_get_num_companion_stacks, ":num_stacks", ":attached_party"),
        (try_for_range, ":i_stack", 0, ":num_stacks"),
          (party_stack_get_troop_id, ":stack_troop", ":attached_party", ":i_stack"),
          (party_stack_get_size, ":stack_size", ":attached_party", ":i_stack"),
          (val_add, ":total_enemy_population", ":stack_size"),        
        (try_end),
      (try_end),
    
      #(assign, reg3, ":total_enemy_population"),
      #(assign, reg4, ":died_enemy_population"),
      #(store_sub, ":remaining_enemy_population", ":total_enemy_population", ":died_enemy_population"),
      #(val_add, ":remaining_enemy_population", 10),
      #(assign, reg5, ":remaining_enemy_population"),
      #(display_message, "@total : {reg3}, died : {reg4}, remaining : {reg5}"),
    
      #remaining enemy population has 10+remaining soldiers in enemy party
      (assign, ":remaining_enemy_population", ":total_enemy_population"),

      (assign, reg5, ":remaining_enemy_population"),
      (assign, reg6, ":total_enemy_morale_gain"),
    
      (set_fixed_point_multiplier, 100),
      (val_mul, ":remaining_enemy_population", 100),
      (store_sqrt, ":sqrt_remaining_enemy_population", ":remaining_enemy_population"),
      (val_div, ":sqrt_remaining_enemy_population", 100),            
      (val_div, ":total_enemy_morale_gain", ":sqrt_remaining_enemy_population"),
      (val_div, ":total_enemy_morale_gain", 4),

      (try_begin),
        (eq, "$cheat_mode", 1),
        (assign, reg7, ":total_enemy_morale_gain"),
        (display_message, "str_total_enemy_morale_gain__reg6_last_total_enemy_morale_gain__reg7_remaining_enemy_population__reg5"),
      (try_end),

      (store_mul, ":party_morale_gain", ":total_enemy_morale_gain", ":main_enemy_party_population"),
      (val_div, ":party_morale_gain", ":total_enemy_population"),
      
      (try_begin),      
        (party_is_active, "$g_enemy_party"),
        
        (call_script, "script_change_party_morale", "$g_enemy_party", ":party_morale_gain"),

        (party_get_num_attached_parties, ":num_attached_parties", "$g_enemy_party"),
        (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
          (party_get_attached_party_with_rank, ":attached_party", "$g_enemy_party", ":attached_party_rank"),
          (party_get_num_companion_stacks, ":num_stacks", ":attached_party"),
          (assign, ":party_population", 0),
          (try_for_range, ":i_stack", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":stack_troop", ":attached_party", ":i_stack"),
            (party_stack_get_size, ":stack_size", ":attached_party", ":i_stack"),
            (val_add, ":party_population", ":stack_size"),        
          (try_end),
          #(store_div, ":party_ratio", ":total_enemy_population_multiplied_by_100", ":party_population"), #party ratio changes between 0..100, shows population ratio of that party among all enemy parties
          (store_mul, ":party_morale_gain", ":total_enemy_morale_gain", ":party_population"),
          (val_div, ":party_morale_gain", ":total_enemy_population"),
          (call_script, "script_change_party_morale", ":attached_party", ":party_morale_gain"),
        (try_end),
      (try_end),  
    (try_end),
    
    #Add morale
    (assign, ":morale_gain", ":total_gain"),
    (val_div, ":morale_gain", ":num_player_party_shares"),#if there are lots of soldiers in my party there will be less morale increase.
    
    (try_begin), 
      (eq, "$cheat_mode", 1),
      (assign, reg0, ":num_player_party_shares"),
      (assign, reg1, ":total_gain"),
      (display_message, "@{!}DEBUGS3 : num_player_party_shares:{reg0}, total_gain:{reg1}"),
    (try_end),  
    
    (call_script, "script_change_player_party_morale", ":morale_gain"),
    (assign, "$g_battle_weary",1),#gdw
    
    (store_mul, ":killed_enemies_by_our_soldiers", ":died_enemy_population", "$g_strength_contribution_of_player"),
    (store_div, ":faction_morale_change", ":killed_enemies_by_our_soldiers", 8), #each 8 killed agent with any faction decreases morale of troops belong to that faction in our party by 1.
    (try_begin),
      (gt, ":faction_morale_change", 2000),
      (assign, ":faction_morale_change", 2000),
    (try_end),    
    
    (try_begin), #here we give positive morale to our troops of with same faction of ally party with 2/3x multipication.
      (ge, "$g_ally_party", 0),

      (store_div, ":ally_faction_morale_change", ":faction_morale_change", 3), #2/3x multipication (less than normal)
      (val_mul, ":ally_faction_morale_change", 2),
      (store_faction_of_party, ":ally_faction", "$g_ally_party"),
      (faction_get_slot, ":faction_morale", ":ally_faction",  "slot_faction_morale_of_player_troops"),
      (val_add, ":faction_morale", ":ally_faction_morale_change"),
      (faction_set_slot, ":ally_faction",  "slot_faction_morale_of_player_troops", ":faction_morale"),
    (try_end),
    
    (try_begin), #here we give positive morale to our troops of owner of rescued village's faction after saving village from bandits by x3 bonus.
      (neg|party_is_active, "$g_enemy_party"),
      (ge, "$current_town", 0),
      
      (val_mul, ":faction_morale_change", 2), #2x bonus (more than normal)
      (store_faction_of_party, ":ally_faction", "$current_town"),
      (faction_get_slot, ":faction_morale", ":ally_faction",  "slot_faction_morale_of_player_troops"),
      (val_add, ":faction_morale", ":faction_morale_change"),
      (faction_set_slot, ":ally_faction",  "slot_faction_morale_of_player_troops", ":faction_morale"),
    (else_try),
      (party_is_active, "$g_enemy_party"),
      (assign, ":currently_in_rebellion", 0),    
      (try_begin),
        (eq, "$players_kingdom", "fac_player_supporters_faction"),
        (neg|faction_slot_eq, "fac_player_supporters_faction", "slot_faction_leader", "trp_player"),
        (assign, ":currently_in_rebellion", 1),
      (try_end),     
      (eq, ":currently_in_rebellion", 0),

      (store_div, ":faction_morale_change", ":faction_morale_change", 3), #2/3x multipication (less than normal)
      (val_mul, ":faction_morale_change", 2),
      (store_faction_of_party, ":enemy_faction", "$g_enemy_party"),
      (faction_get_slot, ":faction_morale", ":enemy_faction",  "slot_faction_morale_of_player_troops"),
      (val_sub, ":faction_morale", ":faction_morale_change"),
      (faction_set_slot, ":enemy_faction",  "slot_faction_morale_of_player_troops", ":faction_morale"),
    (try_end),
    (try_end), #xenoarg chief      
  ]),
  
  #script_print_casualties_to_s0:
  # INPUT:
  # param1: Party_id, param2: 0 = use new line, 1 = use comma
  
  #OUTPUT:
  # string register 0.
  
  ("print_casualties_to_s0",
    [(store_script_param, ":party_no", 1),
     (store_script_param, ":use_comma", 2),
     (str_clear, s0),
     (assign, ":total_reported", 0),
     (assign, ":total_wounded", 0),
     (assign, ":total_killed", 0),
     (assign, ":total_routed", 0),
     (party_get_num_companion_stacks, ":num_stacks",":party_no"),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop_id", ":party_no", ":i_stack"),
       (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
       (party_stack_get_num_wounded, ":num_wounded", ":party_no", ":i_stack"),
       #get number of routed agent numbers
       (try_begin),
         (this_or_next|eq, ":party_no", "p_main_party"),
         (eq, ":party_no", "p_player_casualties"),     
         (troop_get_slot, ":num_routed", ":stack_troop_id", "slot_troop_player_routed_agents"),
         (troop_set_slot, ":stack_troop_id", "slot_troop_player_routed_agents", 0),
       (else_try),
         (party_get_attached_to, ":attached_to", ":party_no"),
         (this_or_next|eq, ":party_no", "p_ally_casualties"),     
         (ge, ":attached_to", 0), 
         (this_or_next|eq, ":party_no", "p_ally_casualties"),     
         (eq, ":attached_to", "p_main_party"),
         (troop_get_slot, ":num_routed", ":stack_troop_id", "slot_troop_ally_routed_agents"),
         (troop_set_slot, ":stack_troop_id", "slot_troop_ally_routed_agents", 0),
       (else_try),
         (troop_get_slot, ":num_routed", ":stack_troop_id", "slot_troop_enemy_routed_agents"),
         (troop_set_slot, ":stack_troop_id", "slot_troop_enemy_routed_agents", 0),
       (try_end),                
       (store_sub, ":num_killed", ":stack_size", ":num_wounded"),
       (val_sub, ":num_killed", ":num_routed"),
       (val_add, ":total_killed", ":num_killed"),
       (val_add, ":total_wounded", ":num_wounded"),
       (val_add, ":total_routed", ":num_routed"),     
       (try_begin),
         (this_or_next|gt, ":num_killed", 0),
         (this_or_next|gt, ":num_wounded", 0),
         (gt, ":num_routed", 0),     
         (store_add, reg3, ":num_killed", ":num_wounded"),
         (store_add, reg3, reg3, ":num_routed"),
         (str_store_troop_name_by_count, s1, ":stack_troop_id", reg3),
         (try_begin),
           (troop_is_hero, ":stack_troop_id"),
           (assign, reg3, 0),
         (try_end),
         (try_begin), #there are people who killed, wounded and routed.
           (gt, ":num_killed", 0),
           (gt, ":num_wounded", 0),
           (gt, ":num_routed", 0),
           (assign, reg4, ":num_killed"),
           (assign, reg5, ":num_wounded"),
           (assign, reg6, ":num_routed"),
           (str_store_string, s2, "str_reg4_killed_reg5_wounded_reg6_routed"),
         (else_try), #there are people who killed and routed.
           (gt, ":num_killed", 0),
           (gt, ":num_routed", 0),
           (assign, reg4, ":num_killed"),
           (assign, reg5, ":num_routed"),
           (str_store_string, s2, "str_reg4_killed_reg5_routed"),     
         (else_try), #there are people who killed and wounded.
           (gt, ":num_killed", 0),
           (gt, ":num_wounded", 0),
           (assign, reg4, ":num_killed"),
           (assign, reg5, ":num_wounded"),
           (str_store_string, s2, "str_reg4_killed_reg5_wounded"),     
         (else_try), #there are people who wounded and routed.
           (gt, ":num_wounded", 0),
           (gt, ":num_routed", 0),
           (assign, reg4, ":num_wounded"),
           (assign, reg5, ":num_routed"),
           (str_store_string, s2, "str_reg4_wounded_reg5_routed"),
         (else_try), #there are people who only killed.
           (gt, ":num_killed", 0),
           (assign, reg1, ":num_killed"),
           (str_store_string, s3, "@killed or seriously wounded"), #chief cambia bajas realistas
           (str_store_string, s2, "str_reg1_blank_s3"),
         (else_try), #there are people who only wounded.
           (gt, ":num_wounded", 0),
           (assign, reg1, ":num_wounded"),
           (str_store_string, s3, "@minor wounded"), #chief cambia bajas realistas
           (str_store_string, s2, "str_reg1_blank_s3"),
         (else_try), #there are people who only routed.
           (assign, reg1, ":num_routed"),
           (str_store_string, s3, "@routed"),
           (str_store_string, s2, "str_reg1_blank_s3"),
         (try_end),
         (try_begin),
           (eq, ":use_comma", 1),
           (try_begin),
             (eq, ":total_reported", 0),
             (str_store_string, s0, "@{!}{reg3?{reg3}:} {s1} ({s2})"),
           (else_try),
             (str_store_string, s0, "@{!}{s0}, {reg3?{reg3}:} {s1} ({s2})"),
           (try_end),
         (else_try),
           (str_store_string, s0, "@{!}{s0}^{reg3?{reg3}:} {s1} ({s2})"),
         (try_end),
         (val_add, ":total_reported", 1),
       (try_end),
     (try_end),
     (try_begin),
       (this_or_next|gt, ":total_killed", 0),
       (this_or_next|gt, ":total_wounded", 0),
       (gt, ":total_routed", 0),
       (store_add, ":total_agents", ":total_killed", ":total_wounded"),
       (val_add, ":total_agents", ":total_routed"),
       (assign, reg3, ":total_agents"),
       (try_begin),
         (gt, ":total_killed", 0),
         (gt, ":total_wounded", 0),
         (gt, ":total_routed", 0),
         (assign, reg4, ":total_killed"),
         (assign, reg5, ":total_wounded"),
         (assign, reg6, ":total_routed"),
         (str_store_string, s2, "str_reg4_killed_reg5_wounded_reg6_routed"),
       (else_try),
         (gt, ":total_killed", 0),
         (gt, ":total_routed", 0),
         (assign, reg4, ":total_killed"),
         (assign, reg5, ":total_routed"),
         (str_store_string, s2, "str_reg4_killed_reg5_routed"),
       (else_try),
         (gt, ":total_killed", 0),
         (gt, ":total_wounded", 0),
         (assign, reg4, ":total_killed"),
         (assign, reg5, ":total_wounded"),
         (str_store_string, s2, "str_reg4_killed_reg5_wounded"),
       (else_try),
         (gt, ":total_wounded", 0),
         (gt, ":total_routed", 0),
         (assign, reg4, ":total_wounded"),
         (assign, reg5, ":total_routed"),
         (str_store_string, s2, "str_reg4_wounded_reg5_routed"),
       (else_try),
         (gt, ":total_killed", 0),
         (str_store_string, s2, "@killed or seriously wounded"), #chief cambia bajas realistas
       (else_try),
         (gt, ":total_wounded", 0),
         (str_store_string, s2, "@minor wounded"), #chief cambia bajas realistas
       (else_try),
         (str_store_string, s2, "@routed"),
       (else_try),
       (try_end),
       (str_store_string, s0, "@{s0}^TOTAL: {reg3} ({s2})"),
     (else_try),
       (try_begin),
         (eq, ":use_comma", 1),
         (str_store_string, s0, "@None"),
       (else_try),
         (str_store_string, s0, "@^None"),
       (try_end),
     (try_end),
  ]),

  #script_write_fit_party_members_to_stack_selection
  # INPUT:
  # param1: party_no, exclude_leader
  #OUTPUT:
  # trp_stack_selection_amounts slots (slot 0 = number of stacks, 1 = number of men fit, 2..n = stack sizes (fit))
  # trp_stack_selection_ids slots (2..n = stack troops)
  ("write_fit_party_members_to_stack_selection",
   [
     (store_script_param, ":party_no", 1),
     (store_script_param, ":exclude_leader", 2),
     (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
     (assign, ":slot_index", 2),
     (assign, ":total_fit", 0),
     (try_for_range, ":stack_index", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop", ":party_no", ":stack_index"),
       (assign, ":num_fit", 0),
       (try_begin),
         (troop_is_hero, ":stack_troop"),
         (try_begin),
           (neg|troop_is_wounded, ":stack_troop"),
           (this_or_next|eq, ":exclude_leader", 0),
           (neq, ":stack_index", 0),
           (assign, ":num_fit",1),
         (try_end),
       (else_try),
         (party_stack_get_size, ":num_fit", ":party_no", ":stack_index"),
         (party_stack_get_num_wounded, ":num_wounded", ":party_no", ":stack_index"),
         (val_sub, ":num_fit", ":num_wounded"),
       (try_end),
       (try_begin),
         (gt, ":num_fit", 0),
         (troop_set_slot, "trp_stack_selection_amounts", ":slot_index", ":num_fit"),
         (troop_set_slot, "trp_stack_selection_ids", ":slot_index", ":stack_troop"),
         (val_add, ":slot_index", 1),
       (try_end),
       (val_add, ":total_fit", ":num_fit"),
     (try_end),
     (val_sub, ":slot_index", 2),
     (troop_set_slot, "trp_stack_selection_amounts", 0, ":slot_index"),
     (troop_set_slot, "trp_stack_selection_amounts", 1, ":total_fit"),
    ]),

  #script_remove_fit_party_member_from_stack_selection
  # INPUT:
  # param1: slot_index
  #OUTPUT:
  # reg0 = troop_no
  # trp_stack_selection_amounts slots (slot 0 = number of stacks, 1 = number of men fit, 2..n = stack sizes (fit))
  # trp_stack_selection_ids slots (2..n = stack troops)
  ("remove_fit_party_member_from_stack_selection",
   [
     (store_script_param, ":slot_index", 1),
     (val_add, ":slot_index", 2),
     (troop_get_slot, ":amount", "trp_stack_selection_amounts", ":slot_index"),
     (troop_get_slot, ":troop_no", "trp_stack_selection_ids", ":slot_index"),
     (val_sub, ":amount", 1),
     (troop_set_slot, "trp_stack_selection_amounts", ":slot_index", ":amount"),
     (troop_get_slot, ":total_amount", "trp_stack_selection_amounts", 1),
     (val_sub, ":total_amount", 1),
     (troop_set_slot, "trp_stack_selection_amounts", 1, ":total_amount"),
     (try_begin),
       (le, ":amount", 0),
       (troop_get_slot, ":num_slots", "trp_stack_selection_amounts", 0),
       (store_add, ":end_cond", ":num_slots", 2),
       (store_add, ":begin_cond", ":slot_index", 1),
       (try_for_range, ":index", ":begin_cond", ":end_cond"),
         (store_sub, ":prev_index", ":index", 1),
         (troop_get_slot, ":value", "trp_stack_selection_amounts", ":index"),
         (troop_set_slot, "trp_stack_selection_amounts", ":prev_index", ":value"),
         (troop_get_slot, ":value", "trp_stack_selection_ids", ":index"),
         (troop_set_slot, "trp_stack_selection_ids", ":prev_index", ":value"),
       (try_end),
       (val_sub, ":num_slots", 1),
       (troop_set_slot, "trp_stack_selection_amounts", 0, ":num_slots"),
     (try_end),
     (assign, reg0, ":troop_no"),
    ]),

  #script_remove_random_fit_party_member_from_stack_selection
  # INPUT:
  # none
  #OUTPUT:
  # reg0 = troop_no
  # trp_stack_selection_amounts slots (slot 0 = number of stacks, 1 = number of men fit, 2..n = stack sizes (fit))
  # trp_stack_selection_ids slots (2..n = stack troops)
  ("remove_random_fit_party_member_from_stack_selection",
   [
     (troop_get_slot, ":total_amount", "trp_stack_selection_amounts", 1),
     (store_random_in_range, ":random_troop", 0, ":total_amount"),
     (troop_get_slot, ":num_slots", "trp_stack_selection_amounts", 0),
     (store_add, ":end_cond", ":num_slots", 2),
     (try_for_range, ":index", 2, ":end_cond"),
       (troop_get_slot, ":amount", "trp_stack_selection_amounts", ":index"),
       (val_sub, ":random_troop", ":amount"),
       (lt, ":random_troop", 0),
       (assign, ":end_cond", 0),
       (store_sub, ":slot_index", ":index", 2),
     (try_end),
     (call_script, "script_remove_fit_party_member_from_stack_selection", ":slot_index"),
    ]),

  
  #script_add_routed_party
  #INPUT: none
  #OUTPUT: none
  ("add_routed_party",
   [                
     (party_get_num_companion_stacks, ":num_stacks", "p_routed_enemies"), #question, I changed (total_enemy_casualties) with (p_routed_enemies) because this is not prisoner in p_routed_enemies party.        
     (assign, ":num_regulars", 0),
     (assign, ":deleted_stacks", 0),
     (try_for_range, ":stack_no", 0, ":num_stacks"),
       (store_sub, ":difference", ":num_stacks", ":stack_no"),
       (ge, ":difference", ":deleted_stacks"),
       (store_sub, ":stack_no_minus_deleted", ":stack_no", ":deleted_stacks"),
       (party_stack_get_troop_id, ":stack_troop", "p_routed_enemies", ":stack_no_minus_deleted"), 
       (try_begin),
         (troop_is_hero, ":stack_troop"),
         (party_stack_get_size, ":stack_size", "p_routed_enemies", ":stack_no_minus_deleted"),
         (party_remove_members, "p_routed_enemies", ":stack_troop", 1),
         (try_begin), 
           (le, ":stack_size", 1),
           (val_add, ":deleted_stacks", 1), #if deleted hero is the only one in his troop, now we have one less stacks
         (try_end),
       (else_try),
         (val_add, ":num_regulars", 1),
       (try_end),
     (try_end),

     #add new party to map if there is at least one routed agent. (new party name : routed_party, template : routed_warriors)
     (try_begin),
       (ge, ":num_regulars", 1),
     
       (set_spawn_radius, 2),
       (spawn_around_party, "p_main_party", "pt_routed_warriors"),
       (assign, ":routed_party", reg0),
     
       (party_set_slot, ":routed_party", "slot_party_commander_party", -1), #we need this because 0 is player's party!

       (assign, ":max_routed_agents", 0),
       (assign, ":routed_party_faction", "fac_neutral"),
       (try_for_range, ":cur_faction", "fac_kingdom_1", "fac_kingdoms_end"),
         (faction_get_slot, ":num_routed_agents_in_this_faction", ":cur_faction", "slot_faction_num_routed_agents"),
         (gt, ":num_routed_agents_in_this_faction", ":max_routed_agents"),
         (assign, ":max_routed_agents", ":num_routed_agents_in_this_faction"),
         (assign, ":routed_party_faction", ":cur_faction"),
       (try_end),
       
       (party_set_faction, ":routed_party", ":routed_party_faction"),

       (party_set_ai_behavior, ":routed_party", ai_bhvr_travel_to_party),

       (assign, ":minimum_distance", 1000000),
       (try_for_parties, ":party_no"),
         (party_is_active, ":party_no"),
         (party_get_slot, ":cur_party_type", ":party_no", "slot_party_type"),
         (this_or_next|eq, ":cur_party_type", spt_town),
         (eq, ":cur_party_type", spt_castle),
         (store_faction_of_party, ":cur_faction", ":party_no"),
         (this_or_next|eq, ":routed_party_faction", "fac_neutral"),
         (eq, ":cur_faction", ":routed_party_faction"),
         (party_get_position, pos1, ":party_no"),
         (store_distance_to_party_from_party, ":dist", ":party_no", "p_main_party"),
         (try_begin),
           (lt, ":dist", ":minimum_distance"),
           (assign, ":minimum_distance", ":dist"),
           (assign, ":nearest_ally_city", ":party_no"),
         (try_end),
       (try_end),     

       (party_get_position, pos1, "p_main_party"), #store position information of main party in pos1
       (party_get_position, pos2, ":nearest_ally_city"), #store position information of target city in pos2

       (assign, ":minimum_distance", 1000000),
       (try_for_range, ":unused", 0, 10),
         (map_get_random_position_around_position, pos3, pos1, 2), #store position of found random position (possible placing position for new routed party) around battle position in pos3
         (get_distance_between_positions, ":dist", pos2, pos3), #store distance between found position and target city in ":dist".
         (try_begin),
           (lt, ":dist", ":minimum_distance"),
           (assign, ":minimum_distance", ":dist"),
           (copy_position, pos63, pos3), 
         (try_end),
       (end_try),
     
       (party_set_position, ":routed_party", pos63),

       (party_set_ai_object, ":routed_party", ":nearest_ally_city"),
       (party_set_flags, ":routed_party", pf_default_behavior, 1),

       #adding party members of p_routed_enemies to routed_party
       (party_clear, ":routed_party"),
       (party_get_num_companion_stacks, ":num_stacks", "p_routed_enemies"), #question, I changed (total_enemy_casualties) with (p_routed_enemies) because this is not prisoner in p_routed_enemies party.
       (try_for_range, ":stack_no", 0, ":num_stacks"),
         (party_stack_get_troop_id, ":stack_troop", "p_routed_enemies", ":stack_no"), 
         (try_begin),
           (neg|troop_is_hero, ":stack_troop"), #do not add routed heroes to (new created) routed party for now.

           (party_stack_get_size, ":stack_size", "p_routed_enemies", ":stack_no"),
           (party_add_members, ":routed_party", ":stack_troop", ":stack_size"),
         (try_end),
       (try_end),
     (try_end),
    ]), #ozan


  #script_cf_training_ground_sub_routine_1_for_melee_details
  # INPUT:
  # value
  #OUTPUT:
  # none
  ("cf_training_ground_sub_routine_1_for_melee_details",
   [
     (store_script_param, ":value", 1),
     (ge, "$temp_3", ":value"),
     (val_add, ":value", 1),
     (troop_get_slot, ":troop_id", "trp_stack_selection_ids", ":value"),
     (str_store_troop_name, s0, ":troop_id"),
     ]),

  #script_training_ground_sub_routine_2_for_melee_details
  # INPUT:
  # value
  #OUTPUT:
  # none
  ("training_ground_sub_routine_2_for_melee_details",
   [
     (store_script_param, ":value", 1),
     (val_sub, ":value", 1),
     (try_begin),
       (lt, ":value", 0),
       (call_script, "script_remove_random_fit_party_member_from_stack_selection"),
     (else_try),
       (call_script, "script_remove_fit_party_member_from_stack_selection", ":value"),
     (try_end),
     (assign, ":troop_id", reg0),
     (store_sub, ":slot_index", "$temp_2", 1),
     (troop_set_slot, "trp_temp_array_a", ":slot_index", ":troop_id"),
     (try_begin),
       (eq, "$temp", "$temp_2"),
       (call_script, "script_start_training_at_training_ground", -1, "$temp"),
     (else_try),
       (val_add, "$temp_2", 1),
       (jump_to_menu, "mnu_training_ground_selection_details_melee_2"),
     (try_end),
     ]),

  #script_cf_training_ground_sub_routine_for_training_result
  # INPUT:
  # arg1: troop_id, arg2: stack_no, arg3: troop_count, arg4: xp_ratio_to_add
  #OUTPUT:
  # none
  ("cf_training_ground_sub_routine_for_training_result",
   [
     (store_script_param, ":troop_id", 1),
     (store_script_param, ":stack_no", 2),
     (store_script_param, ":amount", 3),
     (store_script_param, ":xp_ratio_to_add", 4),

     (store_character_level, ":level", ":troop_id"),
     (store_add, ":level_added", ":level", 5),
     (store_mul, ":min_hardness", ":level_added", 3),
     (val_min, ":min_hardness", 100),
     (store_sub, ":hardness_dif", ":min_hardness", "$g_training_ground_training_hardness"),
     (val_max, ":hardness_dif", 0),
     (store_sub, ":hardness_dif", 100, ":hardness_dif"),
     (val_mul, ":hardness_dif", ":hardness_dif"),
     (val_div, ":hardness_dif", 10), # value over 1000
##     (assign, reg0, ":hardness_dif"),
##     (display_message, "@Hardness difference: {reg0}/1000"),
     (store_mul, ":xp_ratio_to_add_for_stack", ":xp_ratio_to_add", ":hardness_dif"),
     (val_div, ":xp_ratio_to_add_for_stack", 700),#gdw
     (try_begin),
       (eq, ":troop_id", "trp_player"),
       (val_mul, ":xp_ratio_to_add_for_stack", 1),
     (else_try),
       (try_begin),
         (eq, "$g_mt_mode", ctm_melee),
         (try_begin),
           (this_or_next|troop_is_guarantee_ranged, ":troop_id"),
           (troop_is_guarantee_horse, ":troop_id"),
           (val_div, ":xp_ratio_to_add_for_stack", 4),
         (try_end),
       (else_try),
         (eq, "$g_mt_mode", ctm_mounted),
         (try_begin),
           (neg|troop_is_guarantee_horse, ":troop_id"),
           (assign, ":xp_ratio_to_add_for_stack", 0),
         (try_end),
       (else_try),
         (neg|troop_is_guarantee_ranged, ":troop_id"),
         (assign, ":xp_ratio_to_add_for_stack", 0),
       (try_end),
     (try_end),
     (val_add,  ":level", 1),
     (store_mul, ":xp_to_add", 100, ":level"),
     (val_mul, ":xp_to_add", ":amount"),
     (val_div, ":xp_to_add", 20),
     (val_mul, ":xp_to_add", ":xp_ratio_to_add_for_stack"),
     (val_div, ":xp_to_add", 800),#gdw1000
     (store_mul, ":max_xp_to_add", ":xp_to_add", 3),
     (val_div, ":max_xp_to_add", 2),
     (store_div, ":min_xp_to_add", ":xp_to_add", 2),
     (store_random_in_range, ":random_xp_to_add", ":min_xp_to_add", ":max_xp_to_add"),
     (gt, ":random_xp_to_add", 0),
     (try_begin),
       (troop_is_hero, ":troop_id"),
       (add_xp_to_troop, ":random_xp_to_add", ":troop_id"),
       (store_div, ":proficiency_to_add", ":random_xp_to_add", 50),
       (try_begin),
         (gt, ":proficiency_to_add", 0),
         (troop_raise_proficiency, ":troop_id", "$g_training_ground_used_weapon_proficiency", ":proficiency_to_add"),
       (try_end),
     (else_try),
       (party_add_xp_to_stack, "p_main_party", ":stack_no", ":random_xp_to_add"),
     (try_end),
     (assign, reg0, ":random_xp_to_add"),
     ]),


##  #script_cf_print_troop_name_with_stack_index_to_s0
##  # INPUT:
##  # param1: stack_index
##  
##  #OUTPUT:
##  # string register 0.
##  ("cf_print_troop_name_with_stack_index_to_s0",
##   [
##     (store_script_param_1, ":stack_index"),
##     (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
##     (lt, ":stack_index", ":num_stacks"),
##     (party_stack_get_troop_id, ":stack_troop", "p_main_party", ":stack_index"),
##     (str_store_troop_name, s0, ":stack_troop"),
##    ]),

  #script_print_troop_owned_centers_in_numbers_to_s0
  # INPUT:
  # param1: troop_no
  #OUTPUT:
  # string register 0.
  ("print_troop_owned_centers_in_numbers_to_s0",
   [
     (store_script_param_1, ":troop_no"),
     (str_store_string, s0, "@nothing"),
     (assign, ":owned_towns", 0),
     (assign, ":owned_castles", 0),
     (assign, ":owned_villages", 0),
     (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
       (party_slot_eq, ":cur_center", "slot_town_lord", ":troop_no"),
       (try_begin),
         (party_slot_eq, ":cur_center", "slot_party_type", spt_town),
         (val_add, ":owned_towns", 1),
       (else_try),
         (party_slot_eq, ":cur_center", "slot_party_type", spt_castle),
         (val_add, ":owned_castles", 1),
       (else_try),
         (val_add, ":owned_villages", 1),
       (try_end),
     (try_end),
     (assign, ":num_types", 0),
     (try_begin),
       (gt, ":owned_villages", 0),
       (assign, reg0, ":owned_villages"),
       (store_sub, reg1, reg0, 1),
       (str_store_string, s0, "@{reg0} village{reg1?s:}"),
       (val_add, ":num_types", 1),
     (try_end),
     (try_begin),
       (gt, ":owned_castles", 0),
       (assign, reg0, ":owned_castles"),
       (store_sub, reg1, reg0, 1),
       (try_begin),
         (eq, ":num_types", 0),
         (str_store_string, s0, "@{reg0} castle{reg1?s:}"),
       (else_try),
         (str_store_string, s0, "@{reg0} castle{reg1?s:} and {s0}"),
       (try_end),
       (val_add, ":num_types", 1),
     (try_end),
     (try_begin),
       (gt, ":owned_towns", 0),
       (assign, reg0, ":owned_towns"),
       (store_sub, reg1, reg0, 1),
       (try_begin),
         (eq, ":num_types", 0),
         (str_store_string, s0, "@{reg0} town{reg1?s:}"),
       (else_try),
         (eq, ":num_types", 1),
         (str_store_string, s0, "@{reg0} town{reg1?s:} and {s0}"),
       (else_try),
         (str_store_string, s0, "@{reg0} town{reg1?s:}, {s0}"),
       (try_end),
     (try_end),
     (store_add, reg0, ":owned_villages", ":owned_castles"),
     (val_add, reg0, ":owned_towns"),
     ]),

  #script_get_random_melee_training_weapon
  # INPUT: none
  # OUTPUT: reg0 = weapon_1, reg1 = weapon_2
  ("get_random_melee_training_weapon",
   [
     (assign, ":weapon_1", -1),
     (assign, ":weapon_2", -1),
     (store_random_in_range, ":random_no", 0, 3),
     (try_begin),
       (eq, ":random_no", 0),
       (assign, ":weapon_1", "itm_practice_staff"),
     (else_try),
       (eq, ":random_no", 1),
       (assign, ":weapon_1", "itm_practice_sword"),
       (assign, ":weapon_2", "itm_shield_4a"),
     (else_try),
       (assign, ":weapon_1", "itm_practice_sword"),
     (try_end),
     (assign, reg0, ":weapon_1"),
     (assign, reg1, ":weapon_2"),
     ]),

  #script_start_training_at_training_ground
  # INPUT:
  # param1: training_weapon_type, param2: training_param
  ("start_training_at_training_ground",
   [
     (val_add, "$g_training_ground_training_count", 1),
     (store_script_param, ":mission_weapon_type", 1),
     (store_script_param, ":training_param", 2),

     (set_jump_mission, "mt_training_ground_training"),

     (assign, ":training_default_weapon_1", -1),
     (assign, ":training_default_weapon_2", -1),
     (assign, ":training_default_weapon_3", -1),
     (assign, "$scene_num_total_gourds_destroyed", 0),
     (try_begin),
       (eq, ":mission_weapon_type", itp_type_bow),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_archery),
       (assign, ":training_default_weapon_1", "itm_practice_bow"),
       (try_begin),
         (eq, "$g_mt_mode", ctm_mounted),
         (assign, ":training_default_weapon_2", "itm_practice_arrows_100amount"),
       (else_try),
         (assign, ":training_default_weapon_2", "itm_practice_arrows_75amount"),#was10n amountgdw
       (try_end),
     (else_try),
       (eq, ":mission_weapon_type", itp_type_crossbow),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_crossbow),
       (assign, ":training_default_weapon_1", "itm_pict_crossbow"),
       (assign, ":training_default_weapon_2", "itm_bolts"),
     (else_try),
       (eq, ":mission_weapon_type", itp_type_thrown),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_throwing),
       (try_begin),
         (eq, "$g_mt_mode", ctm_mounted),
         (assign, ":training_default_weapon_2", "itm_throwing_daggers"),#_100_amount
       (else_try),
         (assign, ":training_default_weapon_2", "itm_throwing_daggers"),
       (try_end),
     (else_try),
       (eq, ":mission_weapon_type", itp_type_one_handed_wpn),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_one_handed_weapon),
       (assign, ":training_default_weapon_1", "itm_practice_sword"),
     (else_try),
       (eq, ":mission_weapon_type", itp_type_polearm),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_polearm),
       (assign, ":training_default_weapon_1", "itm_practice_spear"),
     (else_try),
       #weapon_type comes as -1 when melee training is selected
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_one_handed_weapon),
       (call_script, "script_get_random_melee_training_weapon"),
       (assign, ":training_default_weapon_1", reg0),
       (assign, ":training_default_weapon_2", reg1),
     (try_end),
     
##     (assign, "$g_training_ground_training_troop_stack_index", ":stack_index"),
     (try_begin),
       (eq, "$g_mt_mode", ctm_mounted),
       (assign, ":training_default_weapon_3", "itm_saddle_horse1"),
       (store_add, "$g_training_ground_training_scene", "scn_training_ground_horse_track_1", "$g_encountered_party"),
       (val_sub, "$g_training_ground_training_scene", training_grounds_begin),
     (else_try),
       (store_add, "$g_training_ground_training_scene", "scn_training_ground_ranged_melee_1", "$g_encountered_party"),
       (val_sub, "$g_training_ground_training_scene", training_grounds_begin),
     (try_end),

     (modify_visitors_at_site, "$g_training_ground_training_scene"),
     (reset_visitors),
     (set_visitor, 0, "trp_player"),

     (assign, ":selected_weapon", -1),
     (try_for_range, ":cur_slot", 0, 4),#equipment slots
       (troop_get_inventory_slot, ":cur_item", "trp_player", ":cur_slot"),
       (ge, ":cur_item", 0),
       (item_get_type, ":item_type", ":cur_item"),
       (try_begin),
         (eq, ":item_type", ":mission_weapon_type"),
         (eq, ":selected_weapon", -1),
         (assign, ":selected_weapon", ":cur_item"),
       (try_end),
     (try_end),
     (mission_tpl_entry_clear_override_items, "mt_training_ground_training", 0),
     (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, "itm_cheap_shoes"),
     (try_begin),
       (ge, ":training_default_weapon_1", 0),
       (try_begin),
         (ge, ":selected_weapon", 0),
         (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, ":selected_weapon"),
       (else_try),
         (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, ":training_default_weapon_1"),
       (try_end),
     (try_end),
     (try_begin),
       (ge, ":training_default_weapon_2", 0),
       (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, ":training_default_weapon_2"),
     (try_end),
     (try_begin),
       (ge, ":training_default_weapon_3", 0),
       (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, ":training_default_weapon_3"),
     (try_end),

     (assign, ":cur_visitor_point", 5),
     (troop_get_slot, ":num_fit", "trp_stack_selection_amounts", 1),
     (store_add, ":end_cond", 5, ":num_fit"),
     (val_min, ":end_cond", 13),
     (try_for_range, ":cur_visitor_point", 5, ":end_cond"),
       (call_script, "script_remove_random_fit_party_member_from_stack_selection"),
       (set_visitor, ":cur_visitor_point", reg0),
       (val_add, ":cur_visitor_point", 1),
     (try_end),
     (try_begin),
       (eq, "$g_mt_mode", ctm_melee),
       (assign, ":total_difficulty", 0),
       (try_for_range, ":i", 0, ":training_param"),
         (troop_get_slot, ":cur_troop", "trp_temp_array_a", ":i"),
         (store_add, ":cur_entry_point", ":i", 1),
         (set_visitor, ":cur_entry_point", ":cur_troop"),
         (mission_tpl_entry_clear_override_items, "mt_training_ground_training", ":cur_entry_point"),
         (mission_tpl_entry_add_override_item, "mt_training_ground_training", ":cur_entry_point", "itm_cheap_shoes"),
         (call_script, "script_get_random_melee_training_weapon"),
         (mission_tpl_entry_add_override_item, "mt_training_ground_training", ":cur_entry_point", reg0),
         (try_begin),
           (ge, reg1, 0),
           (mission_tpl_entry_add_override_item, "mt_training_ground_training", ":cur_entry_point", reg1),
         (try_end),
         (store_character_level, ":cur_troop_level", ":cur_troop"),
         (val_add, ":cur_troop_level", 10),
         (val_mul, ":cur_troop_level", ":cur_troop_level"),
         (val_add, ":total_difficulty", ":cur_troop_level"),
       (try_end),

       (assign, "$g_training_ground_training_num_enemies", ":training_param"),
       (assign, "$g_training_ground_training_hardness",  ":total_difficulty"),
       (store_add, ":number_multiplier", "$g_training_ground_training_num_enemies", 4),
       (val_mul, "$g_training_ground_training_hardness", ":number_multiplier"),
       (val_div, "$g_training_ground_training_hardness", 2400),
       (str_store_string, s0, "@Your opponents are ready for the fight."),
     (else_try),
       (eq, "$g_mt_mode", ctm_mounted),
       (try_begin),
         (eq, ":mission_weapon_type", itp_type_bow),
         (assign, "$g_training_ground_training_hardness", 350),
         (assign, "$g_training_ground_training_num_gourds_to_destroy", 30),
       (else_try),
         (eq, ":mission_weapon_type", itp_type_thrown),
         (assign, "$g_training_ground_training_hardness", 400),
         (assign, "$g_training_ground_training_num_gourds_to_destroy", 30),
       (else_try),
         (eq, ":mission_weapon_type", itp_type_one_handed_wpn),
         (assign, "$g_training_ground_training_hardness", 200),
         (assign, "$g_training_ground_training_num_gourds_to_destroy", 45),
       (else_try),
         (eq, ":mission_weapon_type", itp_type_polearm),
         (assign, "$g_training_ground_training_hardness", 280),
         (assign, "$g_training_ground_training_num_gourds_to_destroy", 35),
       (try_end),
       (str_store_string, s0, "@Try to destroy as many targets as you can. You have two and a half minutes to clear the track."),
     (else_try),
       (eq, "$g_mt_mode", ctm_ranged),
       (store_mul, "$g_training_ground_ranged_distance", ":training_param", 100),
       (assign, ":hardness_modifier", ":training_param"),
       (val_mul, ":hardness_modifier", ":hardness_modifier"),
       (try_begin),
         (eq, ":mission_weapon_type", itp_type_bow),
         (val_mul, ":hardness_modifier", 3),
         (val_div, ":hardness_modifier", 2),
       (else_try),
         (eq, ":mission_weapon_type", itp_type_thrown),
         (val_mul, ":hardness_modifier", 5),
         (val_div, ":hardness_modifier", 2),
         (val_mul, ":hardness_modifier", ":training_param"),
         (val_div, ":hardness_modifier", 2),
       (try_end),
       (store_mul, "$g_training_ground_training_hardness", 100, ":hardness_modifier"),
       (val_div, "$g_training_ground_training_hardness", 6000),
       (str_store_string, s0, "@Stay behind the line on the ground and shoot the targets. Try not to waste any shots."),
     (try_end),
     (jump_to_menu, "mnu_training_ground_description"),
     ]),
  
  
  #script_print_party_to_s0:
  # INPUT:
  # param1: Party-id
  
  #OUTPUT:
  # string register 0.
  
  ##  ("print_party_to_s0",
  ##    [
  ##      (store_script_param_1, ":party"), #Party_id
  ##      (party_get_num_companion_stacks, ":num_stacks",":party"),
  ##      (str_store_string, s50, "str_none"),
  ##      (try_for_range, ":i_stack", 0, ":num_stacks"),
  ##        (party_stack_get_troop_id,     ":stack_troop",":party",":i_stack"),
  ##        (party_stack_get_size,         ":stack_size",":party",":i_stack"),
  ##        (str_store_troop_name_by_count, s61, ":stack_troop", ":stack_size"),
  ##        (try_begin),
  ##          (troop_is_hero, ":stack_troop"),
  ##          (str_store_string_reg, s51, s61),
  ##        (else_try),
  ##          (assign, reg60, ":stack_size"),
  ##          (str_store_string, s63, "str_reg60_s61"),
  ##        (try_end),
  ##        (try_begin),
  ##          (eq, ":i_stack", 0),
  ##          (str_store_string_reg, s50, s51),
  ##        (else_try),
  ##          (str_store_string, s50, "str_s50_comma_s51"),
  ##        (try_end),
  ##      (try_end),
  ##      (str_store_string_reg, s0, s50),
  ##  ]),
  

  
  #script_party_count_fit_regulars:
  # Returns the number of unwounded regular companions in a party
  # INPUT:
  # param1: Party-id
  
  ("party_count_fit_regulars",
    [
      (store_script_param_1, ":party"), #Party_id
      (party_get_num_companion_stacks, ":num_stacks", ":party"),
      (assign, reg0, 0),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", ":party", ":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (party_stack_get_size, ":stack_size",":party",":i_stack"),
        (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
        (val_sub, ":stack_size", ":num_wounded"),
        (val_add, reg0, ":stack_size"),
      (try_end),
  ]),
  
  
  #script_party_count_fit_for_battle:
  # Returns the number of unwounded companions in a party
  # INPUT:
  # param1: Party-id
  # OUTPUT: reg0 = result
  ("party_count_fit_for_battle",
    [
      (store_script_param_1, ":party"), #Party_id
      (party_get_num_companion_stacks, ":num_stacks",":party"),
      (assign, reg0, 0),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party",":i_stack"),
        (assign, ":num_fit",0),
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (try_begin),
            (neg|troop_is_wounded, ":stack_troop"),
            (assign, ":num_fit", 1),
          (try_end),
        (else_try),
          (party_stack_get_size, ":num_fit",":party",":i_stack"),
          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
          (val_sub, ":num_fit", ":num_wounded"),
        (try_end),
        (val_add, reg0, ":num_fit"),
      (try_end),
  ]),


  #script_party_count_members_with_full_health
  # Returns the number of unwounded regulars, and heroes other than player with 100% hitpoints in a party
  # INPUT:
  # param1: Party-id
  # OUTPUT: reg0 = result
  ("party_count_members_with_full_health",
    [
      (store_script_param_1, ":party"), #Party_id
      (party_get_num_companion_stacks, ":num_stacks",":party"),
      (assign, reg0, 0),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party",":i_stack"),
        (neq, ":stack_troop", "trp_player"),
        (assign, ":num_fit",0),
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (store_troop_health, ":troop_hp", ":stack_troop"),
          (try_begin),
            (ge, ":troop_hp", 80),
            (assign, ":num_fit",1),
          (try_end),
        (else_try),
          (party_stack_get_size, ":num_fit",":party",":i_stack"),
          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
          (val_sub, ":num_fit", ":num_wounded"),
          (val_max, ":num_fit", 0),
        (try_end),
        (val_add, reg0, ":num_fit"),
      (try_end),
  ]),

 
  ##  ("get_fit_stack_with_rank",
  ##    [
  ##      (store_script_param_1, ":party"), #Party_id
  ##      (store_script_param_2, ":rank"), #Rank
  ##      (party_get_num_companion_stacks, ":num_stacks",":party"),
  ##      (assign, reg0, -1),
  ##      (assign, ":num_total", 0),
  ##      (try_for_range, ":i_stack", 0, ":num_stacks"),
  ##        (eq, reg(0), -1), #continue only if we haven't found the result yet.
  ##        (party_stack_get_troop_id,     ":stack_troop",":party",":i_stack"),
  ##        (assign, ":num_fit",0),
  ##        (try_begin),
  ##          (troop_is_hero, ":stack_troop"),
  ##          (store_troop_health, ":troop_hp", ":stack_troop"),
  ##          (try_begin),
  ##            (ge,  ":troop_hp", 20),
  ##            (assign, ":num_fit",1),
  ##          (try_end),
  ##        (else_try),
  ##          (party_stack_get_size,         ":num_fit",":party",":i_stack"),
  ##          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
  ##          (val_sub, ":num_fit", ":num_wounded"),
  ##        (try_end),
  ##        (val_add, ":num_total", ":num_fit"),
  ##        (try_begin),
  ##          (lt, ":rank", ":num_total"),
  ##          (assign, reg(0), ":i_stack"),
  ##        (try_end),
  ##      (try_end),
  ##  ]),
  
  #script_get_stack_with_rank:
  # Returns the stack no, containing unwounded regular companions with rank rank.
  # INPUT:
  # param1: Party-id
  # param2: rank
  
  ("get_stack_with_rank",
    [
      (store_script_param_1, ":party"), #Party_id
      (store_script_param_2, ":rank"), #Rank
      (party_get_num_companion_stacks, ":num_stacks",":party"),
      (assign, reg(0), -1),
      (assign, ":num_total", 0),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (eq, reg(0), -1), #continue only if we haven't found the result yet.
        (party_stack_get_troop_id,     ":stack_troop",":party",":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (party_stack_get_size,         ":stack_size",":party",":i_stack"),
        (party_stack_get_num_wounded,  ":num_wounded",":party",":i_stack"),
        (val_sub, ":stack_size", ":num_wounded"),
        (val_add, ":num_total", ":stack_size"),
        (try_begin),
          (lt, ":rank", ":num_total"),
          (assign, reg(0), ":i_stack"),
        (try_end),
      (try_end),
  ]),
  
  #script_inflict_casualties_to_party:
  # INPUT:
  # param1: Party-id
  # param2: number of rounds
  
  #OUTPUT:
  # This script doesn't return a value but populates the parties p_temp_wounded and p_temp_killed with the wounded and killed.
  #Example:
  #  (script_inflict_casualties_to_party, "_p_main_party" ,50),
  #  Simulate 50 rounds of casualties to main_party.
  
  ("inflict_casualties_to_party",
    [
      (party_clear, "p_temp_casualties"),
      (store_script_param_1, ":party"), #Party_id
      (call_script, "script_party_count_fit_regulars", ":party"),
      (assign, ":num_fit", reg(0)), #reg(47) = number of fit regulars.
      (store_script_param_2, ":num_attack_rounds"), #number of attacks
      (try_for_range, ":unused", 0, ":num_attack_rounds"),
        (gt, ":num_fit", 0),
        (store_random_in_range, ":attacked_troop_rank", 0 , ":num_fit"), #attack troop with rank reg(46)
        (assign, reg1, ":attacked_troop_rank"),
        (call_script, "script_get_stack_with_rank", ":party", ":attacked_troop_rank"),
        (assign, ":attacked_stack", reg(0)), #reg(53) = stack no to attack.
        (party_stack_get_troop_id,     ":attacked_troop",":party",":attacked_stack"),
        (store_character_level, ":troop_toughness", ":attacked_troop"),
        (val_add, ":troop_toughness", 5),  #troop-toughness = level + 5
#TEMPERED    chief      ################################    MAKE HARDER TO KILL HIGHER LEVEL TROOPS IN SIMULATED BATTLE  ###########################
		(store_div,":level_bonus",":troop_toughness",5),
		(val_mul,":level_bonus",13),#gdw10
		(val_add,":troop_toughness",":level_bonus"),
		
#TEMPERED   ###################################             END LEVEL BONUS       #######################################################
        (assign, ":casualty_chance", 10000),
        (val_div, ":casualty_chance", ":troop_toughness"), #dying chance
        (try_begin),
          (store_random_in_range, ":rand_num", 0 ,10000),
          (lt, ":rand_num", ":casualty_chance"), #check chance to be a casualty
          (store_random_in_range, ":rand_num2", 0, 2), #check if this troop will be wounded or killed
          (try_begin),
            (troop_is_hero,":attacked_troop"), #currently troop can't be a hero, but no harm in keeping this.
            (store_troop_health, ":troop_hp",":attacked_troop"),
            (val_sub, ":troop_hp", 45),
            (val_max, ":troop_hp", 1),
            (troop_set_health, ":attacked_troop", ":troop_hp"),
          (else_try),
            (lt, ":rand_num2", 1), #wounded
            (party_add_members, "p_temp_casualties", ":attacked_troop", 1),
            (party_wound_members, "p_temp_casualties", ":attacked_troop", 1),
            (party_wound_members, ":party", ":attacked_troop", 1),
          (else_try), #killed
            (party_add_members, "p_temp_casualties", ":attacked_troop", 1),
            (party_remove_members, ":party", ":attacked_troop", 1),
          (try_end),
          (val_sub, ":num_fit", 1), #adjust number of fit regulars.
        (try_end),
      (try_end),
  ]),
  
  
  #script_move_members_with_ratio:
  # INPUT:
  # param1: Source Party-id
  # param2: Target Party-id
  # pin_number = ratio of members to move, multiplied by 1000
  
  #OUTPUT:
  # This script doesn't return a value but moves some of the members of source party to target party according to the given ratio.
  ("move_members_with_ratio",
    [
      (store_script_param_1, ":source_party"), #Source Party_id
      (store_script_param_2, ":target_party"), #Target Party_id
      (party_get_num_prisoner_stacks, ":num_stacks",":source_party"),
      (try_for_range_backwards, ":stack_no", 0, ":num_stacks"),
        (party_prisoner_stack_get_troop_id,     ":stack_troop",":source_party",":stack_no"),
        (party_prisoner_stack_get_size,    ":stack_size",":source_party",":stack_no"),
        (store_mul, ":number_to_move",":stack_size","$pin_number"),
        (val_div, ":number_to_move", 1000),
        (party_remove_prisoners, ":source_party", ":stack_troop", ":number_to_move"),
        (assign, ":number_moved", reg0),
        (party_add_prisoners, ":target_party", ":stack_troop", ":number_moved"),
      (try_end),
      (party_get_num_companion_stacks, ":num_stacks",":source_party"),
      (try_for_range_backwards, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_troop_id,     ":stack_troop",":source_party",":stack_no"),
        (party_stack_get_size,    ":stack_size",":source_party",":stack_no"),
        (store_mul, ":number_to_move",":stack_size","$pin_number"),
        (val_div, ":number_to_move", 1000),
        (party_remove_members, ":source_party", ":stack_troop", ":number_to_move"),
        (assign, ":number_moved", reg0),
        (party_add_members, ":target_party", ":stack_troop", ":number_moved"),
      (try_end),
  ]),
  
  
  # script_count_parties_of_faction_and_party_type:
  # counts number of active parties with a template and faction.
  # Input: arg1 = faction_no, arg2 = party_type
  # Output: reg0 = count
  
  ("count_parties_of_faction_and_party_type",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":party_type"),
      (assign, reg0, 0),
      (try_for_parties, ":party_no"),
        (party_is_active, ":party_no"),
        (party_get_slot, ":cur_party_type", ":party_no", "slot_party_type"),
        (store_faction_of_party, ":cur_faction", ":party_no"),
        (eq, ":cur_party_type", ":party_type"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, reg0, 1),
      (try_end),
  ]),

# script_faction_get_number_of_armies
# Input: arg1 = faction_no
# Output: reg0 = number_of_armies
  ("faction_get_number_of_armies",
   [
      (store_script_param_1, ":faction_no"),
      (assign, ":num_armies", 0),
      (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
		(troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
    	(store_troop_faction, ":hero_faction_no", ":troop_no"),
        (eq, ":hero_faction_no", ":faction_no"),
        (troop_get_slot, ":hero_party", ":troop_no", "slot_troop_leaded_party"),
        (ge, ":hero_party", 0),
        (party_is_active, ":hero_party"),
        (call_script, "script_party_count_fit_regulars", ":hero_party"),
        (assign, ":party_size", reg0),
        (call_script, "script_party_get_ideal_size", ":hero_party"),
        (assign, ":ideal_size", reg0),
        (val_mul, ":ideal_size", 60),
        (val_div, ":ideal_size", 100),
        (gt, ":party_size", ":ideal_size"),
        (val_add, ":num_armies", 1),
      (try_end),
      (assign, reg0, ":num_armies"),
    ]),  
  

# script_faction_recalculate_strength
# Input: arg1 = faction_no
# Output: reg0 = strength
  ("faction_recalculate_strength",
   [
      (store_script_param_1, ":faction_no"),

      (call_script, "script_faction_get_number_of_armies", ":faction_no"),
      (assign, ":num_armies", reg0),
      (assign, ":num_castles", 0),
      (assign, ":num_towns", 0),

      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (eq, ":center_faction", ":faction_no"),
        (try_begin),
          (party_slot_eq, ":center_no", "slot_party_type", spt_castle),
          (val_add, ":num_castles", 1),
        (else_try),
          (party_slot_eq, ":center_no", "slot_party_type", spt_town),
          (val_add, ":num_towns", 1),
        (try_end),
      (try_end),

      (faction_set_slot, ":faction_no", "slot_faction_num_armies", ":num_armies"),
      (faction_set_slot, ":faction_no", "slot_faction_num_castles", ":num_castles"),
      (faction_set_slot, ":faction_no", "slot_faction_num_towns", ":num_towns"),

    ]),  
  
  #script_select_random_town:
  # This script selects a random town in range [towns_begin, towns_end)
  # INPUTS:
  # none
  
  #OUTPUT:
  # reg0: id of the selected random town
##  ("select_random_town",
##    [
##      (assign, ":num_towns", towns_end),
##      (val_sub,":num_towns", towns_begin),
##      (store_random, ":random_town", ":num_towns"),
##      (val_add,":random_town", towns_begin),
##      (assign, reg0, ":random_town"),
##  ]),
  
#  ("select_random_spawn_point",
#    [
#      (assign, reg(20), spawn_points_end),
#      (val_sub,reg(20), spawn_points_begin),
#      (store_random, reg(21), reg(20)),
#      (val_add,reg(21), spawn_points_begin),
#      (assign, "$pout_town", reg(21)),
# ]),
  
  #script_cf_select_random_town_with_faction:
  # This script selects a random town in range [towns_begin, towns_end)
  # such that faction of the town is equal to given_faction
  # INPUT:
  # arg1 = faction_no
  
  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no
  ("cf_select_random_town_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      # First count num matching spawn points
      (assign, ":no_towns", 0),
      (try_for_range,":cur_town", towns_begin, towns_end),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_towns", 1),
      (try_end),
      (gt, ":no_towns", 0), #Fail if there are no towns
      (store_random_in_range, ":random_town", 0, ":no_towns"),
      (assign, ":no_towns", 0),
      (try_for_range,":cur_town", towns_begin, towns_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_towns", 1),
        (gt, ":no_towns", ":random_town"),
        (assign, ":result", ":cur_town"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  #script_cf_select_random_village_with_faction:
  # This script selects a random village in range [villages_begin, villages_end)
  # such that faction of the village is equal to given_faction
  # INPUT:
  # arg1 = faction_no
  
  #OUTPUT:
  # This script may return false if there is no matching village.
  # reg0 = village_no
  ("cf_select_random_village_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      # First count num matching spawn points
      (assign, ":no_villages", 0),
      (try_for_range,":cur_village", villages_begin, villages_end),
        (store_faction_of_party, ":cur_faction", ":cur_village"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_villages", 1),
      (try_end),
      (gt, ":no_villages", 0), #Fail if there are no villages
      (store_random_in_range, ":random_village", 0, ":no_villages"),
      (assign, ":no_villages", 0),
      (try_for_range,":cur_village", villages_begin, villages_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_village"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_villages", 1),
        (gt, ":no_villages", ":random_village"),
        (assign, ":result", ":cur_village"),
      (try_end),
      (assign, reg0, ":result"),
  ]),
  
  
  #script_cf_select_random_walled_center_with_faction:
  # This script selects a random center in range [centers_begin, centers_end)
  # such that faction of the town is equal to given_faction
  # INPUT:
  # arg1 = faction_no
  # arg2 = preferred_center_no
  
  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no (Can fail)
  ("cf_select_random_walled_center_with_faction",
    [
      (store_script_param, ":faction_no", 1),
      (store_script_param, ":preferred_center_no", 2),
      (assign, ":result", -1),
      # First count num matching spawn points
      (assign, ":no_centers", 0),
      (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_centers", 1),
        (eq, ":cur_center", ":preferred_center_no"),
        (val_add, ":no_centers", 99),
      (try_end),
      (gt, ":no_centers", 0), #Fail if there are no centers
      (store_random_in_range, ":random_center", 0, ":no_centers"),
      (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (val_sub, ":random_center", 1),
        (try_begin),
          (eq, ":cur_center", ":preferred_center_no"),
          (val_sub, ":random_center", 99),
        (try_end),
        (lt, ":random_center", 0),
        (assign, ":result", ":cur_center"),
      (try_end),
      (assign, reg0, ":result"),
  ]),


  #script_cf_select_random_walled_center_with_faction_and_owner_priority_no_siege:
  # INPUT:
  # arg1 = faction_no
  # arg2 = owner_troop_no
  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = center_no (Can fail)
  ("cf_select_random_walled_center_with_faction_and_owner_priority_no_siege",
    [
      (store_script_param, ":faction_no", 1),
      (store_script_param, ":troop_no", 2),
      (assign, ":result", -1),
      (assign, ":no_centers", 0),
      
      (call_script, "script_lord_get_home_center", ":troop_no"),
      (assign, ":home_center", reg0),
      
      (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (party_slot_eq, ":cur_center", "slot_center_is_besieged_by", -1),
        (val_add, ":no_centers", 1),
        
        #(party_slot_eq, ":cur_center", "slot_town_lord", ":troop_no"),
        (eq, ":home_center", ":cur_center"), #I changed it with above line, now if lord is owner of any village its bound walled center is counted as 1000. Better this way. ozan-18.01.09
        
        (val_add, ":no_centers", 1000),
      (try_end),

	  #if no center is available count all centers not besieged do not care its faction.
	  (try_begin),
        (le, ":no_centers", 0), 

		(assign, "$g_there_is_no_avaliable_centers", 1),

        (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
	      (party_slot_eq, ":cur_center", "slot_center_is_besieged_by", -1),
          (val_add, ":no_centers", 1),                                   
        (try_end),
	  (else_try),
	    (assign, "$g_there_is_no_avaliable_centers", 0),
	  (try_end),

      (faction_get_slot, ":faction_leader", ":faction_no", "slot_faction_leader"),
	  (this_or_next|eq, "$g_there_is_no_avaliable_centers", 0),
      (neq, ":troop_no", ":faction_leader"), #faction leaders cannot spawn if they have no centers.

      (store_random_in_range, ":random_center", 0, ":no_centers"),
      (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
		(this_or_next|eq, "$g_there_is_no_avaliable_centers", 1),
        (eq, ":cur_faction", ":faction_no"),
        (party_slot_eq, ":cur_center", "slot_center_is_besieged_by", -1),
        (val_sub, ":random_center", 1),
        (try_begin),
          #(party_slot_eq, ":cur_center", "slot_town_lord", ":troop_no"),
          (eq, ":home_center", ":cur_center"), #I changed it with above line, now if lord is owner of any village its bound walled center is counted as 1000. Better this way. ozan-18.01.09
		  (eq, "$g_there_is_no_avaliable_centers", 0),

          (val_sub, ":random_center", 1000),
        (try_end),
        (lt, ":random_center", 0),
        (assign, ":result", ":cur_center"),
      (try_end),
      (assign, reg0, ":result"),
  ]),


  #script_cf_select_random_walled_center_with_faction_and_less_strength_priority:
  # This script selects a random center in range [centers_begin, centers_end)
  # such that faction of the town is equal to given_faction
  # INPUT:
  # arg1 = faction_no
  # arg2 = preferred_center_no
  
  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no (Can fail)
  ("cf_select_random_walled_center_with_faction_and_less_strength_priority",
    [
      (store_script_param, ":faction_no", 1),
      (store_script_param, ":preferred_center_no", 2),
      (assign, ":result", -1),
      # First count num matching spawn points
      (assign, ":no_centers", 0),
      (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (party_slot_eq, ":cur_center", "slot_center_is_besieged_by", -1),
        (val_add, ":no_centers", 1),
        (try_begin),
          (eq, ":cur_center", ":preferred_center_no"),
          (val_add, ":no_centers", 99),
        (try_end),
##        (call_script, "script_party_calculate_regular_strength", ":cur_center"),
##        (assign, ":strength", reg0),
##        (lt, ":strength", 80),
##        (store_sub, ":strength", 100, ":strength"),
##        (val_div, ":strength", 20),
##        (val_add, ":no_centers", ":strength"),
      (try_end),
      (gt, ":no_centers", 0), #Fail if there are no centers
      (store_random_in_range, ":random_center", 0, ":no_centers"),
      (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (party_slot_eq, ":cur_center", "slot_center_is_besieged_by", -1),
        (val_sub, ":random_center", 1),
        (try_begin),
          (eq, ":cur_center", ":preferred_center_no"),
          (val_sub, ":random_center", 99),
        (try_end),
##        (try_begin),
##          (call_script, "script_party_calculate_regular_strength", ":cur_center"),
##          (assign, ":strength", reg0),
##          (lt, ":strength", 80),
##          (store_sub, ":strength", 100, ":strength"),
##          (val_div, ":strength", 20),
##          (val_sub, ":random_center", ":strength"),
##        (try_end),
        (lt, ":random_center", 0),
        (assign, ":result", ":cur_center"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  
  #script_cf_select_random_town_at_peace_with_faction:
  # This script selects a random town in range [towns_begin, towns_end)
  # such that faction of the town is friendly to given_faction
  # INPUT:
  # arg1 = faction_no
  
  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no
  ("cf_select_random_town_at_peace_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      # First count num matching towns
      (assign, ":no_towns", 0),
      (try_for_range,":cur_town", towns_begin, towns_end),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation,":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),
        (val_add, ":no_towns", 1),
      (try_end),
      (gt, ":no_towns", 0), #Fail if there are no towns
      (store_random_in_range, ":random_town", 0, ":no_towns"),
      (assign, ":no_towns", 0),
      (try_for_range,":cur_town", towns_begin, towns_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation,":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),
        (val_add, ":no_towns", 1),
        (gt, ":no_towns", ":random_town"),
        (assign, ":result", ":cur_town"),
      (try_end),
      (assign, reg0, ":result"),
  ]),
  
  #script_cf_select_random_town_at_peace_with_faction_in_trade_route
  # INPUT:
  # arg1 = town_no
  # arg2 = faction_no
  
  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no
  ("cf_select_random_town_at_peace_with_faction_in_trade_route",
    [
      (store_script_param, ":town_no", 1),
      (store_script_param, ":faction_no", 2),
      (assign, ":result", -1),
      (assign, ":no_towns", 0),
      (try_for_range, ":cur_slot", "slot_town_trade_routes_begin", "slot_town_trade_routes_end"),
        (party_get_slot, ":cur_town", ":town_no", ":cur_slot"),
        (gt, ":cur_town", 0),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation, ":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),
        (val_add, ":no_towns", 1),
      (try_end),
      (gt, ":no_towns", 0), #Fail if there are no towns
      (store_random_in_range, ":random_town", 0, ":no_towns"),
      (try_for_range, ":cur_slot", "slot_town_trade_routes_begin", "slot_town_trade_routes_end"),
        (eq, ":result", -1),
        (party_get_slot, ":cur_town", ":town_no", ":cur_slot"),
        (gt, ":cur_town", 0),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation, ":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),
        (val_sub, ":random_town", 1),
        (lt, ":random_town", 0),
        (assign, ":result", ":cur_town"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

##  #activado chief SoT
##    ("cf_select_faction_spawn_point",
##      [
##        # First count num matching spawn points
##        (assign, reg(24), 0),
##        (try_for_range,reg(25), spawn_points_begin, spawn_points_end),
##          (store_faction_of_party, reg(23), reg(25)),
##          (eq, reg(23), "$pin_faction"),
##          (val_add, reg(24), 1),
##        (end_try,0),
##        # reg4 now holds num towns of this faction.
##        (gt, reg(24), 0), #Fail if there are no towns
##        (store_random, reg(26), reg(24)),
##  
##        (assign, reg(24), 0), # reg24 = num points of this faction.
##        (try_for_range,reg(25), spawn_points_begin, spawn_points_end),
##          (store_faction_of_party, reg(23), reg(25)),
##          (eq, reg(23), "$pin_faction"),
##          (try_begin,0),
##            (eq, reg(24), reg(26)),
##           (assign, "$pout_town", reg(25)), # result is this town
##          (end_try,0),
##         (val_add, reg(24), 1),
##        (end_try,0),
##    ]),
  
  
  #script_spawn_party_at_random_town:
  # This script selects a random town in range [towns_begin, towns_end)
  # such that faction of the town is equal to given_faction
  # and spawns a new party there.
  # INPUT:
  # $pin_faction: given_faction
  # $pin_party_template: given_party_template
  
  #OUTPUT:
  # This script may return false if party cannot be spawned.
  # $pout_party: id of the spawned party
  ##  ("spawn_party_at_random_town",
  ##    [
  ##      (call_script,"script_select_random_spawn_point"),
  ##      (set_spawn_radius,1),
  ##      (spawn_around_party,"$pout_town","$pin_party_template"),
  ##      (assign, "$pout_party", reg(0)),
  ##  ]),
  
  #script_cf_spawn_party_at_faction_town:
  # This script selects a random town in range [towns_begin, towns_end)
  # such that faction of the town is equal to given_faction
  # and spawns a new party there.
  # INPUT:
  # $pin_faction: given_faction
  # $pin_party_template: given_party_template
  
  #OUTPUT:
  # This script may return false if party cannot be spawned.
  # $pout_party: id of the spawned party
  ##  ("cf_spawn_party_at_faction_town",
  ##    [
  ##      (call_script,"script_cf_select_faction_spawn_point"),
  ##      (set_spawn_radius,1),
  ##      (spawn_around_party,"$pout_town","$pin_party_template"),
  ##      (assign, "$pout_party", reg(0)),
  ##  ]),
  
  #script_spawn_party_at_random_town_if_below_limit:
  # This script checks if number of parties
  # of specified template is less than limit,
  # If so, it selects a random town in range [towns_begin, towns_end)
  # and spawns a new party there.
  # INPUT:
  # $pin_party_template: given_party_template
  # $pin_limit: limit value
  
  #OUTPUT:
  # $pout_party: id of the spawned party
  # $pout_town: id of the selected faction town
  # Note:
  # This script may return false if number of parties
  # of specified template is greater or equal to limit,
  # or if party cannot be spawned.
##  ("cf_spawn_party_at_random_town_if_below_limit",
##    [
##      (store_num_parties_of_template, reg(22), "$pin_party_template"),
##      (lt,reg(22),"$pin_limit"), #check if we are below limit.
##      (call_script,"script_select_random_spawn_point"),
##      (set_spawn_radius,1),
##      (spawn_around_party,"$pout_town","$pin_party_template"),
##      (assign, "$pout_party", reg(0)),
##  ]),
  
  ##  #script_spawn_party_at_faction_town_if_below_limit:
  ##  # This script checks if number of parties
  ##  # of specified template is less than limit,
  ##  # If so, it selects a random town in range [towns_begin, towns_end)
  ##  # such that faction of the town is equal to given_faction
  ##  # and spawns a new party there.
  ##  # INPUT:
  ##  # $pin_faction: given_faction
  ##  # $pin_party_template: given_party_template
  ##  # $pin_limit: limit value
  ##
  ##  #OUTPUT:
  ##  # $pout_party: id of the spawned party
  ##  # $pout_town: id of the selected faction town
  ##  # Note:
  ##  # This script may return false if number of parties
  ##  # of specified template is greater or equal to limit,
  ##  # or if party cannot be spawned.
###activado chief SoT para forager y scouts
##    ("cf_spawn_party_at_faction_town_if_below_limit",
##     [
##        (store_num_parties_of_template, reg(22), "$pin_party_template"),
##        (lt,reg(22),"$pin_limit"), #check if we are below limit.
##        (call_script,"script_cf_select_faction_spawn_point"),
##        (set_spawn_radius,1),
##        (spawn_around_party,"$pout_town","$pin_party_template"),
##        (assign, "$pout_party", reg(0)),
##    ]),
  
  # script_shuffle_troop_slots:
  # Shuffles a range of slots of a given troop.
  # Used for exploiting a troop as an array.
  # Input: arg1 = troop_no, arg2 = slot_begin, arg3 = slot_end
  ("shuffle_troop_slots",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":slots_begin", 2),
      (store_script_param, ":slots_end", 3),
      (try_for_range, ":cur_slot_no", ":slots_begin", ":slots_end"),
        (store_random_in_range, ":random_slot_no", ":slots_begin", ":slots_end"), #reg(58) = random slot. Now exchange slots reg(57) and reg(58)
        (troop_get_slot, ":cur_slot_value", ":troop_no", ":cur_slot_no"), #temporarily store the value in slot reg(57) in reg(59)
        (troop_get_slot, ":random_slot_value", ":troop_no", ":random_slot_no"), #temporarily store the value in slot reg(58) in reg(60)
        (troop_set_slot, ":troop_no", ":cur_slot_no", ":random_slot_value"), # Now exchange the two...
        (troop_set_slot, ":troop_no", ":random_slot_no", ":cur_slot_value"),
      (try_end),
  ]),
  
  
  # script_get_quest - combines old get_random_quest with new get_dynamic_quest
  
  # Input: arg1 = troop_no (of the troop in conversation), arg2 = min_importance (of the quest)
  # Output: reg0 = quest_no (the slots of the quest will be filled after calling this script)
  ("get_quest",
    [            
      (store_script_param_1, ":giver_troop"),
      
      (store_character_level, ":player_level", "trp_player"),
      (store_troop_faction, ":giver_faction_no", ":giver_troop"),
      
      (troop_get_slot, ":giver_party_no", ":giver_troop", "slot_troop_leaded_party"),
      (troop_get_slot, ":giver_reputation", ":giver_troop", "slot_lord_reputation_type"),
      
      (assign, ":giver_center_no", -1),
      (try_begin),
        (gt, ":giver_party_no", 0),
        (party_get_attached_to, ":giver_center_no", ":giver_party_no"),
      (else_try),
        (is_between, "$g_encountered_party", centers_begin, centers_end),
        (assign, ":giver_center_no", "$g_encountered_party"),
      (try_end),
      
      (try_begin),
        (troop_slot_eq, ":giver_troop", "slot_troop_occupation", slto_kingdom_hero),
        (try_begin),
          (ge, "$g_talk_troop_faction_relation", 0),
          (assign, ":quests_begin", lord_quests_begin),
          (assign, ":quests_end", lord_quests_end),
          (assign, ":quests_begin_2", lord_quests_begin_2),
          (assign, ":quests_end_2", lord_quests_end_2),
        (else_try),
          (assign, ":quests_begin", enemy_lord_quests_begin),
          (assign, ":quests_end", enemy_lord_quests_end),
          (assign, ":quests_begin_2", 0),
          (assign, ":quests_end_2", 0),
        (try_end),
      (else_try),
        (is_between, ":giver_troop", village_elders_begin, village_elders_end),
        (assign, ":quests_begin", village_elder_quests_begin),
        (assign, ":quests_end", village_elder_quests_end),
        (assign, ":quests_begin_2", village_elder_quests_begin_2),
        (assign, ":quests_end_2", village_elder_quests_end_2),
      (else_try),
        (is_between, ":giver_troop", mayors_begin, mayors_end),
        (assign, ":quests_begin", mayor_quests_begin),
        (assign, ":quests_end", mayor_quests_end),
        (assign, ":quests_begin_2", mayor_quests_begin_2),
        (assign, ":quests_end_2", mayor_quests_end_2),
      (else_try),
        (assign, ":quests_begin", lady_quests_begin),
        (assign, ":quests_end", lady_quests_end),
        (assign, ":quests_begin_2", lady_quests_begin_2),
        (assign, ":quests_end_2", lady_quests_end_2),
      (try_end),
	  
      (assign, ":result", -1),
	  (assign, ":quest_target_troop", -1),
	  (assign, ":quest_target_center", -1),
	  (assign, ":quest_target_faction", -1),
	  (assign, ":quest_object_faction", -1),
	  (assign, ":quest_object_troop", -1),
	  (assign, ":quest_object_center", -1),
	  (assign, ":quest_target_party", -1),
	  (assign, ":quest_target_party_template", -1),
	  (assign, ":quest_target_amount", -1),
	  (assign, ":quest_target_dna", -1),
	  (assign, ":quest_target_item", -1),
	  (assign, ":quest_importance", 1),
	  (assign, ":quest_xp_reward", 0),
	  (assign, ":quest_gold_reward", 0),
	  (assign, ":quest_convince_value", 0),
	  (assign, ":quest_expiration_days", 0),
	  (assign, ":quest_dont_give_again_period", 0),	 	  
	  
	  (try_begin), #get dynamic quest is a separate script, so that we can scan a number of different troops at once for it
	   	(call_script, "script_get_dynamic_quest", "$g_talk_troop"),
	   		   	
	    (assign, ":result", reg0),
	    (assign, ":relevant_troop", reg1),
	    (assign, ":relevant_party", reg2),
	    (assign, ":relevant_faction", reg3),
		
	    #GUILDMASTER QUESTS
	    (try_begin),
			(eq, ":result", "qst_track_down_bandits"), 
			(assign, ":quest_target_party", ":relevant_party"),
			(assign ,":quest_expiration_days", 60),
			(assign, ":quest_xp_reward", 1100),
			(assign, ":quest_gold_reward", 1000),
			
		(else_try),	
			(eq, ":result", "qst_retaliate_for_border_incident"), 
			(assign, ":quest_target_troop", ":relevant_troop"),
			(assign, ":quest_target_faction", ":relevant_faction"),
			
			(assign ,":quest_expiration_days", 30),
			(assign, ":quest_xp_reward", 1100),
			(assign, ":quest_gold_reward", 1000),
			
		#KINGDOM LORD QUESTS	
		(else_try),
	        (eq, ":result", "qst_cause_provocation"),
			(assign, ":quest_target_faction", ":relevant_faction"),
	        (assign, ":quest_expiration_days", 30),
	        (assign, ":quest_dont_give_again_period", 50),
			(assign, ":quest_xp_reward", 1000),
			(assign, ":quest_gold_reward", 1000),
			
	    (else_try),
			(eq, ":result", "qst_destroy_bandit_lair"), 
			(assign, ":quest_target_party", ":relevant_party"),
			(assign ,":quest_expiration_days", 50),
			(assign, ":quest_xp_reward", 3000),
			(assign, ":quest_gold_reward", 1500),

		#KINGDOM LADY OR KINGDOM HERO QUESTS	
		(else_try),	
	        (eq, ":result", "qst_rescue_prisoner"),
			(assign, ":quest_target_troop", ":relevant_troop"),
			(assign, ":quest_target_center", ":relevant_party"),

	        (assign, ":quest_expiration_days", 30),
	        (assign, ":quest_dont_give_again_period", 5),
			(assign, ":quest_xp_reward", 1500),
			(assign, ":quest_gold_reward", 3000),
		(try_end),	  
	  (try_end),
	  
	  #no dynamic quest available
	  (try_begin),
		(eq, ":result", -1),

	    (try_for_range, ":unused", 0, 20), #Repeat trial twenty times 
	        (eq, ":result", -1),
	        (assign, ":quest_target_troop", -1),
	        (assign, ":quest_target_center", -1),
	        (assign, ":quest_target_faction", -1),
	        (assign, ":quest_object_faction", -1),
	        (assign, ":quest_object_troop", -1),
	        (assign, ":quest_object_center", -1),
	        (assign, ":quest_target_party", -1),
	        (assign, ":quest_target_party_template", -1),
	        (assign, ":quest_target_amount", -1),
	        (assign, ":quest_target_dna", -1),
	        (assign, ":quest_target_item", -1),
	        (assign, ":quest_importance", 1),
	        (assign, ":quest_xp_reward", 0),
	        (assign, ":quest_gold_reward", 0),
	        (assign, ":quest_convince_value", 0),
	        (assign, ":quest_expiration_days", 0),
	        (assign, ":quest_dont_give_again_period", 0),

            (store_sub, ":num_possible_old_quests", ":quests_end", ":quests_begin"),
            (store_sub, ":num_possible_new_quests", ":quests_end_2", ":quests_begin_2"),
            (store_add, ":num_possible_total_quests", ":num_possible_old_quests", ":num_possible_new_quests"),
            
            (store_random_in_range, ":quest_no", 0, ":num_possible_total_quests"),
            (try_begin),
              (lt, ":quest_no", ":num_possible_old_quests"),
              (store_random_in_range, ":quest_no", ":quests_begin", ":quests_end"), 
            (else_try),
              (store_random_in_range, ":quest_no", ":quests_begin_2", ":quests_end_2"),
            (try_end),
	        
#AJM chief THE QUEST_DONT_GIVE_AGAIN_PERIOD tiene sido doblado para que las quest se repitan la mitad, buscar por :quest_dont_give_again_period
	        (neg|check_quest_active,":quest_no"),
	        (neg|quest_slot_ge, ":quest_no", "slot_quest_dont_give_again_remaining_days", 1),
	        (try_begin),
	          village_elder.quest_deliver_grain.quest_block,
	        (else_try),
              village_elder.quest_deliver_cattle.quest_block,
	        (else_try),
	          village_elder.quest_train_peasants.quest_block,
	        (else_try),
	          # Mayor quests
	          (eq, ":quest_no", "qst_escort_merchant_caravan"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_random_party_in_range, ":quest_target_center", towns_begin, towns_end),
	          (store_distance_to_party_from_party, ":dist", ":giver_center_no",":quest_target_center"),
	          (assign, ":quest_gold_reward", ":dist"),
	          (val_add, ":quest_gold_reward", 20), #chief cambia#gdw40
	          (val_mul, ":quest_gold_reward", 10),#gdw25
	          #(val_div, ":quest_gold_reward", 20),
	          (store_random_in_range, ":quest_target_amount", 6, 12),
	          (assign, "$escort_merchant_caravan_mode", 0),
	          (assign, ":result", ":quest_no"),
	        (else_try),
          # SoT escort bishop chief
          (eq, ":quest_no", "qst_escort_bishop"),
          (is_between, ":giver_center_no", centers_begin, centers_end),
          (store_random_party_in_range, ":quest_target_center", towns_begin, towns_end),
          (store_distance_to_party_from_party, ":dist", ":giver_center_no",":quest_target_center"),
          (assign, ":quest_gold_reward", ":dist"),
          (val_add, ":quest_gold_reward", 80), #chief cambia
          (val_mul, ":quest_gold_reward", 60),
          (val_div, ":quest_gold_reward", 55),
          (store_random_in_range, ":quest_target_amount", 6, 12),
          (assign, "$escort_merchant_caravan_mode", 0),
          (assign, ":result", ":quest_no"),
        (else_try),
      #chief obispo acaba
	          (eq, ":quest_no", "qst_deliver_wine"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_random_party_in_range, ":quest_target_center", towns_begin, towns_end),
	          (store_random_in_range, ":random_no", 0, 2),
	          (try_begin),
	            (eq, ":random_no", 0),
	            (assign, ":quest_target_item", "itm_quest_wine"),
	          (else_try),
	            (assign, ":quest_target_item", "itm_quest_ale"),
	          (try_end),
	          (store_random_in_range, ":quest_target_amount", 6, 12),
	          (store_distance_to_party_from_party, ":dist", ":giver_center_no",":quest_target_center"),
	          (assign, ":quest_gold_reward", ":dist"),
	          (val_add, ":quest_gold_reward", 2),
	          (assign, ":multiplier", 8),#gdw5
	          (val_add, ":multiplier", ":quest_target_amount"),
	          (val_mul, ":quest_gold_reward", ":multiplier"),
	          (val_div, ":quest_gold_reward", 100),
	          (val_mul, ":quest_gold_reward", 15), #chief cambia
	          (store_item_value,"$qst_deliver_wine_debt",":quest_target_item"),
	          (val_mul,"$qst_deliver_wine_debt",":quest_target_amount"),
	          (val_mul,"$qst_deliver_wine_debt", 6),
	          (val_div,"$qst_deliver_wine_debt",5),
	          (assign, ":quest_expiration_days", 7),
	          (assign, ":quest_dont_give_again_period", 40), #chief
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_troublesome_bandits"),
			  (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_character_level, ":quest_gold_reward", "trp_player"),
	          (val_add, ":quest_gold_reward", 30), #chief cambia
	          (val_mul, ":quest_gold_reward", 35),
	          (val_div, ":quest_gold_reward",100),
	          (val_mul, ":quest_gold_reward", 10),
	          (assign, ":quest_expiration_days", 30),
	          (assign, ":quest_dont_give_again_period", 60), #chief
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_kidnapped_girl"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_random_in_range, ":quest_target_center", villages_begin, villages_end),
	          (store_character_level, ":quest_target_amount"),
	          (val_add, ":quest_target_amount", 15),
	          (store_distance_to_party_from_party, ":dist", ":giver_center_no", ":quest_target_center"),
	          (val_add, ":dist", 15),
	          (val_mul, ":dist", 6),#gdw2
	          (val_mul, ":quest_target_amount", ":dist"),
	          (val_div, ":quest_target_amount",100),
	          (val_mul, ":quest_target_amount",10),
	          (assign, ":quest_gold_reward", ":quest_target_amount"),
	          (val_div, ":quest_gold_reward", 40),#gdw I changed something here to reduce gold award
	          (val_mul, ":quest_gold_reward", 10),
                  (assign, ":quest_expiration_days", 22),#gdw15
	          (assign, ":quest_dont_give_again_period", 24), #chief#gdw50
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_move_cattle_herd1"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (call_script, "script_cf_select_random_town_at_peace_with_faction", ":giver_faction_no"),
	          (neq, ":giver_center_no", reg0),
	          (assign, ":quest_target_center", reg0),
	          (store_distance_to_party_from_party, ":dist",":giver_center_no",":quest_target_center"),
	          (assign, ":quest_gold_reward", ":dist"),
	          (val_add, ":quest_gold_reward", 20), #chief cambia40gdw
	          (val_mul, ":quest_gold_reward", 14),#gdw45
	          #(val_div, ":quest_gold_reward", 20),
	          (assign, ":quest_expiration_days", 30),
	          (assign, ":quest_dont_give_again_period", 35), #chief
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_persuade_lords_to_make_peace"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_faction_of_party, ":cur_object_faction", ":giver_center_no"),
	          (call_script, "script_cf_faction_get_random_enemy_faction", ":cur_object_faction"),
	          (assign, ":cur_target_faction", reg0),
	          (call_script, "script_cf_get_random_lord_except_king_with_faction", ":cur_object_faction"),
	          (assign, ":cur_object_troop", reg0),
					  ##diplomacy start+ chief
			  #may also be anyone with tmt_aristocrat > 0
			  (call_script, "script_dplmc_get_troop_morality_value", ":cur_object_troop", tmt_aristocratic),
			  (this_or_next|ge, reg0, 1),
			  ##diplomacy+
	 		 (this_or_next|troop_slot_eq, ":cur_object_troop", "slot_lord_reputation_type", lrep_quarrelsome),
			  (this_or_next|troop_slot_eq, ":cur_object_troop", "slot_lord_reputation_type", lrep_selfrighteous),
			  (this_or_next|troop_slot_eq, ":cur_object_troop", "slot_lord_reputation_type", lrep_martial),
				(troop_slot_eq, ":cur_object_troop", "slot_lord_reputation_type", lrep_debauched),
			  
	          (call_script, "script_cf_get_random_lord_except_king_with_faction", ":cur_target_faction"),
	          (assign, ":quest_target_troop", reg0),
					  ##diplomacy start+ chief
			  #may also be anyone with tmt_aristocrat > 0
			  (call_script, "script_dplmc_get_troop_morality_value", ":quest_target_troop", tmt_aristocratic),
			  (this_or_next|ge, reg0, 1),
			  ##diplomacy+
	  			(this_or_next|troop_slot_eq, ":quest_target_troop", "slot_lord_reputation_type", lrep_quarrelsome),
			  (this_or_next|troop_slot_eq, ":quest_target_troop", "slot_lord_reputation_type", lrep_selfrighteous),
			  (this_or_next|troop_slot_eq, ":quest_target_troop", "slot_lord_reputation_type", lrep_martial),
			  (troop_slot_eq, ":quest_target_troop", "slot_lord_reputation_type", lrep_debauched),
			  			  
	          (assign, ":quest_object_troop", ":cur_object_troop"),
	          (assign, ":quest_target_faction", ":cur_target_faction"),
	          (assign, ":quest_object_faction", ":cur_object_faction"),
	          (assign, ":quest_gold_reward", 10000),#gdw12000 it costs less than 10000 to simply pay off lords
	          (assign, ":quest_convince_value", 8400),#gdw
	          (assign, ":quest_expiration_days", 33),#gdw
	          (assign, ":quest_dont_give_again_period", 30), #chief#gdw
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_deal_with_looters"),
	          (is_between, ":player_level", 0, 15),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_faction_of_party, ":cur_object_faction", ":giver_center_no"),
	          (store_num_parties_destroyed_by_player, ":num_looters_destroyed", "pt_looters"),
	          (party_template_set_slot,"pt_looters","slot_party_template_num_killed",":num_looters_destroyed"),
	          (quest_set_slot,":quest_no","slot_quest_current_state",0),
	          (quest_set_slot,":quest_no","slot_quest_target_party_template","pt_looters"),
	          (assign, ":quest_gold_reward", 500),
	          (assign, ":quest_xp_reward", 700),#gdw
	          (assign, ":quest_expiration_days", 20),
	          (assign, ":quest_dont_give_again_period", 40), #chief#gdw
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_deal_with_night_bandits"),
	          (is_between, ":player_level", 0, 15),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (party_slot_ge, ":giver_center_no", "slot_center_has_bandits", 1),
	          (assign, ":quest_target_center", ":giver_center_no"),
	          (assign, ":quest_expiration_days", 4),
	          (assign, ":quest_dont_give_again_period", 60), #chief
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          # Lady quests
	          (eq, ":quest_no", "qst_rescue_lord_by_replace"),
			  (eq, 1, 0),
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (is_between, ":player_level", 5, 29), #gdw
	            
	            (assign, ":prisoner_relative", -1),
	            
	            (try_begin),
                  (troop_get_slot, ":cur_target_troop", ":giver_troop", "slot_troop_father"), #get giver_troop's father
	              (gt, ":cur_target_troop", 0), #if giver_troop has a father as a troop in game
                  (troop_slot_ge, ":cur_target_troop", "slot_troop_prisoner_of_party", 0), #if giver_troop's father is in a prison
                  (assign, ":prisoner_relative", ":cur_target_troop"),	              
	            (try_end),
	            
	            (try_begin),
	              (eq, ":prisoner_relative", -1), #if giver_troop has no father or giver_troop's father is not in prison.
	              (troop_get_slot, ":cur_target_troop", ":giver_troop", "slot_troop_spouse"), #get giver_troop's spouse
	              (gt, ":cur_target_troop", 0), #if giver_troop has a spouse as a troop in game	              
                  (troop_slot_ge, ":cur_target_troop", "slot_troop_prisoner_of_party", 0), #if giver_troop's spouse is in a prison
	              (assign, ":prisoner_relative", ":cur_target_troop"),
				(try_end),  
				
	            (try_begin),
	              (eq, ":prisoner_relative", -1), #if ((giver_troop has no father) or (giver_troop's father is not in prison)) and ((giver_troop has no spouse) or (giver_troop's spouse is not in prison)).
	              (troop_get_slot, ":cur_target_troop", ":giver_troop", "slot_troop_guardian"), #get giver_troop's spouse
	              (gt, ":cur_target_troop", 0), #if giver_troop has a guardian as a troop in game	              
                  (troop_slot_ge, ":cur_target_troop", "slot_troop_prisoner_of_party", 0), #if giver_troop's guardian is in a prison
	              (assign, ":prisoner_relative", ":cur_target_troop"),
				(try_end),
				
				(try_begin),
				  (eq, "$cheat_mode", 1),
				  (assign, reg0, ":prisoner_relative"),
				  (display_message, "str_prisoner_relative_is_reg0"),
				(try_end),
									            
				(gt, ":prisoner_relative", -1),
	            #(changed 2) no need to this anymore (troop_slot_ge, ":prisoner_relative", "slot_troop_prisoner_of_party", 0),
	            (call_script, "script_search_troop_prisoner_of_party", ":prisoner_relative"),
	            (assign, ":cur_target_center", reg0),	            
	            
	            #(changed 3) no need to check only towns anymore (is_between, ":cur_target_center", towns_begin, towns_end),#Skip if he is not in a town
	            (is_between, ":cur_target_center", walled_centers_begin, walled_centers_end), #Skip if he is not in a walled center
	            
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_target_troop", ":prisoner_relative"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 30), #chief#gdw
	            (assign, ":result", ":quest_no"),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_deliver_message_to_prisoner_lord"),
			  (eq, "$player_has_homage", 0),
			  
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (is_between, ":player_level", 5, 25),
	            (troop_get_slot, ":cur_target_troop", ":giver_troop", "slot_troop_father"),
	            (try_begin),
	              (eq, ":cur_target_troop", 0),
	              (troop_get_slot, ":cur_target_troop", ":giver_troop", "slot_troop_spouse"),
	            (try_end),
	            #(troop_slot_eq, ":cur_target_troop", "slot_troop_is_prisoner", 1),#Skip if the lady's father/husband is not in prison
				(gt, ":cur_target_troop", -1),
	            (troop_slot_ge, ":cur_target_troop", "slot_troop_prisoner_of_party", 0),
	            (call_script, "script_search_troop_prisoner_of_party", ":cur_target_troop"),
	            (assign, ":cur_target_center", reg0),
	            (is_between, ":cur_target_center", towns_begin, towns_end),#Skip if he is not in a town
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 80), #chief
	            (assign, ":result", ":quest_no"),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_duel_for_lady"),
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (ge, ":player_level", 10),
	            (call_script, "script_cf_troop_get_random_enemy_troop_with_occupation", ":giver_troop", slto_kingdom_hero),#Can fail
	            (assign, ":cur_target_troop", reg0),
	            (neg|troop_slot_eq, ":giver_troop", "slot_troop_spouse", ":cur_target_troop"), #must not be in the family
	            (neg|troop_slot_eq, ":giver_troop", "slot_troop_father", ":cur_target_troop"),
	            (neg|troop_slot_ge, ":cur_target_troop", "slot_troop_prisoner_of_party", 0),
	            (troop_slot_ge, ":cur_target_troop", "slot_troop_leaded_party", 0),
	          ##diplomacy start+ add benefactor ~ goodnatured/upstanding equivalence chief
                (neg|troop_slot_eq, ":cur_target_troop", "slot_lord_reputation_type", lrep_benefactor),
                #also disable challenging conventional & moralist ladies
                (neg|troop_slot_eq, ":cur_target_troop", "slot_lord_reputation_type", lrep_conventional),
                (neg|troop_slot_eq, ":cur_target_troop", "slot_lord_reputation_type", lrep_moralist),
                #diplomacy end+
               (neg|troop_slot_eq, ":cur_target_troop", "slot_lord_reputation_type", lrep_goodnatured),
	            (neg|troop_slot_eq, ":cur_target_troop", "slot_lord_reputation_type", lrep_upstanding),
	            (neg|troop_slot_eq, ":cur_target_troop", "slot_lord_reputation_type", lrep_martial),
				
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 90), #chief
	            (assign, ":result", ":quest_no"),
	          (try_end),
	          # Enemy Lord Quests
	        (else_try),
	          (eq, ":quest_no", "qst_lend_surgeon"),
	          (try_begin),
	            (eq, "$g_defending_against_siege", 0),#Skip if the center is under siege (because of resting)
	            (neq, ":giver_reputation", lrep_quarrelsome),
	            (neq, ":giver_reputation", lrep_debauched),
	            (assign, ":max_surgery_level", 0),
	            (assign, ":best_surgeon", -1),
	            (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
	            (try_for_range, ":i_stack", 1, ":num_stacks"),
	              (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
	              (troop_is_hero, ":stack_troop"),
	              (store_skill_level, ":cur_surgery_skill", skl_surgery, ":stack_troop"),
	              (gt, ":cur_surgery_skill", ":max_surgery_level"),
	              (assign, ":max_surgery_level", ":cur_surgery_skill"),
	              (assign, ":best_surgeon", ":stack_troop"),
	            (try_end),
	            
	            (store_character_level, ":cur_level", "trp_player"),
	            (assign, ":required_skill", 5),
	            (val_div, ":cur_level", 10),
	            (val_add, ":required_skill", ":cur_level"),
	            (ge, ":max_surgery_level", ":required_skill"), #Skip if party skill level is less than the required value
	            
	            (assign, ":quest_object_troop", ":best_surgeon"),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 600),#gdw
	            (assign, ":quest_gold_reward", 100),
	            (assign, ":quest_dont_give_again_period", 80), #chief#gdw
	            (assign, ":result", ":quest_no"),
	          (try_end),
	          # Lord Quests
	        (else_try),
	          (eq, ":quest_no", "qst_meet_spy_in_enemy_town"),
			  (eq, "$player_has_homage", 0),
			  
	          (try_begin),
	            (eq, "$players_kingdom", ":giver_faction_no"),
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (neq, ":giver_reputation", lrep_martial),
				
	            (call_script, "script_troop_get_player_relation", ":giver_troop"),
	            (assign, ":giver_relation", reg0),
	            (gt, ":giver_relation", 3),
	            (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),
	            (assign, ":enemy_faction", reg0),
	            (store_relation, ":reln", ":enemy_faction", "fac_player_supporters_faction"),
	            (lt, ":reln", 0),
	            (call_script, "script_cf_select_random_town_with_faction", ":enemy_faction"),
	            (assign, ":cur_target_center", reg0),
	            #Just to make sure that there is a free walker
	            (call_script, "script_cf_center_get_free_walker", ":cur_target_center"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (store_random_in_range, ":quest_target_amount", secret_signs_begin, secret_signs_end),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_gold_reward", 600),#gdw
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 30), #chief#gdw
	            (quest_set_slot, "qst_meet_spy_in_enemy_town", "slot_quest_gold_reward", 500),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_raid_caravan_to_start_war"),
			  (eq, 1, 0), #disable this as a random quest
			  
	          (try_begin),
	            (eq, "$players_kingdom", ":giver_faction_no"),
	            (this_or_next|eq, ":giver_reputation", lrep_cunning),
	            (this_or_next|eq, ":giver_reputation", lrep_quarrelsome),
	            (             eq, ":giver_reputation", lrep_debauched),
	            (gt, ":player_level", 10),
				(eq, 1, 0), #disable this as a random quest
				
	            (neg|faction_slot_eq, ":giver_faction_no", "slot_faction_leader", ":giver_troop"),#Can not take the quest from the king
	            (call_script, "script_cf_faction_get_random_friendly_faction", ":giver_faction_no"),#Can fail
	            (assign, ":quest_target_faction", reg0),
	            (store_troop_faction, ":quest_object_faction", ":giver_troop"),
	            (assign, ":quest_target_party_template", "pt_kingdom_caravan_party"),
	            (assign, ":quest_target_amount", 2),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 150), #chief
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_deliver_message"),
			  (eq, "$player_has_homage", 0),
			  
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (lt, ":player_level", 20),
			    (neg|troop_slot_ge, "trp_player", "slot_troop_renown", 125),
	            (call_script, "script_cf_get_random_lord_in_a_center_with_faction", ":giver_faction_no"),#Can fail
	            (assign, ":cur_target_troop", reg0),
	            (neq, ":cur_target_troop", ":giver_troop"),#Skip himself
	            (call_script, "script_get_troop_attached_party", ":cur_target_troop"),
	            (assign, ":cur_target_center", reg0),#cur_target_center will definitely be a valid center
	            (neq,":giver_center_no", ":cur_target_center"),#Skip current center

	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_xp_reward", 35),
	            (assign, ":quest_gold_reward", 40),
	            (assign, ":quest_dont_give_again_period", 25), #chief
				
	            (assign, ":result", ":quest_no"),
	      
	            (assign, ":quest_expiration_days", 30),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_escort_lady"),
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (ge, ":player_level", 10),

				(ge, ":giver_troop", 0), #skip troops without fathers in range				

				(assign, ":cur_object_troop", -1),
                (try_for_range, ":lady", kingdom_ladies_begin, kingdom_ladies_end),
				  (troop_slot_eq, ":lady", "slot_troop_father", ":giver_troop"),
				  (assign, ":cur_object_troop", ":lady"),
				(try_end),

				(ge, ":cur_object_troop", 0),
							
				(troop_get_slot, ":giver_troop_confirm", ":cur_object_troop", "slot_troop_father"),  # just to make sure
				(eq, ":giver_troop", ":giver_troop_confirm"), # just to make sure

	            (store_random_in_range, ":random_no", 0, 2),
	            (try_begin),
	              (eq, ":random_no", 0),
	              (troop_get_slot, ":cur_object_troop_2", ":giver_troop", "slot_troop_spouse"),
				  (is_between, ":cur_object_troop_2", kingdom_ladies_begin, kingdom_ladies_end),
				  (troop_get_slot, ":giver_troop_confirm", ":cur_object_troop_2", "slot_troop_spouse"),  # just to make sure
				  (eq, ":giver_troop", ":giver_troop_confirm"), # just to make sure
	              (assign, ":cur_object_troop", ":cur_object_troop_2"),
	            (try_end),

	            (gt, ":cur_object_troop", 0),#Skip lords without a lady
	            (troop_get_type, ":cur_troop_gender", ":cur_object_troop"),
###gender fix chief
       (this_or_next|eq, ":cur_troop_gender", 1), #Skip if it is not female
       (this_or_next|eq, ":cur_troop_gender", 3), #Skip if it is not female
       (this_or_next|eq, ":cur_troop_gender", 5), #Skip if it is not female
       (eq, ":cur_troop_gender", 7), #Skip if it is not female
#gender fix chief acaba
	            (gt, ":giver_center_no", 0),#Skip if lord is outside the center
	            (troop_slot_eq, ":cur_object_troop", "slot_troop_cur_center", ":giver_center_no"),#Skip if the lady is not at the same center
	            (call_script, "script_cf_select_random_town_with_faction", ":giver_faction_no"),#Can fail
	            (assign, ":cur_target_center", reg0),
	            (neq, ":cur_target_center", ":giver_center_no"),
	            (hero_can_join),#Skip if player has no available slots

	            (assign, ":quest_object_troop", ":cur_object_troop"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_expiration_days", 20),
	            (assign, ":quest_dont_give_again_period", 60), #chief
	            (assign, ":result", ":quest_no"),
	          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_hunt_down_raiders"),
##          (try_begin),
##            (gt, ":player_level", 10),
##            (faction_slot_eq, ":giver_faction_no", "slot_faction_leader", ":giver_troop"),
##            (call_script, "script_cf_select_random_town_with_faction", ":giver_faction_no"),#Can fail
##            (assign, ":cur_object_center", reg0),
##            (neq, ":cur_object_center", ":giver_center_no"),#Skip current center
##            (call_script, "script_get_random_enemy_center", ":giver_party_no"),
##            (assign, ":cur_target_center", reg0),
##            (ge, ":cur_target_center", 0),
##            (store_faction_of_party, ":cur_target_faction", ":cur_target_center"),
##            (is_between,  ":cur_target_faction", kingdoms_begin, kingdoms_end),
##
##            (assign, ":quest_object_center", ":cur_object_center"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 1500),
##            (assign, ":quest_gold_reward", 1000),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_bring_back_deserters"),
##          (try_begin),
##            (gt, ":player_level", 5),
##            (faction_get_slot, ":cur_target_party_template", ":giver_faction_no", "slot_faction_deserter_party_template"),
##            (faction_get_slot, ":cur_target_troop", ":giver_faction_no", "slot_faction_deserter_troop"),
##            (gt, ":cur_target_party_template", 0),#Skip factions with no deserter party templates
##            (store_num_parties_of_template, ":num_deserters", ":cur_target_party_template"),
##            (ge, ":num_deserters", 2),#Skip if there are less than 2 active deserter parties
##
##            (assign, ":quest_target_troop", ":cur_target_troop"),
##            (assign, ":quest_target_party_template", ":cur_target_party_template"),
##            (assign, ":quest_target_amount", 5),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 500),
##            (assign, ":quest_gold_reward", 300),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_deliver_supply_to_center_under_siege"),
##          (try_begin),
##            (gt, ":player_level", 10),
##            (gt, ":giver_center_no", 0),#Skip if lord is outside the center
##            (call_script, "script_cf_get_random_siege_location_with_faction", ":giver_faction_no"),#Can fail
##            (assign, ":quest_target_center", reg0),
##            (assign, ":quest_target_amount", 10),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 500),
##            (assign, ":quest_gold_reward", 300),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_rescue_lady_under_siege"),
##          (try_begin),
##            (gt, ":player_level", 15),
##            (troop_get_slot, ":cur_object_troop", ":giver_troop", "slot_troop_daughter"),
##            (store_random_in_range, ":random_no", 0, 2),
##            (try_begin),
##              (this_or_next|eq,  ":cur_object_troop", 0),
##              (eq, ":random_no", 0),
##              (troop_get_slot, ":cur_object_troop_2", ":giver_troop", "slot_troop_spouse"),
##              (gt, ":cur_object_troop_2", 0),
##              (assign, ":cur_object_troop", ":cur_object_troop_2"),
##            (try_end),
##            (gt, ":cur_object_troop", 0),#Skip lords without a lady
##            (troop_get_type, ":cur_troop_gender", ":cur_object_troop"),
##            (eq, ":cur_troop_gender", 1),#Skip if lady is not female
##            (troop_get_slot, ":cur_target_center", ":cur_object_troop", "slot_troop_cur_center"),
##            (is_between, ":cur_target_center", centers_begin, centers_end),#Skip if she is not in a center
##            (neq,":giver_center_no", ":cur_target_center"),#Skip current center
##            (call_script, "script_cf_get_random_siege_location_with_faction", ":giver_faction_no"),#Can fail
##            (assign, ":cur_target_center", reg0),
##            (troop_set_slot, ":cur_object_troop", "slot_troop_cur_center", ":cur_target_center"),#Move lady to the siege location
##            (assign, ":quest_object_troop", ":cur_object_troop"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":quest_target_troop", ":giver_troop"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 200),
##            (assign, ":quest_gold_reward", 750),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_deliver_message_to_lover"),
##          (try_begin),
##            (is_between, ":player_level", 5, 30),
##            (troop_get_slot, ":cur_target_troop", ":giver_troop", "slot_troop_lover"),
##            (gt, ":cur_target_troop", 0),#Skip lords without a lover
##            (troop_get_slot, ":cur_target_center", ":cur_target_troop", "slot_troop_cur_center"),
##            (is_between, ":cur_target_center", centers_begin, centers_end),#Skip if she is not in a center
##            (neq,":giver_center_no", ":cur_target_center"),#Skip current center
##            (assign, ":quest_target_troop", ":cur_target_troop"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_bring_reinforcements_to_siege"),
##          (try_begin),
##            (gt, ":player_level", 10),
##            (call_script, "script_cf_get_random_siege_location_with_attacker_faction", ":giver_faction_no"),#Can fail
##            (assign, ":cur_target_center", reg0),
##            (store_random_in_range, ":random_no", 5, 11),
##            (troops_can_join, ":random_no"),#Skip if the player doesn't have enough room
##            (call_script, "script_cf_get_number_of_random_troops_from_party", ":giver_party_no", ":random_no"),#Can fail
##            (assign, ":cur_object_troop", reg0),
##            (party_get_battle_opponent, ":cur_target_party", ":cur_target_center"),
##            (party_get_num_companion_stacks, ":num_stacks", ":cur_target_party"),
##            (gt, ":num_stacks", 0),#Skip if the besieger party has no troops
##            (party_stack_get_troop_id, ":cur_target_troop", ":cur_target_party", 0),
##            (troop_is_hero, ":cur_target_troop"),#Skip if the besieger party has no heroes
##            (neq, ":cur_target_troop", ":giver_troop"),#Skip if the quest giver is the same troop
##            (assign, ":quest_target_troop", ":cur_target_troop"),
##            (assign, ":quest_object_troop", ":cur_object_troop"),
##            (assign, ":quest_target_party", ":cur_target_party"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":quest_target_amount", ":random_no"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 400),
##            (assign, ":quest_gold_reward", 200),
##            (assign, ":result", ":quest_no"),
##          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_deliver_message_to_enemy_lord"),
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (is_between, ":player_level", 5,26),#gdw
	            (call_script, "script_cf_get_random_lord_from_another_faction_in_a_center", ":giver_faction_no"),#Can fail
	            (assign, ":cur_target_troop", reg0),
	            (call_script, "script_get_troop_attached_party", ":cur_target_troop"),
	            (assign, ":quest_target_center", reg0),#quest_target_center will definitely be a valid center
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 220),#gdw
	            (assign, ":quest_gold_reward", 0),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 40),
	          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_bring_prisoners_to_enemy"),
##          (try_begin),
##            (gt, ":player_level", 10),
##            (is_between, ":giver_center_no", centers_begin, centers_end),#Skip if the quest giver is not at a center
##            (store_random_in_range, ":random_no", 5, 11),
##            (troops_can_join_as_prisoner, ":random_no"),#Skip if the player doesn't have enough room
##            (call_script, "script_get_random_enemy_town", ":giver_center_no"),
##            (assign, ":cur_target_center", reg0),
##            (ge, ":cur_target_center", 0),#Skip if there are no enemy towns
##            (store_faction_of_party, ":cur_target_faction", ":cur_target_center"),
##            (faction_get_slot, ":cur_object_troop", ":cur_target_faction", "slot_faction_tier_5_troop"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":quest_object_troop", ":cur_object_troop"),
##            (assign, ":quest_target_amount", ":random_no"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 300),
##            (assign, ":quest_gold_reward", 200),
##            (assign, ":result", ":quest_no"),
##          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_deal_with_bandits_at_lords_village"),
	          (try_begin),
	            (neq, ":giver_reputation", lrep_debauched), 
	            (neq, ":giver_reputation", lrep_quarrelsome), 
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (assign, ":end_cond", villages_end),
	            (assign, ":cur_target_center", -1),
	            (try_for_range, ":cur_village", villages_begin, ":end_cond"),
	              (party_slot_eq, ":cur_village", "slot_town_lord", ":giver_troop"),
	              (party_slot_eq, ":cur_village", "slot_village_infested_by_bandits", 1),
	              (party_slot_eq, ":cur_village", "slot_village_state", svs_normal),
	              (assign, ":cur_target_center", ":cur_village"),
	              (assign, ":end_cond", 0),
	            (try_end),
	            (ge, ":cur_target_center", 0),
	            (neg|check_quest_active, "qst_eliminate_bandits_infesting_village"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_raise_troops"),
	          (try_begin),
	            (neq, ":giver_reputation", lrep_martial),
	            (neq, ":giver_faction_no", "fac_player_supporters_faction"), #we need tier_1_troop a valid value
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (store_character_level, ":cur_level", "trp_player"),
	            (gt, ":cur_level", 5),
	            (troop_slot_ge, "trp_player", "slot_troop_renown", 100),
	             
	            (store_random_in_range, ":quest_target_amount", 5, 8),
	            (party_get_free_companions_capacity, ":free_capacity", "p_main_party"),
	            (le, ":quest_target_amount", ":free_capacity"),
	            (faction_get_slot, ":quest_object_troop", ":giver_faction_no", "slot_faction_tier_1_troop"),
	            (store_random_in_range, ":level_up", 20, 28),#gdw40
	            (val_add, ":level_up", ":cur_level"),
	            (val_div, ":level_up", 10),

	            (store_mul, ":quest_gold_reward", ":quest_target_amount", 14),#gdw10

	            (assign, ":quest_target_troop", ":quest_object_troop"),
	            (try_for_range, ":unused", 0, ":level_up"),
	              (troop_get_upgrade_troop, ":level_up_troop", ":quest_target_troop", 0),
	              (gt, ":level_up_troop", 0),
	              (assign, ":quest_target_troop", ":level_up_troop"),
	              (val_mul, ":quest_gold_reward", ":quest_gold_reward", 7),
	              (val_div, ":quest_gold_reward", ":quest_gold_reward", 4),
	            (try_end),
	      
	            (assign, ":quest_xp_reward", ":quest_gold_reward"),
	            (val_mul, ":quest_xp_reward", 7),#gdw
	            (val_div, ":quest_xp_reward", 10),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 120),
	            (assign, ":quest_dont_give_again_period", 60), #chief
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_collect_taxes"),
			  (eq, "$player_has_homage", 0),
			  
	          (try_begin),
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (neq, ":giver_reputation", lrep_upstanding),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (call_script, "script_cf_troop_get_random_leaded_town_or_village_except_center", ":giver_troop", ":giver_center_no"),
	            (assign, ":quest_target_center", reg0),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_gold_reward", 0),
	            (assign, ":quest_xp_reward", 100),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 50), #chief
	            (assign, ":quest_dont_give_again_period", 45),#gdw
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_hunt_down_fugitive"),
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
	            (assign, ":quest_target_center", reg0),
	            (store_random_in_range, ":quest_target_dna", 0, 1000000),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30), #chief
	            (assign, ":quest_dont_give_again_period", 80),#gdw
	          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_capture_messenger"),
##          (try_begin),
##            (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),
##            (assign, ":cur_target_faction", reg0),
##            (faction_get_slot, ":cur_target_troop", ":cur_target_faction", "slot_faction_messenger_troop"),
##            (gt, ":cur_target_troop", 0),#Checking the validiy of cur_target_troop
##            (store_num_parties_destroyed_by_player, ":quest_target_amount", "pt_messenger_party"),
##
##            (assign, ":quest_target_troop", ":cur_target_troop"),
##            (assign, ":quest_target_party_template", ":cur_target_party_template"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 700),
##            (assign, ":quest_gold_reward", 400),
##            (assign, ":result", ":quest_no"),
##          (try_end),
		        (else_try),
	          (eq, ":quest_no", "qst_kill_local_merchant"),
			  (eq, "$player_has_homage", 0),

	          (try_begin),
                ##diplomacy start+
				#Lords who dislike breaking deals do not give this quest
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_honest),
				(lt, reg0, 1),
				#Roguish lords can give the Kill Local Merchant quest, unless they dislike murder.
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
	            (this_or_next|neq, ":giver_reputation", lrep_roguish),
					(lt, reg0, 1),
				#Ambitious ladies can give this quest
				(this_or_next|eq, ":giver_reputation", lrep_ambitious),
				(this_or_next|eq, ":giver_reputation", lrep_roguish),
                ##diplomacy end+
	            (this_or_next|eq, ":giver_reputation", lrep_quarrelsome),
	            (this_or_next|eq, ":giver_reputation", lrep_cunning),
	            (             eq, ":giver_reputation", lrep_debauched),
	            (neg|faction_slot_eq, ":giver_faction_no", "slot_faction_leader", ":giver_troop"),#Can not take the quest from the king
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (gt, ":player_level", 5),
	            (is_between, ":giver_center_no", towns_begin, towns_end),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 330),#gdw300
	            (assign, ":quest_gold_reward", 1000),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 10),
	            (assign, ":quest_dont_give_again_period", 100), #chief
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_bring_back_runaway_serfs"),
	          (try_begin),
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (neq, ":giver_reputation", lrep_upstanding),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (ge, ":player_level", 5),
	            (gt, ":giver_center_no", 0),#Skip if lord is outside the center
	            (eq, "$g_defending_against_siege", 0),#Skip if the center is under siege (because of resting)
	      
	            (assign, ":cur_object_center", -1),
	            (try_for_range, ":cur_village", villages_begin, villages_end),
	              (party_slot_eq, ":cur_village", "slot_town_lord", ":giver_troop"),
	              (store_distance_to_party_from_party, ":dist", ":cur_village", ":giver_center_no"),
	              (lt, ":dist", 25),
	              (assign, ":cur_object_center", ":cur_village"),
	            (try_end),
	            (ge, ":cur_object_center", 0),#Skip if the quest giver is not the owner of any villages around the center
	            (call_script, "script_cf_select_random_town_with_faction", ":giver_faction_no"),
	            (assign, ":cur_target_center", reg0),
	            (neq, ":cur_target_center", ":giver_center_no"),#Skip current center
	            (store_distance_to_party_from_party, ":dist", ":cur_target_center", ":giver_center_no"),
	            (ge, ":dist", 20),
	            (assign, ":quest_target_party_template", "pt_runaway_serfs"),
	            (assign, ":quest_object_center", ":cur_object_center"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 250),#gdw
	            (assign, ":quest_gold_reward", 170),#gdw
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 60), #chief
	            (assign, "$qst_bring_back_runaway_serfs_num_parties_returned", 0),
	            (assign, "$qst_bring_back_runaway_serfs_num_parties_fleed", 0),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_follow_spy"),
			  (eq, "$player_has_homage", 0),
			  
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (party_get_skill_level, ":tracking_skill", "p_main_party", "skl_tracking"),
	            (ge, ":tracking_skill", 2),
	            (ge, ":player_level", 10),
	            (eq, "$g_defending_against_siege", 0), #Skip if the center is under siege (because of resting)
	            (gt, ":giver_party_no", 0), #Skip if the quest giver doesn't have a party
	            (gt, ":giver_center_no", 0), #skip if the quest giver is not in a center
	            (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_town), #skip if we are not in a town.
	            (party_get_position, pos2, "p_main_party"),
	            (assign, ":min_distance", 99999),
                    (assign, ":cur_object_center", -1),
	            (try_for_range, ":unused_2", 0, 10),
	              (call_script, "script_cf_get_random_enemy_center", ":giver_party_no"),
	              (assign, ":random_object_center", reg0),
	              (party_get_position, pos3, ":random_object_center"),
	              (map_get_random_position_around_position, pos4, pos3, 6),
	              (get_distance_between_positions, ":cur_distance", pos2, pos4),
	              (lt, ":cur_distance", ":min_distance"),
	              (assign, ":min_distance", ":cur_distance"),
	              (assign, ":cur_object_center", ":random_object_center"),
	              (copy_position, pos63, pos4), #Do not change pos63 until quest is accepted
	            (try_end),
	            (gt, ":cur_object_center", 0), #Skip if there are no enemy centers

	            (assign, ":quest_object_center", ":cur_object_center"),
	            (assign, ":quest_dont_give_again_period", 50),
	            (assign, ":result", ":quest_no"),
	            (assign, "$qst_follow_spy_run_away", 0),
	            (assign, "$qst_follow_spy_meeting_state", 0),
	            (assign, "$qst_follow_spy_meeting_counter", 0),
	            (assign, "$qst_follow_spy_spy_back_in_town", 0),
	            (assign, "$qst_follow_spy_partner_back_in_town", 0),
	            (assign, "$qst_follow_spy_no_active_parties", 0),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_capture_enemy_hero"),
	          (try_begin),
	            (eq, "$players_kingdom", ":giver_faction_no"),
	            (neg|faction_slot_eq, "$players_kingdom", "slot_faction_marshall", "trp_player"),
	            (ge, ":player_level", 15),
	            (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),#Can fail
	            (assign, ":quest_target_faction", reg0),
	            (assign, ":quest_expiration_days", 35),#gdw
	            (assign, ":quest_dont_give_again_period", 80),
	            (assign, ":quest_gold_reward", 2300),#gdw
	            (assign, ":result", ":quest_no"),
	          (try_end),
	        (else_try),
	            companions.quest,
	        (else_try),
	          (eq, ":quest_no", "qst_collect_debt"),
			  (eq, 1, 0), #disable this quest pending talk with armagan
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	          # Find a vassal (within the same kingdom?) 
	            (call_script, "script_cf_get_random_lord_in_a_center_with_faction", ":giver_faction_no"),#Can fail
	            (assign, ":quest_target_troop", reg0),
	            (neq, ":quest_target_troop", ":giver_troop"),#Skip himself
	            (call_script, "script_get_troop_attached_party", ":quest_target_troop"),
	            (assign, ":quest_target_center", reg0),#cur_target_center will definitely be a valid center
	            (neq,":giver_center_no", ":quest_target_center"),#Skip current center

	            (assign, ":quest_xp_reward", 33),#gdw
	            (assign, ":quest_gold_reward", 40),
	            (assign, ":result", ":quest_no"),
	            (store_random_in_range, ":quest_target_amount", 6, 9),
	            (val_mul, ":quest_target_amount", 500),
	            (store_div, ":quest_convince_value", ":quest_target_amount", 5),
	            (assign, ":quest_expiration_days", 90),
	            (assign, ":quest_dont_give_again_period", 20),
	          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_capture_conspirators"),
##          (try_begin),
##            (eq, 1,0), #TODO: disable this for now
##            (ge, ":player_level", 10),
##            (is_between, ":giver_center_no", towns_begin, towns_end),#Skip if quest giver's center is not a town
##            (party_slot_eq, ":giver_center_no", "slot_town_lord", ":giver_troop"),#Skip if the current center is not ruled by the quest giver
##            (call_script, "script_cf_get_random_kingdom_hero", ":giver_faction_no"),#Can fail
##
##            (assign, ":quest_target_troop", reg0),
##            (assign, ":quest_target_center", ":giver_center_no"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 10),
##            (assign, ":quest_gold_reward", 10),
##            (assign, ":result", ":quest_no"),
##            (store_character_level, ":cur_level"),
##            (val_div, ":cur_level", 5),
##            (val_max, ":cur_level", 3),
##            (store_add, ":max_parties", 4, ":cur_level"),
##            (store_random_in_range, "$qst_capture_conspirators_num_parties_to_spawn", 4, ":max_parties"),
##            (assign, "$qst_capture_conspirators_num_troops_to_capture", 0),
##            (assign, "$qst_capture_conspirators_num_parties_spawned", 0),
##            (assign, "$qst_capture_conspirators_leave_meeting_counter", 0),
##            (assign, "$qst_capture_conspirators_party_1", 0),
##            (assign, "$qst_capture_conspirators_party_2", 0),
##            (assign, "$qst_capture_conspirators_party_3", 0),
##            (assign, "$qst_capture_conspirators_party_4", 0),
##            (assign, "$qst_capture_conspirators_party_5", 0),
##            (assign, "$qst_capture_conspirators_party_6", 0),
##            (assign, "$qst_capture_conspirators_party_7", 0),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_defend_nobles_against_peasants"),
##          (try_begin),
##            (eq, 1,0), #TODO: disable this for now
##            (ge, ":player_level", 10),
##            (is_between, ":giver_center_no", towns_begin, towns_end),#Skip if quest giver's center is not a town
##            (party_slot_eq, ":giver_center_no", "slot_town_lord", ":giver_troop"),#Skip if the current center is not ruled by the quest giver
##
##            (assign, ":quest_target_center", ":giver_center_no"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 10),
##            (assign, ":quest_gold_reward", 10),
##            (assign, ":result", ":quest_no"),
##            (store_character_level, ":cur_level"),
##            (val_div, ":cur_level", 5),
##            (val_max, ":cur_level", 4),
##            (store_add, ":max_parties", 4, ":cur_level"),
##            (store_random_in_range, "$qst_defend_nobles_against_peasants_num_peasant_parties_to_spawn", 4, ":cur_level"),
##            (store_random_in_range, "$qst_defend_nobles_against_peasants_num_noble_parties_to_spawn", 4, ":cur_level"),
##            (assign, "$qst_defend_nobles_against_peasants_num_nobles_to_save", 0),
##            (assign, "$qst_defend_nobles_against_peasants_num_nobles_saved", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_1", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_2", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_3", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_4", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_5", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_6", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_7", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_8", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_1", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_2", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_3", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_4", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_5", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_6", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_7", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_8", 0),
##          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_incriminate_loyal_commander"),
			  (eq, "$player_has_homage", 0),
			  
	          (try_begin),
	            (neq, ":giver_reputation", lrep_upstanding),
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (eq, "$players_kingdom", ":giver_faction_no"),
	            (ge, ":player_level", 10),
	            (faction_slot_eq, ":giver_faction_no", "slot_faction_leader", ":giver_troop"),
	            (assign, ":try_times", 1),
	            (assign, ":found", 0),
	            (try_for_range, ":unused", 0, ":try_times"),
	              (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),#Can fail
	              (assign, ":cur_target_faction", reg0),

	              (faction_get_slot, ":cur_target_troop", ":cur_target_faction", "slot_faction_leader"),
	              (assign, ":num_centerless_heroes", 0),
	              (try_for_range, ":cur_kingdom_hero", active_npcs_begin, active_npcs_end),
	                (troop_slot_eq, ":cur_kingdom_hero", "slot_troop_occupation", slto_kingdom_hero),
	                #(troop_slot_eq, ":cur_kingdom_hero", "slot_troop_is_prisoner", 0),
	                (neg|troop_slot_ge, ":cur_kingdom_hero", "slot_troop_prisoner_of_party", 0),
	                (neq, ":cur_target_troop", ":cur_kingdom_hero"),
	                (store_troop_faction, ":cur_kingdom_hero_faction", ":cur_kingdom_hero"),
	                (eq, ":cur_target_faction", ":cur_kingdom_hero_faction"),
##                (call_script, "script_get_number_of_hero_centers", ":cur_kingdom_hero"),
##                (eq, reg0, 0),
	                (val_add, ":num_centerless_heroes", 1),
	              (try_end),
	              (gt, ":num_centerless_heroes", 0),
	              (assign, ":cur_object_troop", -1),
	              (store_random_in_range, ":random_kingdom_hero", 0, ":num_centerless_heroes"),
	              (try_for_range, ":cur_kingdom_hero", active_npcs_begin, active_npcs_end),
	                (eq, ":cur_object_troop", -1),
	                (troop_slot_eq, ":cur_kingdom_hero", "slot_troop_occupation", slto_kingdom_hero),
	                (neq, ":cur_target_troop", ":cur_kingdom_hero"),
	                (store_troop_faction, ":cur_kingdom_hero_faction", ":cur_kingdom_hero"),
	                (eq, ":cur_target_faction", ":cur_kingdom_hero_faction"),
##                (call_script, "script_get_number_of_hero_centers", ":cur_kingdom_hero"),
##                (eq, reg0, 0),
	                (val_sub, ":random_kingdom_hero", 1),
	                (lt, ":random_kingdom_hero", 0),
	                (assign, ":cur_object_troop", ":cur_kingdom_hero"),
	              (try_end),

	              (assign, ":cur_target_center", -1),
	              (call_script, "script_get_troop_attached_party", ":cur_target_troop"),
	              (is_between, reg0, towns_begin, towns_end),
	              (party_slot_eq, reg0, "slot_town_lord", ":cur_target_troop"),
	              (assign, ":cur_target_center", reg0),

	              (assign, ":try_times", -1),#Exit the second loop
	              (assign, ":found", 1),
	            (try_end),
	            (eq, ":found", 1),

	            (assign, "$incriminate_quest_sacrificed_troop", 0),

	            (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
	            (try_for_range, ":i_stack", 1, ":num_stacks"),
	              (eq ,"$incriminate_quest_sacrificed_troop", 0),
	              (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
	              (neg|troop_is_hero, ":stack_troop"),
	              (store_character_level, ":stack_troop_level", ":stack_troop"),
	              (ge, ":stack_troop_level", 25),
	              (assign, "$incriminate_quest_sacrificed_troop", ":stack_troop"),
	            (try_end),
	            (gt, "$incriminate_quest_sacrificed_troop", 0),

	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_object_troop", ":cur_object_troop"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_target_faction", ":cur_target_faction"),

	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 900),#gdw
	            (assign, ":quest_gold_reward", 1000),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 180),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_capture_prisoners"),
			  (eq, "$player_has_homage", 0),
			  
	          (try_begin),
	            (eq, "$players_kingdom", ":giver_faction_no"),
	            (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),#Can fail
	            (assign, ":cur_target_faction", reg0),
	            (store_add, ":max_tier_no", "slot_faction_tier_5_troop", 1),
	            (store_random_in_range, ":random_tier_no", "slot_faction_tier_2_troop", ":max_tier_no"),
	            (faction_get_slot, ":cur_target_troop", ":cur_target_faction", ":random_tier_no"),
	            (gt, ":cur_target_troop", 0),
	            (store_random_in_range, ":quest_target_amount", 3, 6),#gdw
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_target_faction", ":cur_target_faction"),
	            (assign, ":quest_importance", 1),
	            (store_character_level, ":quest_gold_reward", ":cur_target_troop"),
	            (val_add, ":quest_gold_reward", 8),#gdw5
	            (val_mul, ":quest_gold_reward", ":quest_gold_reward"),
	            (val_div, ":quest_gold_reward", 5),
	            (val_mul, ":quest_gold_reward", ":quest_target_amount"),
	            (assign, ":quest_xp_reward", ":quest_gold_reward"),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 90),
	            (assign, ":quest_dont_give_again_period", 40),#gdw
	          (try_end),
	        (try_end),
		(try_end),	
	  (try_end),
	  #end of quest finding
	  	  	  
	  
      (try_begin),
        (neq, ":result", -1),
        
        (try_begin),
          (party_is_active, ":quest_target_center"),
          (store_faction_of_party, ":quest_target_faction", ":quest_target_center"),
        (try_end),
        
        (quest_set_slot, ":result", "slot_quest_target_troop", ":quest_target_troop"),
        (quest_set_slot, ":result", "slot_quest_target_center", ":quest_target_center"),
        (quest_set_slot, ":result", "slot_quest_object_troop", ":quest_object_troop"),
        (quest_set_slot, ":result", "slot_quest_target_faction", ":quest_target_faction"),
        (quest_set_slot, ":result", "slot_quest_object_faction", ":quest_object_faction"),
        (quest_set_slot, ":result", "slot_quest_object_center", ":quest_object_center"),
        (quest_set_slot, ":result", "slot_quest_target_party", ":quest_target_party"),
        (quest_set_slot, ":result", "slot_quest_target_party_template", ":quest_target_party_template"),
        (quest_set_slot, ":result", "slot_quest_target_amount", ":quest_target_amount"),
        (quest_set_slot, ":result", "slot_quest_importance", ":quest_importance"),
        (quest_set_slot, ":result", "slot_quest_xp_reward", ":quest_xp_reward"),
        (quest_set_slot, ":result", "slot_quest_gold_reward", ":quest_gold_reward"),
        (quest_set_slot, ":result", "slot_quest_convince_value", ":quest_convince_value"),
        (quest_set_slot, ":result", "slot_quest_expiration_days", ":quest_expiration_days"),
        (quest_set_slot, ":result", "slot_quest_dont_give_again_period", ":quest_dont_give_again_period"),
        (quest_set_slot, ":result", "slot_quest_current_state", 0),
        (quest_set_slot, ":result", "slot_quest_giver_troop", ":giver_troop"),
        (quest_set_slot, ":result", "slot_quest_giver_center", ":giver_center_no"),
        (quest_set_slot, ":result", "slot_quest_target_dna", ":quest_target_dna"),
        (quest_set_slot, ":result", "slot_quest_target_item", ":quest_target_item"),
      (try_end),
      
      (assign, reg0, ":result"),
  ]),

  ("get_dynamic_quest",
  #Dynamic quests are rarer, more important quests
  #this is a separate script from get_quest, so that tavern keepers can scan all NPCs for quests 
    [
    (store_script_param_1, ":giver_troop"),
	
	(assign, ":result", -1),
	(assign, ":relevant_troop", -1),
	(assign, ":relevant_party", -1),
	(assign, ":relevant_faction", -1),
		
	(try_begin),
		(eq, ":giver_troop", -1),
		
	(else_try),
		#1 rescue prisoner		
		(neg|check_quest_active, "qst_rescue_prisoner"),
		(this_or_next|troop_slot_eq, ":giver_troop", "slot_troop_occupation", slto_kingdom_hero),
			(troop_slot_eq, ":giver_troop", "slot_troop_occupation", slto_kingdom_lady),

		(assign, ":target_troop", -1),	
		(try_for_range, ":possible_prisoner", active_npcs_begin, active_npcs_end),	
			(troop_get_slot, ":captor_location", ":possible_prisoner", "slot_troop_prisoner_of_party"),
			(is_between, ":captor_location", walled_centers_begin, walled_centers_end),
			(store_troop_faction, ":giver_troop_faction_no", ":giver_troop"),
			(store_faction_of_party, ":captor_location_faction_no", ":captor_location"),
			(store_relation, ":giver_captor_relation", ":giver_troop_faction_no", ":captor_location_faction_no"),
			(lt, ":giver_captor_relation", 0),
			
			(call_script, "script_troop_get_family_relation_to_troop", ":giver_troop", ":possible_prisoner"), 
			(ge, reg0, 10),
			
			(assign, ":offered_parole", 0),
			(try_begin),
				(call_script, "script_cf_prisoner_offered_parole", ":possible_prisoner"),
				(assign, ":offered_parole", 1),
			(try_end),
			(eq, ":offered_parole", 0),
			
			(neg|party_slot_eq, ":captor_location", "slot_town_lord", "trp_player"),
			
			(assign, ":target_troop", ":possible_prisoner"),
			(assign, ":target_party", ":captor_location"),
		(try_end),

		(gt, ":target_troop", -1),
		(assign, ":result", "qst_rescue_prisoner"),
		(assign, ":relevant_troop", ":target_troop"),
		(assign, ":relevant_party", ":target_party"),
		
	(else_try),
		#2 retaliate for border incident
		(is_between, ":giver_troop", mayors_begin, mayors_end),
		(store_faction_of_troop, ":giver_faction", ":giver_troop"),
		
		(neg|check_quest_active, "qst_retaliate_for_border_incident"),
		(quest_slot_eq, "qst_retaliate_for_border_incident", "slot_quest_dont_give_again_remaining_days", 0),
		(assign, ":target_leader", 0),
  
		(try_for_range, ":kingdom", "fac_kingdom_1", kingdoms_end),
			(call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":giver_faction", ":kingdom"),
			(assign, ":diplomatic_status", reg0),
			(eq, ":diplomatic_status", -1),
			(assign, ":duration", reg1),
			(ge, ":duration", 10),
			
			
			(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":lord_faction", ":lord"),
				(eq, ":lord_faction", ":kingdom"),
		
				(troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_debauched),
				
				(assign, ":target_leader", ":lord"),
				(assign, ":target_faction", ":kingdom"),
			(try_end),
		(try_end),
		(is_between, ":target_leader", active_npcs_begin, active_npcs_end),
		
		(assign, ":result", "qst_retaliate_for_border_incident"),
		(assign, ":relevant_troop", ":target_leader"),  
		(assign, ":relevant_faction", ":target_faction"),  
	(else_try), #Find bandit hideout
		(troop_slot_eq, ":giver_troop", "slot_troop_occupation", slto_kingdom_hero),
		(neg|check_quest_active, "qst_destroy_bandit_lair"),
		(quest_slot_eq, "qst_destroy_bandit_lair", "slot_quest_dont_give_again_remaining_days", 0),

#		(display_message, "@Checking for bandit lair quest"),
				
		(assign, ":lair_found", -1),
		
		(try_for_range, ":bandit_template", "pt_steppe_bandits", "pt_deserters"),
			(party_template_get_slot, ":bandit_lair", ":bandit_template", "slot_party_template_lair_party"),
						
			#No party is active because bandit lairs are removed as soon as they are attacked, by the player -- but can only be removed by the player. This will reset bandit lair to zero
			(gt, ":bandit_lair", "p_spawn_points_end"),
			
			(assign, ":closest_town", -1),
			(assign, ":score_to_beat", 99999),
			
			(try_for_range, ":town_no", towns_begin, towns_end),
				(store_distance_to_party_from_party, ":distance", ":bandit_lair", ":town_no"),
				(lt, ":distance", ":score_to_beat"),
				(assign, ":closest_town", ":town_no"),
				(assign, ":score_to_beat", ":distance"),
			(try_end),
			
			#(str_store_party_name, s7, ":closest_town"),
			#(party_get_slot, ":closest_town_lord", ":closest_town", "slot_town_lord"),						
			#(str_store_troop_name, s8, ":closest_town_lord"),						
			
			(party_slot_eq, ":closest_town", "slot_town_lord", ":giver_troop"),
			(assign, ":lair_found", ":bandit_lair"),
		(try_end),
		
		(gt, ":lair_found", "p_spawn_points_end"),
		
		(assign ,":result", "qst_destroy_bandit_lair"),
		(assign, ":relevant_party", ":lair_found"),  						  
	(else_try),  #3 - bounty on bandit party
		(is_between, ":giver_troop", mayors_begin, mayors_end),
		(neg|check_quest_active, "qst_track_down_bandits"),
		(quest_slot_eq, "qst_track_down_bandits", "slot_quest_dont_give_again_remaining_days", 0),

		(assign, ":cur_town", -1),
		(try_for_range, ":town", towns_begin, towns_end),
			(party_slot_eq, ":town", "slot_town_elder", ":giver_troop"),
			(assign, ":cur_town", ":town"),
		(try_end),
		(gt, ":cur_town", -1),
		
		(call_script, "script_merchant_road_info_to_s42", ":cur_town"), 
		(assign, ":bandit_party_found", reg0),
		(party_is_active, ":bandit_party_found"),
		(gt, ":bandit_party_found", 0),

        (try_begin),
            (eq, "$cheat_mode", 1),
            (display_message, "str_traveller_attack_found"),
        (try_end),
		
		(assign ,":result", "qst_track_down_bandits"),
		(assign, ":relevant_party", ":bandit_party_found"),  
	(else_try),  #raid a caravan to start war
		(troop_slot_eq, ":giver_troop", "slot_lord_reputation_type", lrep_debauched),
		(store_faction_of_troop, ":giver_troop_faction", ":giver_troop"),
		
		(assign, ":junior_debauched_lord_in_faction", -1),
		(try_for_range, ":lord_in_faction", active_npcs_begin, active_npcs_end),
			(troop_slot_eq, ":lord_in_faction", "slot_lord_reputation_type", lrep_debauched),
			(store_faction_of_troop, ":debauched_lord_faction", ":lord_in_faction"),
			(eq, ":debauched_lord_faction", ":giver_troop_faction"),
			(assign, ":junior_debauched_lord_in_faction", ":lord_in_faction"),
		(try_end),
		(eq, ":giver_troop", ":junior_debauched_lord_in_faction"),
		
		(assign, ":faction_to_attack", -1),
		(assign, ":faction_to_attack_score", -1),
		
	    (try_for_range, ":faction_candidate", kingdoms_begin, kingdoms_end),
			(neq, ":faction_candidate", ":giver_troop_faction"),
			(faction_slot_eq, ":faction_candidate", "slot_faction_state", sfs_active),
			(neq, ":faction_candidate", "$players_kingdom"),

			(store_relation, ":relation", ":faction_candidate", ":giver_troop_faction"),
			
			(store_add, ":provocation_slot", ":giver_troop_faction", "slot_faction_provocation_days_with_factions_begin"),
			(val_sub, ":provocation_slot", kingdoms_begin),
			(faction_get_slot, ":provocation_days", ":faction_candidate", ":provocation_slot"),
			
			(ge, ":relation", 0), #disqualifies if the faction is already at war
			(le, ":provocation_days", 0), #disqualifies if the faction has already provoked someone
			
			(store_random_in_range, ":faction_candidate_score", 0, 100),
				#add in scores - no truce?
				
#				(store_add, ":truce_slot", ":giver_troop_faction", "slot_faction_truce_days_with_factions_begin"),
#				(store_add, ":provocation_slot", ":giver_troop_faction", "slot_faction_provocation_days_with_factions_begin"),
#				(val_sub, ":truce_slot", kingdoms_begin),
#				(val_sub, ":provocation_slot", kingdoms_begin),				
#				(faction_slot_eq, ":faction_candidate", ":provocation_slot", 0),
#				(try_begin),
#					(faction_slot_ge, ":faction_candidate", ":truce_slot", 1),
#					(val_sub, ":faction_to_attack_temp_score", 1),
#				(try_end),
				
			(gt, ":faction_candidate_score", ":faction_to_attack_score"),
			(assign, ":faction_to_attack", ":faction_candidate"),
			(assign, ":faction_to_attack_score", ":faction_candidate_score"),
	    (try_end),
		
		(is_between, ":faction_to_attack", kingdoms_begin, kingdoms_end),
		
		(assign ,":result", "qst_cause_provocation"),
		(assign, ":relevant_faction", ":faction_to_attack"),  
		
	(try_end),  
  
    (assign, reg0, ":result"),
    (assign, reg1, ":relevant_troop"),
    (assign, reg2, ":relevant_party"),
    (assign, reg3, ":relevant_faction"),
  
    ]),  
  
  ("get_political_quest", 
  #Political quests are given by the player's political "coach" -- ie, a spouse or the minister -- to improve standing in the faction
  [
	(store_script_param, ":giver_troop", 1),
  
	(assign, ":result", -1),
	(assign, ":quest_target_troop", -1),
	(assign, ":quest_object_troop", -1),
	(assign, ":quest_dont_give_again_period", 7), #one week on average
	
	
	
	(try_begin), #this for kingdom hero, "we have a mutual enemy"
		(neg|check_quest_active, "qst_denounce_lord"),
		(try_begin),
			(ge, "$cheat_mode", 1),
			(quest_get_slot, reg4, "qst_denounce_lord", "slot_quest_dont_give_again_remaining_days"),
			(display_message, "@{!}DEBUG -- Checking for denounce lord, eligible in {reg4} days"),
		(try_end),	
		
		(neg|quest_slot_ge, "qst_denounce_lord", "slot_quest_dont_give_again_remaining_days", 1),
		(neq, ":giver_troop", "$g_player_minister"),
		(neg|troop_slot_eq, "trp_player", "slot_troop_spouse", ":giver_troop"),
		(neg|faction_slot_eq, "$players_kingdom", "slot_faction_leader", "trp_player"),


#		(neg|troop_slot_eq, "$g_talk_troop", "slot_lord_reputation_type", lrep_martial),
		(neg|troop_slot_eq, "$g_talk_troop", "slot_lord_reputation_type", lrep_quarrelsome),
		(neg|troop_slot_eq, "$g_talk_troop", "slot_lord_reputation_type", lrep_goodnatured),
		
#		(neg|troop_slot_ge, "trp_player", "slot_troop_controversy", 10),
		
		
		(assign, ":target_lord", -1),
		(assign, ":score_to_beat", 1),
		
		(try_for_range, ":potential_target", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":potential_target_faction", ":potential_target"),
			(eq, ":potential_target_faction", "$players_kingdom"),
			(neq, ":potential_target", ":giver_troop"),
			(neg|faction_slot_eq, ":potential_target_faction", "slot_faction_leader", ":potential_target"),
			
			#cannot denounce if you also have an intrigue against lord active
			(this_or_next|neg|check_quest_active, "qst_intrigue_against_lord"),
				(neg|quest_slot_eq, "qst_intrigue_against_lord", "slot_quest_target_troop", ":potential_target"),

			(call_script, "script_troop_get_relation_with_troop", ":potential_target", ":giver_troop"),
			(assign, ":relation_with_giver_troop", reg0),
			(lt, ":relation_with_giver_troop", ":score_to_beat"),
			
			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- Rival found in {s4}"),
			(try_end),			
			
			(try_begin),
				(troop_slot_eq, "$g_talk_troop", "slot_lord_reputation_type", lrep_debauched),
				(assign, ":max_rel_w_player", 15),
			(else_try),
				(troop_slot_eq, "$g_talk_troop", "slot_lord_reputation_type", lrep_quarrelsome),
				(assign, ":max_rel_w_player", 10),
			(else_try),
				(assign, ":max_rel_w_player", 5),
			(try_end),
			
			(call_script, "script_troop_get_relation_with_troop", ":potential_target", "trp_player"),
			(assign, ":relation_with_player", reg0),
			(lt, ":relation_with_player", ":max_rel_w_player"),
	
			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- {s4} is not close friend of player"),
			(try_end),			

			(assign, ":enemies_in_faction", 0),
			(try_for_range, ":other_lord", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":other_lord_faction", ":other_lord"),
				(eq, ":other_lord_faction", "$players_kingdom"),
				(call_script, "script_troop_get_relation_with_troop", ":potential_target", ":other_lord"),
				(lt, reg0, 0),
				(val_add, ":enemies_in_faction", 1),
			(try_end),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(assign, reg3, ":enemies_in_faction"),
				(display_debug_message, "@{!}DEBUG -- {s4} has {reg3} rivals"),
			(try_end),						

			(this_or_next|ge, ":enemies_in_faction", 3),
				(ge, "$cheat_mode", 1),
			
			(assign, ":score_to_beat", ":relation_with_giver_troop"),
			(assign, ":target_lord", ":potential_target"),
		(try_end),

		(is_between, ":target_lord", active_npcs_begin, active_npcs_end),
		
		
		(assign, ":result", "qst_denounce_lord"),
		(assign, ":quest_target_troop", ":target_lord"),

	(else_try),
		(neg|check_quest_active, "qst_intrigue_against_lord"),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(quest_get_slot, reg4, "qst_intrigue_against_lord", "slot_quest_dont_give_again_remaining_days"),
			(display_message, "@{!}DEBUG -- Checking for intrigue, eligible in {reg4} days"),
		(try_end),		
		
		(neg|quest_slot_ge, "qst_intrigue_against_lord", "slot_quest_dont_give_again_remaining_days", 1),
		

		
		(neq, ":giver_troop", "$g_player_minister"),
		(neg|troop_slot_eq, "trp_player", "slot_troop_spouse", ":giver_troop"),
		(neg|faction_slot_eq, "$players_kingdom", "slot_faction_leader", "trp_player"),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- Trying for intrigue against lord"),
		(try_end),

		
		(assign, ":target_lord", -1),
		(assign, ":score_to_beat", 10),
		
		(try_for_range, ":potential_target", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":potential_target_faction", ":potential_target"),
			(eq, ":potential_target_faction", "$players_kingdom"),
			(neq, ":potential_target", ":giver_troop"),
			(neg|faction_slot_eq, ":potential_target_faction", "slot_faction_leader", ":potential_target"),
			
			
			(this_or_next|neg|check_quest_active, "qst_denounce_lord"),
				(neg|quest_slot_eq, "qst_denounce_lord", "slot_quest_target_troop", ":potential_target"),

			(faction_get_slot, ":faction_liege", "$players_kingdom", "slot_faction_leader"),
			(call_script, "script_troop_get_relation_with_troop", ":potential_target", ":faction_liege"),
			(assign, ":relation_with_liege", reg0),
			(lt, ":relation_with_liege", ":score_to_beat"),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- {s4} has sufficiently low relation with liege"),
			(try_end),			

			
			(call_script, "script_troop_get_relation_with_troop", ":potential_target", ":giver_troop"),
			(assign, ":relation_with_giver_troop", reg0),
			(lt, ":relation_with_giver_troop", 0),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- {s4} has sufficiently low relation with giver troop"),
			(try_end),			

			
			(call_script, "script_troop_get_relation_with_troop", ":potential_target", "trp_player"),
			(assign, ":relation_with_player", reg0),
			(lt, ":relation_with_player", 0),
	
			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- {s4} has sufficiently low relation with player"),
			(try_end),			
			
			(assign, ":score_to_beat", ":relation_with_liege"),
			(assign, ":target_lord", ":potential_target"),
		(try_end),

		(is_between, ":target_lord", active_npcs_begin, active_npcs_end),
		
		
		(assign, ":result", "qst_intrigue_against_lord"),
		(assign, ":quest_target_troop", ":target_lord"),

		
	(else_try),
		#Resolve dispute, if there is a good chance of achieving the result
		(try_begin),
			(ge, "$cheat_mode", 1),
			(quest_get_slot, reg4, "qst_resolve_dispute", "slot_quest_dont_give_again_remaining_days"),
			(display_message, "@{!}DEBUG -- Checking for resolve dispute, eligible in {reg4} days"),
		(try_end),
		
		(neg|quest_slot_ge, "qst_resolve_dispute", "slot_quest_dont_give_again_remaining_days", 1),

		
		
		(this_or_next|troop_slot_eq, "trp_player", "slot_troop_spouse", "$g_talk_troop"),
			(eq, "$g_talk_troop", "$g_player_minister"),
			
		(assign, ":target_lord", -1),
		(assign, ":object_lord", -1),
		(assign, ":best_chance_of_success", 20),
		
		(try_for_range, ":lord_1", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":lord_1_faction", ":lord_1"),
			(eq, ":lord_1_faction", "$players_kingdom"),
			(neq, ":lord_1", "$g_talk_troop"),
			
			(try_for_range, ":lord_2", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":lord_2_faction", ":lord_2"),
				(eq, ":lord_2_faction", "$players_kingdom"),
			
				(neq, ":lord_1", ":lord_2"),
				(neq, ":lord_2", "$g_talk_troop"),
				
				(call_script, "script_troop_get_relation_with_troop", ":lord_1", ":lord_2"),
				(assign, ":lord_1_relation_with_lord_2", reg0),
				(lt, ":lord_1_relation_with_lord_2", -5),
				
				(call_script, "script_troop_get_relation_with_troop", ":lord_1", "trp_player"),
				(assign, ":relation_with_lord_1", reg0),
				
				(call_script, "script_troop_get_relation_with_troop", ":lord_2", "trp_player"),
				(assign, ":relation_with_lord_2", reg0),
				
				(gt, ":relation_with_lord_1", 0),
				(gt, ":relation_with_lord_2", 0),
				
				(store_mul, ":chance_of_success", ":relation_with_lord_1", ":relation_with_lord_2"),
				
				
				(gt, ":chance_of_success", ":best_chance_of_success"),
				(assign, ":best_chance_of_success", ":chance_of_success"),
				(assign, ":target_lord", ":lord_1"),
				(assign, ":object_lord", ":lord_2"),
			(try_end),
		(try_end),
		
		
		(is_between, ":target_lord", active_npcs_begin, active_npcs_end),

		(assign, ":result", "qst_resolve_dispute"),
		(assign, ":quest_target_troop", ":target_lord"),
		(assign, ":quest_object_troop", ":object_lord"),
		
	(else_try),
		(try_begin),
			(ge, "$cheat_mode", 1),
			(quest_get_slot, reg4, "qst_offer_gift", "slot_quest_dont_give_again_remaining_days"),
			(display_message, "@{!}DEBUG -- Checking for offer gift, eligible in {reg4} days"),
		(try_end),	
	
		(neg|quest_slot_ge, "qst_offer_gift", "slot_quest_dont_give_again_remaining_days", 1),

		(assign, ":relative_found", -1),
		(assign, ":score_to_beat", 5),
		
		(try_for_range, ":potential_relative", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":relative_faction", ":potential_relative"),
			(eq, ":relative_faction", "$players_kingdom"),
			(neq, ":potential_relative", ":giver_troop"),
			(neg|faction_slot_eq, ":relative_faction", "slot_faction_leader", ":potential_relative"),
			
			(call_script, "script_troop_get_family_relation_to_troop", ":giver_troop", ":potential_relative"),
			(assign, ":family_relation", reg0),
			(ge, ":family_relation", ":score_to_beat"),
			
			(store_sub, ":min_relation_w_player", 0, ":family_relation"),
		
			(call_script, "script_troop_get_relation_with_troop", "trp_player", ":potential_relative"),
			(assign, ":relation_with_player", reg0),
			(is_between, ":relation_with_player", ":min_relation_w_player", 0),
			
			(assign, ":score_to_beat", ":family_relation"),
			(assign, ":relative_found", ":potential_relative"),
			
		(try_end),
		
		(is_between, ":relative_found", active_npcs_begin, active_npcs_end),
		
		(assign, ":result", "qst_offer_gift"),
		(assign, ":quest_target_troop", ":relative_found"),
	(try_end),
	
  
	(try_begin),
		(gt, ":result", -1),
		(quest_set_slot, ":result", "slot_quest_target_troop", ":quest_target_troop"),
          (quest_set_slot, ":result", "slot_quest_object_troop", ":quest_object_troop"), ##CABA - bugfix was "slot_quest_target_troop" chief
		
		(quest_set_slot, ":result", "slot_quest_giver_troop", ":giver_troop"),
        (quest_set_slot, ":result", "slot_quest_dont_give_again_period", ":quest_dont_give_again_period"),
    (try_end), 
  
    (assign, reg0, ":result"),
    (assign, reg1, ":quest_target_troop"),
    (assign, reg2, ":quest_object_troop"),
  
  ]),
  
  
  ("npc_find_quest_for_player_to_s11", 
  [
  (store_script_param, ":faction", 1),

  (assign, ":quest_giver_found", -1),
  (try_for_range, ":quest_giver", active_npcs_begin, mayors_end),
    (eq, ":quest_giver_found", -1),

	(neg|troop_slot_eq, "trp_player", "slot_troop_spouse", ":quest_giver"),
	
	(gt, ":quest_giver", "$g_troop_list_no"),
	
	(assign, "$g_troop_list_no", ":quest_giver"),
	
	(this_or_next|troop_slot_eq, ":quest_giver", "slot_troop_occupation", slto_kingdom_hero),
		(is_between, ":quest_giver", mayors_begin, mayors_end),

	(neg|troop_slot_ge, ":quest_giver", "slot_troop_prisoner_of_party", centers_begin),
	
	(try_begin),
		(is_between, ":quest_giver", mayors_begin, mayors_end),
		(assign, ":quest_giver_faction", -1),
		(try_for_range,":town", towns_begin, towns_end),
			(party_slot_eq, ":town", "slot_town_elder", ":quest_giver"),
			(store_faction_of_party, ":quest_giver_faction", ":town"),
		(try_end),
	(else_try),
		(store_faction_of_troop, ":quest_giver_faction", ":quest_giver"),	
	(try_end),
	(eq, ":faction", ":quest_giver_faction"),
	
	(call_script, "script_get_dynamic_quest", ":quest_giver"),	
    (gt, reg0, -1),
	
    (assign, ":quest_giver_found", ":quest_giver"),
	(try_begin),
          (eq, "$cheat_mode", 1),
	  (str_store_troop_name, s4, ":quest_giver_found"),
	  (display_message, "str_test_diagnostic_quest_found_for_s4"),
        (try_end),
	
  (try_end),
 
  (assign, reg0, ":quest_giver_found"), 
  
    ]),  
  
  
  
  # script_cf_get_random_enemy_center_within_range
  # Input: arg1 = party_no, arg2 = range (in kms)
  # Output: reg0 = center_no
  ("cf_get_random_enemy_center_within_range",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":range", 2),

      (assign, ":num_centers", 0),
      (store_faction_of_party, ":faction_no", ":party_no"),
      (try_for_range, ":cur_center", centers_begin, centers_end),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (lt, ":cur_relation", 0),
        (store_distance_to_party_from_party, ":dist", ":party_no", ":cur_center"),
        (le, ":dist", ":range"),
        (val_add, ":num_centers", 1),
      (try_end),
      (gt, ":num_centers", 0),
      (store_random_in_range, ":random_center", 0, ":num_centers"),
      (assign, ":end_cond", centers_end),
      (try_for_range, ":cur_center", centers_begin, ":end_cond"),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (lt, ":cur_relation", 0),
        (store_distance_to_party_from_party, ":dist", ":party_no", ":cur_center"),
        (le, ":dist", ":range"),
        (val_sub, ":random_center", 1),
        (lt, ":random_center", 0),
        (assign, ":result", ":cur_center"),
        (assign, ":end_cond", 0),#break
      (try_end),
      (assign, reg0, ":result"),
  ]),
  
  # script_cf_faction_get_random_enemy_faction
  # Input: arg1 = faction_no
  # Output: reg0 = faction_no (Can fail)
  ("cf_faction_get_random_enemy_faction",
    [
      (store_script_param_1, ":faction_no"),
      
      (assign, ":result", -1),
      (assign, ":count_factions", 0),
      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (le, ":cur_relation", -1),
        (val_add, ":count_factions", 1),
      (try_end),
      (store_random_in_range,":random_faction",0,":count_factions"),
      (assign, ":count_factions", 0),
      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (eq, ":result", -1),
        (faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (le, ":cur_relation", -1),
        (val_add, ":count_factions", 1),
        (gt, ":count_factions", ":random_faction"),
        (assign, ":result", ":cur_faction"),
      (try_end),
      
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),

  # script_cf_faction_get_random_friendly_faction
  # Input: arg1 = faction_no
  # Output: reg0 = faction_no (Can fail)
  ("cf_faction_get_random_friendly_faction",
    [
      (store_script_param_1, ":faction_no"),
      
      (assign, ":result", -1),
      (assign, ":count_factions", 0),
      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
        (neq, ":cur_faction", ":faction_no"),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (ge, ":cur_relation", 0),
        (val_add, ":count_factions", 1),
      (try_end),
      (store_random_in_range,":random_faction",0,":count_factions"),
      (assign, ":count_factions", 0),
      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (eq, ":result", -1),
        (faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
        (neq, ":cur_faction", ":faction_no"),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (ge, ":cur_relation", 0),
        (val_add, ":count_factions", 1),
        (gt, ":count_factions", ":random_faction"),
        (assign, ":result", ":cur_faction"),
      (try_end),
      
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),  
  
  # script_cf_troop_get_random_enemy_troop_with_occupation
  # Input: arg1 = troop_no,
  # Output: reg0 = enemy_troop_no (Can fail)
  ("cf_troop_get_random_enemy_troop_with_occupation",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":occupation"),
      
      (assign, ":result", -1),
      (assign, ":count_enemies", 0),
      (try_for_range, ":enemy_troop_no", active_npcs_begin, active_npcs_end),
        (troop_slot_eq, ":enemy_troop_no", "slot_troop_occupation", ":occupation"),
        (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":enemy_troop_no"),         
        (lt, reg0, -10), 
        (val_add, ":count_enemies", 1),
      (try_end),
      
      (gt, ":count_enemies", 0),
      (store_random_in_range,":random_enemy",0,":count_enemies"),
      
      (assign, ":count_enemies", 0),
      (try_for_range, ":enemy_troop_no", active_npcs_begin, active_npcs_end),
        (troop_slot_eq, ":enemy_troop_no", "slot_troop_occupation", ":occupation"),
        (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":enemy_troop_no"), 
        (lt, reg0, -10),
        (val_add, ":count_enemies", 1),
        (eq, ":random_enemy", ":count_enemies"),
        (assign, ":result", ":enemy_troop_no"),
      (try_end),
      
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),
  
  
##  # script_cf_troop_get_random_enemy_troop_as_a_town_lord
##  # Input: arg1 = troop_no
##  # Output: reg0 = enemy_troop_no (Can fail)
##  ("cf_troop_get_random_enemy_troop_as_a_town_lord",
##    [
##      (store_script_param_1, ":troop_no"),
##      
##      (assign, ":result", -1),
##      (assign, ":count_enemies", 0),
##      (try_for_range, ":cur_slot", "slot_troop_enemies_begin", "slot_troop_enemies_end"),
##        (troop_get_slot, ":cur_enemy", ":troop_no", ":cur_slot"),
##        (gt, ":cur_enemy", 0),
##        (troop_slot_eq, ":cur_enemy", "slot_troop_occupation", slto_kingdom_hero),
##        (call_script, "script_get_number_of_hero_centers", ":cur_enemy"),
##        (gt, reg0, 0),
##        (val_add, ":count_enemies", 1),
##      (try_end),
##      (store_random_in_range,":random_enemy",0,":count_enemies"),
##      (assign, ":count_enemies", 0),
##      (try_for_range, ":cur_slot", "slot_troop_enemies_begin", "slot_troop_enemies_end"),
##        (eq, ":result", -1),
##        (troop_get_slot, ":cur_enemy", ":troop_no", ":cur_slot"),
##        (gt, ":cur_enemy", 0),
##        (troop_slot_eq, ":cur_enemy", "slot_troop_occupation", slto_kingdom_hero),
##        (call_script, "script_get_number_of_hero_centers", ":cur_enemy"),
##        (gt, reg0, 0),
##        (val_add, ":count_enemies", 1),
##        (gt, ":count_enemies", ":random_enemy"),
##        (assign, ":result", ":cur_enemy"),
##      (try_end),
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),
  
  
  ##  # script_cf_get_random_enemy_with_valid_slot
  ##  # Input: arg1 = faction_no, arg2 = slot_no
  ##  # Output: reg0 = faction_no (Can fail)
  ##  ("cf_get_random_enemy_with_valid_slot",
  ##    [
  ##      (store_script_param_1, ":faction_no"),
  ##      (store_script_param_2, ":slot_no"),
  ##
  ##      (assign, ":result", -1),
  ##      (assign, ":count_factions", 0),
  ##      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
  ##        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
  ##        (le, ":cur_relation", -10),
  ##        (faction_get_slot, ":cur_value", ":cur_faction", ":slot_no"),
  ##        (gt, ":cur_value", 0),#Checking validity
  ##        (val_add, ":count_factions", 1),
  ##      (try_end),
  ##      (store_random_in_range,":random_faction",0,":count_factions"),
  ##      (assign, ":count_factions", 0),
  ##      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
  ##        (eq, ":result", -1),
  ##        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
  ##        (le, ":cur_relation", -10),
  ##        (faction_get_slot, ":cur_value", ":cur_faction", ":slot_no"),
  ##        (gt, ":cur_value", 0),#Checking validity
  ##        (val_add, ":count_factions", 1),
  ##        (gt, ":count_factions", ":random_faction"),
  ##        (assign, ":result", ":cur_faction"),
  ##      (try_end),
  ##
  ##      (neq, ":result", -1),
  ##      (assign, reg0, ":result"),
  ##  ]),
  
  
##  # script_cf_get_random_kingdom_hero
##  # Input: arg1 = faction_no
##  # Output: reg0 = troop_no (Can fail)
##  ("cf_get_random_kingdom_hero",
##    [
##      (store_script_param_1, ":faction_no"),
##      (assign, ":count_heroes", 0),
##      (try_for_range, ":center_no", centers_begin, centers_end),
##        (store_faction_of_party, ":cur_faction", ":center_no"),
##        (eq, ":cur_faction", ":faction_no"),
##        (party_get_slot, ":cur_lord", ":center_no", "slot_town_lord"),
##        (is_between, ":cur_lord", heroes_begin, heroes_end),
##        (val_add, ":count_heroes", 1),
##      (try_end),
##      (store_random_in_range, ":random_hero", 0, ":count_heroes"),
##      (assign, ":result", -1),
##      (assign, ":count_heroes", 0),
##      (try_for_range, ":center_no", centers_begin, centers_end),
##        (eq, ":result", -1),
##        (store_faction_of_party, ":cur_faction", ":center_no"),
##        (eq, ":cur_faction", ":faction_no"),
##        (party_get_slot, ":cur_lord", ":center_no", "slot_town_lord"),
##        (is_between, ":cur_lord", heroes_begin, heroes_end),
##        (val_add, ":count_heroes", 1),
##        (lt, ":random_hero", ":count_heroes"),
##        (assign, ":result", ":cur_lord"),
##      (try_end),
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),
  
  
# script_cf_get_random_kingdom_hero_as_lover - removed

  
  
##  # script_cf_get_random_siege_location_with_faction
##  # Input: arg1 = faction_no
##  # Output: reg0 = center_no, Can Fail!
##  ("cf_get_random_siege_location_with_faction",
##    [
##      (store_script_param_1, ":faction_no"),
##      (assign, ":result", -1),
##      (assign, ":count_sieges", 0),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (party_get_battle_opponent, ":besieger_party", ":center_no"),
##        (gt, ":besieger_party", 0),
##        (store_faction_of_party, ":cur_faction_no", ":center_no"),
##        (eq, ":cur_faction_no", ":faction_no"),
##        (val_add, ":count_sieges", 1),
##      (try_end),
##      (store_random_in_range,":random_center",0,":count_sieges"),
##      (assign, ":count_sieges", 0),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (eq, ":result", -1),
##        (party_get_battle_opponent, ":besieger_party", ":center_no"),
##        (gt, ":besieger_party", 0),
##        (store_faction_of_party, ":cur_faction_no", ":center_no"),
##        (eq, ":cur_faction_no", ":faction_no"),
##        (val_add, ":count_sieges", 1),
##        (gt, ":count_sieges", ":random_center"),
##        (assign, ":result", ":center_no"),
##      (try_end),
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),
  
##  # script_cf_get_random_siege_location_with_attacker_faction
##  # Input: arg1 = faction_no
##  # Output: reg0 = center_no, Can Fail!
##  ("cf_get_random_siege_location_with_attacker_faction",
##    [
##      (store_script_param_1, ":faction_no"),
##      (assign, ":result", -1),
##      (assign, ":count_sieges", 0),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (party_get_battle_opponent, ":besieger_party", ":center_no"),
##        (gt, ":besieger_party", 0),
##        (store_faction_of_party, ":cur_faction_no", ":besieger_party"),
##        (eq, ":cur_faction_no", ":faction_no"),
##        (val_add, ":count_sieges", 1),
##      (try_end),
##      (store_random_in_range,":random_center",0,":count_sieges"),
##      (assign, ":count_sieges", 0),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (eq, ":result", -1),
##        (party_get_battle_opponent, ":besieger_party", ":center_no"),
##        (gt, ":besieger_party", 0),
##        (store_faction_of_party, ":cur_faction_no", ":besieger_party"),
##        (eq, ":cur_faction_no", ":faction_no"),
##        (val_add, ":count_sieges", 1),
##        (gt, ":count_sieges", ":random_center"),
##        (assign, ":result", ":center_no"),
##      (try_end),
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),
  
  
  
##  # script_cf_get_number_of_random_troops_from_party
##  # Input: arg1 = party_no, arg2 = number of troops to remove
##  # Output: reg0 = troop_no, Can fail if there are no slots having the required number of units!
##  ("cf_get_number_of_random_troops_from_party",
##    [
##      (store_script_param_1, ":party_no"),
##      (store_script_param_2, ":no_to_remove"),
##      
##      (assign, ":result", -1),
##      (assign, ":count_stacks", 0),
##      
##      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
##      (try_for_range, ":i_stack", 0, ":num_stacks"),
##        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
##        (party_stack_get_num_wounded, ":num_wounded",":party_no",":i_stack"),
##        (val_sub, ":stack_size", ":num_wounded"),
##        (ge, ":stack_size", ":no_to_remove"),
##        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
##        (neg|troop_is_hero, ":stack_troop"),
##        (val_add, ":count_stacks", 1),
##      (try_end),
##      (store_random_in_range,":random_stack",0,":count_stacks"),
##      (assign, ":count_stacks", 0),
##      (try_for_range, ":i_stack", 0, ":num_stacks"),
##        (eq, ":result", -1),
##        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
##        (party_stack_get_num_wounded, ":num_wounded",":party_no",":i_stack"),
##        (val_sub, ":stack_size", ":num_wounded"),
##        (ge, ":stack_size", ":no_to_remove"),
##        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
##        (neg|troop_is_hero, ":stack_troop"),
##        (val_add, ":count_stacks", 1),
##        (gt, ":count_stacks", ":random_stack"),
##        (assign, ":result", ":stack_troop"),
##      (try_end),
##      
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),
  
  
  
  
  # script_cf_get_random_lord_in_a_center_with_faction
  # Input: arg1 = faction_no
  # Output: reg0 = troop_no, Can Fail!
  ("cf_get_random_lord_in_a_center_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (eq, ":faction_no", ":lord_faction_no"),
        (troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", "slot_troop_is_prisoner", 0),
        (neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
        (troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
        (ge, ":lord_party", 0),
        (party_get_attached_to, ":lord_attachment", ":lord_party"),
        (is_between, ":lord_attachment", centers_begin, centers_end), #is troop in a center?
        (val_add, ":count_lords", 1),
      (try_end),
      (store_random_in_range, ":random_lord", 0, ":count_lords"),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (eq, ":result", -1),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (eq, ":faction_no", ":lord_faction_no"),
        (troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", "slot_troop_is_prisoner", 0),
        (neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
        (troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
        (ge, ":lord_party", 0),
        (party_get_attached_to, ":lord_attachment", ":lord_party"),
        (is_between, ":lord_attachment", centers_begin, centers_end), #is troop in a center?
        (val_add, ":count_lords", 1),
        (lt, ":random_lord", ":count_lords"),
        (assign, ":result", ":lord_no"),
      (try_end),
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),

  # script_cf_get_random_lord_except_king_with_faction
  # Input: arg1 = faction_no
  # Output: reg0 = troop_no, Can Fail!
  ("cf_get_random_lord_except_king_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (eq, ":faction_no", ":lord_faction_no"),
        (neg|faction_slot_eq, ":faction_no", "slot_faction_leader", ":lord_no"),
        (troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", "slot_troop_is_prisoner", 0),
        (neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
        (troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
        (ge, ":lord_party", 0),
        (val_add, ":count_lords", 1),
      (try_end),
      (store_random_in_range, ":random_lord", 0, ":count_lords"),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (eq, ":result", -1),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (eq, ":faction_no", ":lord_faction_no"),
        (neg|faction_slot_eq, ":faction_no", "slot_faction_leader", ":lord_no"),
        (troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", "slot_troop_is_prisoner", 0),
        (neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
        (troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
        (ge, ":lord_party", 0),
        (val_add, ":count_lords", 1),
        (lt, ":random_lord", ":count_lords"),
        (assign, ":result", ":lord_no"),
      (try_end),
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),
  
  
  # script_cf_get_random_lord_from_another_faction_in_a_center
  # Input: arg1 = faction_no
  # Output: reg0 = troop_no, Can Fail!
  ("cf_get_random_lord_from_another_faction_in_a_center",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (neq, ":lord_faction_no", ":faction_no"),
        (store_relation, ":our_relation", ":lord_faction_no", "fac_player_supporters_faction"),
        (store_relation, ":lord_relation", ":lord_faction_no", ":faction_no"),
        (lt, ":lord_relation", 0),
        (ge, ":our_relation", 0),
        (troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", "slot_troop_is_prisoner", 0),
        (neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
        (troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
        (ge, ":lord_party", 0),
        (party_get_attached_to, ":lord_attachment", ":lord_party"),
        (is_between, ":lord_attachment", centers_begin, centers_end), #is troop in a center?
        (val_add, ":count_lords", 1),
      (try_end),
      (store_random_in_range, ":random_lord", 0, ":count_lords"),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (eq, ":result", -1),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (neq, ":lord_faction_no", ":faction_no"),
        (store_relation, ":our_relation", ":lord_faction_no", "fac_player_supporters_faction"),
        (store_relation, ":lord_relation", ":lord_faction_no", ":faction_no"),
        (lt, ":lord_relation", 0),
        (ge, ":our_relation", 0),
        (troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", "slot_troop_is_prisoner", 0),
        (neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
        (troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
        (ge, ":lord_party", 0),
        (party_get_attached_to, ":lord_attachment", ":lord_party"),
        (is_between, ":lord_attachment", centers_begin, centers_end), #is troop in a center?
        (val_add, ":count_lords", 1),
        (lt, ":random_lord", ":count_lords"),
        (assign, ":result", ":lord_no"),
      (try_end),
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),
  
  # script_get_closest_walled_center
  # Input: arg1 = party_no
  # Output: reg0 = center_no (closest)
  ("get_closest_walled_center",
    [
      (store_script_param_1, ":party_no"),
      (assign, ":min_distance", 9999999),
      (assign, reg0, -1),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
        (lt, ":party_distance", ":min_distance"),
        (assign, ":min_distance", ":party_distance"),
        (assign, reg0, ":center_no"),
      (try_end),
  ]),  
  
  # script_get_closest_center
  # Input: arg1 = party_no
  # Output: reg0 = center_no (closest)
  ("get_closest_center",
    [
      (store_script_param_1, ":party_no"),
      (assign, ":min_distance", 9999999),
      (assign, reg0, -1),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
        (lt, ":party_distance", ":min_distance"),
        (assign, ":min_distance", ":party_distance"),
        (assign, reg0, ":center_no"),
      (try_end),
  ]),

  # script_get_closest_walled_center_of_faction
  # Input: arg1 = party_no, arg2 = kingdom_no
  # Output: reg0 = center_no (closest)
  ("get_closest_walled_center_of_faction",
    [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":kingdom_no"),
      (assign, ":min_distance", 99999),
      (assign, ":result", -1),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":faction_no", ":center_no"),
        (eq, ":faction_no", ":kingdom_no"),
        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
        (lt, ":party_distance", ":min_distance"),
        (assign, ":min_distance", ":party_distance"),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),
  
  
##  # script_get_closest_town_of_faction
##  # Input: arg1 = party_no, arg2 = kingdom_no
##  # Output: reg0 = center_no (closest)
##  ("get_closest_town_of_faction",
##    [
##      (store_script_param_1, ":party_no"),
##      (store_script_param_2, ":kingdom_no"),
##      (assign, ":min_distance", 9999999),
##      (assign, ":result", -1),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (store_faction_of_party, ":faction_no", ":center_no"),
##        (eq, ":faction_no", ":kingdom_no"),
##        (party_slot_eq, ":center_no", "slot_party_type", spt_town),
##        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
##        (lt, ":party_distance", ":min_distance"),
##        (assign, ":min_distance", ":party_distance"),
##        (assign, ":result", ":center_no"),
##      (try_end),
##      (assign, reg0, ":result"),
##  ]),

  
  # script_let_nearby_parties_join_current_battle
  # Input: arg1 = besiege_mode, arg2 = dont_add_friends_other_than_accompanying
  # Output: none
  ("let_nearby_parties_join_current_battle",
    [
      (store_script_param, ":besiege_mode", 1),
      (store_script_param, ":dont_add_friends_other_than_accompanying", 2),
              
#      (store_character_level, ":player_level", "trp_player"),  ##CC commander chief off     
      (try_for_parties, ":party_no"),
        (party_is_active, ":party_no"),
        (party_get_battle_opponent, ":opponent",":party_no"),
        (lt, ":opponent", 0), #party is not itself involved in a battle
        (party_get_attached_to, ":attached_to",":party_no"),
        (lt, ":attached_to", 0), #party is not attached to another party
        (get_party_ai_behavior, ":behavior", ":party_no"),
#TEMPERED chief CHANGES BEGIN
			(party_get_slot,":hire_time_end",":party_no","slot_party_hired"),
			(store_current_hours,":cur_hour"),
			(party_get_slot, ":party_type",":party_no","slot_party_type"),
			(party_get_template_id,":party_template_id",":party_no"),
			(neg|is_between,":party_no",spawn_points_begin, spawn_points_end),
			(neq,":party_template_id","pt_entrench"),
			(neq, ":party_type", spt_town),
			(neq, ":party_type", spt_castle),
			(neq, ":party_type", spt_kingdom_caravan),
			(neq, ":party_type", spt_messenger),
			(neq,":party_template_id","pt_spy_party"), 
			(neq,":party_template_id","pt_skirmish_party"),
			(neq,":party_template_id","pt_funeral_pyre"),
#TEMPERED CHANGES END      
        (neq, ":behavior", ai_bhvr_in_town),
              
        (party_stack_get_troop_id, ":stack_troop", ":party_no", 0),  
        (try_begin),
          (neg|is_between, ":stack_troop", "trp_looter", "trp_dena_pirate"),

          (assign, ":join_distance", 5), #day/not bandit
          (try_begin),
            (is_currently_night),
            (assign, ":join_distance", 3), #nigh/not bandit
          (try_end),    
        (else_try),  
          (assign, ":join_distance", 3), #day/bandit
          (try_begin),
            (is_currently_night),
            (assign, ":join_distance", 2), #night/bandit
          (try_end),    
        (try_end),          

		#Quest bandits do not join battle
		(this_or_next|neg|check_quest_active, "qst_track_down_bandits"),
			(neg|quest_slot_eq, "qst_track_down_bandits", "slot_quest_target_party", ":party_no"),
		(this_or_next|neg|check_quest_active, "qst_troublesome_bandits"),
			(neg|quest_slot_eq, "qst_troublesome_bandits", "slot_quest_target_party", ":party_no"),
			
			
			
         (store_distance_to_party_from_party, ":distance", ":party_no", "p_main_party"),
        (lt, ":distance", ":join_distance"),

        (store_faction_of_party, ":faction_no", ":party_no"),
        (store_faction_of_party, ":enemy_faction", "$g_enemy_party"),
        (try_begin),
          (eq, ":faction_no", "fac_player_supporters_faction"),
          (assign, ":reln_with_player", 100),
        (else_try),
          (store_relation, ":reln_with_player", ":faction_no", "fac_player_supporters_faction"),
        (try_end),
        (try_begin),
          (eq, ":faction_no", ":enemy_faction"),
          (assign, ":reln_with_enemy", 100),
        (else_try),
          (store_relation, ":reln_with_enemy", ":faction_no", ":enemy_faction"),
        (try_end),
#TEMPERED chief CHANGES BEGIN   ADDED HIRED PARTIES CHECK FOR PEASANTS TO JOIN BATTLE
			(try_begin),
				(gt,":hire_time_end",":cur_hour"),
				(assign, ":reln_with_player", 100),
			(try_end),
			(try_begin),
				(this_or_next|eq,":party_template_id","pt_village_farmers"),
				(eq,":party_template_id","pt_village_defenders"),
				(ge,"$commoner_trust",40),
				(assign, ":reln_with_player", 100),
				(try_begin),
					(ge,"$commoner_trust",80),
					(assign, ":reln_with_enemy", -1),
				(try_end),
			(try_end),
##			(try_begin), #unirse bandidos chief
##				(this_or_next|eq,":party_template_id","pt_sea_raiders"),
##				(eq,":party_template_id","pt_sea_raiders2"),
##				(assign, ":reln_with_enemy", 100),
##			(try_end),
##			(try_begin), #unirse bandidos chief 2
##				(this_or_next|eq,":party_template_id","pt_mountain_bandits"),
##				(eq,":party_template_id","pt_forest_bandits"),
##				(assign, ":reln_with_enemy", 100),
##			(try_end),
##			(try_begin), #unirse bandidos chief 3
##				(this_or_next|eq,":party_template_id","pt_desert_bandits"),
##				(eq,":party_template_id","pt_taiga_bandits"),
##				(assign, ":reln_with_enemy", 100),
##			(try_end),
##			(try_begin), #unirse bandidos chief 3
##				(this_or_next|eq,":party_template_id","pt_steppe_bandits"),
##				(eq,":party_template_id","pt_looters"),
##				(assign, ":reln_with_enemy", 100),
##			(try_end),
#TEMPERED CHANGES END

        (assign, ":enemy_side", 1),
        (try_begin),
          (neq, "$g_enemy_party", "$g_encountered_party"),
          (assign, ":enemy_side", 2),
        (try_end),

        (try_begin),
          (eq, ":besiege_mode", 0),
          (lt, ":reln_with_player", 0),
          (gt, ":reln_with_enemy", 0),
          (party_get_slot, ":party_type", ":party_no"),
###CC chief commander cambia          
##          (assign, ":enemy_is_bandit_party_and_level_is_greater_than_6", 0),
##          (try_begin),
##            (party_stack_get_troop_id, ":stack_troop", ":party_no", 0),
##            (is_between, ":stack_troop", "trp_looter", "trp_pict_footmant2"),                    
##            (gt, ":player_level", 6),
##            (assign, ":enemy_is_bandit_party_and_level_is_greater_than_6", 1),
##          (try_end),  
          ## CC
          (party_get_template_id,":template_id",":party_no"),
          (this_or_next|is_between,":template_id","pt_looters","pt_merchant_caravan"),
          ## CC
          (eq, ":party_type", spt_kingdom_hero_party),          

##          (this_or_next|eq, ":party_type", spt_kingdom_hero_party),          
##          (eq, ":enemy_is_bandit_party_and_level_is_greater_than_6", 1),
  ###CC commander chief cambia                                        
          (get_party_ai_behavior, ":ai_bhvr", ":party_no"),
          (neq, ":ai_bhvr", ai_bhvr_avoid_party),
          (party_quick_attach_to_current_battle, ":party_no", ":enemy_side"), #attach as enemy
          (str_store_party_name, s1, ":party_no"),
          (display_message, "str_s1_joined_battle_enemy", color_bad_news), #chief garnier anade color
        (else_try),          
          (try_begin),
            (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
            (party_slot_eq, ":party_no", "slot_party_ai_object", "trp_player"),
            (assign, ":party_is_accompanying_player", 1),
          (else_try),  
            (assign, ":party_is_accompanying_player", 0),
          (try_end),
          
          (this_or_next|eq, ":dont_add_friends_other_than_accompanying", 0),
          (eq, ":party_is_accompanying_player", 1),
          (gt, ":reln_with_player", 0),
          (lt, ":reln_with_enemy", 0),
          
          (assign, ":following_player", 0),
          (try_begin),
            (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),            
            (party_slot_eq, ":party_no", "slot_party_ai_object", "p_main_party"),
            (assign, ":following_player", 1),
          (try_end),             

          (assign, ":do_join", 1),
          (try_begin),
            (eq, ":besiege_mode", 1),                        
            (eq, ":following_player", 0),                        
            (assign, ":do_join", 0),
            (eq, ":faction_no", "$players_kingdom"),
            (faction_slot_eq, "$players_kingdom", "slot_faction_marshall", "trp_player"),
            (assign, ":do_join", 1),
          (try_end),          
          (eq, ":do_join", 1),
#somebody patrullas chief          
##          (party_get_slot, ":party_type", ":party_no"),
##          (eq, ":party_type", spt_kingdom_hero_party),
##          (party_stack_get_troop_id, ":leader", ":party_no", 0),
##          #(troop_get_slot, ":player_relation", ":leader", "slot_troop_player_relation"),
##          (call_script, "script_troop_get_player_relation", ":leader"),
            (party_get_slot, ":party_type", ":party_no", "slot_party_type"),
            (this_or_next|eq, ":party_type", spt_kingdom_hero_party),
            (this_or_next|eq, ":party_type", spt_companion_raider),
            (eq, ":party_type", spt_patrol),
            (party_stack_get_troop_id, ":leader", ":party_no", 0),
            #       (troop_get_slot, ":player_relation", ":leader", "slot_troop_player_relation"),
            (try_begin),
              (troop_slot_eq, ":leader", "slot_troop_occupation", slto_kingdom_hero),
              (call_script, "script_troop_get_player_relation", ":leader"),
            (else_try),
              (eq, ":party_type", spt_companion_raider),
              (call_script, "script_npc_morale", ":leader"),
            (else_try),
              # (store_faction_of_troop, ":fac", ":leader"),
              (store_relation, reg0, "$players_kingdom", ":faction_no"),
            (try_end),
#somebody patrullas chief acaba
          (assign, ":player_relation", reg0),
          
          (assign, ":join_even_you_do_not_like_player", 0),
          (try_begin),
            (faction_slot_eq, "$players_kingdom", "slot_faction_marshall", "trp_player"), #new added, if player is marshal and if he is accompanying then join battle even lord do not like player
            (eq, ":following_player", 1),
            (assign, ":join_even_you_do_not_like_player", 1),
          (try_end),              
          
          (this_or_next|ge, ":player_relation", 0),          
          (eq, ":join_even_you_do_not_like_player", 1),
          
          (party_quick_attach_to_current_battle, ":party_no", 0), #attach as friend
          (str_store_party_name, s1, ":party_no"),
          (display_message, "str_s1_joined_battle_friend", color_good_news), #chief garnier anade color
        (try_end),
      (try_end),
  ]),
    
  # script_party_wound_all_members_aux
  # Input: arg1 = party_no
  ("party_wound_all_members_aux",
    [
      (store_script_param_1, ":party_no"),
      
      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
          (party_wound_members, ":party_no", ":stack_troop", ":stack_size"),
        (else_try),
          (troop_set_health, ":stack_troop", 0),
        (try_end),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":party_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":party_no", ":attached_party_rank"),
        (call_script, "script_party_wound_all_members_aux", ":attached_party"),
      (try_end),      
  ]),    
  
  # script_party_wound_all_members
  # Input: arg1 = party_no
  ("party_wound_all_members",
    [
      (store_script_param_1, ":party_no"),
      
      (call_script, "script_party_wound_all_members_aux", ":party_no"),
  ]),
  
  
  
  # script_calculate_battle_advantage
  # Output: reg0 = battle advantage
  ("calculate_battle_advantage",
    [
      (call_script, "script_party_count_fit_for_battle", "p_collective_friends"),
      (assign, ":friend_count", reg(0)),
      
      (party_get_skill_level, ":player_party_tactics",  "p_main_party", skl_tactics),
      (party_get_skill_level, ":ally_party_tactics",  "p_collective_friends", skl_tactics),
      (val_max, ":player_party_tactics", ":ally_party_tactics"),
     
      (call_script, "script_party_count_fit_for_battle", "p_collective_enemy"),
      (assign, ":enemy_count", reg(0)),
      
      (party_get_skill_level, ":enemy_party_tactics",  "p_collective_enemy", skl_tactics),
      
      (val_add, ":friend_count", 1),
      (val_add, ":enemy_count", 1),
      
      (try_begin),
        (ge, ":friend_count", ":enemy_count"),
        (val_mul, ":friend_count", 100),
        (store_div, ":ratio", ":friend_count", ":enemy_count"),
        (store_sub, ":raw_advantage", ":ratio", 100),
      (else_try),
        (val_mul, ":enemy_count", 100),
        (store_div, ":ratio", ":enemy_count", ":friend_count"),
        (store_sub, ":raw_advantage", 100, ":ratio"),
      (try_end),
      (val_mul, ":raw_advantage", 2),
      
      (val_mul, ":player_party_tactics", 30),
      (val_mul, ":enemy_party_tactics", 30),
      (val_add, ":raw_advantage", ":player_party_tactics"),
      (val_sub, ":raw_advantage", ":enemy_party_tactics"),
      (val_div, ":raw_advantage", 100),
      
      
      (assign, reg0, ":raw_advantage"),

     #rigale ambush chief / sneaking bonus malus
     (str_clear,s1),

     (try_begin),
       (neq, "$ambush_set_by_player", 0),
       (try_begin),
           (eq, "$type_of_ambushing_success", 1), #crit success
           (val_add, reg0, 6),
           (str_store_string,s1,"@ (AMBUSH BONUS: 6)"),
       (else_try),
            (eq, "$type_of_ambushing_success", 2), #success
           (val_add, reg0, 3),
           (str_store_string,s1,"@ (AMBUSH BONUS: 3)"),
       (else_try),
            (eq, "$type_of_ambushing_success", 3), #failure
           (val_sub, reg0, 6),
           (str_store_string,s1,"@ (AMBUSH MALUS: 6)"),
       (else_try),
            (eq, "$type_of_ambushing_success", 4), #crit failure
           (val_sub, reg0, 10),
           (str_store_string,s1,"@ (AMBUSH MALUS: 10)"),
        (try_end),
      
     (else_try),
       (neq, "$sneaking_set_by_player", 0),
         (try_begin),#SNEAKING RESULTS
           (eq, "$type_of_sneaking_success", 1), #crit success
           (try_begin),(eq,is_currently_night), (val_add, reg0, 2),(try_end),
           (val_add, reg0, 3),
           (str_store_string,s1,"@ (SNEAKING BONUS: 3)"),
       (else_try),
            (eq, "$type_of_sneaking_success", 2), #success
           (try_begin),(eq,is_currently_night), (val_add, reg0, 2),(try_end),
           (val_add, reg0, 1),
           (str_store_string,s1,"@ (SNEAKING BONUS: 1)"),
       (else_try),
            (eq, "$type_of_sneaking_success", 3), #failure
           (val_sub, reg0, 3),
           (str_store_string,s1,"@ (SNEAKING MALUS: 3)"),
       (else_try),
            (eq, "$type_of_sneaking_success", 4), #crit failure
           (val_sub, reg0, 6),
           (str_store_string,s1,"@ (SNEAKING MALUS: 6)"),
       (try_end),
     (try_end),

     (display_message, "@Battle Advantage = {reg0}.{s1}", 0xFFFFFFFF), #chief rigale cambia
     #rigale chief acaba
 ]),
  
  
  # script_cf_check_enemies_nearby
  # Input: none
  # Output: none, fails when enemies are nearby
  ("cf_check_enemies_nearby",
    [
      (get_player_agent_no, ":player_agent"),
#      (agent_is_alive, ":player_agent"),
      (agent_get_position, pos1, ":player_agent"),
      (assign, ":result", 0),
      (set_fixed_point_multiplier, 100),
      (try_for_agents,":cur_agent"),
        (neq, ":cur_agent", ":player_agent"),
##        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
##        (neg|agent_is_ally, ":cur_agent"),
        (agent_get_position, pos2, ":cur_agent"),
        (get_distance_between_positions, ":cur_distance", pos1, pos2),
        (le, ":cur_distance", 1), #0'01 meters chief cambiada distancia
        (assign, ":result", 1),
      (try_end),
      (eq, ":result", 0),
  ]),
  
  # script_get_heroes_attached_to_center_aux
  # For internal use only
  ("get_heroes_attached_to_center_aux",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_get_num_companion_stacks, ":num_stacks",":center_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":center_no",":i_stack"),
        (troop_is_hero, ":stack_troop"),
        (party_add_members, ":party_no_to_collect_heroes", ":stack_troop", 1),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":center_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":center_no", ":attached_party_rank"),
        (call_script, "script_get_heroes_attached_to_center_aux", ":attached_party", ":party_no_to_collect_heroes"),
      (try_end),
  ]),
  
  # script_get_heroes_attached_to_center
  # Input: arg1 = center_no, arg2 = party_no_to_collect_heroes
  # Output: none, adds heroes to the party_no_to_collect_heroes party
  ("get_heroes_attached_to_center",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_clear, ":party_no_to_collect_heroes"),
      (call_script, "script_get_heroes_attached_to_center_aux", ":center_no", ":party_no_to_collect_heroes"),

#rebellion changes begin -Arma
     (try_for_range, ":pretender", pretenders_begin, pretenders_end),
        (neq, ":pretender", "$supported_pretender"),
        (troop_slot_eq, ":pretender", "slot_troop_cur_center", ":center_no"),
        (party_add_members, ":party_no_to_collect_heroes", ":pretender", 1),
     (try_end),

#     (try_for_range, ":rebel_faction", rebel_factions_begin, rebel_factions_end),
#        (faction_slot_eq, ":rebel_faction", "slot_faction_state", sfs_inactive_rebellion),
#        (faction_slot_eq, ":rebel_faction", "slot_faction_inactive_leader_location", ":center_no"),
#        (faction_get_slot, ":pretender", ":rebel_faction", "slot_faction_leader"),
#        (party_add_members, ":party_no_to_collect_heroes", ":pretender", 1),
#     (try_end),
#rebellion changes end


  ]),
  
  
  # script_get_heroes_attached_to_center_as_prisoner_aux
  # For internal use only
  ("get_heroes_attached_to_center_as_prisoner_aux",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_get_num_prisoner_stacks, ":num_stacks",":center_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_prisoner_stack_get_troop_id, ":stack_troop",":center_no",":i_stack"),
        (troop_is_hero, ":stack_troop"),
        (party_add_members, ":party_no_to_collect_heroes", ":stack_troop", 1),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":center_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":center_no", ":attached_party_rank"),
        (call_script, "script_get_heroes_attached_to_center_as_prisoner_aux", ":attached_party", ":party_no_to_collect_heroes"),
      (try_end),
  ]),
  
  
  # script_get_heroes_attached_to_center_as_prisoner
  # Input: arg1 = center_no, arg2 = party_no_to_collect_heroes
  # Output: none, adds heroes to the party_no_to_collect_heroes party
  ("get_heroes_attached_to_center_as_prisoner",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_clear, ":party_no_to_collect_heroes"),
      (call_script, "script_get_heroes_attached_to_center_as_prisoner_aux", ":center_no", ":party_no_to_collect_heroes"),
  ]),
  
##  
##  # script_cf_get_party_leader
##  # Input: arg1 = party_no
##  # Output: reg0 = troop_no of the leader (Can fail)
##  ("cf_get_party_leader",
##    [
##      (store_script_param_1, ":party_no"),
##      
##      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
##      (gt, ":num_stacks", 0),
##      (party_stack_get_troop_id, ":stack_troop", ":party_no", 0),
##      (troop_is_hero, ":stack_troop"),
##      (assign, reg0, ":stack_troop"),
##  ]),
  
  # script_give_center_to_faction
  # Input: arg1 = center_no, arg2 = faction
  ("give_center_to_faction",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":faction_no"),
      ##diplomacy chief begin
      (party_set_slot, ":center_no", "slot_center_taxation", 0),
      (try_begin),
        (party_slot_eq, ":center_no", "slot_village_infested_by_bandits", "trp_peasant_woman"),
        (party_set_slot, ":center_no", "slot_village_infested_by_bandits", 0),
      (try_end),

      constable.consequences_give_center,
      ##diplomacy chief end
      
      (try_begin),
        (eq, ":faction_no", "fac_player_supporters_faction"),        
        (faction_get_slot, ":player_faction_king", "fac_player_supporters_faction", "slot_faction_leader"),
        (eq, ":player_faction_king", "trp_player"),
        
        (try_begin),
          (is_between, ":center_no", walled_centers_begin, walled_centers_end),
          (assign, ":number_of_walled_centers_players_kingdom_has", 1),
        (else_try),
          (assign, ":number_of_walled_centers_players_kingdom_has", 0),
        (try_end),
        
        (try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
          (store_faction_of_party, ":owner_faction_no", ":walled_center"),
          (eq, ":owner_faction_no", "fac_player_supporters_faction"),          
          (val_add, ":number_of_walled_centers_players_kingdom_has", 1),
        (try_end),
        
        (ge, ":number_of_walled_centers_players_kingdom_has", 10),
        (unlock_achievement, ACHIEVEMENT_VICTUM_SEQUENS),
      (try_end),  
      
      (try_begin),
        (check_quest_active, "qst_join_siege_with_army"),
        (quest_slot_eq, "qst_join_siege_with_army", "slot_quest_target_center", ":center_no"),
        (call_script, "script_abort_quest", "qst_join_siege_with_army", 0),
        #Reactivating follow army quest
        (faction_get_slot, ":faction_marshall", "$players_kingdom", "slot_faction_marshall"),
        (str_store_troop_name_link, s9, ":faction_marshall"),
        (setup_quest_text, "qst_follow_army"),
        (str_store_string, s2, "@{s9} wants you to resume following his army until further notice."),
        (call_script, "script_start_quest", "qst_follow_army", ":faction_marshall"),
        (assign, "$g_player_follow_army_warnings", 0),
      (try_end),

      #(store_faction_of_party, ":old_faction", ":center_no"),
      (call_script, "script_give_center_to_faction_aux", ":center_no", ":faction_no"),
      (call_script, "script_update_village_market_towns"),

      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (call_script, "script_faction_recalculate_strength", ":cur_faction"),
      (try_end),
      (assign, "$g_recalculate_ais", 1),
	  
	  (try_begin),
        (eq, ":faction_no", "fac_player_supporters_faction"),
		(faction_slot_eq, "fac_player_supporters_faction", "slot_faction_state", sfs_inactive),
		(call_script, "script_activate_player_faction", "trp_player"),
	  (try_end),
	  	  
      #(call_script, "script_activate_deactivate_player_faction", ":old_faction"),
      #(try_begin),
      #(eq, ":faction_no", "fac_player_supporters_faction"),
      #(faction_slot_eq, "fac_player_supporters_faction", "slot_faction_leader", "trp_player"),
      #(call_script, "script_give_center_to_lord", ":center_no", "trp_player", 0),
	
      #check with Armagan -- what is this here for?
      #(try_for_range, ":cur_village", villages_begin, villages_end),
      #(store_faction_of_party, ":cur_village_faction", ":cur_village"),
      #(eq, ":cur_village_faction", "fac_player_supporters_faction"),
      #(neg|party_slot_eq, ":cur_village", "slot_town_lord", "trp_player"),
      #(call_script, "script_give_center_to_lord", ":cur_village", "trp_player", 0),
      #(try_end),
      #(try_end),
    ]),
  
  # script_give_center_to_faction_aux
  # Input: arg1 = center_no, arg2 = faction
  ("give_center_to_faction_aux",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":faction_no"),

      (store_faction_of_party, ":old_faction", ":center_no"),
      (party_set_faction, ":center_no", ":faction_no"),

      (try_begin),
        (party_slot_eq, ":center_no", "slot_party_type", spt_village),
        (party_get_slot, ":farmer_party", ":center_no", "slot_village_farmer_party"),
        (gt, ":farmer_party", 0),
        (party_is_active, ":farmer_party"),
        (party_set_faction, ":farmer_party", ":faction_no"),
      (try_end),

      (try_begin),
	    #This bit of seemingly redundant code (the neq condition) is designed to prevent a bug that occurs when a player first conquers a center -- apparently this script is called again AFTER it is handed to a lord
		#Without this line, then the player's dialog selection does not have any affect, because town_lord is set again to stl_unassigned after the player makes his or her choice
	    (neq, ":faction_no", ":old_faction"),
		
        (party_set_slot, ":center_no", "slot_center_ex_faction", ":old_faction"),
        (party_get_slot, ":old_town_lord", ":center_no", "slot_town_lord"),
        (party_set_slot, ":center_no", "slot_town_lord", stl_unassigned),
        (party_set_banner_icon, ":center_no", 0),#Removing banner
        (call_script, "script_update_faction_notes", ":old_faction"),
      (try_end),  
      
      (call_script, "script_update_faction_notes", ":faction_no"),
      (call_script, "script_update_center_notes", ":center_no"),
      
      (try_begin),
        (ge, ":old_town_lord", 0),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (call_script, "script_update_troop_notes", ":old_town_lord"),
      (try_end),

      (try_for_range, ":other_center", centers_begin, centers_end),
        (party_slot_eq, ":other_center", "slot_village_bound_center", ":center_no"),
        (call_script, "script_give_center_to_faction_aux", ":other_center", ":faction_no"),
      (try_end),
  ]),
  
  # script_change_troop_faction
  # Input: arg1 = troop_no, arg2 = faction
  ("change_troop_faction",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":faction_no"),
      (try_begin),
        #Reactivating inactive or defeated faction
        (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (neg|faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
        (faction_set_slot, ":faction_no", "slot_faction_state", sfs_active),
        #(call_script, "script_store_average_center_value_per_faction"),
      (try_end),

	  #Political ramifications
	  (store_faction_of_troop, ":orig_faction", ":troop_no"),
	  ##diplomacy start+ save these for reference chief
	  #(faction_get_slot, ":orig_faction_leader", ":orig_faction", "slot_faction_leader"),
	  (faction_get_slot, ":new_faction_leader", ":faction_no", "slot_faction_leader"),
	  ##diplomacy end+

 #remove if he is marshal
	  (try_begin),
		(faction_slot_eq, ":orig_faction", "slot_faction_marshall", ":troop_no"),
        (call_script, "script_check_and_finish_active_army_quests_for_faction", ":orig_faction"),       

		#No current issue on the agenda
		(try_begin),
			(faction_slot_eq, ":orig_faction", "slot_faction_political_issue", 0),
		
			(faction_set_slot, ":orig_faction", "slot_faction_political_issue", 1), #Appointment of marshal
			(store_current_hours, ":hours"),
			(val_max, ":hours", 0),
			(faction_set_slot, ":orig_faction", "slot_faction_political_issue_time", ":hours"), #Appointment of marshal
			(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":orig_faction"),
				(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
			(try_end),		
			(try_begin),
				(eq, "$players_kingdom", ":orig_faction"),
				(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
			(try_end),		
		(try_end),
		
        (try_begin),
		  (troop_get_slot, ":old_marshall_party", ":troop_no", "slot_troop_leaded_party"),
          (party_is_active, ":old_marshall_party"),
          (party_set_marshall, ":old_marshall_party", 0),
        (try_end),  

		(faction_set_slot, ":orig_faction", "slot_faction_marshall", -1),
	  (try_end),
	  #Removal as marshal ends
	  
	  #Other political ramifications
	  (troop_set_slot, ":troop_no", "slot_troop_stance_on_faction_issue", -1),
	  (try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
		(troop_slot_eq, ":active_npc", "slot_troop_stance_on_faction_issue", ":troop_no"),
		(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
	  (try_end),
	  #Political ramifications end
	  
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":troop_no"),
			(display_message, "@{!}DEBUG - {s4} faction changed from script change_troop_faction"), 
		(try_end),
	  	  
      (troop_set_faction, ":troop_no", ":faction_no"),
	  ##diplomacy start+ chief
	  ##Don't give lords amnesia about what the player said to recruit them.
	  ##OLD:
      #(troop_set_slot, ":troop_no", "slot_troop_recruitment_random", 0),
      #(troop_set_slot, ":troop_no", "slot_lord_recruitment_argument", 0),
      #(troop_set_slot, ":troop_no", "slot_lord_recruitment_candidate", 0),
      #(troop_set_slot, ":troop_no", "slot_troop_promised_fief", 0),
	  ##NEW
	  (try_begin),
		 (eq, ":troop_no", "trp_player"),
		 #Don't change of this for the player.
	  (else_try),
	    (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
		 (this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
			(eq, ":faction_no", "$players_kingdom"),
		 (ge, ":new_faction_leader", 0),
		 (this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
		 (this_or_next|eq, ":new_faction_leader", "trp_player"),
		 (this_or_next|troop_slot_eq, ":new_faction_leader", "slot_troop_spouse", "trp_player"),
			(troop_slot_eq, "trp_player", "slot_troop_spouse", ":new_faction_leader"),
		 #Joined faction that player is ruler or co-ruler of.  Don't forget
		 #any promises received.
		 (troop_set_slot, ":troop_no", "slot_troop_recruitment_random", 0),
	  (else_try),
	     #Joined a new faction.  Previous promises moot.
		 (troop_set_slot, ":troop_no", "slot_troop_recruitment_random", 0),
		 (troop_set_slot, ":troop_no", "slot_lord_recruitment_argument", 0),
		 (troop_set_slot, ":troop_no", "slot_lord_recruitment_candidate", 0),
		 (troop_set_slot, ":troop_no", "slot_troop_promised_fief", 0),
	  (try_end),
	  ##diplomacy end+

      #Give new title
#      (call_script, "script_troop_set_title_according_to_faction", ":troop_no", ":faction_no"), #quita chief nuevo titulo
      
      (try_begin),
        (this_or_next|eq, ":faction_no", "$players_kingdom"),
        (eq, ":faction_no", "fac_player_supporters_faction"),
        (call_script, "script_check_concilio_calradi_achievement"),
      (try_end),

      #Takes walled centers and dependent villages with him
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
        (party_set_faction, ":center_no", ":faction_no"),
        (try_for_range, ":village_no", villages_begin, villages_end),
          (party_slot_eq, ":village_no", "slot_village_bound_center", ":center_no"),
          (party_set_faction, ":village_no", ":faction_no"),
          (party_get_slot, ":farmer_party_no", ":village_no", "slot_village_farmer_party"),
          (try_begin),
            (gt, ":farmer_party_no", 0),
            (party_is_active, ":farmer_party_no"),
            (party_set_faction, ":farmer_party_no", ":faction_no"),
          (try_end),
          (try_begin),
            (party_get_slot, ":old_town_lord", ":village_no", "slot_town_lord"),
            (neq, ":old_town_lord", ":troop_no"),
            (party_set_slot, ":village_no", "slot_town_lord", stl_unassigned),
          (try_end),
        (try_end),
      (try_end),
	  
	  #Dependant kingdom ladies switch faction
	  (try_for_range, ":kingdom_lady", kingdom_ladies_begin, kingdom_ladies_end),
		(call_script, "script_get_kingdom_lady_social_determinants", ":kingdom_lady"),
		(assign, ":closest_male_relative", reg0),
		(assign, ":new_center", reg1),
		
		(eq, ":closest_male_relative", ":troop_no"),
		
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":kingdom_lady"),
			(display_message, "@{!}DEBUG - {s4} faction changed by guardian moving"), 
		(try_end),
		
		(troop_set_faction, ":kingdom_lady", ":faction_no"),
		(troop_slot_eq, ":kingdom_lady", "slot_troop_prisoner_of_party", -1),
		(troop_set_slot, ":kingdom_lady", "slot_troop_cur_center", ":new_center"),
	  (try_end),
	  
	  #Remove his control over villages under another fortress
      (try_for_range, ":village_no", villages_begin, villages_end),
        (party_slot_eq, ":village_no", "slot_town_lord", ":troop_no"),
        (store_faction_of_party, ":village_faction", ":village_no"),
        (try_begin),
          (neq, ":village_faction", ":faction_no"),
          (party_set_slot, ":village_no", "slot_town_lord", stl_unassigned),
        (try_end),
      (try_end),
	  
	  #Free prisoners
      (try_begin),
        (troop_get_slot, ":leaded_party", ":troop_no", "slot_troop_leaded_party"),
        (gt, ":leaded_party", 0),
        (party_set_faction, ":leaded_party", ":faction_no"),
        (party_get_num_prisoner_stacks, ":num_stacks", ":leaded_party"),
        (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
          (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":leaded_party", ":troop_iterator"),
          (store_troop_faction, ":cur_faction", ":cur_troop_id"),
          (troop_is_hero, ":cur_troop_id"),
          (eq, ":cur_faction", ":faction_no"),
          (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
          (party_remove_prisoners, ":leaded_party", ":cur_troop_id", 1),
        (try_end),
      (try_end),
	  
	  #Annull all quests of which the lord is giver
	  (try_for_range, ":quest", all_quests_begin, all_quests_end),
		(check_quest_active, ":quest"),
		(quest_slot_eq, ":quest", "slot_quest_giver_troop", ":troop_no"),
		
		(str_store_troop_name, s4, ":troop_no"),
		(try_begin),
		  (eq, "$cheat_mode", 1),
  		  (display_message, "str_s4_changing_sides_aborts_quest"),
        (try_end),
		(call_script, "script_abort_quest", ":quest", 0),
	  (try_end),
	  
	  #Boot all lords out of centers whose faction has changed
	  (try_for_range, ":lord_to_move", active_npcs_begin, active_npcs_end),
		(troop_get_slot, ":lord_led_party", ":lord_to_move", "slot_troop_leaded_party"),
	    (party_is_active, ":lord_led_party"),
		(party_get_attached_to, ":led_party_attached", ":lord_led_party"),
		(is_between, ":led_party_attached", walled_centers_begin, walled_centers_end),
		(store_faction_of_party, ":led_party_faction", ":lord_led_party"),
		(store_faction_of_party, ":attached_party_faction", ":led_party_attached"),
		(neq, ":led_party_faction", ":attached_party_faction"),
		
		(party_detach, ":lord_led_party"),
	  (try_end),
	  
	  #Increase relation with lord in new faction by 5
	  #Or, if player kingdom, make inactive pending confirmation
	  (faction_get_slot, ":faction_liege", ":faction_no", "slot_faction_leader"),
	  (try_begin),
		(eq, ":faction_liege", "trp_player"),
		(neq, ":troop_no", "$g_talk_troop"),
	    (troop_set_slot, ":troop_no", "slot_troop_occupation", slto_inactive), #POSSIBLE REASON 1
	  (else_try),
		(is_between, ":faction_liege", active_npcs_begin, active_npcs_end),
		(is_between, ":troop_no", active_npcs_begin, active_npcs_end),
		(call_script, "script_troop_change_relation_with_troop", ":faction_liege", ":troop_no", 10),#gdw10
		(val_add, "$total_indictment_changes", 10),
	  (try_end),
	  
	  #Break courtship relations
	  (try_begin),
	  	(troop_slot_ge, ":troop_no", "slot_troop_spouse", 0),
		#Already married, do nothing
	  (else_try),
		(is_between, ":troop_no", active_npcs_begin, active_npcs_end),
	    (try_for_range, ":love_interest_slot", "slot_troop_love_interest_1", "slot_troop_love_interests_end"),
			(troop_get_slot, ":courted_lady", ":troop_no", ":love_interest_slot"),
			(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":courted_lady", ":troop_no"),
	    (try_end),
		(call_script, "script_assign_troop_love_interests", ":troop_no"),
	  (else_try),	
		(is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(try_for_range, ":love_interest_slot", "slot_troop_love_interest_1", "slot_troop_love_interests_end"),
				(troop_slot_eq, ":active_npc", ":love_interest_slot", ":troop_no"),
				(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":troop_no", ":active_npc"),
			(try_end),
		(try_end),
	  (try_end),
	  
	  #Stop raidings/sieges of new faction's fief if there is any
	  (troop_get_slot, ":troop_party", ":troop_no", "slot_troop_leaded_party"),
	  (try_for_range, ":center_no", centers_begin, centers_end),
	    (party_slot_eq, ":center_no", "slot_party_type", spt_village),
	    (party_get_slot, ":raided_by", ":center_no", "slot_village_raided_by"),	    
	    (eq, ":raided_by", ":troop_party"),
	    (party_set_slot, ":center_no", "slot_village_raided_by", -1),
	    (try_begin),
	      (party_slot_eq, ":center_no", "slot_village_state", svs_being_raided),	      
	      (party_set_slot, ":center_no", "slot_village_state", svs_normal),
	      (party_set_extra_text, ":center_no", "str_empty_string"),
	    (try_end),
	  (else_try),  	    
	    (party_get_slot, ":besieged_by", ":center_no", "slot_center_is_besieged_by"),
	    (eq, ":besieged_by", ":troop_party"),
	    (party_set_slot, ":center_no", "slot_center_is_besieged_by", -1),
	    (try_begin),	    
	      (party_slot_eq, ":center_no", "slot_village_state", svs_under_siege),	      
	      (party_set_slot, ":center_no", "slot_village_state", svs_normal),
	      (party_set_extra_text, ":center_no", "str_empty_string"),
	    (try_end),
	  (try_end),
	  	  
      (call_script, "script_update_all_notes"),

      (call_script, "script_update_village_market_towns"),
      (assign, "$g_recalculate_ais", 1),
      ]),

  # script_troop_set_title_according_to_faction
  # Input: arg1 = troop_no, arg2 = faction_no
  ("troop_set_title_according_to_faction",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":faction_no", 2),
      (try_begin),
        (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (str_store_troop_name_plural, s0, ":troop_no"),
        (troop_get_type, ":gender", ":troop_no"),
        (store_sub, ":title_index", ":faction_no", kingdoms_begin),
        (try_begin),
###gender fix chief
       (this_or_next|eq, ":gender", 0), #male
       (this_or_next|eq, ":gender", 2), #male
       (this_or_next|eq, ":gender", 4), #male
       (eq, ":gender", 6), #male
#gender fix chief acaba
          (val_add, ":title_index", kingdom_titles_male_begin),
        (else_try),
          (val_add, ":title_index", kingdom_titles_female_begin),
        (try_end),
        (str_store_string, s1, ":title_index"),
        (troop_set_name, ":troop_no", s1),
        (troop_get_slot, ":troop_party", ":troop_no", "slot_troop_leaded_party"),
        (gt, ":troop_party", 0),
        (str_store_troop_name, s5, ":troop_no"),
        (party_set_name, ":troop_party", "str_s5_s_party"),
      (try_end),
      ]),

  # script_give_center_to_lord
  # Input: arg1 = center_no, arg2 = lord_troop, arg3 = add_garrison_to_center
  ("give_center_to_lord",
    [
      (store_script_param, ":center_no", 1),
      (store_script_param, ":lord_troop_id", 2), #-1 only in the case of a player deferring ownership of a center
      (store_script_param, ":add_garrison", 3),
      ##diplomacy chief begin
      (party_set_slot, ":center_no", "slot_center_taxation", 0),
      (try_begin),
        (party_slot_eq, ":center_no", "slot_village_infested_by_bandits", "trp_peasant_woman"),
        (party_set_slot, ":center_no", "slot_village_infested_by_bandits", 0),
      (try_end),
      ##diplomacy chief end

	  (try_begin),
	  ##diplomacy start+ chief notable events like this should be logged by default chief pone off, demasiados textos
##	   (ge, ":lord_troop_id", 0),
##		(str_store_party_name_link, s4, ":center_no"),
##		(str_store_troop_name_link, s5, ":lord_troop_id"),
##		(store_troop_faction, ":msg_faction_no", ":lord_troop_id"),
##		#Floris - refine text
##		(try_begin),
##			(eq, ":msg_faction_no", "fac_player_faction"),
##			(is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
##			(assign, ":msg_faction_no", "$players_kingdom"),
##		(try_end),
##		#Floris - refine text end
##		(str_store_faction_name_link, s7, ":msg_faction_no"),
##		(try_begin),
##		   (faction_slot_eq, ":msg_faction_no", "slot_faction_leader", ":lord_troop_id"),
##		   (display_log_message, "@{s5} of the {s7} has taken ownership of {s4}."),
##		(else_try),
##		   (display_log_message, "@{s4} has been awarded to {s5} of the {s7}."),
##		(try_end),
##	  (else_try),
	  ##diplomacy end+
	    (eq, "$cheat_mode", 1),
		(ge, ":lord_troop_id", 0),
		(str_store_party_name, s4, ":center_no"),
		(str_store_troop_name, s5, ":lord_troop_id"),
		(display_debug_message, "@{!}DEBUG -- {s4} awarded to {s5}"),
	  (try_end),
	  (try_begin),
	    (eq, ":lord_troop_id", "trp_player"),
	    (unlock_achievement, ACHIEVEMENT_ROYALITY_PAYMENT),
	    
	    (assign, ":number_of_fiefs_player_have", 1),
	    (try_for_range, ":cur_center", centers_begin, centers_end),
	      (neq, ":cur_center", ":center_no"),
	      (party_slot_eq, ":cur_center", "slot_town_lord", "trp_player"),
	      (val_add, ":number_of_fiefs_player_have", 1),
	    (try_end),
	    
	    (ge, ":number_of_fiefs_player_have", 5),
	    (unlock_achievement, ACHIEVEMENT_MEDIEVAL_EMLAK),	    
	  (try_end),
      
      (party_get_slot, ":old_lord_troop_id", ":center_no", "slot_town_lord"),
      
	  (try_begin), #This script is ONLY called with lord_troop_id = -1 when it is the player faction 
	    (eq, ":lord_troop_id", -1),
	    (assign, ":lord_troop_faction", "fac_player_supporters_faction"),
        (party_set_banner_icon, ":center_no", 0),#Removing banner
		
      (else_try),	
	    (eq, ":lord_troop_id", "trp_player"),
	    (assign, ":lord_troop_faction", "$players_kingdom"), #was changed on Apr 27 from fac_plyr_sup_fac

      (else_try),	  
		(store_troop_faction, ":lord_troop_faction", ":lord_troop_id"),
	  (try_end),	
	  (faction_get_slot, ":faction_leader", ":lord_troop_faction", "slot_faction_leader"),
	  
	  (try_begin),
	    (eq, ":faction_leader", "trp_player"),

        (try_begin),
            (troop_get_type, ":is_female", "trp_player"),
            (val_mod, ":is_female", 2),    #gender fix chief moto
      (eq, ":is_female", 1),
            (unlock_achievement, ACHIEVEMENT_QUEEN),
        (try_end),
	  (try_end),

	  (try_begin),
		(eq, ":faction_leader", ":old_lord_troop_id"),
		(call_script, "script_add_log_entry", logent_liege_grants_fief_to_vassal, ":faction_leader", ":center_no", ":lord_troop_id", ":lord_troop_faction"),
        (troop_set_slot, ":lord_troop_id", "slot_troop_promised_fief", 0),
	  (try_end),

      (try_begin),
	    (eq, ":lord_troop_id", -1), #Lord troop ID -1 is only used when a player is deferring assignment of a fief
        (party_set_faction, ":center_no", "$players_kingdom"),
	  (else_try),
        (eq, ":lord_troop_id", "trp_player"),
        (gt, "$players_kingdom", 0),
        (party_set_faction, ":center_no", "$players_kingdom"),
      (else_try),
        (eq, ":lord_troop_id", "trp_player"),
        (neg|is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
        (party_set_faction, ":center_no", "fac_player_supporters_faction"),
      (else_try),
        (party_set_faction, ":center_no", ":lord_troop_faction"),
      (try_end),
      (party_set_slot, ":center_no", "slot_town_lord", ":lord_troop_id"),

      (try_begin),
        (party_slot_eq, ":center_no", "slot_party_type", spt_village),
        (party_get_slot, ":farmer_party_no", ":center_no", "slot_village_farmer_party"),
        (gt, ":farmer_party_no", 0),
        (party_is_active, ":farmer_party_no"),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (party_set_faction, ":farmer_party_no", ":center_faction"),
      (try_end),

    (try_begin),
        (this_or_next|party_slot_eq, ":center_no", "slot_party_type", spt_town),
			(party_slot_eq, ":center_no", "slot_party_type", spt_castle),
		(gt, ":lord_troop_id", -1),
		
#normal_banner_begin
        (troop_get_slot, ":cur_banner", ":lord_troop_id", "slot_troop_banner_scene_prop"),
        (gt, ":cur_banner", 0),
        (val_sub, ":cur_banner", banner_scene_props_begin),
        (val_add, ":cur_banner", banner_map_icons_begin),
        (party_set_banner_icon, ":center_no", ":cur_banner"),
# custom_banner_begin
#        (troop_get_slot, ":flag_icon", ":lord_troop_id", "slot_troop_custom_banner_map_flag_type"),
#        (ge, ":flag_icon", 0),
#        (val_add, ":flag_icon", custom_banner_map_icons_begin),
#        (party_set_banner_icon, ":center_no", ":flag_icon"),
    (try_end),

#    (try_begin),
#		(eq, 1, 0),
 #       (eq, ":lord_troop_id", "trp_player"),
 #       (neq, ":old_lord_troop_id", "trp_player"),
 #       (party_get_slot, ":center_relation", ":center_no", "slot_center_player_relation"),
 #       (is_between, ":center_relation", -4, 5),
 #       (call_script, "script_change_player_relation_with_center", ":center_no", 5),
 #       (gt, ":old_lord_troop_id", 0),
 #       (call_script, "script_change_player_relation_with_troop", ":old_lord_troop_id", -25),
 #   (try_end),
	(try_begin),
		(gt, ":lord_troop_id", -1),
		(call_script, "script_update_troop_notes", ":lord_troop_id"),
	(try_end),
	
    (call_script, "script_update_center_notes", ":center_no"),
    
    (try_begin),
      (gt, ":lord_troop_faction", 0),
      (call_script, "script_update_faction_notes", ":lord_troop_faction"),
    (try_end),  
    
    (try_begin),
        (ge, ":old_lord_troop_id", 0),
        (call_script, "script_update_troop_notes", ":old_lord_troop_id"),
        (store_troop_faction, ":old_lord_troop_faction", ":old_lord_troop_id"),
        (call_script, "script_update_faction_notes", ":old_lord_troop_faction"),
    (try_end),

    (try_begin),
        (eq, ":add_garrison", 1),
        (this_or_next|party_slot_eq, ":center_no", "slot_party_type", spt_town),
			(party_slot_eq, ":center_no", "slot_party_type", spt_castle),
        (assign, ":garrison_strength", 3), 
        (try_begin),
          (party_slot_eq, ":center_no", "slot_party_type", spt_town),
          (assign, ":garrison_strength", 9),
        (try_end),
        (try_for_range, ":unused", 0, ":garrison_strength"),
          (call_script, "script_cf_reinforce_party", ":center_no"),
        (try_end),
        ## ADD some XP initially
        (try_for_range, ":unused", 0, 7),
          (store_mul, ":xp_range_min", 150, ":garrison_strength"),
          (store_mul, ":xp_range_max", 200, ":garrison_strength"),
          (store_random_in_range, ":xp", ":xp_range_min", ":xp_range_max"),
          (party_upgrade_with_xp, ":center_no", ":xp", 0),
        (try_end),
    (try_end),

	(faction_get_slot, ":faction_leader", ":lord_troop_faction", "slot_faction_leader"),
	(store_current_hours, ":hours"),
	
	#the next block handles gratitude, objections and jealousies
	(try_begin),
	  	(gt, ":hours", 0),
		(gt, ":lord_troop_id", 0),
		
    	(call_script, "script_troop_change_relation_with_troop", ":lord_troop_id", ":faction_leader", 19),
		(val_add, "$total_promotion_changes", 19),#gdw10bw
		
		#smaller factions are more dramatically influenced by internal jealousies
		#Disabled as of NOV 2010
#		(try_begin),
#			(neg|faction_slot_ge, ":lord_troop_faction", "slot_faction_number_of_parties", 4),
#			(assign, ":faction_size_multiplier", 6),
#		(else_try),
#			(neg|faction_slot_ge, ":lord_troop_faction", "slot_faction_number_of_parties", 8),
#			(assign, ":faction_size_multiplier", 5),
#		(else_try),
#			(neg|faction_slot_ge, ":lord_troop_faction", "slot_faction_number_of_parties", 16),
#			(assign, ":faction_size_multiplier", 4),
#		(else_try),
#			(neg|faction_slot_ge, ":lord_troop_faction", "slot_faction_number_of_parties", 32),
#			(assign, ":faction_size_multiplier", 3),
#		(else_try),	
#			(assign, ":faction_size_multiplier", 2),
#		(try_end),
		
		#factional politics -- each lord in the faction adjusts his relation according to the relation with the lord receiving the faction
		(try_for_range, ":other_lord", active_npcs_begin, active_npcs_end),
			(troop_slot_eq, ":other_lord", "slot_troop_occupation", slto_kingdom_hero),
			(neq, ":other_lord", ":lord_troop_id"),
			
		    (store_troop_faction, ":other_troop_faction", ":other_lord"),
		    (eq, ":lord_troop_faction", ":other_troop_faction"),

		    (neq, ":other_lord", ":faction_leader"),
			
	        (call_script, "script_troop_get_relation_with_troop", ":other_lord", ":lord_troop_id"),
			(assign, ":relation_with_troop", reg0),

			#relation reduction = relation/10 minus 2. So,0 = -2, 8 = -1, 16+ = no change or bonus, 24+ gain one point
		    (store_div, ":relation_with_liege_change", ":relation_with_troop", 8), #caba changed from 16 to8 #gdw8
		    (val_sub, ":relation_with_liege_change", 2),

		    (val_clamp, ":relation_with_liege_change", -4, 3),
			
			(try_begin),
				#upstanding and goodnatured lords will not lose relation unless they actively dislike the other lord
				(this_or_next|troop_slot_eq, ":other_lord", "slot_lord_reputation_type", lrep_upstanding),
					(troop_slot_eq, ":other_lord", "slot_lord_reputation_type", lrep_goodnatured),
				(ge, ":relation_with_troop", 0),
				(val_max, ":relation_with_liege_change", 0),
			(else_try),
				#penalty is increased for lords who have the more unpleasant reputation types
				(this_or_next|troop_slot_eq, ":other_lord", "slot_lord_reputation_type", lrep_selfrighteous),
				(this_or_next|troop_slot_eq, ":other_lord", "slot_lord_reputation_type", lrep_debauched),
					(troop_slot_eq, ":other_lord", "slot_lord_reputation_type", lrep_quarrelsome),
				(lt, ":relation_with_liege_change", 0),
				(val_mul, ":relation_with_liege_change", 3),
				(val_div, ":relation_with_liege_change", 2),
			(try_end),

			
		    (neq, ":relation_with_liege_change", 0),
			#removed Nov 2010
#		  	(val_mul, ":relation_reduction", ":faction_size_multiplier"),
#		  	(val_div, ":relation_reduction", 2),
			#removed Nov 2010
			#this might have to do with companions?gdw
			(try_begin),
				(troop_slot_eq, ":other_lord", "slot_troop_stance_on_faction_issue", ":lord_troop_id"),
				(val_add, ":relation_with_liege_change", 2),#gdw1
				(val_max, ":relation_with_liege_change", 2),#gdw1
			(try_end),
			
 	        (call_script, "script_troop_change_relation_with_troop", ":other_lord", ":faction_leader", ":relation_with_liege_change"),
			(val_add, "$total_promotion_changes", ":relation_with_liege_change"),
			
		    (try_begin),
				(this_or_next|le, ":relation_with_liege_change", -5), #Nov 2010 - #changed from -8gdw -4 to offset gain from granting fief
				(this_or_next|troop_slot_eq, ":other_lord", "slot_troop_promised_fief", 1), #1 is any fief
					(troop_slot_eq, ":other_lord", "slot_troop_promised_fief", ":center_no"),
				(call_script, "script_add_log_entry", logent_troop_feels_cheated_by_troop_over_land, ":other_lord", ":center_no", ":lord_troop_id", ":lord_troop_faction"),
				(assign, reg5, ":other_lord"),
				(assign, reg6, ":center_no"),
				(assign, reg7, ":lord_troop_id",),
				(assign, reg8, ":lord_troop_faction",),
			(display_debug_message, "@{!}DEBUG -- {reg7} feels cheated that other lord {reg5} was given fief {reg6} in faction {reg8}"),
      	    (try_end),
		 (try_end),
	(try_end),
		
	#Villages from another faction will also be transferred along with a fortress
    (try_begin),
		(is_between, ":center_no", walled_centers_begin, walled_centers_end),
        (try_for_range, ":cur_village", villages_begin, villages_end),
			(party_slot_eq, ":cur_village", "slot_village_bound_center", ":center_no"),
			(store_faction_of_party, ":cur_village_faction", ":cur_village"),
			(neq, ":cur_village_faction", ":lord_troop_faction"),
			
			(call_script, "script_give_center_to_lord", ":cur_village", ":lord_troop_id", 0),
        (try_end),
    (try_end),       
  ]),
  
##  # script_give_town_to_besiegers
##  # Input: arg1 = center_no, arg2 = besieger_party
##  ("give_town_to_besiegers",
##    [
##      (store_script_param_1, ":center_no"),
##      (store_script_param_2, ":besieger_party"),
##      (store_faction_of_party, ":besieger_faction", ":besieger_party"),
##      
##      (try_begin),
##        (call_script, "script_cf_get_party_leader", ":besieger_party"),
##        (assign, ":new_leader", reg0),
##      (else_try),
##        (call_script, "script_select_kingdom_hero_for_new_center", ":besieger_faction"),
##        (assign, ":new_leader", reg0),
##      (try_end),
##      
##      (call_script, "script_give_center_to_lord", ":center_no", ":new_leader"),
##      
##      (try_for_parties, ":party_no"),
##        (get_party_ai_object, ":object", ":party_no"),
##        (get_party_ai_behavior, ":behavior", ":party_no"),
##        (eq, ":object", ":center_no"),
##        (this_or_next|eq, ":behavior", ai_bhvr_travel_to_party),
##        (eq, ":behavior", ai_bhvr_attack_party),
##        (party_set_ai_behavior, ":party_no", ai_bhvr_hold),
##        (party_set_slot, ":party_no", "slot_party_ai_state", spai_undefined),
##        (party_set_flags, ":party_no", pf_default_behavior, 0),
##      (try_end),
##      
##      #Staying at the center for a while
##      (party_set_ai_behavior, ":besieger_party", ai_bhvr_hold),
##      (party_set_slot, ":besieger_party", "slot_party_ai_state", spai_undefined),
##      (party_set_flags, ":besieger_party", pf_default_behavior, 0),
##      
##      (faction_get_slot, ":reinforcement_a", ":besieger_faction", "slot_faction_reinforcements_a"),
##      (faction_get_slot, ":reinforcement_b", ":besieger_faction", "slot_faction_reinforcements_b"),
##      (party_add_template, ":center_no", ":reinforcement_a"),
##      (party_add_template, ":center_no", ":reinforcement_b"),
##  ]),
##  
  
  # script_get_number_of_hero_centers
  # Input: arg1 = troop_no
  # Output: reg0 = number of centers that are ruled by the hero
  ("get_number_of_hero_centers",
    [
      (store_script_param_1, ":troop_no"),
      (assign, ":result", 0),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
        (val_add, ":result", 1),
      (try_end),
      (assign, reg0, ":result"),
  ]),
  
  
  ##  # script_cf_get_new_center_leader_chance_for_troop
  ##  # Input: arg1 = troop_no
  ##  # Output: reg0 = chance of the troop to rule a new center
  ##  ("cf_get_new_center_leader_chance_for_troop",
  ##    [
  ##      (store_script_param_1, ":troop_no"),
  ##      (troop_get_slot, ":troop_rank", ":troop_no", "slot_troop_kingdom_rank"),
  ##      (try_begin),
  ##        (eq, ":troop_rank", 4),
  ##        (assign, ":troop_chance", 1000),
  ##      (else_try),
  ##        (eq, ":troop_rank", 3),
  ##        (assign, ":troop_chance", 800),
  ##      (else_try),
  ##        (eq, ":troop_rank", 2),
  ##        (assign, ":troop_chance", 400),
  ##      (else_try),
  ##        (eq, ":troop_rank", 1),
  ##        (assign, ":troop_chance", 100),
  ##      (else_try),
  ##        (assign, ":troop_chance", 10),
  ##      (try_end),
  ##
  ##      (call_script, "script_get_number_of_hero_centers", ":troop_no"),
  ##      (assign, ":number_of_hero_centers", reg0),
  ##      (try_begin),
  ##        (gt, ":number_of_hero_centers", 0),
  ##        (val_mul, ":number_of_hero_centers", 2),
  ##        (val_mul, ":number_of_hero_centers", ":number_of_hero_centers"),
  ##        (val_div, ":troop_chance", ":number_of_hero_centers"),
  ##      (try_end),
  ##      (assign, reg0, ":troop_chance"),
  ##      (eq, reg0, 0),
  ##      (assign, reg0, 1),
  ##  ]),
  
  
##  # script_select_kingdom_hero_for_new_center
##  # Input: arg1 = faction_no
##  # Output: reg0 = troop_no as the new leader
##  ("select_kingdom_hero_for_new_center",
##    [
##      (store_script_param_1, ":kingdom"),
##      
##      (assign, ":min_num_centers", -1),
##      (assign, ":min_num_centers_troop", -1),
##      
##      (try_for_range, ":troop_no", kingdom_heroes_begin, kingdom_heroes_end),
##        (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
##        (store_troop_faction, ":troop_faction", ":troop_no"),
##        (eq, ":troop_faction", ":kingdom"),
##        (call_script, "script_get_number_of_hero_centers", ":troop_no"),
##        (assign, ":num_centers", reg0),
##        (try_begin),
##          (lt, ":num_centers", ":min_num_centers"),
##          (assign, ":min_num_centers", ":num_centers"),
##          (assign, ":min_num_centers_troop", ":troop_no"),
##        (try_end),
##      (try_end),
##      (assign, reg0, ":min_num_centers_troop"),
##  ]),
  
  
  # script_cf_get_random_enemy_center
  # Input: arg1 = party_no
  # Output: reg0 = center_no
  ("cf_get_random_enemy_center",
    [
      (store_script_param_1, ":party_no"),
      
      (assign, ":result", -1),
      (assign, ":total_enemy_centers", 0),
      (store_faction_of_party, ":party_faction", ":party_no"),
      
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (store_relation, ":party_relation", ":center_faction", ":party_faction"),
        (lt, ":party_relation", 0),
        (val_add, ":total_enemy_centers", 1),
      (try_end),

      (gt, ":total_enemy_centers", 0),
      (store_random_in_range, ":random_center", 0, ":total_enemy_centers"),
      (assign, ":total_enemy_centers", 0),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (store_relation, ":party_relation", ":center_faction", ":party_faction"),
        (lt, ":party_relation", 0),
        (val_sub, ":random_center", 1),
        (lt, ":random_center", 0),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),
  
  
##  # script_get_random_enemy_town
##  # Input: arg1 = party_no
##  # Output: reg0 = center_no
##  ("get_random_enemy_town",
##    [
##      (store_script_param_1, ":party_no"),
##      
##      (assign, ":result", -1),
##      (assign, ":total_enemy_centers", 0),
##      (store_faction_of_party, ":party_faction", ":party_no"),
##      
##      (try_for_range, ":center_no", towns_begin, towns_end),
##        (store_faction_of_party, ":center_faction", ":center_no"),
##        (neq, ":center_faction", ":party_faction"),
##        (val_add, ":total_enemy_centers", 1),
##      (try_end),
##      
##      (try_begin),
##        (eq, ":total_enemy_centers", 0),
##      (else_try),
##        (store_random_in_range, ":random_center", 0, ":total_enemy_centers"),
##        (assign, ":total_enemy_centers", 0),
##        (try_for_range, ":center_no", towns_begin, towns_end),
##          (eq, ":result", -1),
##          (store_faction_of_party, ":center_faction", ":center_no"),
##          (neq, ":center_faction", ":party_faction"),
##          (store_relation, ":party_relation", ":center_faction", ":party_faction"),
##          (le, ":party_relation", -10),
##          (val_add, ":total_enemy_centers", 1),
##          (lt, ":random_center", ":total_enemy_centers"),
##          (assign, ":result", ":center_no"),
##        (try_end),
##      (try_end),
##      (assign, reg0, ":result"),
##  ]),
  
  
  
  # script_find_travel_location
  # Input: arg1 = center_no
  # Output: reg0 = new_center_no (to travel within the same faction)
  ("find_travel_location",
    [
      (store_script_param_1, ":center_no"),
      (store_faction_of_party, ":faction_no", ":center_no"),
      (assign, ":total_weight", 0),
      (try_for_range, ":cur_center_no", centers_begin, centers_end),
        (neq, ":center_no", ":cur_center_no"),
        (store_faction_of_party, ":center_faction_no", ":cur_center_no"),
        (eq, ":faction_no", ":center_faction_no"),
        
        (store_distance_to_party_from_party, ":cur_distance", ":center_no", ":cur_center_no"),
        (val_add, ":cur_distance", 1),
        
        (assign, ":new_weight", 100000),
        (val_div, ":new_weight", ":cur_distance"),
        (val_add, ":total_weight", ":new_weight"),
      (try_end),
      
      (assign, reg0, -1),
      
      (try_begin),
        (eq, ":total_weight", 0),
      (else_try),
        (store_random_in_range, ":random_weight", 0 , ":total_weight"),
        (assign, ":total_weight", 0),
        (assign, ":done", 0),
        (try_for_range, ":cur_center_no", centers_begin, centers_end),
          (eq, ":done", 0),
          (neq, ":center_no", ":cur_center_no"),
          (store_faction_of_party, ":center_faction_no", ":cur_center_no"),
          (eq, ":faction_no", ":center_faction_no"),
          
          (store_distance_to_party_from_party, ":cur_distance", ":center_no", ":cur_center_no"),
          (val_add, ":cur_distance", 1),
          
          (assign, ":new_weight", 100000),
          (val_div, ":new_weight", ":cur_distance"),
          (val_add, ":total_weight", ":new_weight"),
          (lt, ":random_weight", ":total_weight"),
          (assign, reg0, ":cur_center_no"),
          (assign, ":done", 1),
        (try_end),
      (try_end),
  ]),
  
  
  # script_get_relation_between_parties
  # Input: arg1 = party_no_1, arg2 = party_no_2
  # Output: reg0 = relation between parties
  ("get_relation_between_parties",
    [
      (store_script_param_1, ":party_no_1"),
      (store_script_param_2, ":party_no_2"),
      
      (store_faction_of_party, ":party_no_1_faction", ":party_no_1"),
      (store_faction_of_party, ":party_no_2_faction", ":party_no_2"),
      (try_begin),
        (eq, ":party_no_1_faction", ":party_no_2_faction"),
        (assign, reg0, 100),
      (else_try),
        (store_relation, ":relation", ":party_no_1_faction", ":party_no_2_faction"),
        (assign, reg0, ":relation"),
      (try_end),
  ]),
  # script_calculate_weekly_party_wage
  # Input: arg1 = party_no
  # Output: reg0 = weekly wage
  ("calculate_weekly_party_wage",
    [
      (store_script_param_1, ":party_no"),
      
      (assign, ":result", 0),
      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
        (call_script, "script_npc_get_troop_wage", ":stack_troop", ":party_no"),
        (assign, ":cur_wage", reg0),
        (val_mul, ":cur_wage", ":stack_size"),
        (val_add, ":result", ":cur_wage"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

 # script_calculate_player_faction_wage

 # Input: arg1 = party_no
 # Output: reg0 = weekly wage
 #         reg1 = number of troops paid #motomataru fix debt morale penalty
 ("calculate_player_faction_wage",
   [(assign, ":nongarrison_wages", 0),
    (assign, ":garrison_wages", 0),
    (assign, reg1, 0), #motomataru chief fix debt morale penalty
        (assign, ":ungarrison_wages", 0), #somebody chief patrullas
    (try_for_parties, ":party_no"),
      (assign, ":garrison_troop", 0),
          (assign, ":ungarrison_troop", 0), #somebody patrullas chief mercenarios
      (try_begin),
        (this_or_next|party_slot_eq, ":party_no", "slot_party_type", spt_town),
        (party_slot_eq, ":party_no", "slot_party_type", spt_castle),
        (party_slot_eq, ":party_no", "slot_town_lord", "trp_player"),
        (assign, ":garrison_troop", 1),
      (try_end),
#somebody chief patrullas
          (try_begin),
            (call_script, "script_cf_is_patrol",":party_no"),
            # (eq,reg0,0),    MOTO not needed
    (assign, ":ungarrison_troop", 1),
          (try_end),
#somebody chief patrullas acaba
      (this_or_next|eq, ":party_no", "p_main_party"),
      (this_or_next|eq, ":garrison_troop", 1),
           (eq, ":ungarrison_troop", 1),
     (party_get_num_companion_stacks, ":num_stacks",":party_no"),

      (try_for_range, ":i_stack", 0, ":num_stacks"),

        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
        (val_add, reg1, ":stack_size"), #motomataru chief fix debt morale penalty
        (call_script, "script_game_get_troop_wage", ":stack_troop", ":party_no"),
        (assign, ":cur_wage", reg0),
        (val_mul, ":cur_wage", ":stack_size"),
        (try_begin),
          (eq, ":garrison_troop", 1),
          (val_add, ":garrison_wages", ":cur_wage"),
        (else_try),
#somebody chief patrullas
              (try_begin),
                (eq, ":ungarrison_troop", 1),
                (val_add, ":ungarrison_wages", ":cur_wage"),
              (else_try),
#somebody chief patrullas acaba
          (val_add, ":nongarrison_wages", ":cur_wage"),
        (try_end),
      (try_end),
    (try_end),
#somebody patrullas
        (try_end),
        (val_mul, ":garrison_wages", 3),
        (options_get_campaign_ai, ":reduce"),
        (val_mul, ":reduce", 2),
        (val_add, ":reduce", 4),#4,6,8
        (val_div, ":garrison_wages", ":reduce"),#0.75/0.5/0.375 payment for garrisons
        (store_sub, ":total_payment", 14, "$g_cur_week_half_daily_wage_payments"), #between 0 and 7
        (val_mul, ":ungarrison_wages", 12),
        (val_div, ":ungarrison_wages", ":reduce"),
        (val_add, ":nongarrison_wages", ":ungarrison_wages"),
#somebody patrullas chief acaba
    (val_mul, ":nongarrison_wages", ":total_payment"),
    (val_div, ":nongarrison_wages", 14),
    (store_add, reg0, ":nongarrison_wages", ":garrison_wages"),
   ]),
  
  # script_calculate_hero_weekly_net_income_and_add_to_wealth
  # Input: arg1 = troop_no
  # Output: none
  ("calculate_hero_weekly_net_income_and_add_to_wealth",
    [
      (store_script_param_1, ":troop_no"),
      
      (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
      (troop_get_slot, ":cur_wealth", ":troop_no", "slot_troop_wealth"),
#TEMPERED chief CHANGES BEGIN
		(call_script,"script_update_hero_inventory",":troop_no",":cur_wealth"),
		(assign,":cur_wealth",reg0),
#TEMPERED CHANGES END      
      
      ## CC commander cambia chief dinero de los heros
      (call_script, "script_get_lord_weekly_income", ":troop_no"),
      (assign, ":weekly_income", reg0),
      ## CC
      
      (assign, ":cur_weekly_wage", 0),
      (try_begin),
        (gt, ":party_no",0),
        (call_script, "script_calculate_weekly_party_wage", ":party_no"),
        (assign, ":cur_weekly_wage", reg0),
        ## CC
        (store_skill_level, ":leadership_level", "skl_leadership", ":troop_no"),
        (store_mul, ":leadership_bonus", 5, ":leadership_level"),
        (store_sub, ":leadership_factor", 100, ":leadership_bonus"), 
        (val_mul, ":cur_weekly_wage", ":leadership_factor"),  #wage = wage * (100 - 5*leadership)/100
        (val_div, ":cur_weekly_wage", 100),
        ## CC
      (try_end),
      (val_sub, ":weekly_income", ":cur_weekly_wage"),
      
      (val_add, ":cur_wealth", ":weekly_income"),
      
      (try_begin),
        (lt, ":cur_wealth", 0),
        (store_sub, ":percent_under", 0, ":cur_wealth"),
        (val_mul, ":percent_under", 100),
        (val_div, ":percent_under", ":cur_weekly_wage"),
        (val_div, ":percent_under", 5), #Max 20 percent
        
        (call_script, "script_party_inflict_attrition", ":party_no", ":percent_under", 1),
      (try_end),
      
      (val_max, ":cur_wealth", 0),
      (troop_set_slot, ":troop_no", "slot_troop_wealth", ":cur_wealth"),
  ]),
  ##CC commander chief acaba cambios
  
  # script_cf_reinforce_party
  # Input: arg1 = party_no,
  # Output: none
  # Adds reinforcement to party according to its type and faction
  # Called from several places, simple_triggers for centers, script_hire_men_to_kingdom_hero_party for hero parties
  ("cf_reinforce_party",
    [
      (store_script_param_1, ":party_no"),
      
      (store_faction_of_party, ":party_faction", ":party_no"),
      (party_get_slot, ":party_type",":party_no", "slot_party_type"),

#Rebellion changes begin: 
      (try_begin),
        (eq, ":party_type", spt_kingdom_hero_party),
        (party_stack_get_troop_id, ":leader", ":party_no"),
        (troop_get_slot, ":party_faction",  ":leader", "slot_troop_original_faction"),
      (try_end),
#Rebellion changes end

      (try_begin),
        (eq, ":party_faction", "fac_player_supporters_faction"),
        (party_get_slot, ":town_lord", ":party_no", "slot_town_lord"),
        (try_begin),
        ##diplomacy chief begin
          (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
          (assign, ":party_faction", "$g_player_culture"),
          
          (try_begin), #debug
            (eq, "$cheat_mode", 1),
            (str_store_party_name, s11, ":party_no"),
            (display_message, "@pt in {s11}"),
          (try_end),
          
        (else_try),
        ##diplomacy chief end
          (gt, ":town_lord", 0),
          (troop_get_slot, ":party_faction", ":town_lord", "slot_troop_original_faction"),
        (else_try),
          (party_get_slot, ":party_faction", ":party_no", "slot_center_original_faction"),
        (try_end),
      (try_end),
      
      (faction_get_slot, ":party_template_a", ":party_faction", "slot_faction_reinforcements_a"),
      (faction_get_slot, ":party_template_b", ":party_faction", "slot_faction_reinforcements_b"),
      (faction_get_slot, ":party_template_c", ":party_faction", "slot_faction_reinforcements_c"),

      (assign, ":party_template", 0),
      (store_random_in_range, ":rand", 0, 100),
  	  ##diplomacy start+ chief
	  #Implement "quality vs. quantity" in a way that is visible in player battles
	  #(previously, quantity increased party size, but quality only had an effect
	  #in autocalc battles)
	  (try_begin),
		(is_between, ":party_faction", kingdoms_begin, kingdoms_end),
		(faction_get_slot, ":dplmc_quality", ":party_faction", "slot_faction_quality"),
		(val_clamp, ":dplmc_quality", -3, 4),
		(val_add, ":rand", ":dplmc_quality"),
		(val_clamp, ":rand", 0, 101),
	  (try_end),
	  ##diplomacy end+
      (try_begin),
        (this_or_next|eq, ":party_type", spt_town),
        (eq, ":party_type", spt_castle),  #CASTLE OR TOWN
        (try_begin),
          (lt, ":rand", 65),
          (assign, ":party_template", ":party_template_a"),
        (else_try),
          (assign, ":party_template", ":party_template_b"),
        (try_end),
      (else_try),
        (eq, ":party_type", spt_kingdom_hero_party),
        (try_begin),
          (lt, ":rand", 50),
          (assign, ":party_template", ":party_template_a"),
        (else_try),
          (lt, ":rand", 75),
          (assign, ":party_template", ":party_template_b"),
        (else_try),
          (assign, ":party_template", ":party_template_c"),
        (try_end),
      (else_try),
      (try_end),

      (try_begin),
        (gt, ":party_template", 0),
        (party_add_template, ":party_no", ":party_template"),
      (try_end),
  ]),
  
  # script_hire_men_to_kingdom_hero_party
  # Input: arg1 = troop_no (hero of the party)
  # Output: none
  ("hire_men_to_kingdom_hero_party",
    [
      (store_script_param_1, ":troop_no"),
      
      (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
      (troop_get_slot, ":cur_wealth", ":troop_no", "slot_troop_wealth"),
      
      #while hiring reinforcements party leaders can only use 3/4 of their budget. This value is holding in ":hiring budget".
      (assign, ":hiring_budget", ":cur_wealth"),
      (val_mul, ":hiring_budget", 3),
      (val_div, ":hiring_budget", 4),            
    
      (call_script, "script_party_get_ideal_size", ":party_no"),
      (assign, ":ideal_size", reg0),
      (store_mul, ":ideal_top_size", ":ideal_size", 3),
      (val_div, ":ideal_top_size", 2),

	  #(try_begin),
	  #	(ge, "$cheat_mode", 1),
      #  (str_store_troop_name, s7, ":troop_no"),
      #  (assign, reg9, ":cur_wealth"),
      #  (display_message, "@{!}DEBUGS : {s7} total budget is {reg9}"),
      #  (assign, reg6, ":ideal_size"),
      #  (assign, reg7, ":ideal_top_size"),
      #  (assign, reg8, ":hiring_budget"),
      #  (display_message, "str_debug__hiring_men_to_s7_ideal_size__reg6_ideal_top_size__reg7_hiring_budget__reg8"),
      #(try_end),
	  	  
      (party_get_num_companions, ":party_size", ":party_no"),
      
      (store_faction_of_party, ":party_faction", ":party_no"),
      (try_begin),
        (this_or_next|eq, ":party_faction", "fac_player_supporters_faction"),
        (eq, ":party_faction", "$players_kingdom"),        
        (assign, ":reinforcement_cost", reinforcement_cost_moderate),
      (else_try),
        (options_get_campaign_ai, ":reduce_campaign_ai"),
        (assign, ":reinforcement_cost", reinforcement_cost_moderate),
        (try_begin), 
          (eq, ":reduce_campaign_ai", 0), #hard
          (assign, ":reinforcement_cost", reinforcement_cost_hard),
        (else_try), 
          (eq, ":reduce_campaign_ai", 1), #moderate
          (assign, ":reinforcement_cost", reinforcement_cost_moderate),
        (else_try), 
          (eq, ":reduce_campaign_ai", 2), #easy
          (assign, ":reinforcement_cost", reinforcement_cost_easy),
        (try_end),           
      (try_end),  
      
      (assign, ":num_rounds", 1),            
      (try_for_range, ":unused", 0 , ":num_rounds"),
        (try_begin),
          (lt, ":party_size", ":ideal_size"),
          (gt, ":hiring_budget", ":reinforcement_cost"),
          (gt, ":party_no", 0), 
          (call_script, "script_cf_reinforce_party", ":party_no"),
          (val_sub, ":cur_wealth", ":reinforcement_cost"),
          (troop_set_slot, ":troop_no", "slot_troop_wealth", ":cur_wealth"),
        (else_try),
          (gt, ":party_size", ":ideal_top_size"),
          (store_troop_faction, ":troop_faction", ":troop_no"),
          (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
          (assign, ":total_regulars", 0),
          (assign, ":total_regular_levels", 0),
          (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
            (neg|troop_is_hero, ":stack_troop"),
            (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
            (store_character_level, ":stack_level", ":stack_troop"),
            (store_troop_faction, ":stack_faction", ":stack_troop"),
            (try_begin),
              (eq, ":troop_faction", ":stack_faction"),
              (val_mul, ":stack_level", 3), #reducing the chance of the faction troops' removal
            (try_end),
            (val_mul, ":stack_level", ":stack_size"),
            (val_add, ":total_regulars", ":stack_size"),
            (val_add, ":total_regular_levels", ":stack_level"),
          (try_end),
          (gt, ":total_regulars", 0),
          (store_div, ":average_level", ":total_regular_levels", ":total_regulars"),
          (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
            (neg|troop_is_hero, ":stack_troop"),
            (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
            (store_character_level, ":stack_level", ":stack_troop"),
            (store_troop_faction, ":stack_faction", ":stack_troop"),
            (try_begin),
              (eq, ":troop_faction", ":stack_faction"),
              (val_mul, ":stack_level", 3),
            (try_end),
            (store_sub, ":level_dif", ":average_level", ":stack_level"),
            (val_div, ":level_dif", 3),
            (store_add, ":prune_chance", 10, ":level_dif"),
            (gt, ":prune_chance", 0),
            (call_script, "script_get_percentage_with_randomized_round", ":stack_size", ":prune_chance"),
            (gt, reg0, 0),
            (party_remove_members, ":party_no", ":stack_troop", reg0),
          (try_end),
        (try_end),
      (try_end),
  ]),

  # script_get_percentage_with_randomized_round
  # Input: arg1 = value, arg2 = percentage
  # Output: none
  ("get_percentage_with_randomized_round",
    [
      (store_script_param, ":value", 1),
      (store_script_param, ":percentage", 2),

      (store_mul, ":result", ":value", ":percentage"),
      (val_div, ":result", 100),
      (store_mul, ":used_amount", ":result", 100),
      (val_div, ":used_amount", ":percentage"),
      (store_sub, ":left_amount", ":value", ":used_amount"),
      (try_begin),
        (gt, ":left_amount", 0),
        (store_mul, ":chance", ":left_amount", ":percentage"),
        (store_random_in_range, ":random_no", 0, 100),
        (lt, ":random_no", ":chance"),
        (val_add, ":result", 1),
      (try_end),
      (assign, reg0, ":result"),
      ]),
  
  # script_create_cattle_herd1
  # Input: arg1 = center_no, arg2 = amount (0 = default)
  # Output: reg0 = party_no
  ("create_cattle_herd1",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":amount"),
      
      (assign, ":herd_party", -1),
      (set_spawn_radius,1),

      (spawn_around_party,":center_no", "pt_cattle_herd1"),
      (assign, ":herd_party", reg0),
      (party_get_position, pos1, ":center_no"),
      (call_script, "script_map_get_random_position_around_position_within_range", 1, 2),
      (party_set_position, ":herd_party", pos2),

      (party_set_slot, ":herd_party", "slot_party_type", spt_cattle_herd1),
      (party_set_slot, ":herd_party", "slot_party_ai_state", spai_undefined),
      (party_set_ai_behavior, ":herd_party", ai_bhvr_hold),

      (party_set_slot, ":herd_party", "slot_party_commander_party", -1), #we need this because 0 is player's party!

      (try_begin),
        (gt, ":amount", 0),
        (party_clear, ":herd_party"),
        (party_add_members, ":herd_party", "trp_cattle", ":amount"),
      (try_end),
       
      (assign, reg0, ":herd_party"),
  ]),

  #script_buy_cattle_from_village
  # Input: arg1 = village_no, arg2 = amount, arg3 = single_cost
  # Output: reg0 = party_no
  ("buy_cattle_from_village",
    [
      (store_script_param, ":village_no", 1),
      (store_script_param, ":amount", 2),
      (store_script_param, ":single_cost", 3),

      #Changing price of the cattle
      (try_for_range, ":unused", 0, ":amount"),
        (call_script, "script_game_event_buy_item", "itm_cattle_meat", 0),
        (call_script, "script_game_event_buy_item", "itm_cattle_meat", 0),
      (try_end),

      #(party_get_slot, ":num_cattle", ":village_no", "slot_village_number_of_cattle"),
      (party_get_slot, ":num_cattle", ":village_no", "slot_center_head_cattle"),
      (val_sub, ":num_cattle", ":amount"),
      (party_set_slot, ":village_no", "slot_center_head_cattle", ":num_cattle"),
      
      (store_mul, ":cost", ":single_cost", ":amount"),
      (troop_remove_gold, "trp_player", ":cost"),

      (assign, ":continue", 1),
      (try_for_parties, ":cur_party"),
        (eq, ":continue", 1),
        (party_slot_eq, ":cur_party", "slot_party_type", spt_cattle_herd1),
        (store_distance_to_party_from_party, ":dist", ":village_no", ":cur_party"),
        (lt, ":dist", 6),
        (assign, ":subcontinue", 1),
        (try_begin),
          (check_quest_active, "qst_move_cattle_herd1"),
          (quest_slot_eq, "qst_move_cattle_herd1", "slot_quest_target_party", ":cur_party"),
          (assign, ":subcontinue", 0),
        (try_end),
        (eq, ":subcontinue", 1),
        (party_add_members, ":cur_party", "trp_cattle", ":amount"),
        (assign, ":continue", 0),
        (assign, reg0, ":cur_party"),
      (try_end),
      (try_begin),
        (eq, ":continue", 1),
        (call_script, "script_create_cattle_herd1", ":village_no", ":amount"),
      (try_end),
  ]),

  #script_kill_cattle_from_herd
  # Input: arg1 = party_no, arg2 = amount
  # Output: none (fills trp_temp_troop's inventory)
  ("kill_cattle_from_herd",
    [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":amount"),

      (troop_clear_inventory, "trp_temp_troop"),
      (store_mul, ":meat_amount", ":amount", 2),
      (store_mul, ":meat_amount2", ":amount", 2), #chief
      (troop_add_items, "trp_temp_troop", "itm_cattle_meat", ":meat_amount"),
      (troop_add_items, "trp_temp_troop", "itm_raw_leather", ":meat_amount2"), #chief

      (troop_get_inventory_capacity, ":inv_size", "trp_temp_troop"),
      (try_for_range, ":i_slot", 0, ":inv_size"),
        (troop_get_inventory_slot, ":item_id", "trp_temp_troop", ":i_slot"),
        (eq, ":item_id", "itm_cattle_meat"),
        (troop_set_inventory_slot_modifier, "trp_temp_troop", ":i_slot", imod_fresh),
      (try_end),

      (party_get_num_companions, ":num_cattle", ":party_no"),
      (try_begin),
        (ge, ":amount", ":num_cattle"),
        (remove_party, ":party_no"),
      (else_try),
        (party_remove_members, ":party_no", "trp_cattle", ":amount"),
      (try_end),
      ]),
  
  # script_create_kingdom_hero_party
  # Input: arg1 = troop_no, arg2 = center_no
  # Output: $pout_party = party_no
  ("create_kingdom_hero_party",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":center_no", 2),
     
      (store_troop_faction, ":troop_faction_no", ":troop_no"),
      
      (assign, "$pout_party", -1),
      (try_begin),
        (eq, "$g_there_is_no_avaliable_centers", 0),
        (set_spawn_radius, 0),
	  (else_try),
        (set_spawn_radius, 15),
      (try_end),
      (spawn_around_party, ":center_no", "pt_kingdom_hero_party"),
      
      (assign, "$pout_party", reg0),
      
      (party_set_faction, "$pout_party", ":troop_faction_no"),
      (party_set_slot, "$pout_party", "slot_party_type", spt_kingdom_hero_party),
      (call_script, "script_party_set_ai_state", "$pout_party", spai_undefined, -1),
      (troop_set_slot, ":troop_no", "slot_troop_leaded_party", "$pout_party"),
      (party_add_leader, "$pout_party", ":troop_no"),
      (str_store_troop_name, s5, ":troop_no"),
      (party_set_name, "$pout_party", "str_s5_s_party"),
      
      (party_set_slot, "$pout_party", "slot_party_commander_party", -1), #we need this because 0 is player's party!
#TEMPERED chief  ADDED KINGDOM HERO PARTY SLOTS
	  (party_set_slot, "$pout_party", "slot_party_entrenched", 0),
	  (party_set_slot, "$pout_party", "slot_party_hired", -1),
          (party_set_slot, "$pout_party", "slot_party_nearby", -1),
	  (troop_set_slot, ":troop_no", "slot_troop_duel_challenger", -1),
	  (troop_set_slot, ":troop_no", "slot_troop_duel_challenged", -1),
#TEMPERED CHANGES END

      #Setting the flag icon
      #normal_banner_begin
      (troop_get_slot, ":cur_banner", ":troop_no", "slot_troop_banner_scene_prop"),
      (try_begin),
        (gt, ":cur_banner", 0),
        (val_sub, ":cur_banner", banner_scene_props_begin),
        (val_add, ":cur_banner", banner_map_icons_begin),
        (party_set_banner_icon, "$pout_party", ":cur_banner"),
      #custom_banner_begin
      #(troop_get_slot, ":flag_icon", ":troop_no", "slot_troop_custom_banner_map_flag_type"),
      #(try_begin),
      #  (ge, ":flag_icon", 0),
      #  (val_add, ":flag_icon", custom_banner_map_icons_begin),
      #  (party_set_banner_icon, "$pout_party", ":flag_icon"),
      (try_end),

      (try_begin),
        #because of below two lines, lords can only hire more than one party_template(stack) at game start once a time during all game.
        (troop_slot_eq, ":troop_no", "slot_troop_spawned_before", 0),
        (troop_set_slot, ":troop_no", "slot_troop_spawned_before", 1),
        (assign, ":num_tries", 20),
        (try_begin),
          (store_troop_faction, ":troop_kingdom", ":troop_no"),
          (faction_slot_eq, ":troop_kingdom", "slot_faction_leader", ":troop_no"),
          (assign, ":num_tries", 50),
        (try_end),

        #(str_store_troop_name, s0, ":troop_no"),
        #(display_message, "{!}str_debug__hiring_men_to_party_for_s0"),

        (try_for_range, ":unused", 0, ":num_tries"),
          (call_script, "script_hire_men_to_kingdom_hero_party", ":troop_no"),
        (try_end),
        
        (assign, ":xp_rounds", 0),

        (options_get_campaign_ai, ":reduce_campaign_ai"),
        (try_begin),
          (this_or_next|eq, ":troop_faction_no", "$players_kingdom"),
          (eq, ":troop_faction_no", "fac_player_supporters_faction"),
          (assign, ":xp_rounds", 0),
        (else_try),
          (eq, ":reduce_campaign_ai", 0), #hard
          (assign, ":xp_rounds", 2),
        (else_try),
          (eq, ":reduce_campaign_ai", 1), #moderate
          (assign, ":xp_rounds", 1),
        (else_try),                        
          (eq, ":reduce_campaign_ai", 2), #easy
          (assign, ":xp_rounds", 0),
        (try_end),           

        (troop_get_slot, ":renown", ":troop_no", "slot_troop_renown"),
        (store_div, ":renown_xp_rounds", ":renown", 100),
        (val_add, ":xp_rounds", ":renown_xp_rounds"),
        (try_for_range, ":unused", 0, ":xp_rounds"),
          (call_script, "script_upgrade_hero_party", "$pout_party", 4000),
        (try_end),
      (try_end),
  ]),
  
  # script_create_kingdom_party_if_below_limit
  # Input: arg1 = faction_no, arg2 = party_type (variables beginning with spt_)
  # Output: reg0 = party_no
  ("create_kingdom_party_if_below_limit",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":party_type"),

      (call_script, "script_count_parties_of_faction_and_party_type", ":faction_no", ":party_type"),
      (assign, ":party_count", reg0),
      
      (assign, ":party_count_limit", 0),

      (faction_get_slot, ":num_towns", ":faction_no", "slot_faction_num_towns"),

      (try_begin),
##        (eq, ":party_type", spt_forager),
##        (assign, ":party_count_limit", 1),
##      (else_try),
##        (eq, ":party_type", spt_scout),
##        (assign, ":party_count_limit", 1),
##      (else_try),
##        (eq, ":party_type", spt_patrol),
##        (assign, ":party_count_limit", 1),
##      (else_try),
##        (eq, ":party_type", spt_messenger),
##        (assign, ":party_count_limit", 1),
##      (else_try),
          (this_or_next|eq, ":party_type", spt_merchant_caravan),    #### This is our sea trader  ##THIS INSTEAD chief
        (eq, ":party_type", spt_kingdom_caravan),
        (try_begin),
          (eq, ":num_towns", 0),
          (assign, ":party_count_limit", 0),
        (else_try),
          (eq, ":num_towns", 1),
          (assign, ":party_count_limit", 1),
        (else_try),
          (eq, ":num_towns", 2),
          (assign, ":party_count_limit", 3),
        (else_try),
          (assign, ":party_count_limit", 5),
        (try_end),
        ##diplomacy chief begin
          #overwriting party count limit MAX(2 * X - 1, 0)
        (store_mul, ":party_count_limit", ":num_towns", 2),
        (val_sub, ":party_count_limit", 1),
        (val_max, ":party_count_limit", 0),
        ##diplomacy chief end
##      (else_try),
##        (eq, ":party_type", spt_prisoner_train),
##        (assign, ":party_count_limit", 1),
      (try_end),
#seatrade chief
(try_begin),
    (eq, ":party_type", spt_merchant_caravan),
		(try_begin),
			(eq, ":num_towns", 0),
			(assign, ":party_count_limit", 0),
		(else_try),	
			(eq, ":num_towns", 1),
            (assign, ":party_count_limit", 1),
		(else_try),
			(eq, ":num_towns", 2),
            (assign, ":party_count_limit", 1),
		(else_try),	
            (assign, ":party_count_limit", 2),
		(try_end),
(try_end),
#seatrade chief acaba      
      (assign, reg0, -1),
      (try_begin),
        (lt, ":party_count", ":party_count_limit"),
        (call_script,"script_cf_create_kingdom_party", ":faction_no", ":party_type"),
      (try_end),
  ]),
  
  
  # script_cf_create_kingdom_party
  # Input: arg1 = faction_no, arg2 = party_type (variables beginning with spt_)
  # Output: reg0 = party_no
  ("cf_create_kingdom_party",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":party_type"),
      
      (str_store_faction_name, s7, ":faction_no"),
      (assign, ":party_name_str", "str_no_string"),
      
##      (faction_get_slot, ":reinforcements_a", ":faction_no", "slot_faction_reinforcements_a"),
      (faction_get_slot, ":reinforcements_b", ":faction_no", "slot_faction_reinforcements_b"),
##      (faction_get_slot, ":reinforcements_c", ":faction_no", "slot_faction_reinforcements_c"),
      
      (try_begin),
##        (eq, ":party_type", spt_forager),
##        (assign, ":party_template", "pt_forager_party"),
#        (assign, ":party_name_str", "str_s7_foragers"),
##      (else_try),
##        (eq, ":party_type", spt_scout),
##        (assign, ":party_template", "pt_scout_party"),
#        (assign, ":party_name_str", "str_s7_scouts"),
##      (else_try),
##        (eq, ":party_type", spt_patrol),
##        (assign, ":party_template", "pt_patrol_party"),
#        (assign, ":party_name_str", "str_s7_patrol"),
##      (else_try),
        (eq, ":party_type", spt_kingdom_caravan),
        (assign, ":party_template", "pt_kingdom_caravan_party"),
#        (assign, ":party_name_str", "str_s7_caravan"),
        (else_try), #seatrade chief empieza
          (eq, ":party_type", spt_merchant_caravan),
          (assign, ":party_template", "pt_sea_traders"),            #####SEATRADE Marker##### chief acaba
##      (else_try),
##        (eq, ":party_type", spt_messenger),
##        (assign, ":party_template", "pt_messenger_party"),
#        (assign, ":party_name_str", "str_s7_messenger"),
##      (else_try),
##        (eq, ":party_type", spt_raider),
##        (assign, ":party_template", "pt_raider_party"),
##        (assign, ":party_name_str", "str_s7_raiders"),
##      (else_try),
##        (eq, ":party_type", spt_prisoner_train),
##        (assign, ":party_template", "pt_prisoner_train_party"),
#        (assign, ":party_name_str", "str_s7_prisoner_train"),
      (try_end),
      
      (assign, ":result", -1),
      (try_begin),
        (try_begin),
            (this_or_next|eq, ":party_type", spt_merchant_caravan),   ##SEATRADE chief
          (eq, ":party_type", spt_kingdom_caravan),
          (call_script,"script_cf_select_random_town_with_faction", ":faction_no", -1),
          (set_spawn_radius, 0),
        (else_try), #not used at the moment
          (call_script,"script_cf_select_random_walled_center_with_faction", ":faction_no", -1),
          (set_spawn_radius, 1),
        (try_end),
        (assign, ":spawn_center", reg0),
        (is_between, ":spawn_center", centers_begin, centers_end),
        (assign, ":continue", 0), ## SEATRADE chief
        (try_begin), ## SEATRADE chief
            (eq, ":party_type", spt_kingdom_caravan),
            (spawn_around_party,":spawn_center",":party_template"),
            (assign, ":result", reg0),
            (assign, ":continue", 1),
        (else_try),        
            (eq, ":party_type", spt_merchant_caravan),
            (party_slot_ge, ":spawn_center", "slot_town_is_coastal", 1),
            (party_get_slot, ":radius", ":spawn_center", "slot_town_is_coastal"),
            (party_get_position, pos0 , ":spawn_center"),
            (map_get_water_position_around_position, pos1, pos0, ":radius"),
            (spawn_around_party,":spawn_center",":party_template"),
            (assign, ":result", reg0),
            (party_set_position, ":result", pos1),
            (assign, ":continue", 1),
        (try_end),    
        (eq, ":continue", 1), ## SEATRADE END chief
##        (spawn_around_party,":spawn_center",":party_template"), #off seatrade chief
##        (assign, ":result", reg0), #off seatrade chief
        (party_set_faction, ":result", ":faction_no"),
        (try_begin),
            (this_or_next|eq, ":party_type", spt_merchant_caravan), ##SEATRADE chief
          (eq, ":party_type", spt_kingdom_caravan),
          (party_set_slot, ":result", "slot_party_home_center", ":spawn_center"),
          (party_set_slot, ":result", "slot_party_last_traded_center", ":spawn_center"),
		(try_end),
        (party_set_slot, ":result", "slot_party_type", ":party_type"),
        (party_set_slot, ":result", "slot_party_ai_state", spai_undefined),
        (try_begin),
          (neq, ":party_name_str", "str_no_string"),
          (party_set_name, ":result", ":party_name_str"),
        (try_end),
        
        (try_begin),
##          (eq, ":party_type", spt_forager),
##          (party_add_template, ":result", ":reinforcements_a"),
##        (else_try),
##          (eq, ":party_type", spt_scout),
##          (party_add_template, ":result", ":reinforcements_c"),
##        (else_try),
##          (eq, ":party_type", spt_patrol),
##          (party_add_template, ":result", ":reinforcements_a"),
##          (party_add_template, ":result", ":reinforcements_b"),
##        (else_try),
            (this_or_next|eq, ":party_type", spt_merchant_caravan),   ##SEATRADE chief
          (eq, ":party_type", spt_kingdom_caravan),
          (try_begin),
            (eq, ":faction_no", "fac_player_supporters_faction"),
            (party_get_slot, ":reinforcement_faction", ":spawn_center", "slot_center_original_faction"),
            (faction_get_slot, ":reinforcements_b", ":reinforcement_faction", "slot_faction_reinforcements_b"),
          (try_end),
          (party_add_template, ":result", ":reinforcements_b"),
          (party_add_template, ":result", ":reinforcements_b"),
          (party_set_ai_behavior,":result",ai_bhvr_travel_to_party),
          (party_set_ai_object,":result",":spawn_center"),
          (party_set_flags, ":result", pf_default_behavior, 1),
          (store_sub, ":item_to_price_slot", "slot_town_trade_good_prices_begin", trade_goods_begin),
          (try_for_range, ":cur_goods", trade_goods_begin, trade_goods_end),
            (store_add, ":cur_goods_price_slot", ":cur_goods", ":item_to_price_slot"),
            (party_set_slot, ":result", ":cur_goods_price_slot", average_price_factor),
          (try_end),
	  (party_set_bandit_attraction, ":result", 75), ##ADDED THIS LINE seatrade chief
	  		  ## Floris - Trade with Merchant Caravans
			  (party_get_slot, ":town_prosperity", ":spawn_center", "slot_town_prosperity"),
			  (val_max, ":town_prosperity", 40),
			  (store_random_in_range, ":prosperity", 30, ":town_prosperity"),
			  (party_set_slot, ":result", "slot_town_prosperity", ":prosperity"),
			  #(assign, reg1, ":prosperity"), #DEBUG
			  (val_mul, ":prosperity", 50),
			  (store_random_in_range, ":wealth", 600, ":prosperity"),
			  (party_set_slot, ":result", "slot_town_wealth", ":wealth"),
			  #(assign, reg0, ":result"), #DEBUG
			  #(assign, reg2, ":wealth"), #DEBUG
			  #(display_message, "@Pty{reg0} - Prosperity: {reg1}; Wealth: {reg2}"), #DEBUG
			  (party_set_slot, ":result", "slot_center_player_relation", 0),
			  (assign, reg1, 0), #Profit, typically
			  ## Floris - Trade with Merchant Caravans
##        (else_try),
##          (eq, ":party_type", spt_messenger),
##          (faction_get_slot, ":messenger_troop", ":faction_no", "slot_faction_messenger_troop"),
##          (party_add_leader, ":result", ":messenger_troop"),
##          (party_set_ai_behavior,":result",ai_bhvr_travel_to_party),
##          (party_set_ai_object,":result",":spawn_center"),
##          (party_set_flags, ":result", pf_default_behavior, 0),
##        (else_try),
##          (eq, ":party_type", spt_raider),
##          (party_add_template, ":result", ":reinforcements_c"),
##          (party_add_template, ":result", ":reinforcements_b"),
##          (party_add_template, ":result", "pt_raider_captives"),
##        (else_try),
##          (eq, ":party_type", spt_prisoner_train),
##          (party_add_template, ":result", ":reinforcements_b"),
##          (party_add_template, ":result", ":reinforcements_a"),
##          (try_begin),
##            (call_script,"script_cf_faction_get_random_enemy_faction",":faction_no"),
##            (store_random_in_range,":r",0,3),
##            (try_begin),
##              (lt, ":r", 1),
##              (faction_get_slot, ":captive_reinforcements", reg0, "slot_faction_reinforcements_b"),
##            (else_try),
##              (faction_get_slot, ":captive_reinforcements", reg0, "slot_faction_reinforcements_a"),
##            (try_end),
##            (party_add_template, ":result", ":captive_reinforcements",1),
##          (else_try),
##            (party_add_template, ":result", "pt_default_prisoners"),
##          (try_end),
        (try_end),
      (try_end),
      (ge, ":result", 0),
      (assign, reg0, ":result"),
  ]),
  
  # script_get_troop_attached_party
  # Input: arg1 = troop_no
  # Output: reg0 = party_no (-1 if troop's party is not attached to a party)
  ("get_troop_attached_party",
    [
      (store_script_param_1, ":troop_no"),
      
      (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
      (assign, ":attached_party_no", -1),
      (try_begin),
        (ge, ":party_no", 0),
        (party_get_attached_to, ":attached_party_no", ":party_no"),
      (try_end),
      (assign, reg0, ":attached_party_no"),
  ]),


  # script_center_get_food_consumption
  # Input: arg1 = center_no
  # Output: reg0: food consumption (1 food item counts as 100 units)
  ("center_get_food_consumption",
    [
      (store_script_param_1, ":center_no"),
      (assign, ":food_consumption", 0),
      (try_begin),
        (party_slot_eq, ":center_no", "slot_party_type", spt_town),
        (assign, ":food_consumption", 500),
      (else_try),
        (party_slot_eq, ":center_no", "slot_party_type", spt_castle),
        (assign, ":food_consumption", 50),
      (try_end),
      ##diplomacy start+ chief
      (try_begin),
 		 #Optional change: increase food consumption with garrison size
		 #The rationale goes like this:
		 #The average reinforcement size for a town or castle is 9.5 per round.
		 #At the start of the game:
		 #
		 #  Castles get 15 reinforcement rounds, for around 142.5 troops
		 #  Towns   get 40 reinforcement rounds, for around 380 troops
		 #
		 #Of course both the castles and the towns have other people living
		 #there as well.
		 (party_get_num_companions, ":garrison_size", ":center_no"),
		 (try_begin),
			(party_slot_eq, ":center_no", "slot_party_type", spt_castle),
			(gt, ":garrison_size", 150),
			#Assume that the garrison accounts for most of the food consumption.
			(store_div, ":food_consumption", ":garrison_size", 3),
		 (else_try),
			(party_slot_eq, ":center_no", "slot_party_type", spt_town),
			(gt, ":garrison_size", 380),
			#Assume that the garrison makes the same contribution to size for towns.
			(store_div, ":food_consumption", ":garrison_size", 3),#for 381, equals 127
			(val_add, ":food_consumption", 500 - 127),
		 (try_end),
		 
		 #Optional change: increase food consumption with prosperity
		 (party_slot_eq, ":center_no", "slot_party_type", spt_town),
         (party_get_slot, reg0, ":center_no", "slot_town_prosperity"),
			(gt, reg0, 50),#<- increase only
         (val_add, reg0, 75),
         (val_mul, ":food_consumption", reg0),
         (val_add, ":food_consumption", 62),
         (val_div, ":food_consumption", 125),
      (try_end),
      ##diplomacy+
      (assign, reg0, ":food_consumption"),
  ]),
  
  # script_center_get_food_store_limit
  # Input: arg1 = center_no
  # Output: reg0: food consumption (1 food item counts as 100 units)
  ("center_get_food_store_limit",
    [
      (store_script_param_1, ":center_no"),
      (assign, ":food_store_limit", 0),
      (try_begin),
        #AJM chief SINCE TOWNS/CASTLES TOTALLY CHEAT ABOUT HOW OFTEN THEY GET FILLED TO THEIR FOOD CAP, REGARDLESS OF WHAT IT IS
        #AJM chief I'M RANDOMLY LIMITING THE MAX TO 10% TO 100% OF THE NORMAL CAP. IN THIS WAY, IT MAY ACTUALLY BE POSSIBLE TO STARVE OUT
        #AJM chief A TOWN/CASTLE IF YOU BESIEGE THEM WHEN THEIR FOOD STORES ARE 'RUNNING LOW'
        (party_slot_eq, ":center_no", "slot_party_type", spt_town),
        (store_random_in_range, ":random_no", 5000, 50000),
        (assign, ":food_store_limit", ":random_no"),
      (else_try),
        (party_slot_eq, ":center_no", "slot_party_type", spt_castle), #AJM chief EDITED HERE TOO, THIS IS CASTLES MAX FOOD
        (store_random_in_range, ":random_no", 500, 1500),
        (assign, ":food_store_limit", ":random_no"),
      (try_end),
      (assign, reg0, ":food_store_limit"),
  ]),

  # script_refresh_village_defenders
  # Input: arg1 = village_no
  # Output: none
  ("refresh_village_defenders",
    [
      (store_script_param_1, ":village_no"),

      (assign, ":ideal_size", 50),
      (try_begin),
        (party_get_num_companions, ":party_size", ":village_no"),
        (lt, ":party_size", ":ideal_size"),
        (party_add_template, ":village_no", "pt_village_defenders"),
      (try_end),
  ]),

  # script_village_set_state
  # Input: arg1 = center_no arg2:new_state
  # Output: reg0: food consumption (1 food item counts as 100 units)
  ("village_set_state",
    [
      (store_script_param_1, ":village_no"),
      (store_script_param_2, ":new_state"),
      (try_begin),
        (eq, ":new_state", 0),
        (party_set_extra_text, ":village_no", "str_empty_string"),
        (party_set_slot, ":village_no", "slot_village_raided_by", -1),
      (else_try),
        (eq, ":new_state", svs_being_raided),
        (party_set_extra_text, ":village_no", "@(Being Raided)"),
      (else_try),
        (eq, ":new_state", svs_looted),
        (party_set_extra_text, ":village_no", "@(Looted)"),
				
        (party_set_slot, ":village_no", "slot_village_raided_by", -1),
        (call_script, "script_change_center_prosperity", ":village_no", -53), #gdw
		(val_add, "$newglob_total_prosperity_from_villageloot", -53),#gdw

		(try_begin), #optional - lowers the relationship between a lord and his liege if his fief is looted
			(eq, 5, 0),
			(party_get_slot, ":town_lord", ":village_no", "slot_town_lord"),
			(is_between, ":town_lord", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":town_lord_faction", ":town_lord"),
			(faction_get_slot, ":faction_leader", ":town_lord_faction", "slot_faction_leader"),
			(call_script, "script_troop_change_relation_with_troop", ":town_lord", ":faction_leader", -1),
			(val_add, "$total_battle_ally_changes", -1),
		(try_end),
      (else_try),
        (eq, ":new_state", svs_under_siege),
        (party_set_extra_text, ":village_no", "@(Under Siege)"),
				
		#Divert all caravans heading to the center
		#Note that occasionally, no alternative center will be found. In that case, the caravan will try to run the blockade
		(try_for_parties, ":party_no"), 
			(gt, ":party_no", "p_spawn_points_end"),
			(party_slot_eq, ":party_no", "slot_party_type", spt_kingdom_caravan),
            (party_slot_eq, ":party_no", "slot_party_ai_object", ":village_no"),

			(party_get_slot, ":origin", ":party_no", "slot_party_last_traded_center"),
			(store_faction_of_party, ":merchant_faction", ":party_no"),
			
            (call_script, "script_cf_select_most_profitable_town_at_peace_with_faction_in_trade_route", ":origin", ":merchant_faction"),
            (assign, ":target_center", reg0),
			(is_between, ":target_center", centers_begin, centers_end),
			
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_party),
            (party_set_ai_object, ":party_no", ":target_center"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", "slot_party_ai_state", spai_trading_with_town),
            (party_set_slot, ":party_no", "slot_party_ai_object", ":target_center"),
		(try_end),		
      (try_end),
      (party_set_slot, ":village_no", "slot_village_state", ":new_state"),
  ]),

  # script_process_sieges
  # Input: none
  # Output: none
  #called from triggers
  ("process_sieges",
    [
       (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
         #Reducing siege hardness every day by 20
         (party_get_slot, ":siege_hardness", ":center_no", "slot_center_siege_hardness"),
         (val_sub, ":siege_hardness", 20),
         (val_max, ":siege_hardness", 0),
         (party_set_slot, ":center_no", "slot_center_siege_hardness", ":siege_hardness"),
       
         (party_get_slot, ":town_food_store", ":center_no", "slot_party_food_store"),
         (call_script, "script_center_get_food_store_limit", ":center_no"),
         (assign, ":food_store_limit", reg0),
         (try_begin),
           (party_get_slot, ":besieger_party", ":center_no", "slot_center_is_besieged_by"),
           (ge, ":besieger_party", 0), #town is under siege
       
           #Reduce prosperity of besieged castle/town by -0.33/-4 every day.
           (try_begin),
             (try_begin),
               (is_between, ":center_no", castles_begin, castles_end),
               (store_random_in_range, ":random_value", 0, 3),
               (try_begin),
                 (eq, ":random_value", 0),
                 (assign, ":daily_siege_effect_on_prosperity", -1),
               (else_try),
                 (assign, ":daily_siege_effect_on_prosperity", 0),
               (try_end),
             (else_try),
               (assign, ":daily_siege_effect_on_prosperity", -4),
             (try_end),
       
             (call_script, "script_change_center_prosperity", ":center_no", ":daily_siege_effect_on_prosperity"),
             (val_add, "$newglob_total_prosperity_from_townloot", ":daily_siege_effect_on_prosperity"),
           (try_end),

           (store_faction_of_party, ":center_faction", ":center_no"),
        # Lift siege unless there is an enemy party nearby
           (assign, ":siege_lifted", 0),
           (try_begin),
             (try_begin),
               (neg|party_is_active, ":besieger_party"),
               (assign, ":siege_lifted", 1),
             (else_try),
               (store_distance_to_party_from_party, ":besieger_distance", ":center_no", ":besieger_party"),
               (gt, ":besieger_distance", 5),
               (assign, ":siege_lifted", 1),
  			 ##diplomacy chief begin
         (neg|party_slot_eq, ":center_no", "slot_village_infested_by_bandits", "trp_peasant_woman"), 
         ##diplomacychief end
			 (else_try),  
			   (store_faction_of_party, ":besieger_faction", ":besieger_party"),
               (store_relation, ":reln", ":besieger_faction", ":center_faction"),
               (ge, ":reln", 0),
               (assign, ":siege_lifted", 1),
             (try_end),
			 
			 
             (eq, ":siege_lifted", 1),
			 #If another lord can take over the siege, it isn't lifted
             (try_for_range, ":enemy_hero", active_npcs_begin, active_npcs_end),
               (troop_slot_eq, ":enemy_hero", "slot_troop_occupation", slto_kingdom_hero),
               (troop_get_slot, ":enemy_party", ":enemy_hero", "slot_troop_leaded_party"),
               (ge, ":enemy_party", 0),
               (party_is_active, ":enemy_party"),
               (store_faction_of_party, ":party_faction", ":enemy_party"),
               (store_relation, ":reln", ":party_faction", ":center_faction"),
               (lt, ":reln", 0),
               (store_distance_to_party_from_party, ":distance", ":center_no", ":enemy_party"),
               (lt, ":distance", 4),
               (assign, ":besieger_party", ":enemy_party"),

               (party_set_slot, ":center_no", "slot_center_is_besieged_by", ":enemy_party"),
               (assign, ":siege_lifted", 0),
             (try_end),
           (try_end),
           (try_begin),
             (eq, ":siege_lifted", 1),
             (call_script, "script_lift_siege", ":center_no", 1),
           (else_try),
             (call_script, "script_center_get_food_consumption", ":center_no"),
             (assign, ":food_consumption", reg0),
             (val_sub, ":town_food_store", ":food_consumption"), # reduce food only under siege???
             (try_begin),
               (le, ":town_food_store", 0), #town is starving
               (store_random_in_range, ":r", 0, 100),
               (lt, ":r", 10), 
               (call_script, "script_party_wound_all_members", ":center_no"), # town falls with 10% chance if starving
             (try_end),
           (try_end),
         (else_try),
           #town is not under siege...
           (val_add, ":town_food_store", 30), #add 30 food (significant for castles only.
         (try_end),

         (val_min, ":town_food_store", ":food_store_limit"),
         (val_max, ":town_food_store", 0),
         (party_set_slot, ":center_no", "slot_party_food_store", ":town_food_store"),
       (try_end),
  ]),

  # script_lift_siege
  # Input: arg1 = center_no, arg2 = display_message
  # Output: none
  #called from triggers
  ("lift_siege",
    [
      (store_script_param, ":center_no", 1),
      (store_script_param, ":display_message", 2),
      (party_set_slot, ":center_no", "slot_center_is_besieged_by", -1), #clear siege
      (call_script, "script_village_set_state",  ":center_no", 0), #clear siege flag
      (try_begin),
        (eq, ":center_no", "$g_player_besiege_town"),
        (assign, "$g_siege_method", 0), #remove siege progress
         #siege warfare chief
         (assign, "$g_empieza_asedio", 0),
         (assign, "$g_siege_circunvalation", 0),
         (assign, "$g_siege_saneamiento", 0),
         (assign, "$g_close_port", 0),
         (assign, "$g_traicion_interna", 0),
         (assign, "$g_infiltracion_interna", 0),
         (assign, "$g_campos_cercanos", 0),
         (assign, "$g_listos_para_asalto", 0),
         (assign, "$g_mantlets_1", 0),
         (assign, "$g_enemigo_quema_comida", 0),
         (assign, "$g_cabezas_dentro", 0),
       (party_set_slot,":center_no", "slot_center_blockaded", 0),
       (party_set_slot,":center_no", "slot_center_port_blockaded", 0),
         #siege warfare acaba
      (try_end),
      (try_begin),
        (eq, ":display_message", 1),
        (str_store_party_name_link, s3, ":center_no"),
        (display_message, "@{s3} is no longer under siege."),
      (try_end),
      ]),


  # script_process_alarms
  # Input: none
  # Output: none
  #called from triggers
  ("process_alarms",
    [	
      (assign, ":current_modula", "$g_alarm_modula"),
      (val_add, "$g_alarm_modula", 1),
      (try_begin),
        (eq, "$g_alarm_modula", 3),
        (assign, "$g_alarm_modula", 0),
      (try_end),
      
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_mod, ":center_modula", ":center_no", 3),
        (eq, ":center_modula", ":current_modula"),
        
        (party_set_slot, ":center_no", "slot_center_last_spotted_enemy", -1),
        (party_set_slot, ":center_no", "slot_center_sortie_strength", 0),
        (party_set_slot, ":center_no", "slot_center_sortie_enemy_strength", 0),
        
        (assign, ":spotting_range", 3),
        (try_begin),
          (is_currently_night),
          (assign, ":spotting_range", 2),
        (try_end),
        
        (try_begin),
          (party_slot_eq, ":center_no", "slot_center_has_watch_tower", 1),
          (val_mul, ":spotting_range", 2),
        (else_try),
          (neg|is_between, ":center_no", villages_begin, villages_end),
          (val_add, ":spotting_range", 1),
          (val_mul, ":spotting_range", 2),
        (try_end),

        (store_faction_of_party, ":center_faction", ":center_no"),
		
        (try_for_parties, ":party_no"),
          (this_or_next|party_slot_eq, ":party_no", "slot_party_type", spt_kingdom_hero_party),
          (eq, ":party_no", "p_main_party"),
          
          (store_faction_of_party, ":party_faction", ":party_no"),
          
          (try_begin),
            (eq, ":party_no", "p_main_party"),
            (assign, ":party_faction", "$players_kingdom"),
          (try_end),
          
          (try_begin),          
            (eq, ":party_faction", ":center_faction"),
            
            (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),
            (le, ":distance", ":spotting_range"),
            
            (party_get_slot, ":cached_strength", ":party_no", "slot_party_cached_strength"),
            (party_get_slot, ":sortie_strength", ":center_no", "slot_center_sortie_strength"),
            (val_add, ":sortie_strength", ":cached_strength"),
            (party_set_slot, ":center_no", "slot_center_sortie_strength", ":sortie_strength"),		 
          (else_try),
            (neq, ":party_faction", ":center_faction"),
		  
            (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),

			(try_begin),
				(lt, ":distance", 10),
				(store_current_hours, ":hours"),
				(store_sub, ":faction_recce_slot", ":party_faction", kingdoms_begin),
				(val_add, ":faction_recce_slot", "slot_center_last_reconnoitered_by_faction_time"),
				(party_set_slot, ":center_no", ":faction_recce_slot", ":hours"),
				
				#(eq, "$cheat_mode", 1),
				#(str_store_faction_name, s4, ":party_faction"),
				#(str_store_party_name, s5, ":center_no"),
				#(display_message, "@{!}DEBUG -- {s4} reconnoiters {s5}"),
			(try_end),

		    (store_relation, ":reln", ":center_faction", ":party_faction"),
            (lt, ":reln", 0),
			
			(try_begin),
	            (le, ":distance", ":spotting_range"),
	            
	            (party_get_slot, ":cached_strength", ":party_no", "slot_party_cached_strength"),
	            (party_get_slot, ":enemy_strength", ":center_no", "slot_center_sortie_enemy_strength"),
	            (val_add, ":enemy_strength", ":cached_strength"),
	            (party_set_slot, ":center_no", "slot_center_sortie_enemy_strength", ":enemy_strength"),
	            (party_set_slot, ":center_no", "slot_center_last_spotted_enemy", ":party_no"),
			(try_end),
			
          (try_end),		  		  		  		  		  
        (try_end),
      (try_end),
      
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_mod, ":center_modula", ":center_no", 3),
        (eq, ":center_modula", ":current_modula"),
        
        (try_begin), #eligible units sortie out of castle
          (is_between, ":center_no", walled_centers_begin, walled_centers_end),
          (party_slot_ge, ":center_no", "slot_center_last_spotted_enemy", 0),
          
          (party_get_slot, ":sortie_strength", ":center_no", "slot_center_sortie_strength"),
          (party_get_slot, ":enemy_strength", ":center_no", "slot_center_sortie_enemy_strength"),
          
          #Below two lines are new added by ozan. While AI want to drive nearby besieging enemy parties by making sortie them, they give up current battle if they are already joining one.
          #Lets assume there is a battle inside the castle, because enemies are inside castle and they are so close to castle they will be also added to "slot_center_sortie_enemy_strength"
          #But in this scenario, they are not outside the castle, so searching/patrolling enemy outside the castle is useless at this point. 
          #So if there is already a battle inside the center, do not sortie and search enemy outside.
          (party_get_battle_opponent, ":center_battle_opponent", ":center_no"),
          (try_begin),
		    (ge, "$cheat_mode", 1),
            (ge, ":center_battle_opponent", 0),
            (str_store_party_name, s7, ":center_no"),
            (str_store_party_name, s6, ":center_battle_opponent"),
            (display_message, "@{!}DEBUG : There are already enemies ({s6}) inside {s7}."),
          (try_end),
          (lt, ":center_battle_opponent", 0), 
          #New added by ozan ended.
                                        
          (try_begin),
            (eq, "$cheat_mode", 1),
            (str_store_party_name, s4, ":center_no"),
            (assign, reg3, ":sortie_strength"),
            (assign, reg4, ":enemy_strength"),
            (display_message, "@{!}DEBUG -- Calculating_sortie for {s4} strength of {reg3} vs {reg4} enemies"),
          (try_end),
          
          (store_mul, ":enemy_strength_mul_14_div_10", ":enemy_strength", 14),
          (val_div, ":enemy_strength_mul_14_div_10", 10),
          (gt, ":sortie_strength", ":enemy_strength_mul_14_div_10"),
          
          (assign, ":at_least_one_party_sorties", 0),
          (try_for_parties, ":sortie_party"),
            (party_get_attached_to, ":town", ":sortie_party"),
            (eq, ":town", ":center_no"),
            
            (party_slot_eq, ":sortie_party", "slot_party_type", spt_kingdom_hero_party),
            
            (party_get_slot, ":cached_strength", ":sortie_party", "slot_party_cached_strength"),
            (ge, ":cached_strength", 100),
            
            (party_detach, ":sortie_party"),
            (call_script, "script_party_set_ai_state", ":sortie_party",  spai_patrolling_around_center, ":center_no"),
            
            (try_begin),          
              (eq, "$cheat_mode", 1),
              (str_store_party_name, s4, ":sortie_party"),
              (display_message, "str_s4_sorties"),
            (try_end),
            
            (eq, ":at_least_one_party_sorties", 0),
            (assign, ":at_least_one_party_sorties", ":sortie_party"),
          (try_end),
          
          (try_begin),
            (party_is_in_town, "p_main_party", ":center_no"),
			(eq, "$g_player_is_captive", 0),
            (gt, ":at_least_one_party_sorties", 0),
            (call_script, "script_add_notification_menu", "mnu_notification_sortie_possible", ":center_no", ":sortie_party"),	
          (try_end),
		(try_end),
		
		(store_faction_of_party, ":center_faction", ":center_no"),
		
		#Send message
		(this_or_next|eq, "$cheat_mode", 1), #this is message
		(this_or_next|party_slot_eq, ":center_no", "slot_town_lord", "trp_player"),
		(eq, ":center_faction", "$players_kingdom"),
		
		(party_get_slot, ":enemy_party", ":center_no", "slot_center_last_spotted_enemy"),
		(ge, ":enemy_party", 0),
		(store_distance_to_party_from_party, ":dist", "p_main_party", ":center_no"),
		(assign, ":has_messenger", 0),
		(try_begin),
		  (this_or_next|party_slot_eq, ":center_no", "slot_town_lord", "trp_player"),
		  (eq, ":center_faction", "fac_player_supporters_faction"),
		  (party_slot_eq, ":center_no", "slot_center_has_messenger_post", 1),
		  (assign, ":has_messenger", 1),
		(try_end),
		
		(this_or_next|eq, "$cheat_mode", 1),
		(this_or_next|lt, ":dist", 30),
			(eq, ":has_messenger", 1),
		
		(str_store_party_name_link, s1, ":center_no"),
        (party_get_slot, ":exact_enemy_strength", ":center_no", "slot_center_sortie_enemy_strength"),
		
		(try_begin),
			(lt, ":exact_enemy_strength", 500),
			(display_message, "@Small bands of enemies spotted near {s1}.", color_bad_news),
		(else_try),
			(lt, ":exact_enemy_strength", 1000),
			(display_message, "@Enemy patrols spotted near {s1}.", color_bad_news),
		(else_try),
			(lt, ":exact_enemy_strength", 2000),
			(display_message, "@Medium-sized group of enemies spotted near {s1}.", color_bad_news),
		(else_try),
			(lt, ":exact_enemy_strength", 4000),
			(display_message, "@Significant group of enemies spotted near {s1}.", color_bad_news),
		(else_try),
			(lt, ":exact_enemy_strength", 8000),
			(display_message, "@Army of enemies spotted near {s1}.", color_bad_news),
		(else_try),
			(lt, ":exact_enemy_strength", 16000),
			(display_message, "@Large army of enemies spotted near {s1}.", color_bad_news),
		(else_try),
			(display_message, "@Great host of enemies spotted near {s1}.", color_bad_news),
		(try_end),
		#maybe do audio sound?
		
      (try_end),
     ]),

  # script_allow_vassals_to_join_indoor_battle
  # Input: none
  # Output: none 
  ("allow_vassals_to_join_indoor_battle",
    [
     #if our commander attacks an enemy army
     (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
       (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
       (neg|troop_slot_ge, ":troop_no", "slot_troop_prisoner_of_party", 0),
       (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
       (gt, ":party_no", 0),
       (party_is_active, ":party_no"),
                
       (party_get_attached_to, ":party_is_attached_to", ":party_no"),
       (lt, ":party_is_attached_to", 0),

       (store_troop_faction, ":faction_no", ":troop_no"),

       (try_begin),
         #(faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
         (this_or_next|party_slot_eq, ":party_no", "slot_party_ai_state", spai_screening_army),	#MOTO don't forget screeners
         (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
         (party_get_slot, ":commander_party", ":party_no", "slot_party_ai_object"),
         (gt, ":commander_party", 0),
         (party_is_active, ":commander_party"),
               
         (assign, ":besieged_center", -1),          
         (try_begin),
           (party_slot_eq, ":commander_party", "slot_party_ai_state", spai_holding_center), #if commander is holding a center
           (party_get_slot, ":commander_object", ":commander_party", "slot_party_ai_object"), #get commander's ai object (center they are holding)
           (party_get_battle_opponent, ":besieger_enemy", ":commander_object"), #get this object's battle opponent
           (party_is_active, ":besieger_enemy"),
           (assign, ":besieged_center", ":commander_object"),
           (assign, ":commander_object", ":besieger_enemy"),
         (else_try),
           (party_slot_eq, ":commander_party", "slot_party_ai_state", spai_engaging_army), #if commander is engaging an army          
           (party_get_slot, ":commander_object", ":commander_party", "slot_party_ai_object"), #get commander's ai object (army which they engaded)
           (ge, ":commander_object", 0), #if commander has an object
           (neg|is_between, ":commander_object", centers_begin, centers_end), #if this object is not a center, so it is a party
           (party_is_active, ":commander_object"),
           (party_get_battle_opponent, ":besieged_center", ":commander_object"), #get this object's battle opponent
         (else_try),
           (assign, ":besieged_center", -1),
         (try_end),
         
         (is_between, ":besieged_center", walled_centers_begin, walled_centers_end), #if battle opponent of our commander's ai object is a walled center

         (party_get_attached_to, ":attached_to_party", ":commander_party"), #if commander is attached to besieged center already.
         (eq, ":attached_to_party", ":besieged_center"),

         (store_faction_of_party, ":besieged_center_faction", ":besieged_center"),#get (battle opponent of our commander's ai object)'s faction
         (eq, ":besieged_center_faction", ":faction_no"), #if battle opponent of our commander's ai object is from same faction with current party
         (party_is_active, ":commander_object"),
         #make also follow_or_not check if needed

         (call_script, "script_party_set_ai_state", ":party_no", spai_engaging_army, ":commander_object"), #go and help commander

         (try_begin),
           (eq, "$cheat_mode", 1),
           (str_store_party_name, s7, ":party_no"),
           (str_store_party_name, s6, ":commander_object"),         
           (display_message, "@{!}DEBUG : {s7} is helping his commander by fighting with {s6}."),
         (try_end),
       (else_try),
         #(faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_center),

         (this_or_next|party_slot_eq, ":party_no", "slot_party_ai_state", spai_screening_army),	#MOTO don't forget screeners
         (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
         (party_get_slot, ":commander_party", ":party_no", "slot_party_ai_object"),
         (gt, ":commander_party", 0),
         (party_is_active, ":commander_party"),
                
         (party_get_battle_opponent, ":besieged_center", ":commander_party"), #get this object's battle opponent

         #make also follow_or_not check if needed
                  
         (is_between, ":besieged_center", walled_centers_begin, walled_centers_end), #if this object is a center
         (party_get_attached_to, ":attached_to_party", ":party_no"),
         (neq, ":attached_to_party", ":besieged_center"),
         (party_is_active, ":besieged_center"),

         (call_script, "script_party_set_ai_state", ":party_no", spai_engaging_army, ":besieged_center"), #go and help commander         
                  
         #(try_begin),
         #  (eq, "$cheat_mode", 1),
         #  (str_store_party_name, s7, ":party_no"),
         #  (str_store_party_name, s6, ":besieged_center"),         
         #  (display_message, "@{!}DEBUG : {s7} is helping his commander by attacking {s6}."),
         #(try_end),  

         #(party_set_ai_behavior, ":party_no", ai_bhvr_attack_party),
         #(party_set_ai_object, ":party_no", ":besieged_center"),
         #(party_set_flags, ":party_no", pf_default_behavior, 1), #is these needed?
         #(party_set_slot, ":party_no", "slot_party_ai_substate", 1), #is these needed?
       (try_end),
     (try_end),       
     ]),
  
  # script_party_set_ai_state
  # Input: arg1 = party_no, arg2 = new_ai_state, arg3 = action_object (if necessary)
  # Output: none (Can fail)
  
  #Redone somewhat on Feb 18 to make sure that initative is set properly
  
  ("party_set_ai_state",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":new_ai_state", 2),
      (store_script_param, ":new_ai_object", 3),
            
      (party_get_slot, ":old_ai_state", ":party_no", "slot_party_ai_state"),
      (party_get_slot, ":old_ai_object", ":party_no", "slot_party_ai_object"),
      (party_get_attached_to, ":attached_to_party", ":party_no"),
      (assign, ":party_is_in_town", 0),
      (try_begin),
        (is_between, ":attached_to_party", centers_begin, centers_end),
        (assign, ":party_is_in_town", ":attached_to_party"),
      (try_end),
          
      (assign, ":commander", -1),          
      (try_begin),
        (party_is_active, ":party_no"),
	    (party_stack_get_troop_id, ":commander", ":party_no", 0),	
	    (store_faction_of_party, ":faction_no", ":party_no"),
	  (try_end),  
	  
	  (try_begin),
	    (lt, ":commander", 0),
        #sometimes 0 sized parties enter "party_set_ai_state" script. So only discard them	    
	    #(try_begin),
        #  (eq, "$cheat_mode", 1),        
	    #  (str_store_troop_name, s6, ":party_no"),      
        #  (party_get_num_companions, reg6, ":party_no"),
        #  (display_message, "@{!}DEBUGS : party name is : {s6}, party size is : {reg6}, new ai discarded."),
        #(try_end),  
	  (else_try),
	    #Party does any business in town
	    (try_begin),
	      (is_between, ":party_is_in_town", walled_centers_begin, walled_centers_end),
	      (party_slot_eq, ":party_is_in_town", "slot_center_is_besieged_by", -1),
	      (call_script, "script_troop_does_business_in_center", ":commander", ":party_is_in_town"),
	    (else_try),	      
	      (party_slot_eq, ":party_no", "slot_party_ai_state", spai_visiting_village),
	      (party_get_slot, ":party_is_in_village", ":party_no", "slot_party_ai_object"),	     
	      (is_between, ":party_is_in_village", villages_begin, villages_end),
	      #(party_slot_eq, ":party_is_in_village", "slot_center_is_looted_by", -1),
		  (neg|party_slot_eq, ":party_is_in_village", "slot_village_state", svs_being_raided),
		  (neg|party_slot_eq, ":party_is_in_village", "slot_village_state", svs_looted),
	      (store_distance_to_party_from_party, ":distance", ":party_no", ":party_is_in_village"),
	      (lt, ":distance", 3),
	      (call_script, "script_troop_does_business_in_center", ":commander", ":party_is_in_village"),
	    (try_end),
	    
	    (party_set_slot, ":party_no", "slot_party_follow_me", 0),
	    
	    (try_begin),
	      (eq, ":old_ai_state", ":new_ai_state"),
	      (eq, ":old_ai_object", ":new_ai_object"),
          #do nothing. Nothing is changed.
        (else_try),
          (assign, ":initiative", 80),	#MOTO change to 80 from 100 - not at peak mobilization
          (assign, ":aggressiveness", 5),	#MOTO change to average from 8
          (assign, ":courage", 5),	#MOTO change to average from 8
          
          (try_begin),
            (this_or_next|eq, ":new_ai_state", spai_accompanying_army),
            (eq, ":new_ai_state", spai_screening_army),
            
            (party_set_ai_behavior, ":party_no", ai_bhvr_escort_party),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            
            (try_begin),
              (gt, ":party_is_in_town", 0),
              (party_detach, ":party_no"),
            (try_end),
            
            (try_begin),
              (eq, ":new_ai_state", spai_screening_army),
              (assign, ":aggressiveness", 8),	#MOTO drop to 8 (maximum) from 9
              (assign, ":courage", 8),	#MOTO drop to 8 (maximum) from 9
              (assign, ":initiative", 100),	#MOTO change to 100 from 80, army is in high state of mobilization
            (else_try),
              (assign, ":aggressiveness", 3),	#MOTO drop to 3 from 6
              (assign, ":courage", 8),	#MOTO drop to 8 (maximum) from 9
              (assign, ":initiative", 50),	#MOTO increase to average from 10 (not really more tied down than in siege)
            (try_end),
          (else_try),
            (eq, ":new_ai_state", spai_besieging_center),
            
            (party_get_position, pos1, ":new_ai_object"),
            (map_get_random_position_around_position, pos2, pos1, 2),
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", "slot_party_follow_me", 1),
            (party_set_slot, ":party_no", "slot_party_ai_substate", 0),
            
            (try_begin),
              (gt, ":party_is_in_town", 0),
              (neq, ":party_is_in_town", ":new_ai_object"),
              (party_detach, ":party_no"),
            (try_end),
            
            (assign, ":aggressiveness", 3),	#MOTO raise to 3 from 1 for travel
            (assign, ":courage", 5),	#MOTO drop to average from 9 - in enemy territory
            (assign, ":initiative", 100),
          (else_try),
            (eq, ":new_ai_state", spai_holding_center),
            
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_party),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            
            (try_begin),
              (gt, ":party_is_in_town", 0),
              (neq, ":party_is_in_town", ":new_ai_object"),
              (party_detach, ":party_no"),
            (try_end),
            
            (assign, ":aggressiveness", 3),	#MOTO decrease to 3 from 7 - focused on getting home
            (assign, ":courage", 8),	#MOTO decrease to 8 (maximum) from 9
            (assign, ":initiative", 80),	#MOTO decrease to 80 from 100 - not at peak mobilization
            #(party_set_ai_initiative, ":party_no", 99),
          (else_try),
            (eq, ":new_ai_state", spai_patrolling_around_center),
			
			#MOTO move this functionality from npc_decision_checklist_party_ai to generalize
			(try_begin),
			  (neg|is_between, ":new_ai_object", villages_begin, villages_end),
			  (party_get_battle_opponent, ":besieger_party", ":new_ai_object"),
			(else_try),
			  (party_slot_eq, ":new_ai_object", "slot_village_state", svs_being_raided),
			  (party_get_slot, ":besieger_party", ":new_ai_object", "slot_village_raided_by"),
			(else_try),
			  (assign, ":besieger_party", -1),
			(try_end),
			  
			(try_begin),
			  (gt, ":besieger_party", 0),
			  (party_is_active, ":besieger_party"),
				
			  (assign, ":new_ai_state", spai_engaging_army),
			  (assign, ":new_ai_object", ":besieger_party"),
			(try_end),
			
            (eq, ":new_ai_state", spai_patrolling_around_center),
			#MOTO end move this functionality from npc_decision_checklist_party_ai to generalize
	  
            (party_get_position, pos1, ":new_ai_object"),
            (map_get_random_position_around_position, pos2, pos1, 1),
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            
            #MOTO do in process_hero_ai
            # (try_begin),
              # (faction_slot_eq, ":faction_no",      "slot_faction_ai_state", sfai_attacking_enemies_around_center),
              # (party_set_ai_patrol_radius, ":party_no", 1), #line      100
            # (else_try),  
              # (party_set_ai_patrol_radius, ":party_no", 5),      #line 100
            # (try_end),
            #MOTO end do in process_hero_ai
            
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", "slot_party_follow_me", 1),
            (party_set_slot, ":party_no", "slot_party_ai_substate", 0),
            
            (try_begin),
              (gt, ":party_is_in_town", 0),
              (party_detach, ":party_no"),
            (try_end),
            
            # (try_begin),	MOTO move this part after section to apply to ALL defensive actions
              # #new to avoid losing time of marshal with attacking unimportant targets while there is a threat in our centers.
              # # (ge, ":commander", 0),	MOTO everyone hurry to defense!
              # # (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":commander"),
	          # (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
	          
	          # (party_get_position, pos3, ":party_no"),
	          # (get_distance_between_positions, ":distance_to_center", pos1, pos3),
	          	          	      
	          # (try_begin),    
	            # (ge, ":distance_to_center", 800), #added new (1.122)
                # (assign, ":initiative", 10), 
                # (assign, ":aggressiveness", 1),
                # (assign, ":courage", 8), 
              # (else_try), #below added new (1.122)
                # (assign, ":initiative", 100), 
                # (assign, ":aggressiveness", 8),
                # (assign, ":courage", 8),              
              # (try_end),
            # (else_try),              
              (assign, ":aggressiveness", 3),	#MOTO set to 3 from 8 for travel
              (assign, ":courage", 8),
              (assign, ":initiative", 80),		#MOTO change to 80 from 100
            # (try_end),  
          (else_try),
            (eq, ":new_ai_state", spai_visiting_village),
            (party_get_position, pos1, ":new_ai_object"),
            (map_get_random_position_around_position, pos2, pos1, 2),
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", "slot_party_ai_substate", 0),
            (try_begin),
              (gt, ":party_is_in_town", 0),
              (neq, ":party_is_in_town", ":new_ai_object"),
              (party_detach, ":party_no"),
            (try_end),
            
            (assign, ":aggressiveness", 3),	#MOTO set to 3 from 8 for travel
            (assign, ":courage", 8),
            (assign, ":initiative", 80),	#MOTO set to 80 from 100
          (else_try), #0.660: this is where the 1625/1640 bugs happen with an improper ai_object
            (eq, ":new_ai_state", spai_raiding_around_center),
            (party_get_position, pos1, ":new_ai_object"),
            (map_get_random_position_around_position, pos2, pos1, 1),
            (party_set_ai_behavior, ":party_no", ai_bhvr_patrol_location),
            # (party_set_ai_patrol_radius, ":party_no", 10),
			(party_set_ai_patrol_radius, ":party_no", 2),    #MOTO double new defensive patrol radius
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
	        (party_set_slot, ":party_no", "slot_party_follow_me", 1),
	        (party_set_slot, ":party_no", "slot_party_ai_substate", 0),
	        (try_begin),
	          (gt, ":party_is_in_town", 0),
	          (neq, ":party_is_in_town", ":new_ai_object"),
	          (party_detach, ":party_no"),
	        (try_end),
	        
	        # (try_begin),	MOTO not an emergency
	          # (ge, ":commander", 0),
	          # (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":commander"),
	          # (assign, ":aggressiveness", 1),
	          # (assign, ":courage", 8),
	          # (assign, ":initiative", 20),
	        # (else_try),
	          (assign, ":aggressiveness", 7),
	          (assign, ":courage", 5),	#MOTO set to average from 8 - in enemy territory
	          (assign, ":initiative", 100),
	        # (try_end),
	      (else_try),
	        (eq, ":new_ai_state", spai_engaging_army),
	        
	        (party_set_ai_behavior, ":party_no", ai_bhvr_attack_party),
	        (party_set_ai_object, ":party_no", ":new_ai_object"),
	        (party_set_flags, ":party_no", pf_default_behavior, 0),
	        (try_begin),
	          (gt, ":party_is_in_town", 0),
	          (party_detach, ":party_no"),
	        (try_end),
	        
            # (try_begin),	MOTO move this part after section to apply to ALL defensive actions
              # #new to avoid losing time of marshal with attacking unimportant targets while there is a threat in our centers.
              # # (ge, ":commander", 0),	MOTO everyone hurry to defense!
              # # (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":commander"),
	          # (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
              # (assign, ":initiative", 10), 
              # (assign, ":aggressiveness", 1),
              # (assign, ":courage", 8),
            # (else_try),              
	          (assign, ":aggressiveness", 8),
	          (assign, ":courage", 5),	#MOTO drop to 5 from 8 - in enemy territory
	          (assign, ":initiative", 100),
	        # (try_end),  
	      (else_try),
	        (eq, ":new_ai_state", spai_retreating_to_center),
	        (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_party),
	        (party_set_ai_object, ":party_no", ":new_ai_object"),
	        (party_set_flags, ":party_no", pf_default_behavior, 1),
	        (party_set_slot, ":party_no", "slot_party_commander_party", -1),
	        (try_begin),
	          (gt, ":party_is_in_town", 0),
	          (neq, ":party_is_in_town", ":new_ai_object"),
	          (party_detach, ":party_no"),
	        (try_end),
	        
	        (assign, ":aggressiveness", 3),
	        (assign, ":courage", 4),
            (assign, ":initiative", 80),	#MOTO change to 80 from 100, army is in high state of mobilization but scrambling
	      (else_try),
	        (eq, ":new_ai_state", spai_undefined),
	        (party_set_ai_behavior, ":party_no", ai_bhvr_hold),
	        (party_set_flags, ":party_no", pf_default_behavior, 0),
	      (try_end),
	      
		  #MOTO defensive emergency
		  #moved from 1.122 mods above and modified
          (try_begin),
            #new to avoid losing time of marshal with attacking unimportant targets while there is a threat in our centers.
            # (ge, ":commander", 0),	MOTO everyone hurry to defense!
            # (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":commander"),
			(faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
			
            (this_or_next|eq, ":new_ai_state", spai_holding_center),
	        (this_or_next|eq, ":new_ai_state", spai_engaging_army),
            (eq, ":new_ai_state", spai_patrolling_around_center),

            (party_get_position, pos1, ":new_ai_object"),
	        (party_get_position, pos3, ":party_no"),
	        (get_distance_between_positions, ":distance", pos1, pos3),

	        (try_begin),    
	          # (ge, ":distance_to_center", 800), #added new (1.122)
              (ge, ":distance", 1500),    #1.5 x patrol radius, see script_process_hero_ai below
              (assign, ":initiative", 80),	#MOTO change to 80 from 10, army is in high state of mobilization but scrambling
              (assign, ":aggressiveness", 1),
              (assign, ":courage", 8), 
            (else_try), #below added new (1.122)
              (assign, ":initiative", 100), 
              (assign, ":aggressiveness", 8),
              (assign, ":courage", 8),              
            (try_end),
          (try_end),
		  #MOTO end defensive emergency
			
	      (try_begin),
	        (troop_slot_eq, ":commander", "slot_lord_reputation_type", lrep_martial),
	        (val_add, ":aggressiveness", 2),
	        (val_add, ":courage", 2),
	      (else_try),
	        (troop_slot_eq, ":commander", "slot_lord_reputation_type", lrep_debauched),
	        (val_sub, ":aggressiveness", 1),
	        (val_sub, ":courage", 1),
	      (try_end),
	      
	      (party_set_slot, ":party_no", "slot_party_ai_state", ":new_ai_state"),
	      (party_set_slot, ":party_no", "slot_party_ai_object", ":new_ai_object"),
	      (party_set_aggressiveness, ":party_no", ":aggressiveness"),
	      (party_set_courage, ":party_no", ":courage"),
	      (party_set_ai_initiative, ":party_no", ":initiative"),
	    (try_end),
	  (try_end),

	  #Helpfulness
	  (try_begin),
	    (ge, ":commander", 0),
	  
	    (party_set_helpfulness, ":party_no", 101),
	    (try_begin),
  	      (troop_slot_eq, ":commander", "slot_lord_reputation_type", lrep_martial),
 	      (party_set_helpfulness, ":party_no", 200),
	    (else_try),
  	      (troop_slot_eq, ":commander", "slot_lord_reputation_type", lrep_upstanding),
	      (party_set_helpfulness, ":party_no", 150),
	    (else_try),
	      (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
	      (party_set_helpfulness, ":party_no", 110),
	    (else_try),
	      (troop_slot_eq, ":commander", "slot_lord_reputation_type", lrep_quarrelsome),
	      (party_set_helpfulness, ":party_no", 90),	  
	    (else_try),
	      (troop_slot_eq, ":commander", "slot_lord_reputation_type", lrep_selfrighteous),
	      (party_set_helpfulness, ":party_no", 80),	  
	    (else_try),
	      (troop_slot_eq, ":commander", "slot_lord_reputation_type", lrep_debauched),
	      (party_set_helpfulness, ":party_no", 50),
	    (try_end),	  
	  (try_end),  
  ]),
#moto chief acaba
  ("cf_party_under_player_suggestion",
    [
    (store_script_param, ":party_no", 1),
	
	(party_slot_eq, ":party_no", "slot_party_following_orders_of_troop", "trp_kingdom_heroes_including_player_begin"),
	
	(party_get_slot, ":ai_state", ":party_no", "slot_party_ai_state"),
	(party_slot_eq, ":party_no", "slot_party_orders_type", ":ai_state"),

	(party_get_slot, ":ai_object", ":party_no", "slot_party_ai_object"),
	(party_slot_eq, ":party_no", "slot_party_orders_object", ":ai_object"),
	
	(store_current_hours, ":hours_since_orders_given"),
	(party_get_slot, ":orders_time", ":party_no", "slot_party_orders_time"),
	
	(val_sub, ":hours_since_orders_given", ":orders_time"),
	(lt, ":hours_since_orders_given", 12),  
	]),
	    
  #Currently called from process_ai_state, could be called from elsewhere
  #It is used for lord to (1)Court ladies (2)Collect rents (3)Look for volunteers
  ("troop_does_business_in_center", 
  [
    (store_script_param, ":troop_no", 1),
    (store_script_param, ":center_no", 2),
    
    (troop_get_slot, ":led_party", ":troop_no", "slot_troop_leaded_party"),
    
    (store_current_hours, ":current_time"),
    (try_begin),
#      (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"), #this was added to get lords in centers out and visiting their fiefs, but I've adjusted the decision checklist
      (is_between, ":center_no", walled_centers_begin, walled_centers_end),
      (party_set_slot, ":led_party", "slot_party_last_in_any_center", ":current_time"),
      (try_begin),
        (call_script, "script_lord_get_home_center", ":troop_no"),
        (eq, ":center_no", reg0),
        (party_set_slot, ":led_party", "slot_party_last_in_home_center", ":current_time"),
      (try_end),
    (try_end),
    
    #Collect the rents
    (try_begin),
      (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
      
      (party_get_slot, ":accumulated_rents", ":center_no", "slot_center_accumulated_rents"),
      (party_get_slot, ":accumulated_tariffs", ":center_no", "slot_center_accumulated_tariffs"),
      (troop_get_slot, ":troop_wealth", ":troop_no", "slot_troop_wealth"),
      (val_add, ":troop_wealth", ":accumulated_rents"),
      (val_add, ":troop_wealth", ":accumulated_tariffs"),
      
      (troop_set_slot, ":troop_no", "slot_troop_wealth", ":troop_wealth"),
      (party_set_slot, ":center_no", "slot_center_accumulated_rents", 0),
      (party_set_slot, ":center_no", "slot_center_accumulated_tariffs", 0),
      
      (try_begin),
        (this_or_next|eq, "$cheat_mode", 1),
        (eq, "$cheat_mode", 3),
        (assign, reg1, ":troop_wealth"),
        (str_store_party_name, s4, ":center_no"),
        (add_troop_note_from_sreg, ":troop_no", 1, "str_current_wealth_reg1_taxes_last_collected_from_s4", 0),
      (try_end),
    (try_end),
	
	#Recruit volunteers
    (try_begin),
		(is_between, ":center_no", villages_begin, villages_end),
	
        (party_get_slot, ":troop_type", ":center_no", "slot_center_npc_volunteer_troop_type"),
        (party_get_slot, ":troop_amount", ":center_no", "slot_center_npc_volunteer_troop_amount"),
        (party_set_slot, ":center_no", "slot_center_npc_volunteer_troop_amount", -1),
        ##diplomacy chief begin
        (try_begin),
          (store_faction_of_party, ":party_faction", ":led_party"),
          (eq, ":party_faction", "fac_player_supporters_faction"),
          (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
          (faction_get_slot, ":troop_type", "$g_player_culture", "slot_faction_tier_1_troop"),
        (try_end),

        (try_begin), #debug
          (eq, "$cheat_mode", 1),
          (assign, reg2, ":troop_amount"),
          (str_store_string, s11, "@{reg2}"),
          (str_store_troop_name, s12, ":troop_type"),
          (str_store_faction_name, s13, ":party_faction"),
          (str_store_party_name, s14, ":center_no"),
          (str_store_party_name, s10, ":led_party"),
          (display_message, "@ {s10} of {s13} recruits {s11} {s12} in {s14}"),
        (try_end), 
        ##diplomacy chief end
        (party_add_members, ":led_party", ":troop_type", ":troop_amount"),
    (try_end),
   
    #Courtship
    (try_begin),
		(party_get_slot, ":time_of_last_courtship", ":led_party", "slot_party_leader_last_courted"),
		(store_sub, ":hours_since_last_courtship", ":current_time", ":time_of_last_courtship"),
		(gt, ":hours_since_last_courtship", 72),

		(troop_slot_eq, ":troop_no", "slot_troop_spouse", -1),
		(try_for_range, ":love_interest_slot", "slot_troop_love_interest_1", "slot_troop_love_interests_end"),
			(troop_get_slot, ":love_interest", ":troop_no", ":love_interest_slot"),
			(gt, ":love_interest", 0),
			(troop_get_slot, ":love_interest_town", ":love_interest", "slot_troop_cur_center"),
			(eq, ":center_no", ":love_interest_town"),
			
			(call_script, "script_courtship_event_troop_court_lady", ":troop_no", ":love_interest"),
			(party_set_slot, ":led_party", "slot_party_leader_last_courted", ":current_time"),
		(try_end),   
    (try_end),	
    ]),

  # script_process_kingdom_parties_ai
  # This is called more frequently than decide_kingdom_parties_ai
  # Input: none
  # Output: none
  #called from triggers
  ("process_kingdom_parties_ai",
    [
       (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
         (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
         (neg|troop_slot_ge, ":troop_no", "slot_troop_prisoner_of_party", 0),
         (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
         (gt, ":party_no", 0),
         (call_script, "script_process_hero_ai", ":troop_no"),
       (try_end),
  ]),
  
  # script_process_hero_ai
  # This is called more frequently than script_decide_kingdom_party_ais
  #Handles sieges, raids, etc -- does not change the party's basic mission.
  # Input: none
  # Output: none
  #called from triggers
  ("process_hero_ai",
    [
    (store_script_param_1, ":troop_no"),
#TEMPERED chief SKIP HERO IF HE IS INVOLVED IN A DUEL
	(store_current_hours,":cur_hour"),
	(troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
	(assign,":continue",0),
	(try_begin),
		(troop_slot_ge,":troop_no","slot_troop_duel_challenger",":cur_hour"),
		(assign,":continue",1),
		(troop_slot_ge,":troop_no","slot_troop_prisoner_of_party",0),
		(troop_set_slot,":troop_no","slot_troop_duel_challenger",-1),
		(str_store_troop_name,s1,":troop_no"),
		(display_message,"@ Your duel with {s1} was canceled due to unforseen circumstances."),
	(else_try),
		(troop_slot_ge,":troop_no","slot_troop_duel_challenged",":cur_hour"),
		(assign,":continue",1),
		(troop_slot_ge,":troop_no","slot_troop_prisoner_of_party",0),
		(troop_set_slot,":troop_no","slot_troop_duel_challenged",-1),
		(str_store_troop_name,s1,":troop_no"),
		(display_message,"@ Your duel with {s1} was canceled due to unforseen circumstances."),
	(try_end),
	(str_clear,s1),
	(try_begin),
		(le,":continue",0),
#TEMPERED END CHANGES
        (party_is_active, ":party_no"),    #MOTO chief avoid invalid party bug
        (store_faction_of_party, ":faction_no", ":party_no"),
        (party_get_slot, ":ai_state", ":party_no", "slot_party_ai_state"),
        (party_get_slot, ":ai_object", ":party_no", "slot_party_ai_object"),
        (try_begin),
#TEMPERED chief CHANGES FOR HIRED TO ATTACK
				(eq,":ai_state",spai_engaging_army),
				(party_slot_ge,":party_no","slot_party_hired",":cur_hour"),
				(gt,":ai_object",0),
				(party_is_active,":ai_object"),
				(party_set_ai_behavior, ":party_no", ai_bhvr_attack_party),
				(party_set_ai_object, ":party_no", ":ai_object"),
				(party_set_flags, ":party_no", pf_default_behavior, 1),
				(display_message,"@debug:  party is hired to engage army."),
			(else_try),
    #TEMPERED END CHANGES
          (eq, ":ai_state", spai_besieging_center),
          (try_begin),
            (party_slot_eq, ":ai_object", "slot_center_is_besieged_by", -1),
            (store_distance_to_party_from_party, ":distance", ":party_no", ":ai_object"),
            (lt, ":distance", 3),
            (try_begin),
              (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
              (party_get_slot, ":commander_party", ":party_no", "slot_party_ai_object"),
              (party_set_slot, ":ai_object", "slot_center_is_besieged_by", ":commander_party"),
            (else_try),
              (party_set_slot, ":ai_object", "slot_center_is_besieged_by", ":party_no"),
            (try_end),
            (store_current_hours, ":cur_hours"),
            (party_set_slot, ":ai_object", "slot_center_siege_begin_hours", ":cur_hours"),

            (str_store_party_name_link, s1, ":ai_object"),
            (str_store_troop_name_link, s2, ":troop_no"),
            (str_store_faction_name_link, s3, ":faction_no"),
            (display_log_message, "@{s1} has been besieged by {s2} of {s3}."),
            (try_begin),
              (store_faction_of_party, ":ai_object_faction", ":ai_object"),
              (this_or_next|party_slot_eq, ":ai_object", "slot_town_lord", "trp_player"),
              (eq, ":ai_object_faction", "fac_player_supporters_faction"),
              (call_script, "script_add_notification_menu", "mnu_notification_center_under_siege", ":ai_object", ":troop_no"),
            (try_end),
            (call_script, "script_village_set_state", ":ai_object", svs_under_siege),
            (assign, "$g_recalculate_ais", 1),
          (try_end),
        (else_try),
          (eq, ":ai_state", spai_raiding_around_center),
          (party_slot_eq, ":party_no", "slot_party_ai_substate", 0),
          (assign, ":selected_village", 0),
          (try_for_range, ":enemy_village_no", villages_begin, villages_end),
            (eq, ":selected_village", 0),
            (store_faction_of_party, ":enemy_village_faction", ":enemy_village_no"),
            (try_begin),
              (party_slot_eq, ":enemy_village_no", "slot_town_lord", "trp_player"),
              (store_relation, ":reln", "fac_player_supporters_faction", ":faction_no"),
            (else_try),
              (store_relation, ":reln", ":enemy_village_faction", ":faction_no"),
            (try_end),
            (lt, ":reln", 0),
            (store_distance_to_party_from_party, ":dist", ":enemy_village_no", ":party_no"),
            (lt, ":dist", 15),
            (party_slot_eq, ":enemy_village_no", "slot_village_state", 0), #village is not already raided
            #CHANGE STATE TO RAID THIS VILLAGE
            (assign, ":selected_village", ":enemy_village_no"),
          (try_end),
          (try_begin),
            (eq, ":selected_village", 0),
            (is_between, ":ai_object", villages_begin, villages_end),
            (assign, ":selected_village", ":ai_object"),
          (try_end),
          (try_begin),
            (gt, ":selected_village", 0),
            (call_script, "script_party_set_ai_state", ":party_no", spai_raiding_around_center, ":selected_village"),
            (try_begin),
              (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
              (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_raiding_village),
              (faction_set_slot, ":faction_no", "slot_faction_ai_object", ":selected_village"),
            (try_end),
            (party_get_position, pos1, ":selected_village"),
            (map_get_random_position_around_position, pos2, pos1, 1),
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":selected_village"),
            (party_set_slot, ":party_no", "slot_party_ai_substate", 1),
          (try_end),
        (else_try),
          (eq, ":ai_state", spai_raiding_around_center),#substate is 1
          (try_begin),                                
            (store_distance_to_party_from_party, ":distance", ":party_no", ":ai_object"),
            (lt, ":distance", 2),
            (try_begin),
              (party_slot_eq, ":ai_object", "slot_village_state", 0),
              (call_script, "script_village_set_state", ":ai_object", svs_being_raided),
              (party_set_slot, ":ai_object", "slot_village_raided_by", ":party_no"),
              (try_begin),
                (store_faction_of_party, ":village_faction", ":ai_object"),
                (this_or_next|party_slot_eq, ":ai_object", "slot_town_lord", "trp_player"),
                (eq, ":village_faction", "fac_player_supporters_faction"),
                (store_distance_to_party_from_party, ":dist", "p_main_party", ":ai_object"),
                (this_or_next|lt, ":dist", 30),
                (party_slot_eq, ":ai_object", "slot_center_has_messenger_post", 1),
                (call_script, "script_add_notification_menu", "mnu_notification_village_raid_started", ":ai_object", ":troop_no"),
              (try_end),
            (else_try),
              (party_slot_eq, ":ai_object", "slot_village_state", svs_being_raided),
            (else_try),
              #if anything other than being_raided leave
              (party_set_slot, ":party_no", "slot_party_ai_substate", 0),
            (try_end),
          (try_end),
        (else_try),
          (eq, ":ai_state", spai_retreating_to_center),
          (try_begin),
            (party_get_battle_opponent, ":enemy_party", ":party_no"),
            (ge, ":enemy_party", 0), #we are in a battle! we may be caught in a loop!
            (call_script, "script_party_set_ai_state", ":party_no", spai_undefined, -1),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", "slot_party_commander_party", -1),
          (try_end),
		#MOTO rewrite to update ALL states from script_party_set_ai_state when objective reached or eliminated
        # (else_try),
          # (eq, ":ai_state", spai_patrolling_around_center),
                    
          # (try_begin),
            # (party_slot_eq, ":party_no", "slot_party_ai_substate", 0),
            # (store_distance_to_party_from_party, ":distance", ":party_no", ":ai_object"),
            # (lt, ":distance", 6),
            # (party_set_slot, ":party_no", "slot_party_ai_substate", 1),
                    
	        # (party_set_aggressiveness, ":party_no", 8),
	        # (party_set_courage, ":party_no", 8),
	        # (party_set_ai_initiative, ":party_no", 100),
	                    
            # (party_set_ai_behavior, ":party_no", ai_bhvr_patrol_party),
            # (party_set_ai_object, ":party_no", ":ai_object"),
          # (try_end),
        # (else_try),
          # (eq, ":ai_state", spai_holding_center),
        (try_end),
		
		(try_begin),
		  (ge, ":ai_object", 0),
		  (neg|party_is_active, ":ai_object"),	#object was eliminated
		  (call_script, "script_npc_decision_checklist_party_ai", ":troop_no"),
		  (assign, ":ai_state", reg0),
		  (assign, ":ai_object", reg1),
		  (call_script, "script_party_set_ai_state", ":party_no", ":ai_state", ":ai_object"),
		(try_end),
		
		#state changes
		(assign, ":initiative", 0),	#test variable
		
		#start fights between passing armies
		(try_begin),
		  (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
		  (assign, ":enemy_distance", 1000),
		  
		  (try_for_range, ":enemy_faction", kingdoms_begin, kingdoms_end),
			(store_relation, ":reln", ":faction_no", ":enemy_faction"),
			(lt, ":reln", 0),
			(faction_get_slot, ":enemy_marshal", ":enemy_faction", "slot_faction_marshall"),
			(ge, ":enemy_marshal", 0),
			(troop_get_slot, ":enemy_marshal_party", ":enemy_marshal", "slot_troop_leaded_party"),
			(party_is_active, ":enemy_marshal_party"),
			(store_distance_to_party_from_party, ":distance", ":party_no", ":enemy_marshal_party"),
			(gt, ":enemy_distance", ":distance"),
			(assign, ":enemy_distance", ":distance"),
		  (try_end),
		  
		  (lt, ":distance", 25),
		  
		  (try_begin),
			(faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
			(assign, ":aggressiveness", 8),
			(assign, ":courage", 8),
			(assign, ":initiative", 100),
		  (else_try),
			(assign, ":aggressiveness", 8),
			(assign, ":courage", 5),	#in enemy territory
			(assign, ":initiative", 100),
		  (try_end),
		  
		(else_try),
		  (ge, ":ai_object", 0),
		  (party_is_active, ":ai_object"),
		  
		  (try_begin),
			(eq, ":ai_state", spai_accompanying_army),
			(party_get_battle_opponent, ":commander_opponent", ":ai_object"),
			(lt, ":commander_opponent", 0),	#marshal not in a fight?
			(party_get_slot, ":commander_ai_object", ":ai_object", "slot_party_ai_object"),
			(try_begin),
			  (party_is_active, ":commander_ai_object"),
			  (store_distance_to_party_from_party, ":distance", ":party_no", ":commander_ai_object"),
			(else_try),
			  (assign, ":distance", 1000),
			(try_end),
		  (else_try),
			(store_distance_to_party_from_party, ":distance", ":party_no", ":ai_object"),
		  (try_end),
		  
		  #defensive emergency
		  (try_begin),
			(faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
			(try_begin),
			  (le, ":distance", 15),	#1.5 x patrol radius
			  
			  (try_begin),
				(this_or_next|eq, ":ai_state", spai_engaging_army),
				(eq, ":ai_state", spai_patrolling_around_center),
				(assign, ":aggressiveness", 8),
				(assign, ":courage", 8),
				(assign, ":initiative", 100),
				(try_begin),
				  (eq, ":ai_state", spai_patrolling_around_center),
				  (party_slot_eq, ":party_no", "slot_party_ai_substate", 0),
				  (party_set_slot, ":party_no", "slot_party_ai_substate", 1),
				  (party_set_ai_behavior, ":party_no", ai_bhvr_patrol_party),
				  (party_set_ai_object, ":party_no", ":ai_object"),
				  (party_set_ai_patrol_radius, ":party_no", 1),
				(try_end),
				
			  (else_try),
				(eq, ":ai_state", spai_accompanying_army),
				(party_get_slot, ":commander_ai_state", ":ai_object", "slot_party_ai_state"),
				(this_or_next|ge, ":commander_opponent", 0),	#commander in a fight?
				(this_or_next|eq, ":commander_ai_state", spai_engaging_army),
				(eq, ":commander_ai_state", spai_patrolling_around_center),
				(assign, ":aggressiveness", 8),
				(assign, ":courage", 8),
				(assign, ":initiative", 100),
			  (try_end),
			(try_end),
			
		  #reach objective
		  (else_try),
			(eq, ":ai_state", spai_holding_center),
			(party_is_in_any_town, ":party_no"),
			(assign, ":aggressiveness", 5),
			(assign, ":courage", 8),
			(assign, ":initiative", 50),
			
		  (else_try),
			(eq, ":ai_state", spai_besieging_center),
			(le, ":distance", 3),
			(assign, ":aggressiveness", 1),
			(assign, ":courage", 5),
			(assign, ":initiative", 20),
			
		  (else_try),
			(eq, ":ai_state", spai_visiting_village),
			(le, ":distance", 3),
			(assign, ":aggressiveness", 5),
			(assign, ":courage", 8),
			(assign, ":initiative", 50),

		  (else_try),
			(eq, ":ai_state", spai_patrolling_around_center),
			(le, ":distance", 15),	#1.5 x patrol radius
			(party_slot_eq, ":party_no", "slot_party_ai_substate", 0),
			(party_set_slot, ":party_no", "slot_party_ai_substate", 1),
			(assign, ":aggressiveness", 8),
			(assign, ":courage", 8),
			(assign, ":initiative", 80),
			(party_set_ai_behavior, ":party_no", ai_bhvr_patrol_party),
			(party_set_ai_object, ":party_no", ":ai_object"),
			(party_set_ai_patrol_radius, ":party_no", 1),
			
		  (else_try),
			(eq, ":ai_state", spai_accompanying_army),
			(party_get_slot, ":commander_ai_state", ":ai_object", "slot_party_ai_state"),
			(this_or_next|ge, ":commander_opponent", 0),	#commander in a fight?
			(this_or_next|eq, ":commander_ai_state", spai_engaging_army),
			(eq, ":commander_ai_state", spai_raiding_around_center),
			(le, ":distance", 15),	#1.5 x patrol radius
			(assign, ":aggressiveness", 8),
			(assign, ":courage", 5),
			(assign, ":initiative", 100),
		  (try_end),
		(try_end),
		  
		#set new values
		(try_begin),
		  (gt, ":initiative", 0),
			
		  (try_begin),
			(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_martial),
			(val_add, ":aggressiveness", 2),
			(val_add, ":courage", 2),
		  (else_try),
			(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
			(val_sub, ":aggressiveness", 1),
			(val_sub, ":courage", 1),
		  (try_end),

		  (party_set_aggressiveness, ":party_no", ":aggressiveness"),
		  (party_set_courage, ":party_no", ":courage"),
		  (party_set_ai_initiative, ":party_no", ":initiative"),
		(try_end),
		#MOTO end rewrite to update ALL states from script_party_set_ai_state when objective reached or eliminated
	  (try_end),	
  ]),

  # script_begin_assault_on_center
  # Input: arg1: faction_no
  # Output: none
  #called from triggers
  ("begin_assault_on_center",
   [
     (store_script_param, ":center_no", 1),
	
     (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
       (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
       (neg|troop_slot_ge, ":troop_no", "slot_troop_prisoner_of_party", 0),
       (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
       (gt, ":party_no", 0),
       (party_is_active, ":party_no"),

       (assign, ":continue", 0),
       (try_begin),
         (party_slot_eq, ":party_no", "slot_party_ai_state", spai_besieging_center),
         (party_slot_eq, ":party_no", "slot_party_ai_object", ":center_no"),
         (party_slot_eq, ":party_no", "slot_party_ai_substate", 0),
         (assign, ":continue", 1),
       (else_try),
         (this_or_next|party_slot_eq, ":party_no", "slot_party_ai_state", spai_screening_army),	#MOTO don't forget screeners
         (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
         (party_get_slot, ":commander_party", ":party_no", "slot_party_ai_object"),
         (gt, ":commander_party", 0),
         (party_is_active, ":commander_party"),
         (party_slot_eq, ":commander_party", "slot_party_ai_state", spai_besieging_center),
         (party_slot_eq, ":commander_party", "slot_party_ai_object", ":center_no"),
         (call_script, "script_party_set_ai_state", ":party_no", spai_besieging_center, ":center_no"),
         (assign, ":continue", 1),
       (try_end),

       (eq, ":continue", 1),

       (party_set_ai_behavior, ":party_no", ai_bhvr_attack_party),
       (party_set_ai_object, ":party_no", ":center_no"),
       (party_set_flags, ":party_no", pf_default_behavior, 1),
       (party_set_slot, ":party_no", "slot_party_ai_substate", 1),
     (try_end),
   ]),
  
  #DEPRECATED - Using new political issue system instead
  ("select_faction_marshall",
   [
#     (store_script_param_1, ":faction_no"),
 #    (faction_get_slot, ":faction_leader", ":faction_no", "slot_faction_leader"),
  #   (faction_get_slot, ":old_faction_marshall", ":faction_no", "slot_faction_marshall"),
     
   #  (assign, ":old_marshal_is_avaliable", 0),
    # (try_begin),
     #  (gt, ":old_faction_marshall", 0),
      # (troop_get_slot, ":old_marshal_party", ":old_faction_marshall", "slot_troop_leaded_party"),
     #  (party_is_active, ":old_marshal_party"),
    #   (assign, ":old_marshal_is_avaliable", 1),
   #  (try_end),
     
     #Ozan : I am adding some codes here because sometimes armies demobilize during last seconds of an 
	 #important event like taking a castle, ext because of marshal change. When marshal changes during 
	 #an important event occurs new marshal's followers become 0 and continueing siege attack seems less 
	 #valuable then armies demobilize, faction ai become "do nothing", "I cannot think anything to do" ext.
		
   #  (assign, ":there_is_an_important_situation", 0),
   #  (faction_get_slot, ":current_ai_object", ":faction_no", "slot_faction_ai_object"),
     
   #  (try_begin), #do not demobilize during taking a castle/town (fighting in the castle)
   #    (is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
   #    (party_get_battle_opponent, ":besieger_party", ":current_ai_object"),
   #    (ge, ":besieger_party", 0),
   #    (party_is_active, ":besieger_party"),
   #    (store_faction_of_party, ":besieger_faction", ":besieger_party"),
   #    (this_or_next|eq, ":besieger_faction", ":faction_no"),
   #    (eq, ":besieger_faction", "fac_player_faction"),
   #    (assign, ":there_is_an_important_situation", 1),
   #  (try_end),

   #  (try_begin), #do not demobilize during raiding a village (holding around village)
   #    (is_between, ":current_ai_object", centers_begin, centers_end),
   #    (neg|is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),		  
   #    (party_slot_eq, ":current_ai_object", "slot_village_state", svs_being_raided),
   #    (assign, ":there_is_an_important_situation", 1),
   #  (try_end),

   #  (try_begin), #do not demobilize during besigning a siege (holding around castle)
   #    (is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
   #    #(str_store_party_name, s7, ":current_ai_object"),
   #    (party_get_slot, ":besieger_party", ":current_ai_object", "slot_center_is_besieged_by"),
   #    (ge, ":besieger_party", 0),
   #    (party_is_active, ":besieger_party"),
   #    #(str_store_party_name, s7, ":besieger_party"),
   #    (store_faction_of_party, ":besieger_faction", ":besieger_party"),
   #    (this_or_next|eq, ":besieger_faction", ":faction_no"),
   #    (eq, ":besieger_faction", "fac_player_faction"),		  
   #    (assign, ":there_is_an_important_situation", 1),
   #  (try_end),
     
   #  (try_begin),   
   #    (this_or_next|eq, ":there_is_an_important_situation", 0),
   #    (eq, ":old_marshal_is_avaliable", 0),
       #end addition ozan
   
   
    #   (assign, ":total_renown", 0),
    #   (try_for_range, ":loop_var", active_npcs_including_player_begin, active_npcs_end),
    #     (assign, ":cur_troop", ":loop_var"),
    #     (assign, ":continue", 0),
    #     (try_begin),
    #       (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
    #       (assign, ":cur_troop", "trp_player"),
    #       (try_begin),
    #         (eq, ":faction_no", "$players_kingdom"),
    #         (assign, ":continue", 1),
    #       (try_end),
    #     (else_try),
    #       (troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
    #       (store_troop_faction, ":cur_faction", ":cur_troop"),
    #       (eq, ":cur_faction", ":faction_no"),
    #       (troop_get_slot, ":cur_party", ":cur_troop", "slot_troop_leaded_party"),
    #       (gt, ":cur_party", 0),
    #       (party_is_active, ":cur_party"),
    #       (call_script, "script_party_count_fit_for_battle", ":cur_party"),
    #       (assign, ":party_fit_for_battle", reg0),
    #       (call_script, "script_party_get_ideal_size", ":cur_party"),
    #       (assign, ":ideal_size", reg0),
    #       (store_mul, ":relative_strength", ":party_fit_for_battle", 100),
    #       (val_div, ":relative_strength", ":ideal_size"),
    #       (ge, ":relative_strength", 25),
    #       (assign, ":continue", 1),
    #     (try_end),
         
     #    (eq, ":continue", 1),
	   
    #     (troop_get_slot, ":renown", ":cur_troop", "slot_troop_renown"),
	#     (call_script, "script_troop_get_relation_with_troop", ":cur_troop", ":faction_leader"),
	#     (store_mul, ":relation_modifier", reg0, 15),
	#     (val_add, ":renown", ":relation_modifier"),
	#     (val_max, ":renown", 1),
	#   
    #     (try_begin),
    #       (eq, ":cur_troop", "trp_player"),
    #       (neq, ":old_faction_marshall", "trp_player"),
    #       (assign, ":renown", 0),
   #      (try_end),
    #     (try_begin),
    #       (eq, ":cur_troop", ":faction_leader"),
    #       (val_mul, ":renown", 3),
    #       (val_div, ":renown", 4),
    #     (try_end),
    #     (try_begin),
    #       (eq, ":cur_troop", ":old_faction_marshall"),
    #       (val_mul, ":renown", 1000),
    #     (try_end),
    #     (val_add, ":total_renown", ":renown"),
    #   (try_end),
    #   (assign, ":result", -1),
    #   (try_begin),
    #     (gt, ":total_renown", 0),
    #     (store_random_in_range, ":random_renown", 0, ":total_renown"),
    #     (try_for_range, ":loop_var", active_npcs_including_player_begin, active_npcs_end),
    #       (eq, ":result", -1),
    #       (assign, ":cur_troop", ":loop_var"),
    #       (assign, ":continue", 0),
    #       (try_begin),
    #         (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
    #         (assign, ":cur_troop", "trp_player"),
   #          (try_begin),
   #            (eq, ":faction_no", "$players_kingdom"),
   #            (assign, ":continue", 1),
   #          (try_end),
   #        (else_try),
   #          (troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
   #          (store_troop_faction, ":cur_faction", ":cur_troop"),
   #          (eq, ":cur_faction", ":faction_no"),
   #          (troop_get_slot, ":cur_party", ":cur_troop", "slot_troop_leaded_party"),
   #          (gt, ":cur_party", 0),
   #          (party_is_active, ":cur_party"),
   #          (call_script, "script_party_count_fit_for_battle", ":cur_party"),
   #          (assign, ":party_fit_for_battle", reg0),
      #       (call_script, "script_party_get_ideal_size", ":cur_party"),
      #       (assign, ":ideal_size", reg0),
      #       (store_mul, ":relative_strength", ":party_fit_for_battle", 100),
      #       (val_div, ":relative_strength", ":ideal_size"),
      #       (ge, ":relative_strength", 25),
      #       (assign, ":continue", 1),
      #     (try_end),
      #     (eq, ":continue", 1),

		#   (troop_get_slot, ":renown", ":cur_troop", "slot_troop_renown"),
	    #   (call_script, "script_troop_get_relation_with_troop", ":cur_troop", ":faction_leader"),
	    #   (store_mul, ":relation_modifier", reg0, 15),
	    #   (val_add, ":renown", ":relation_modifier"),
	    #   (val_max, ":renown", 1),
		# 
        #   (try_begin),
        #     (eq, ":cur_troop", "trp_player"),
        #     (neq, ":old_faction_marshall", "trp_player"),
        #     (assign, ":renown", 0),
        #   (try_end),
        #   (try_begin),
        #     (eq, ":cur_troop", ":faction_leader"),
        #     (val_mul, ":renown", 3),
         #    (val_div, ":renown", 4),
         #  (try_end),
         #  (try_begin),
       #      (eq, ":cur_troop", ":old_faction_marshall"),
       #      (val_mul, ":renown", 1000),
       #    (try_end),
       #    (val_sub, ":random_renown", ":renown"),
       #    (lt, ":random_renown", 0),
       #    (assign, ":result", ":cur_troop"),
       #  (try_end),
      # (try_end),
      # (try_begin),
         #(eq, "$cheat_mode", 1),
        # (ge, ":result", 0),
       #  (str_store_troop_name, s1, ":result"),
      #   (str_store_faction_name, s2, ":faction_no"),
     #    (display_message, "@{!}{s1} is chosen as the marshall of {s2}."),
    #   (try_end),
   #  (else_try),
   #    (faction_get_slot, ":old_faction_marshall", ":faction_no", "slot_faction_marshall"),
   #    (assign, ":result", ":old_faction_marshall"),
   #  (try_end),
     
   #  (assign, reg0, ":result"),
     ]),

   #script_update_report_to_army_quest_note
   ("update_report_to_army_quest_note",  
   [
     (store_script_param, ":faction_no", 1),
     (store_script_param, ":new_strategy", 2),
     (store_script_param, ":old_faction_ai_state", 3),

     (try_begin),       
     (le, "$number_of_report_to_army_quest_notes", 13),

     (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),

     (try_begin), #updating quest notes for only report to army quest
       (eq, ":faction_no", "$players_kingdom"),      
       (neq, ":new_strategy", ":old_faction_ai_state"),
       (check_quest_active, "qst_report_to_army"),
       (ge, ":faction_marshal", 0),
              
       (str_store_troop_name_link, s11, ":faction_marshal"),
       (store_current_hours, ":hours"),
       (call_script, "script_game_get_date_text", 0, ":hours"),
       
       (try_begin),       
         (this_or_next|eq, ":new_strategy", sfai_attacking_enemies_around_center),
         (this_or_next|eq, ":new_strategy", sfai_attacking_center),
         (eq, ":new_strategy", sfai_gathering_army),         
         (faction_get_slot, ":faction_object", ":faction_no", "slot_faction_ai_object"),
         (ge, ":faction_object", 0), 
         (str_store_party_name_link, s21, ":faction_object"),
       (try_end),  
                                                        
       (try_begin),
         (eq, ":new_strategy", sfai_gathering_army),
         
         (try_begin),                    
           (ge, "$g_gathering_reason", 0),
           (str_store_party_name_link, s21, "$g_gathering_reason"),
           (str_store_string, s14, "str_we_should_prepare_to_defend_s21_but_we_should_gather_our_forces_until_we_are_strong_enough_to_engage_them"),
         (else_try),
           (str_store_string, s14, "str_it_is_time_to_go_on_the_offensive_and_we_must_first_assemble_the_army"),
         (try_end),
         
         (str_store_string, s14, "@({s1}) {s11}: {s14}"),         
         (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
         (val_add, "$number_of_report_to_army_quest_notes", 1),
       (else_try),
         (eq, ":new_strategy", sfai_attacking_enemies_around_center),                
        
         (try_begin),
           (is_between, ":faction_object", walled_centers_begin, walled_centers_end),
           (str_store_string, s14, "str_we_should_ride_to_break_the_siege_of_s21"),
           (str_store_string, s14, "@({s1}) {s11}: {s14}"),
           (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
           (val_add, "$number_of_report_to_army_quest_notes", 1),
         (else_try),  
           (is_between, ":faction_object", villages_begin, villages_end),
           (str_store_string, s14, "str_we_should_ride_to_defeat_the_enemy_gathered_near_s21"),
           (str_store_string, s14, "@({s1}) {s11}: {s14}"),
           (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
           (val_add, "$number_of_report_to_army_quest_notes", 1),
         (try_end),  
       (else_try),
         (this_or_next|eq, ":new_strategy", sfai_attacking_center),
         (eq, ":new_strategy", sfai_raiding_village),

         (try_begin),
           (is_between, ":faction_object", walled_centers_begin, walled_centers_end),
           (str_store_string, s14, "str_we_believe_the_fortress_will_be_worth_the_effort_to_take_it"),
           (str_store_string, s14, "@{s14} ({s21})"),
           (str_store_string, s14, "@({s1}) {s11}: {s14}"),
           (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
           (val_add, "$number_of_report_to_army_quest_notes", 1),
         (else_try),  
           (is_between, ":faction_object", villages_begin, villages_end),
           (str_store_string, s14, "str_we_shall_leave_a_fiery_trail_through_the_heart_of_the_enemys_lands_targeting_the_wealthy_settlements_if_we_can"),
           (str_store_string, s14, "@{s14} ({s21})"),
           (str_store_string, s14, "@({s1}) {s11}: {s14}"),
           (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
           (val_add, "$number_of_report_to_army_quest_notes", 1),
         (try_end),
       (try_end),         
     (try_end),
     (try_end),
   ]),
     
  
  # script_decide_faction_ai
  # Input: arg1: faction_no
  # Output: none
  #called from triggers
  ("decide_faction_ai",
  #This handles political issues and faction issues
   [
    (store_script_param_1, ":faction_no"),
	   
	   
    (faction_get_slot, ":old_faction_ai_state", ":faction_no", "slot_faction_ai_state"),
    (faction_get_slot, ":old_faction_ai_object", ":faction_no", "slot_faction_ai_object"),
	(faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),

	 
	#Remove marshal if he has become too controversial,, or he has defected, or has been taken prisoner
	(try_begin),
        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
		(neq, ":faction_no", "fac_player_supporters_faction"),
		(ge, ":faction_marshal", "trp_player"),
		
		(store_faction_of_troop, ":marshal_faction", ":faction_marshal"),
		(try_begin),
			(eq, ":faction_marshal", "trp_player"),
			(assign, ":marshal_faction", "$players_kingdom"),
		(try_end),
		
		
		(assign, ":player_marshal_is_prisoner", 0),
		(try_begin),
			(eq, ":faction_marshal", "trp_player"),
			(eq, "$g_player_is_captive", 1),
			(assign, ":player_marshal_is_prisoner", 1),
		(try_end),
		
		
		#High controversy level, or marshal has defected, or is prisoner
		(this_or_next|neq, ":marshal_faction", ":faction_no"),		
		(this_or_next|troop_slot_ge, ":faction_marshal", "slot_troop_controversy", 80),
		(this_or_next|eq, ":player_marshal_is_prisoner", 1),
			(troop_slot_ge, ":faction_marshal", "slot_troop_prisoner_of_party", 0),
		
		(assign, ":few_following_player_campaign", 0),
		(try_begin),
			(eq, ":faction_marshal", "trp_player"),
			(assign, ":vassals_following_player_campaign", 0),
			(gt, "$g_player_days_as_marshal", 1),
			(try_for_range, ":vassal", active_npcs_begin, active_npcs_end),
				(troop_slot_eq, ":vassal", "slot_troop_occupation", slto_kingdom_hero),
				(store_faction_of_troop, ":vassal_faction", ":vassal"),
				(eq, ":vassal_faction", ":faction_no"),
				(call_script, "script_npc_decision_checklist_troop_follow_or_not", ":vassal"),
				(eq, reg0, 1),
				(val_add, ":vassals_following_player_campaign", 1),
			(try_end),
			(lt, ":vassals_following_player_campaign", 4),
			(assign, ":few_following_player_campaign", 1),
		(try_end),
		
		#Only remove marshal for controversy if offensive campaign in progress
		(this_or_next|eq, ":old_faction_ai_state", sfai_default),
		(this_or_next|eq, ":old_faction_ai_state", sfai_feast),		
		(this_or_next|neq, ":marshal_faction", ":faction_no"),
		(this_or_next|eq, ":few_following_player_campaign", 1),
		(this_or_next|eq, ":player_marshal_is_prisoner", 1),
			(troop_slot_ge, ":faction_marshal", "slot_troop_prisoner_of_party", 0),
		
		#No current issue on the agenda
		(this_or_next|faction_slot_eq, ":faction_no", "slot_faction_political_issue", 0),
		(this_or_next|eq, ":player_marshal_is_prisoner", 1),
			(troop_slot_ge, ":faction_marshal", "slot_troop_prisoner_of_party", 0),
		
		(faction_set_slot, ":faction_no", "slot_faction_political_issue", 1), #Appointment of marshal
		(store_current_hours, ":hours"),
		(val_max, ":hours", 0),
		(faction_set_slot, ":faction_no", "slot_faction_political_issue_time", ":hours"), #Appointment of marshal
		
        (faction_get_slot, ":old_marshall", ":faction_no", "slot_faction_marshall"),
        (try_begin),
		  (ge, ":old_marshall", 0),
		  (troop_get_slot, ":old_marshall_party", ":old_marshall", "slot_troop_leaded_party"),
          (party_is_active, ":old_marshall_party"),
          (party_set_marshall, ":old_marshall_party", 0),
        (try_end),  

		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(faction_slot_eq, "$players_kingdom", "slot_faction_marshall", "trp_player"),
			(call_script, "script_add_notification_menu", "mnu_notification_relieved_as_marshal", 0, 0),
		(else_try),
			(neq, ":old_marshall", "trp_player"),
			(call_script, "script_change_troop_renown", ":old_marshall", 15),
		(try_end),
		(faction_set_slot, ":faction_no", "slot_faction_marshall", -1),
		(assign, ":faction_marshal", -1),
		
		
		
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
		(try_end),		
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
		(try_end),
		
	(else_try),	 #If marshal not present, and not already on agenda, make political issue
		(eq, ":faction_marshal", -1),
		(neg|faction_slot_ge, ":faction_no", "slot_faction_political_issue", 1), #This to avoid resetting votes every time
	
        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
		(neq, ":faction_no", "fac_player_supporters_faction"),
		
		(faction_set_slot, ":faction_no", "slot_faction_political_issue", 1), #Appointment of marshal
		(store_current_hours, ":hours"),
		(val_max, ":hours", 0),
		(faction_set_slot, ":faction_no", "slot_faction_political_issue_time", ":hours"), #Appointment of marshal
		
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
		(try_end),		
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
		(try_end),
		
		
	(else_try),	#If player is marshal, but not part of faction
		(eq, ":faction_marshal", "trp_player"),
		(neq, "$players_kingdom", ":faction_no"),

		(faction_set_slot, ":faction_no", "slot_faction_political_issue", 1), #Appointment of marshal
		(store_current_hours, ":hours"),
		(val_max, ":hours", 0),
		(faction_set_slot, ":faction_no", "slot_faction_political_issue_time", ":hours"), #Appointment of marshal

        (faction_get_slot, ":old_marshall", ":faction_no", "slot_faction_marshall"),
        (try_begin),
		  (ge, ":old_marshall", 0),
		  (troop_get_slot, ":old_marshall_party", ":old_marshall", "slot_troop_leaded_party"),
          (party_is_active, ":old_marshall_party"),
          (party_set_marshall, ":old_marshall_party", 0),
        (try_end),  

		(faction_set_slot, ":faction_no", "slot_faction_marshall", -1),
		(assign, ":faction_marshal", -1),
		
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
		(try_end),		
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
		(try_end),
		
	(try_end),
	 
	#If the faction issue is a center no longer under faction control, remove and reset 
	(try_begin), 
		(faction_get_slot, ":faction_political_issue", ":faction_no", "slot_faction_political_issue"),
		(is_between, ":faction_political_issue", centers_begin, centers_end),
		(store_faction_of_party, ":disputed_center_faction", ":faction_political_issue"),
		(neq, ":disputed_center_faction", ":faction_no"),
		
		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_faction_name, s4, ":faction_no"),
			(str_store_party_name, s5, ":disputed_center_faction"),
			(display_message, "@{!}DEBUG -- {s4} drops {s5} as issue as it has changed hands"),
		(try_end),
		
		#Reset political issue
		(faction_set_slot, ":faction_no", "slot_faction_political_issue", 0),
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
		(try_end),		
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
		(try_end),
		
	(try_end),
	
	
	#Resolve the political issue on the agenda
	(try_begin),
		(faction_slot_ge, ":faction_no", "slot_faction_political_issue", 1),
		(neq, ":faction_no", "fac_player_supporters_faction"),
		
		#Do not switch marshals during a campaign
		(this_or_next|faction_slot_ge, ":faction_no", "slot_faction_political_issue", centers_begin),
		(this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_default),
			(faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_feast),
		
		
		(faction_get_slot, ":faction_leader", ":faction_no", "slot_faction_leader"),
		
		(assign, ":total_lords", 0),
		(assign, ":lords_who_have_voted", 0),
		(assign, ":popular_favorite", -1),
	
		#Reset number of votes
		(troop_set_slot, "trp_player", "slot_troop_temp_slot", 0),
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(troop_set_slot, ":active_npc", "slot_troop_temp_slot", 0),
		(try_end),

		#Tabulate votes
		##diplomacy start+ chief
		(try_begin),#count the player's vote
			(eq, "$players_kingdom", ":faction_no"),
			(ge, "$player_has_homage", 1),
			(troop_get_slot, ":lord_chosen_candidate", "trp_player", "slot_troop_stance_on_faction_issue"),
      			(gt, ":lord_chosen_candidate", -1),
			#You may notice that I don't count the player for "total_lords" if he was undecided.
			#This is so faction behavior will not be changed from Native if the player did not
			#support anyone.
			(val_add, ":total_lords", 1),
			(val_add, ":lords_who_have_voted", 1),
			(troop_set_slot, ":lord_chosen_candidate", "slot_troop_temp_slot", 1),
			(assign, ":popular_favorite", ":lord_chosen_candidate"),
		(try_end),
		##diplomacy end+
		(try_for_range, ":voting_lord", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":voting_lord_faction", ":voting_lord"),
			(eq, ":voting_lord_faction", ":faction_no"),
			(val_add, ":total_lords", 1),
			(troop_get_slot, ":lord_chosen_candidate", ":voting_lord", "slot_troop_stance_on_faction_issue"),
			(gt, ":lord_chosen_candidate", -1),									
			(val_add, ":lords_who_have_voted", 1),			
			(troop_get_slot, ":total_votes", ":lord_chosen_candidate", "slot_troop_temp_slot"),
			(val_add, ":total_votes", 1),
			(troop_set_slot, ":lord_chosen_candidate", "slot_troop_temp_slot", ":total_votes"),
			(try_begin),
				(gt, ":popular_favorite", -1),
				(troop_get_slot, ":current_winner_votes", ":popular_favorite", "slot_troop_temp_slot"),
				(gt, ":total_votes", ":current_winner_votes"),
				(assign, ":popular_favorite", ":lord_chosen_candidate"),
			(else_try),	
				(eq, ":popular_favorite", -1),
				(assign, ":popular_favorite", ":lord_chosen_candidate"),
			(try_end),
		(try_end),	

		#Check to see if enough lords have voted
		(store_div, ":number_required_for_quorum", ":total_lords", 5),
		(val_mul, ":number_required_for_quorum", 4),
				##diplomacy start+ chief
		#Replace number required for quorum, altering it based on the centralization
		#value.  Do the same for the minimum time left on the agenda.
		(faction_get_slot, ":centralization", ":faction_no", "slot_faction_centralization"),
		(val_clamp, ":centralization", -3, 4),
		(try_begin),
			#Disable this for now, since NPC kingdoms set their policies randomly.
			(eq, 0, 1),
			(neq, ":centralization", 0),
			(store_sub, ":number_required_for_quorum", 15, ":centralization"),#fully centralized = 12/20 , fully decentralized = 18/20
			(try_begin),
				#If the plutocracy/aristocracy slider is negative, allow it to offset
				#a negative centralization value for the purpose of quorum, on the
				#assumption that part of the "quorum" is accounted for by the influence
				#of merchants.  They do not vote currently, although integrating guild masters
				#and/or village elders into the faction issue system is something to consider
				#for the future.
				(ge, ":number_required_for_quorum", 16),
				(faction_get_slot, ":aristocracy", ":faction_no", "slot_faction_aristocracy"),
				(lt, ":aristocracy", 0),
				(val_clamp, ":aristocracy", -3, 4),
				(val_add, ":number_required_for_quorum", ":aristocracy"),
				(val_max, ":number_required_for_quorum", 15),
			(try_end),
			(val_mul, ":number_required_for_quorum", ":total_lords"),
			(val_div, ":number_required_for_quorum", 20),
		(try_end),
		##diplomacy end+

		
#		(gt, ":lords_who_have_voted", ":number_required_for_quorum"),

		(store_current_hours, ":hours_on_agenda"),
		(faction_get_slot, ":hours_when_put_on_agenda", ":faction_no", "slot_faction_political_issue_time"), #Appointment of marshal
		(val_sub, ":hours_on_agenda", ":hours_when_put_on_agenda"),
		##diplomacy start+ chief
		#Before, the maximum number of hours on the agenda for an issue before it became
		#eligible for resolution regardless of quorum was fixed at 120 (five days).
		#Modify this by 16 hours for every point of centralization, for a minimum
		#of 3 days and a maximum of 7 days.
		(assign, ":hours_on_agenda_threshold", 120),
		(try_begin),
			#Disable this for now, since arguably all of the NPC kingdoms are
			#supposed to have fairly similar structures.  From a gameplay perspective,
			#they choose their kingdom policy at random, so enabling this is  probably
			#not going to have good effects, unless more thought is given to balancing
			#centralization/decentralization for NPC kingdoms.
			(eq, 0, 1),
			(store_mul, ":hours_on_agenda_threshold", ":centralization", 16),
			(val_add, ":hours_on_agenda_threshold", 120),
			(try_begin),
				(neq, ":centralization", 0),
			(try_end),
		(try_end),
		
		#(this_or_next|gt, ":lords_who_have_voted", ":number_required_for_quorum"),
		#	(ge, ":hours_on_agenda", 120),
		
		(this_or_next|gt, ":lords_who_have_voted", ":number_required_for_quorum"),
			(ge, ":hours_on_agenda", ":hours_on_agenda_threshold"),
		##diplomacy end+

		(try_begin),
			(eq, "$cheat_mode", 1),
			(assign, reg4, ":lords_who_have_voted"),
			(assign, reg5, ":number_required_for_quorum"),
			(assign, reg7, ":hours_on_agenda"),
			(str_store_faction_name, s4, ":faction_no"),
			(display_message, "@{!}DEBUG -- Issue resolution for {s4}: {reg4} votes for a quorum of {reg5}, {reg7} hours on agenda"),
		(try_end),


		(try_begin),
		  (eq, "$cheat_mode", 1),
		  (display_message, "@{!}DEBUG -- Faction resolves political issue"),
		(try_end),

	
		#Resolve faction political issue
		(assign, ":winning_candidate", -1),
		##diplomacy start+ chief
		#Change "liege overrules lords" check.  The version in Native caused relation death spirals:
		#a lord who has no fiefs becomes unhappy, and since relation is symmetrical, this can result
		#in the liege never granting him fiefs.
		#
		#OLD BEHAVIOR:
#		(else_try),
#			(call_script, "script_troop_get_relation_with_troop", ":faction_leader", ":popular_favorite"),
#			(this_or_next|ge, reg0, 10),
#			(this_or_next|troop_slot_eq, ":faction_leader", "slot_troop_stance_on_faction_issue", ":popular_favorite"),
#				(troop_slot_eq, ":faction_leader", "slot_troop_stance_on_faction_issue", -1),
#
#			(assign, ":winning_candidate", ":popular_favorite"),
#		(else_try),#Lord overrules lords' opinion
#			(gt, ":faction_leader", -1), #not sure why this is necessary
#			(troop_get_slot, ":liege_choice", ":faction_leader", "slot_troop_stance_on_faction_issue"),
#			(ge, ":liege_choice", -1),
#
#			(assign, ":winning_candidate", ":liege_choice"),
#      (try_end),
#
#      NEW BEHAVIOR
        (troop_get_slot, ":liege_choice", ":faction_leader", "slot_troop_stance_on_faction_issue"),
		(assign, ":min_liege_relation", 10),#<-- Same as in default
		(faction_get_slot, ":issue_on_table", ":faction_no", "slot_faction_political_issue"),
		(try_begin),
		  (is_between, ":issue_on_table", castles_begin, castles_end),
		  (store_random_in_range, ":min_liege_relation", 0, 16),
		  (val_sub, ":min_liege_relation", 5),#-5 to 10
		(else_try),
		  (is_between, ":issue_on_table", villages_begin, villages_end),
		  (store_random_in_range, ":min_liege_relation", 0, 21),
		  (val_mul, ":min_liege_relation", -1),#-20 to 0
		(try_end),
		#New override check
		(try_begin),
			#When the player is co-ruler of the kingdom, his/her support for the popular
			#candidate can be sufficient to guarantee success over the opposition of the
			#king/queen.
			(ge, ":faction_leader", 1),
			(eq, "$players_kingdom", ":faction_no"),
			(this_or_next|troop_slot_eq, ":faction_leader", "slot_troop_spouse", "trp_player"),
				(troop_slot_eq, "trp_player", "slot_troop_spouse", ":faction_leader"),
			(troop_slot_eq, "trp_player", "slot_troop_stance_on_faction_issue", ":popular_favorite"),
			(assign, ":winning_candidate", ":popular_favorite"),
		(else_try),
			#The leader may overrule a choice he disagrees with, if he dislikes the candidate
			#sufficiently and has someone else in mind.
			(ge, ":faction_leader", 1),
			(neg|troop_slot_eq, ":faction_leader", "slot_troop_stance_on_faction_issue", ":popular_favorite"),
			(neg|troop_slot_eq, ":faction_leader", "slot_troop_stance_on_faction_issue", -1),
			(call_script, "script_troop_get_relation_with_troop", ":faction_leader", ":popular_favorite"),
			(assign, ":winning_candidate", ":liege_choice"),
			(try_begin),
				#Print a message letting people know when this happens.
				(neq, ":popular_favorite", -1),
				(this_or_next|eq, "$players_kingdom", ":faction_no"),
					(ge, "$cheat_mode", 1),
				(str_store_faction_name, s4, ":faction_no"),
				(str_store_troop_name, s5, ":winning_candidate"),
				(str_store_troop_name, s0, ":faction_leader"),
				(try_begin),
					(eq, ":issue_on_table", 1),
					(display_message, "@{s5} has the greatest support among the lords of the {s4} to be the next marshall, but {s0} overrules their choice."),
				(else_try),
					(is_between, ":issue_on_table", centers_begin, centers_end),
					(str_store_party_name, s1, ":issue_on_table"),
					(display_message, "@{s5} has the greatest support among the lords of the {s4} to receive {s1}, but {s0} overrules their choice."),
				(try_end),
			(try_end),
		(else_try),
			#No override: use popular candidate
			(assign, ":winning_candidate", ":popular_favorite"),
		(try_end),
		##diplomacy end+

		#Carry out faction decision
		(try_begin), #Nothing happens
			(eq, ":winning_candidate", -1),
			
		(else_try), #For player, create a menu to accept or refuse
			(eq, ":winning_candidate", "trp_player"),
			(eq, "$players_kingdom", ":faction_no"),
			(call_script, "script_add_notification_menu", "mnu_notification_player_faction_political_issue_resolved_for_player", 0, 0),
		(else_try),
			(eq, ":winning_candidate", "trp_player"),
			(neq, "$players_kingdom", ":faction_no"),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_faction_name, s4, ":faction_no"),
				(str_store_party_name, s5, ":winning_candidate"),
				(display_message, "@{!}DEBUG -- {s4} drops {s5} as winner, for having changed sides"),
			(try_end),
			
			(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":faction_no"),
				(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
			(try_end),		
			(try_begin),
				(eq, "$players_kingdom", ":faction_no"),
				(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
			(try_end),
			
		(else_try),	#If candidate is not of winning faction, reset lrod votes
			(store_faction_of_troop, ":winning_candidate_faction", ":winning_candidate"),
			(neq, ":winning_candidate_faction", ":faction_no"),
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_faction_name, s4, ":faction_no"),
				(str_store_party_name, s5, ":winning_candidate"),
				(display_message, "@{!}DEBUG -- {s4} drops {s5} as winner, for having changed sides"),
			(try_end),
			
			(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":faction_no"),
				(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
			(try_end),		
			(try_begin),
				(eq, "$players_kingdom", ":faction_no"),
				(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
			(try_end),
			
		(else_try), #Honor awarded to another
			(faction_get_slot, ":issue_on_table", ":faction_no", "slot_faction_political_issue"),
			(try_begin), #A marshalship awarded to another
				(eq, ":issue_on_table", 1),
				(is_between, ":winning_candidate", active_npcs_begin, active_npcs_end),
				
				(this_or_next|is_between, ":winning_candidate", active_npcs_begin, active_npcs_end), #Prevents bug in which player given marshaldom of kingdom of which he/she is not a member
					(eq, "$players_kingdom", ":faction_no"),
				
				(assign, ":faction_marshal", ":winning_candidate"),
			(else_try), #A fief awarded to another
				(is_between, ":issue_on_table", centers_begin, centers_end),
				
				#If given to the player, resolved above
				(call_script, "script_give_center_to_lord", ":issue_on_table", ":winning_candidate", 0), #Zero means don't add garrison
				
				#If the player had requested a captured castle
				(try_begin),
					(eq, ":issue_on_table", "$g_castle_requested_by_player"),
					(party_slot_ge, ":issue_on_table", "slot_town_lord", active_npcs_begin),
					(store_faction_of_party, ":faction_of_issue", ":issue_on_table"),
					(eq, ":faction_of_issue", "$players_kingdom"),
					(assign, "$g_center_to_give_to_player", ":issue_on_table"),
					(try_begin),
						(troop_get_slot, ":husband", "trp_player", "slot_troop_spouse"),
						(is_between, ":husband", active_npcs_begin, active_npcs_end),
						(eq, "$g_castle_requested_for_troop", ":husband"),
						(neq, ":winning_candidate", ":husband"),
						(jump_to_menu, "mnu_requested_castle_granted_to_another_female"),
					(else_try),
						(jump_to_menu, "mnu_requested_castle_granted_to_another"),
					(try_end),	
				(try_end),
				
			(try_end),
		
			(try_begin),
				(eq, ":faction_no", "$players_kingdom"),
				(call_script, "script_add_notification_menu", "mnu_notification_player_faction_political_issue_resolved", ":issue_on_table", ":winning_candidate"),
			(try_end),
		
		#Reset political issue
			(faction_set_slot, ":faction_no", "slot_faction_political_issue", 0),
			(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":faction_no"),
				(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
			(try_end),
			(try_begin),
				(eq, "$players_kingdom", ":faction_no"),
				(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
			(try_end),			
		(try_end),
	(try_end),

	#Add fief to faction issues
	(try_begin),
		(faction_get_slot, ":faction_issue", ":faction_no", "slot_faction_political_issue"),
		(le, ":faction_issue", 0),
		
		(assign, ":landless_lords", 0),
		(assign, ":unassigned_centers", 0),
		(assign, ":first_unassigned_center_found", 0),
		
		(troop_set_slot, "trp_player", "slot_troop_temp_slot", 0),
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(troop_set_slot, ":active_npc", "slot_troop_temp_slot", 0),
		(try_end),
		
		(try_for_range, ":center", centers_begin, centers_end),
			(store_faction_of_party, ":center_faction", ":center"),
			(eq, ":center_faction", ":faction_no"),
			
			(party_get_slot, ":town_lord", ":center", "slot_town_lord"),
			
			(try_begin),
				(lt, ":town_lord", 0),
				(val_add, ":unassigned_centers", 1),
				(try_begin),
					(eq, ":first_unassigned_center_found", 0),
					(assign, ":first_unassigned_center_found", ":center"),
				(try_end),
			(else_try),
				(troop_set_slot, ":town_lord", "slot_troop_temp_slot", 1),
			(try_end),
		(try_end),
		
		(store_add, ":landless_lords_plus_unassigned_centers", ":landless_lords", ":unassigned_centers"),
		(ge, ":landless_lords_plus_unassigned_centers", 2),		
			
		(faction_set_slot, ":faction_no", "slot_faction_political_issue", ":first_unassigned_center_found"),
		(store_current_hours, ":hours"),
		(faction_set_slot, ":faction_no", "slot_faction_political_issue_time", ":hours"), #Fief put on agenda
		
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", "slot_troop_stance_on_faction_issue", -1),
		(try_end),
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
		(try_end),				
	(try_end),
	 
	 
    (try_begin), #If the marshal is changed
       (neg|faction_slot_eq, ":faction_no", "slot_faction_marshall", ":faction_marshal"),
       #(assign, ":marshall_changed", 1),
       (eq, "$players_kingdom", ":faction_no"),
       (str_store_troop_name_link, s1, ":faction_marshal"),
       (str_store_faction_name_link, s2, ":faction_no"),
       (display_message, "@{s1} is the new marshal of {s2}."),
       (call_script, "script_check_and_finish_active_army_quests_for_faction", ":faction_no"),       
    (try_end),	 
	 
    (try_begin), #If the marshal is changed
       (neg|faction_slot_eq, ":faction_no", "slot_faction_marshall", ":faction_marshal"),
	   (gt, ":faction_marshal", -1),
       (call_script, "script_appoint_faction_marshall", ":faction_no", ":faction_marshal"),   
    (try_end),	 
		 
	#DO FACTION AI HERE
	(try_begin),
		(eq, ":faction_no", "$players_kingdom"),
		(eq, ":faction_marshal", "trp_player"),
	    (assign, ":faction_ai_decider", "trp_player"),
	(else_try),
		(is_between, ":faction_marshal", active_npcs_begin, active_npcs_end),
		(assign, ":faction_ai_decider", ":faction_marshal"),
	(else_try),
		(faction_get_slot, ":faction_ai_decider", ":faction_no", "slot_faction_leader"),
	(try_end),
	 
    (call_script, "script_npc_decision_checklist_faction_ai_alt",  ":faction_ai_decider"),
    (assign, ":new_strategy", reg0),
    (assign, ":new_object", reg1),
    	   
    #new ozan
    (try_begin),
       (neq, ":new_strategy", ":old_faction_ai_state"),
       (eq, ":new_strategy", sfai_gathering_army),
       (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
       (ge, ":faction_marshal", 0),
       (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
       (party_is_active, ":marshal_party"),    #MOTO chief bug fix
       (party_set_slot, ":marshal_party", "slot_party_ai_object", -1),
       (assign, "$g_gathering_new_started", 1),
       (call_script, "script_npc_decision_checklist_party_ai", ":faction_marshal"), #This handles AI for both marshal and other parties		
       (call_script, "script_party_set_ai_state", ":marshal_party", reg0, reg1),
       (assign, "$g_gathering_new_started", 0),
    (else_try),      
       #check if marshal arrived his target city during active gathering
       
       #for now i disabled below lines because after always/active gathering armies become very large.
       #in current style marshal makes active gathering only at first, it travels to a city and waits there.
       
       (eq, ":new_strategy", ":old_faction_ai_state"),
       (eq, ":new_strategy", sfai_gathering_army),
       (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
       (ge, ":faction_marshal", 0),
       (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
       (party_is_active, ":marshal_party"),    #MOTO chief bug fix
       (party_get_slot, ":party_ai_object", ":marshal_party", "slot_party_ai_object"),

       (ge, ":party_ai_object", 0),
       (ge, ":marshal_party", 0),
       (party_is_active, ":marshal_party"),
       (party_is_active, ":party_ai_object"),    
       (store_distance_to_party_from_party, ":dist", ":marshal_party", ":party_ai_object"),
       (le, ":dist", 5),

       (party_set_slot, ":marshal_party", "slot_party_ai_object", -1),
    (try_end),
     #end ozan
	   	   	   
     #The following logic is mostly transplanted to the new decision_checklist 
     #Decision_checklist is used because I want to be able to reproduce the logic for strings
     #(call_script, "script_old_faction_ai"), 
     #ozan - I collected all comment-out lines in here (faction ai script) and placed most bottom of scripts.py to avoid confusing.	   		 	
     
     (faction_set_slot, ":faction_no", "slot_faction_ai_state", ":new_strategy"),
     (faction_set_slot, ":faction_no", "slot_faction_ai_object", ":new_object"),

     (call_script, "script_update_report_to_army_quest_note", ":faction_no", ":new_strategy", ":old_faction_ai_state"),

     (try_begin),
       (eq, ":new_strategy", sfai_feast),
       
       (store_current_hours, ":hours"),
       (faction_set_slot, ":faction_no", "slot_faction_last_feast_start_time", ":hours"), #new
       
       (try_begin),
         (eq, "$g_player_eligible_feast_center_no", ":new_object"),
         (assign, "$g_player_eligible_feast_center_no", -1), #reset needed
       (try_end),
       (call_script, "script_start_feast_tournament", ":new_object"),
     (try_end),	
	
     #Change of strategy
     (try_begin),
       (neq, ":new_strategy", ":old_faction_ai_state"),
		
       (try_begin),
         (ge, "$cheat_mode", 1),
         (str_store_faction_name, s5, ":faction_no"),
         (display_message, "str_s5_decides_s14"),
       (try_end),
		
       (store_current_hours, ":hours"),
       (faction_set_slot, ":faction_no", "slot_faction_ai_current_state_started", ":hours"),

       #Feast ends
       (try_begin),
         (eq, ":old_faction_ai_state", sfai_feast),
         (call_script, "script_faction_conclude_feast", ":faction_no", ":old_faction_ai_object"),
       (try_end),
						      		
       #Feast begins
       (try_begin),
         (eq, ":new_strategy", sfai_feast),
         (faction_get_slot, ":faction_object", ":faction_no", "slot_faction_ai_object"),
		 
##         (str_store_faction_name, s1, ":faction_no"),
##         (str_store_party_name, s2, ":faction_object"),
##         (display_message, "str_lords_of_the_s1_gather_for_a_feast_at_s2"),
		
         (party_get_slot, ":feast_host", ":faction_object", "slot_town_lord"),

         (try_begin),
           (check_quest_active, "qst_wed_betrothed"),
           (quest_slot_eq, "qst_wed_betrothed", "slot_quest_giver_troop", ":feast_host"),
           (neg|quest_slot_ge, "qst_wed_betrothed", "slot_quest_expiration_days", 362),
           (call_script, "script_add_notification_menu", "mnu_notification_player_wedding_day", ":feast_host", ":faction_object"),
		 (else_try),
           (check_quest_active, "qst_wed_betrothed_female"),
           (quest_get_slot, ":player_betrothed", "qst_wed_betrothed", "slot_quest_giver_troop"),
		   (store_faction_of_troop, ":player_betrothed_faction", ":player_betrothed"),
		   (eq, ":player_betrothed_faction", ":faction_no"),
           (neg|quest_slot_ge, "qst_wed_betrothed", "slot_quest_expiration_days", 362),
           (call_script, "script_add_notification_menu", "mnu_notification_player_kingdom_holds_feast", ":feast_host", ":faction_object"),
         (else_try),
           (eq, "$players_kingdom", ":faction_no"),
           (troop_slot_ge, "trp_player", "slot_troop_renown", 150),
           (party_get_slot, ":feast_host", ":faction_object", "slot_town_lord"),
           (call_script, "script_add_notification_menu", "mnu_notification_player_kingdom_holds_feast", ":feast_host", ":faction_object"),
         (try_end),
       (try_end),
		
       #Offensive begins
       (try_begin),
         (eq, ":old_faction_ai_state", sfai_gathering_army),
         (is_between, ":new_strategy", sfai_attacking_center, sfai_feast),
		 (try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_faction_name, s5, ":faction_no"),
			(display_message, "str_s5_begins_offensive"),
		 (try_end),
			
         # #Appoint screening party MOTO move to script_npc_decision_checklist_party_ai so marshall will always have a screening party
         # (try_begin),
           # (assign, ":total_lords_participating", 0),
           # (assign, ":best_screening_party", -1),
           # (assign, ":score_to_beat", 30), #closest in size to 50
           # (troop_get_slot, ":faction_marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
           # (party_is_active, ":faction_marshal_party"),							

           # (try_for_range, ":screen_leader", active_npcs_begin, active_npcs_end),
             # (store_faction_of_troop, ":screen_leader_faction", ":screen_leader"),
             # (eq, ":screen_leader_faction", ":faction_no"),
			 
             # (troop_get_slot, ":screening_party", ":screen_leader", "slot_troop_leaded_party"),
             # (party_is_active, ":screening_party"),			
             # (party_slot_eq, ":screening_party", "slot_party_ai_state", spai_accompanying_army),
             # (party_slot_eq, ":screening_party", "slot_party_ai_object", ":faction_marshal_party"),
             # (val_add, ":total_lords_participating", 1),

		     # (try_begin),
			  # (ge, "$cheat_mode", 1),
		      # (str_store_party_name, s4, ":screening_party"),
			  # (display_message, "@{!}DEBUG -- {s4} participates in offensive"),
		     # (try_end),

			 
             # (store_party_size_wo_prisoners, ":screening_party_score", ":screening_party"),
             # (val_sub, ":screening_party_score", 50),
			 # (val_abs, ":screening_party_score"),
			 
			 
			 # (lt, ":screening_party_score", ":score_to_beat"),

             # #set party and score
             # (assign, ":best_screening_party", ":screening_party"),
             # (assign, ":score_to_beat", ":screening_party_score"),
           # (try_end),			

           # (gt, ":total_lords_participating", 2),
           # (party_is_active, ":best_screening_party"),
           # (party_is_active, ":faction_marshal_party"),
           # (call_script, "script_party_set_ai_state", ":best_screening_party", spai_screening_army, ":faction_marshal_party"),
		   # (try_begin),
			# (ge, "$cheat_mode", 1),
		    # (str_store_party_name, s4, ":best_screening_party"),
			# (display_message, "@{!}DEBUG -- {s4} chosen as screen"),
		   # (try_end),
           # #after this - dialogs on what doing, npc_decision_checklist
         # (try_end),	
#moto chief acaba		 
       #Offensive concludes
       (else_try),
	     (store_current_hours, ":hours"),
         (this_or_next|eq, ":old_faction_ai_state", sfai_gathering_army),
         (this_or_next|eq, ":old_faction_ai_state", sfai_attacking_center),
         (this_or_next|eq, ":old_faction_ai_state", sfai_raiding_village),
		 #(this_or_next|eq, ":old_faction_ai_state", sfai_attacking_enemies_around_center),
			(eq, ":old_faction_ai_state", sfai_attacking_enemy_army),
		 
         (this_or_next|eq, ":new_strategy", sfai_default),
			(eq, ":new_strategy", sfai_feast),				
						
         (call_script, "script_check_and_finish_active_army_quests_for_faction", ":faction_no"),       		 
         (faction_set_slot, ":faction_no", "slot_faction_last_offensive_concluded", ":hours"),
        (try_end),
    (try_end),
	
    (try_begin),
       (eq, "$players_kingdom", ":faction_no"),
       (neg|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_center),
       (check_quest_active, "qst_join_siege_with_army"),
       (call_script, "script_abort_quest", "qst_join_siege_with_army", 0),
    (try_end),

    (try_begin),
       #old condition to rest, I changed below part - ozan, to rest (a faction's old strategy should be feast or default) and (a faction's new strategy should be feast or default)
       #(this_or_next|eq, ":new_strategy", sfai_default),
       #(this_or_next|eq, ":new_strategy", sfai_feast),
       #(this_or_next|eq, ":old_faction_ai_state", sfai_default),
       #(eq, ":old_faction_ai_state", sfai_feast),
       
       #new condition to rest, (a faction's new strategy should be feast or default) and (":hours_at_current_state" > 20)
       (this_or_next|eq, ":new_strategy", sfai_default),
		(eq, ":new_strategy", sfai_feast),                            
              
       (store_current_hours, ":hours_at_current_state"),
       (faction_get_slot, ":current_state_started", ":faction_no", "slot_faction_ai_current_state_started"),
       (val_sub, ":hours_at_current_state", ":current_state_started"),
       (ge, ":hours_at_current_state", 18), #Must have at least 18 hours to reset
              
       (store_current_hours, ":hours"),       
       (faction_set_slot, ":faction_no", "slot_faction_ai_last_rest_time", ":hours"),
    (try_end),     
  ]),

  # script_check_and_finish_active_army_quests_for_faction
  # Input: faction_no
  # Output: none
  ("check_and_finish_active_army_quests_for_faction",
   [
     (store_script_param_1, ":faction_no"),
     (try_begin),
       (eq, "$players_kingdom", ":faction_no"),
       (try_begin),
         (check_quest_active, "qst_report_to_army"),
         (call_script, "script_cancel_quest", "qst_report_to_army"),
       (try_end),
       (assign, ":one_active", 0),
       (try_for_range, ":quest_no", army_quests_begin, army_quests_end),
         (check_quest_active, ":quest_no"),
         (call_script, "script_cancel_quest", ":quest_no"),
		 (troop_get_slot, ":army_quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
         (assign, ":one_active", 1),
       (try_end),
       (try_begin),
         (check_quest_active, "qst_follow_army"),
         (assign, ":one_active", 1),
		 (troop_get_slot, ":army_quest_giver_troop", "qst_follow_army", "slot_quest_giver_troop"),
         (call_script, "script_end_quest", "qst_follow_army"),
       (try_end),
       (eq, ":one_active", 1),
       (faction_get_slot, ":last_offensive_time", ":faction_no", "slot_faction_last_offensive_concluded"),
       (store_current_hours, ":cur_hours"),
       (store_sub, ":total_time_served", ":cur_hours", ":last_offensive_time"),
       (store_mul, ":xp_reward", ":total_time_served", 6),#gdw5
       (val_div, ":xp_reward", 50),
       (val_mul, ":xp_reward", 50),
       (val_add, ":xp_reward", 50),
       (add_xp_as_reward, ":xp_reward"),
	   (call_script, "script_troop_change_relation_with_troop", "trp_player", ":army_quest_giver_troop", 2),
     (try_end),
    ]),
  
    # script_troop_get_player_relation
    # Input: arg1 = troop_no
    # Output: reg0 = effective relation (modified by troop reputation, honor, etc.)
    ("troop_get_player_relation",
      [
        (store_script_param_1, ":troop_no"),
        (troop_get_slot, ":reputation", ":troop_no", "slot_lord_reputation_type"),
        (troop_get_slot, ":effective_relation", ":troop_no", "slot_troop_player_relation"),
        (assign, ":honor_bonus", 0),
        (try_begin),
          (eq,  ":reputation", lrep_quarrelsome),
          (val_add, ":effective_relation", -3),
        (try_end),
        (try_begin),
          (ge, "$player_honor", 0),
          (try_begin),
            (this_or_next|eq,  ":reputation", lrep_upstanding),
            (             eq,  ":reputation", lrep_goodnatured),
            (store_div, ":honor_bonus", "$player_honor", 3),
            (this_or_next|eq,  ":reputation", lrep_martial),
            (             eq,  ":reputation", lrep_cunning),
            (store_div, ":honor_bonus", "$player_honor", 5),#gdw
          (try_end),
        (try_end),
        (try_begin),
          (lt, "$player_honor", 0),
          (try_begin),
            (this_or_next|eq,  ":reputation", lrep_upstanding),
            (             eq,  ":reputation", lrep_goodnatured),
            (store_div, ":honor_bonus", "$player_honor", 3),
          (else_try),
            (eq,  ":reputation", lrep_martial),
            (store_div, ":honor_bonus", "$player_honor", 5),
          (try_end),
        (try_end),
        (val_add, ":effective_relation", ":honor_bonus"),
        (val_clamp, ":effective_relation", -100, 101),
        (assign, reg0, ":effective_relation"),
    ]),
  
  # script_change_troop_renown
  # Input: arg1 = troop_no, arg2 = relation difference
  # Output: none
  ("change_troop_renown",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":renown_change"),
      
      (troop_get_slot, ":old_renown", ":troop_no", "slot_troop_renown"),

	  (try_begin),
		(gt, ":renown_change", 0),
		(assign, reg4, ":renown_change"),
		
		(store_div, ":subtraction", ":old_renown", 200), 
	    (val_sub, ":renown_change", ":subtraction"),
	    (val_max, ":renown_change", 0),
		
	    (eq, ":troop_no", "trp_player"), 

	    (assign, reg5, ":renown_change"),
		
		(eq, "$cheat_mode", 1),
	    (display_message, "str_renown_change_of_reg4_reduced_to_reg5_because_of_high_existing_renown"),
	  (try_end),

      (store_add, ":new_renown", ":old_renown", ":renown_change"),
      (val_max, ":new_renown", 0),
      (troop_set_slot, ":troop_no", "slot_troop_renown", ":new_renown"),
	  
      (try_begin),
        (eq, ":troop_no", "trp_player"),

		(try_begin),
		  (ge, ":new_renown", 50),

          (try_begin),
            (troop_get_type, ":is_female", "trp_player"),
             (val_mod, ":is_female", 2),    #gender fix chief moto
      (eq, ":is_female", 1),
            (unlock_achievement, ACHIEVEMENT_TALK_OF_THE_TOWN),
          (try_end),
		(try_end),

        (str_store_troop_name, s1, ":troop_no"),
        (assign, reg12, ":renown_change"),
        (val_abs, reg12),
        (try_begin),
         (gt, ":renown_change", 0),
         (display_message, "@You gained {reg12} renown."),
        (else_try),
          (lt, ":renown_change", 0),
          (display_message, "@You lose {reg12} renown."),
        (try_end),
      (try_end),
      (call_script, "script_update_troop_notes", ":troop_no"),
  ]),
  
  
  # script_change_player_relation_with_troop
  # Input: arg1 = troop_no, arg2 = relation difference
  # Output: none
  ("change_player_relation_with_troop",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":difference"),

      (try_begin),
        (neq, ":troop_no", "trp_player"),
        (neg|is_between, ":troop_no", soldiers_begin, soldiers_end),
		(neq, ":troop_no", -1),
        (neq, ":difference", 0),
        (call_script, "script_troop_get_player_relation", ":troop_no"),
        (assign, ":old_effective_relation", reg0),
        (troop_get_slot, ":player_relation", ":troop_no", "slot_troop_player_relation"),
        (val_add, ":player_relation", ":difference"),
        (val_clamp, ":player_relation", -100, 101),
        (try_begin),
          (troop_set_slot, ":troop_no", "slot_troop_player_relation", ":player_relation"),
          (try_begin),
            (le, ":player_relation", -50),
            (unlock_achievement, ACHIEVEMENT_OLD_DIRTY_SCOUNDREL),
          (try_end),
                    
          (str_store_troop_name_link, s1, ":troop_no"),
          (call_script, "script_troop_get_player_relation", ":troop_no"),
          (assign, ":new_effective_relation", reg0),
          (neq, ":old_effective_relation", ":new_effective_relation"),
          (assign, reg1, ":old_effective_relation"),
          (assign, reg2, ":new_effective_relation"),
          (try_begin),
            (gt, ":difference", 0),
            (display_message, "str_troop_relation_increased", color_bad_news),
          (else_try),
            (lt, ":difference", 0),
            (display_message, "str_troop_relation_detoriated", color_bad_news),
          (try_end),
          (try_begin),
            (eq, ":troop_no", "$g_talk_troop"),
            (assign, "$g_talk_troop_relation", ":new_effective_relation"),
            (call_script, "script_setup_talk_info"),
          (try_end),
          (call_script, "script_update_troop_notes", ":troop_no"),
        (try_end),
      (try_end),
  ]),

  # script_change_player_relation_with_center
  # Input: arg1 = party_no, arg2 = relation difference
  # Output: none
  ("change_player_relation_with_center",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":difference"),
      
      (party_get_slot, ":player_relation", ":center_no", "slot_center_player_relation"),
      (assign, reg1, ":player_relation"),
      (val_add, ":player_relation", ":difference"),
      (val_clamp, ":player_relation", -100, 100),
      (assign, reg2, ":player_relation"),
      (party_set_slot, ":center_no", "slot_center_player_relation", ":player_relation"),
      (try_begin),
        (le, ":player_relation", -50),
        (unlock_achievement, ACHIEVEMENT_OLD_DIRTY_SCOUNDREL),
      (try_end),
      
      (str_store_party_name_link, s1, ":center_no"),
      (try_begin),
        (gt, ":difference", 0),
        (display_message, "@Your relation with {s1} has improved.", color_good_news),
		(party_slot_eq, ":center_no", "slot_party_type", spt_village), #TEMPERED chief  ADDED COMMONER TRUST
		(val_add,"$commoner_trust",":difference"), #TEMPERED chief  ADDED COMMONER TRUST
      (else_try),
        (lt, ":difference", 0),
        (display_message, "@Your relation with {s1} has deteriorated.", color_bad_news),
		(party_slot_eq, ":center_no", "slot_party_type", spt_village), #TEMPERED chief  ADDED COMMONER TRUST
		(val_add,"$commoner_trust",":difference"), #TEMPERED chief ADDED COMMONER TRUST
      (try_end),
      (try_begin),
        (party_slot_eq, ":center_no", "slot_party_type", spt_village),
        (call_script, "script_update_volunteer_troops_in_village", ":center_no"),
      (try_end),
      
      (try_begin),
        (this_or_next|is_between, "$g_talk_troop", village_elders_begin, village_elders_end),
        (is_between, "$g_talk_troop", mayors_begin, mayors_end),
        (assign, "$g_talk_troop_relation", ":player_relation"),
        (call_script, "script_setup_talk_info"),
      (try_end),
  ]),
  
  
  # script_change_player_relation_with_faction
  # Input: arg1 = faction_no, arg2 = relation difference
  # Output: none
  ("change_player_relation_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":difference"),
      
      (store_relation, ":player_relation", ":faction_no", "fac_player_supporters_faction"),
      (assign, reg1, ":player_relation"),
      (val_add, ":player_relation", ":difference"),
      (assign, reg2, ":player_relation"),
      (set_relation, ":faction_no", "fac_player_faction", ":player_relation"),
      (set_relation, ":faction_no", "fac_player_supporters_faction", ":player_relation"),
      (try_begin),
        (le, ":player_relation", -50),
        (unlock_achievement, ACHIEVEMENT_OLD_DIRTY_SCOUNDREL),
      (try_end),
      
      (str_store_faction_name_link, s1, ":faction_no"),
      (try_begin),
        (gt, ":difference", 0),
        (display_message, "str_faction_relation_increased"),
      (else_try),
        (lt, ":difference", 0),
        (display_message, "str_faction_relation_detoriated"),
      (try_end),
      (call_script, "script_update_all_notes"),
      ]),

  # script_set_player_relation_with_faction
  # Input: arg1 = faction_no, arg2 = relation
  # Output: none
  ("set_player_relation_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":relation"),
      
      (store_relation, ":player_relation", ":faction_no", "fac_player_supporters_faction"),
      (store_sub, ":reln_dif", ":relation", ":player_relation"),
      (call_script, "script_change_player_relation_with_faction", ":faction_no", ":reln_dif"),
      ]),

  
  
 # script_change_player_relation_with_faction_ex
  # changes relations with other factions also (according to their relations between each other)
  # Input: arg1 = faction_no, arg2 = relation difference
  # Output: none
  ("change_player_relation_with_faction_ex",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":difference"),

      (store_relation, ":player_relation", ":faction_no", "fac_player_supporters_faction"),
      (assign, reg1, ":player_relation"),
      (val_add, ":player_relation", ":difference"),
      (assign, reg2, ":player_relation"),
      (set_relation, ":faction_no", "fac_player_faction", ":player_relation"),
      (set_relation, ":faction_no", "fac_player_supporters_faction", ":player_relation"),

      (str_store_faction_name_link, s1, ":faction_no"),
      (try_begin),
        (gt, ":difference", 0),
        (display_message, "str_faction_relation_increased"),
      (else_try),
        (lt, ":difference", 0),
        (display_message, "str_faction_relation_detoriated"),
      (try_end),

      (display_message, "@Your relations with all other factions change."),    #MOTO avoid 31 messages
      (try_for_range, ":other_faction", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":other_faction", "slot_faction_state", sfs_active),
        (neq, ":faction_no", ":other_faction"),
        (store_relation, ":other_faction_relation", ":faction_no", ":other_faction"),
        (store_relation, ":player_relation", ":other_faction", "fac_player_supporters_faction"),
        (store_mul, ":relation_change", ":difference", ":other_faction_relation"),
        (val_div, ":relation_change", 100),
        (val_add, ":player_relation", ":relation_change"),
       ##diplomacy chief start moto
              (try_begin),
                  (store_add, ":truce_slot",      "fac_player_supporters_faction",      "slot_faction_truce_days_with_factions_begin"),
                   (val_sub, ":truce_slot", kingdoms_begin),
                   (faction_get_slot, ":truce_days", ":other_faction",      ":truce_slot"),
                  (this_or_next|eq, ":truce_days", 0), #other faction      only affected if no truce
                  (gt, ":difference", 0), #or change > 0
                  (store_relation, ":cur_relation", ":other_faction",      "fac_player_supporters_faction"),

##        ##diplomacy chief start
##        (try_begin),
##            (store_add, ":truce_slot", "fac_player_supporters_faction", "slot_faction_truce_days_with_factions_begin"),
##  		    (val_sub, ":truce_slot", kingdoms_begin),
##  		    (faction_get_slot, ":truce_days", ":other_faction", ":truce_slot"),
##            (this_or_next|eq, ":truce_days", 0), #other faction only affected if no truce
##            (gt, ":difference", 0), #or change > 0
##            (store_relation, ":cur_relation", ":other_faction", "fac_player_supporters_faction"),
##
##            #display relation change message
##            (store_sub,  ":relation_change", ":player_relation", ":cur_relation"),
##            (str_store_faction_name_link, s1, ":other_faction"),
##            (assign, reg1, ":cur_relation"),
##            (assign, reg2, ":player_relation"),
##            (try_begin),
##              (gt, ":relation_change", 0),
##              (display_message, "str_faction_relation_increased"),
##            (else_try),
##              (lt, ":relation_change", 0),
##              (display_message, "str_faction_relation_detoriated"),
##            (try_end),
##
##            #display war declaration
##            (try_begin),
##                (ge, ":cur_relation", 0), #old relation > 0 -> peace
##                (lt, ":player_relation", 0), #new relation < 0 -> war
##                (call_script, "script_add_notification_menu", "mnu_notification_war_declared", ":other_faction", ":faction_no"),
##            (try_end),
##        ##diplomacy end
            #display war declaration
                  (try_begin),
                      (ge, ":cur_relation", 0), #old relation > 0      -> peace
                      (lt, ":player_relation", 0), #new relation < 0      -> war
                      (call_script, "script_add_notification_menu",      "mnu_notification_war_declared", ":other_faction", ":faction_no"),
                  (try_end),
##        ##diplomacy end

      (set_relation, ":other_faction", "fac_player_faction", ":player_relation"),
        (set_relation, ":other_faction", "fac_player_supporters_faction", ":player_relation"),
        ##diplomacy chief begin
        (try_end),
##        ##diplomacy end
      (try_end),
      (try_begin),
        (faction_slot_eq, "fac_player_supporters_faction", "slot_faction_state", sfs_active),
        (try_for_range, ":kingdom_no", kingdoms_begin, kingdoms_end),
          (faction_slot_eq, ":kingdom_no", "slot_faction_state", sfs_active),
          (call_script, "script_update_faction_notes", ":kingdom_no"),
        (try_end),
      (try_end),
  ]),
  
  # script_cf_get_random_active_faction_except_player_faction_and_faction
  # Input: arg1 = except_faction_no
  # Output: reg0 = random_faction
  ("cf_get_random_active_faction_except_player_faction_and_faction",
    [
      (store_script_param_1, ":except_faction_no"),
      (assign, ":num_factions", 0),
      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (neq, ":faction_no", ":except_faction_no"),
        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
        (val_add, ":num_factions", 1),
      (try_end),
      (gt, ":num_factions", 0),
      (assign, ":selected_faction", -1),
      (store_random_in_range, ":random_faction", 0, ":num_factions"),
      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (ge, ":random_faction", 0),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (neq, ":faction_no", ":except_faction_no"),
        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
        (val_sub, ":random_faction", 1),
        (lt, ":random_faction", 0),
        (assign, ":selected_faction", ":faction_no"),
      (try_end),
      (assign, reg0, ":selected_faction"),
  ]),

  # script_make_kingdom_hostile_to_player
  # Input: arg1 = faction_no, arg2 = relation difference
  # Output: none
  ("make_kingdom_hostile_to_player",
    [
      (store_script_param_1, ":kingdom_no"),
      (store_script_param_2, ":difference"),

      (try_begin),
        (lt, ":difference", 0),
        (store_relation, ":player_relation", ":kingdom_no", "fac_player_supporters_faction"),
        (val_min, ":player_relation", 0),
        (val_add, ":player_relation", ":difference"),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_no", ":player_relation"),
      (try_end),
  ]),
  
  # script_change_player_honor
  # Input: arg1 = honor difference
  # Output: none
  ("change_player_honor",
    [
      (store_script_param_1, ":honor_dif"),
      (val_add, "$player_honor", ":honor_dif"),
      (try_begin),
        (gt, ":honor_dif", 0),
        (display_message, "@You gain Reputation.", color_good_news),
      (else_try),
        (lt, ":honor_dif", 0),
        (display_message, "@You lose Reputation.", color_bad_news),
      (try_end),
#fire arrow chief
            (try_begin),
        #(eq, "$cheat_mode", 1),
        (assign, reg1, "$player_honor"),
        (display_message, "@Now player reputation is {reg1}"),
      (try_end),
#fire arrow acaba chief
##      (val_mul, ":honor_dif", 1000),
##      (assign, ":temp_honor", 0),
##      (assign, ":num_nonlinear_steps", 10),
##      (try_begin),
##        (gt, "$player_honor", 0),
##        (lt, ":honor_dif", 0),
##        (assign, ":num_nonlinear_steps", 0),
##      (else_try),
##        (lt, "$player_honor", 0),
##        (gt, ":honor_dif", 0),
##        (assign, ":num_nonlinear_steps", 3),
##      (try_end),
##      
##      (try_begin),
##        (ge, "$player_honor", 0),
##        (assign, ":temp_honor", "$player_honor"),
##      (else_try),
##        (val_sub, ":temp_honor", "$player_honor"),
##      (try_end),
##      (try_for_range, ":unused",0,":num_nonlinear_steps"),
##        (ge, ":temp_honor", 10000),
##        (val_div, ":temp_honor", 2),
##        (val_div, ":honor_dif", 2),
##      (try_end),
##      (val_add, "$player_honor", ":honor_dif"),
  ]),

  # script_change_player_party_morale
  # Input: arg1 = morale difference
  # Output: none
  ("change_player_party_morale",
    [
      (store_script_param_1, ":morale_dif"),
      (party_get_morale, ":cur_morale", "p_main_party"),
      (val_clamp, ":cur_morale", 0, 100),
            
      (store_add, ":new_morale", ":cur_morale", ":morale_dif"),
      (val_clamp, ":new_morale", 0, 100),
      (set_show_messages, 1),#gdw
      (party_set_morale, "p_main_party", ":new_morale"),
      (try_begin),
        (lt, ":new_morale", ":cur_morale"),
        (store_sub, reg1, ":cur_morale", ":new_morale"),
        (display_message, "str_party_lost_morale", color_bad_news),
      (else_try),
        (gt, ":new_morale", ":cur_morale"),
        (store_sub, reg1, ":new_morale", ":cur_morale"),
        (display_message, "str_party_gained_morale", color_good_news),
      (try_end),
  ]),

  # script_cf_player_has_item_without_modifier
  # Input: arg1 = item_id, arg2 = modifier
  # Output: none (can_fail)
  ("cf_player_has_item_without_modifier",
    [
      (store_script_param, ":item_id", 1),
      (store_script_param, ":modifier", 2),
      (player_has_item, ":item_id"),
      #checking if any of the meat is not rotten
      (assign, ":has_without_modifier", 0),
      (troop_get_inventory_capacity, ":inv_size", "trp_player"),
      (try_for_range, ":i_slot", 0, ":inv_size"),
        (troop_get_inventory_slot, ":cur_item", "trp_player", ":i_slot"),
        (eq, ":cur_item", ":item_id"),
        (troop_get_inventory_slot_modifier, ":cur_modifier", "trp_player", ":i_slot"),
        (neq, ":cur_modifier", ":modifier"),
        (assign, ":has_without_modifier", 1),
        (assign, ":inv_size", 0), #break
      (try_end),
      (eq, ":has_without_modifier", 1),
  ]),

##  # script_get_player_party_morale_values ESTE ES EL NATIVE, DEBAJO MODIFICA MOTOMATARU
##  # Output: reg0 = player_party_morale_target
##  ("get_player_party_morale_values",
##    [
##      (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
##      (assign, ":num_men", 0),
###	  (assign, ":num_companions",0), #Tempered chief added for companions positive adjustment to morale
##      (try_for_range, ":i_stack", 1, ":num_stacks"),
##        (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
##        (try_begin),
##          (troop_is_hero, ":stack_troop"),
##          (val_add, ":num_men", 1), #it was 3 in "Mount&Blade", now it is 1 in Warband
###		  (val_add, ":num_companions",1), #Tempered chief added for companions positive adjustment to morale
##        (else_try),
##          (party_stack_get_size, ":stack_size","p_main_party",":i_stack"),
##          (val_add, ":num_men", ":stack_size"),
##        (try_end),
##      (try_end),
###	  (val_mul,":num_companions", 4),   #Tempered chief added for companions positive adjustment to morale
##      (assign, "$g_player_party_morale_modifier_party_size", ":num_men"),
##        (val_div, "$g_player_party_morale_modifier_party_size", 3), #chief anadido para reducir el modificador negativo por numero
##    
##      (store_skill_level, ":player_leadership", "skl_leadership", "trp_player"),
##      
##      (try_begin),
##        (eq, "$players_kingdom", "fac_player_supporters_faction"),
##        (faction_get_slot, ":cur_faction_king", "$players_kingdom", "slot_faction_leader"),
##        (eq, ":cur_faction_king", "trp_player"),
##        (store_mul, "$g_player_party_morale_modifier_leadership", ":player_leadership", 15),
##      (else_try),  
##        (store_mul, "$g_player_party_morale_modifier_leadership", ":player_leadership", 12),
##      (try_end),  
##      
##      (assign, ":new_morale", "$g_player_party_morale_modifier_leadership"),
##      (val_sub, ":new_morale", "$g_player_party_morale_modifier_party_size"),
##      
##      (val_add, ":new_morale", 50),
###      (val_add, ":new_morale", ":num_companions"), #Tempered added for companions positive adjustment to morale
##      
##      (assign, "$g_player_party_morale_modifier_food", 0),
##      (try_for_range, ":cur_edible", food_begin, food_end),      
##        (call_script, "script_cf_player_has_item_without_modifier", ":cur_edible", imod_rotten),
##        (item_get_slot, ":food_bonus", ":cur_edible", "slot_item_food_bonus"),
##        
##        (val_mul, ":food_bonus", 3),
##        (val_div, ":food_bonus", 2),
##        
##        (val_add, "$g_player_party_morale_modifier_food", ":food_bonus"),
##      (try_end),
##      (val_add, ":new_morale", "$g_player_party_morale_modifier_food"),
##
##      (try_begin),
##        (eq, "$g_player_party_morale_modifier_food", 0),
##        (assign, "$g_player_party_morale_modifier_no_food", 30),
##        (val_sub, ":new_morale", "$g_player_party_morale_modifier_no_food"),
##      (else_try),
##        (assign, "$g_player_party_morale_modifier_no_food", 0),
##      (try_end),
##
##      (assign, "$g_player_party_morale_modifier_debt", 0),
##      (try_begin),
##        (gt, "$g_player_debt_to_party_members", 0),
##        (call_script, "script_calculate_player_faction_wage"),
##        (assign, ":total_wages", reg0),
##        (store_mul, "$g_player_party_morale_modifier_debt", "$g_player_debt_to_party_members", 10),
##		(val_max, ":total_wages", 1),
##        (val_div, "$g_player_party_morale_modifier_debt", ":total_wages"),
##        (val_clamp, "$g_player_party_morale_modifier_debt", 1, 31),
##        (val_sub, ":new_morale", "$g_player_party_morale_modifier_debt"),
##      (try_end),
##
##      (val_clamp, ":new_morale", 0, 100),
##      (assign, reg0, ":new_morale"),
##      ]),

  #chief motomataru moral script cambiado
 # script_get_player_party_morale_values modified by motomataru
 # Output: reg0 = player_party_morale_target
 ("get_player_party_morale_values",[
   (assign, ":new_morale", 50),
   (assign, ":num_men", 0),
   # (assign, ":num_companions",0), #Tempered chief added for companions positive adjustment to morale MOTO effect now comes through companion LD for party size

   (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
   (try_for_range, ":i_stack", 1, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
       (try_begin),
           (troop_is_hero, ":stack_troop"),
           (val_add, ":num_men", 1), #it was 3 in "Mount&Blade", now it is 1 in Warband
           # (val_add, ":num_companions",1), #Tempered chief added for companions positive adjustment to morale
       (else_try),
           (party_stack_get_size, ":stack_size","p_main_party",":i_stack"),
           (val_add, ":num_men", ":stack_size"),
       (try_end),
   (try_end),
   (call_script, "script_game_get_party_companion_limit"),
   (val_div, reg0, 2),    #this is how many the player can lead effectively (so average morale)
   (try_begin),
       (ge, reg0, ":num_men"),
       # (val_mul,":num_companions", 4),   #Tempered chief added for companions positive adjustment to morale
       (assign, "$g_player_party_morale_modifier_party_size", 0),
   (else_try),
       (store_sub, "$g_player_party_morale_modifier_party_size", ":num_men", reg0),
       (val_mul, "$g_player_party_morale_modifier_party_size", 100),
       (val_div, "$g_player_party_morale_modifier_party_size", reg0),
       (val_div, "$g_player_party_morale_modifier_party_size", 3),    #up to -33 effect
       (val_sub, ":new_morale", "$g_player_party_morale_modifier_party_size"),
   (try_end),
   # (val_add, ":new_morale", ":num_companions"), #Tempered added for companions positive adjustment to morale

   (assign, "$g_player_party_morale_modifier_food", -15),    #troops expect basic bread + meat
   (try_for_range, ":cur_edible", food_begin, food_end),
       (call_script, "script_cf_player_has_item_without_modifier", ":cur_edible", imod_rotten),
       (item_get_slot, ":food_bonus", ":cur_edible", "slot_item_food_bonus"),
       (val_add, "$g_player_party_morale_modifier_food", ":food_bonus"),
   (try_end),
   (val_add, ":new_morale", "$g_player_party_morale_modifier_food"),

   (try_begin),
       (eq, "$g_player_party_morale_modifier_food", -15),
       (assign, "$g_player_party_morale_modifier_no_food", 15),
       (val_sub, ":new_morale", "$g_player_party_morale_modifier_no_food"),
   (else_try),
       (assign, "$g_player_party_morale_modifier_no_food", 0),
   (try_end),

   (assign, "$g_player_party_morale_modifier_debt", 0),
   (try_begin),
       (gt, "$g_player_debt_to_party_members", 0),
       (call_script, "script_calculate_player_faction_wage"),
       (gt, reg0, 0),    #if no more party, then no more morale penalty!
       (assign, ":new_wages", reg0),
       (assign, ":num_current_party_members", reg1),

       (store_mul, "$g_player_party_morale_modifier_debt", "$g_player_debt_to_party_members", 100),
       (try_begin),    #if party has grown, then morale impact of debt is diluted
           (gt, ":num_current_party_members", "$g_player_num_creditors"),
           (val_div, "$g_player_party_morale_modifier_debt", ":new_wages"),
       (else_try),
           (val_div, "$g_player_party_morale_modifier_debt", "$g_player_old_wages"),
       (try_end),
       (val_div, "$g_player_party_morale_modifier_debt", 3),    #target -33 effect for each week without ANY pay
       (val_sub, ":new_morale", "$g_player_party_morale_modifier_debt"),
   (try_end),

   #(assign, reg3,"$g_player_party_morale_modifier_weariness"),this has opcode errors
   #(party_get_slot, "$g_player_party_morale_modifier_weariness", "p_main_party", "slot_party_unrested_morale_penalty"),
   (party_get_slot, reg3, "p_main_party", "slot_party_unrested_morale_penalty"),
	#(assign, reg3,"$g_player_party_morale_modifier_weariness"),
	(try_begin),
		(ge, "$cheat_mode", 1),
	 	(display_message, "@_player_party_morale_modifier_weariness is {reg3}"),
	(try_end),


   (val_max, reg3,0),
   (val_sub, ":new_morale", reg3),

   (val_clamp, ":new_morale", 0, 100),
   (assign, reg0, ":new_morale"),
   ]),
 #moral motomataru chief acaba

  ("diplomacy_party_attacks_neutral", #called from game_menus (plundering a village, raiding a village),  from dialogs: surprise attacking a neutral lord, any attack on caravan or villagers
#Has no effect if factions are already at war 
    [
      (store_script_param, ":attacker_party", 1),
      (store_script_param, ":defender_party", 2),
	  
	  (store_faction_of_party, ":attacker_faction", ":attacker_party"),
	  (store_faction_of_party, ":defender_faction", ":defender_party"),
	  
	  (party_stack_get_troop_id, ":attacker_leader", ":attacker_party", 0),
	  
	  (try_begin),
		(eq, ":attacker_party", "p_main_party"),
        #MOTO chief rewrite
              (assign, ":attacker_faction", "$players_kingdom"),
              
              (try_begin),
                  (eq, ":attacker_faction", "fac_no_faction"),
                  (assign, ":attacker_faction",      "fac_player_supporters_faction"),
              (try_end),
              #MOTO rewrite end
      (store_relation, ":relation", ":attacker_faction", ":defender_faction"),
	    (ge, ":relation", 0),
      (call_script, "script_change_player_honor", -2),
	  (try_end),

	  (try_begin),
		(check_quest_active, "qst_cause_provocation"),
		(quest_slot_eq, "qst_cause_provocation", "slot_quest_target_faction", ":defender_faction"),
		(quest_get_slot, ":giver_troop", "qst_cause_provocation", "slot_quest_giver_troop"),
		(store_faction_of_troop, ":attacker_faction", ":giver_troop"),
		(call_script, "script_succeed_quest", "qst_cause_provocation"),		
	  (try_end),
	  
	  (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":attacker_faction", ":defender_faction"),
	  (assign, ":diplomatic_status", reg0),
	  
	  (try_begin),
	    (eq, ":attacker_faction", "fac_player_supporters_faction"),
		(neg|faction_slot_eq, "fac_player_supporters_faction", "slot_faction_state", sfs_active),
		#player faction inactive, no effect		
	  (else_try),	
		(eq, ":diplomatic_status", -2),
	    #war, no effect
	  (else_try),	
	    (eq, ":attacker_faction", "fac_player_supporters_faction"),
		(faction_slot_eq, ":attacker_faction", "slot_faction_leader", "trp_player"),
		(call_script, "script_faction_follows_controversial_policy", "fac_player_supporters_faction",logent_policy_ruler_attacks_without_provocation),
	  (else_try),
      (eq, ":diplomatic_status", 1),
		#truce
		(party_stack_get_troop_id, ":defender_party_leader", ":defender_party", 0),
		(try_begin),
			(neg|is_between, ":defender_party_leader", active_npcs_begin, active_npcs_end),
			(store_faction_of_party, ":defender_party_faction", ":defender_party"),
			(faction_get_slot, ":defender_party_leader", ":defender_party_faction", "slot_faction_leader"),
		(try_end),
		
		(call_script, "script_add_log_entry", logent_border_incident_troop_breaks_truce, ":attacker_leader", -1, ":defender_party_leader", ":attacker_faction"),
	  (else_try),	
		#truce
		(call_script, "script_add_log_entry", logent_border_incident_troop_attacks_neutral, ":attacker_leader", -1, ":defender_party_leader", ":attacker_faction"),
	  (try_end),
	  	  
	  (try_begin),
	    (is_between, ":defender_party", villages_begin, villages_end),
	    (call_script, "script_add_log_entry", logent_village_raided, ":attacker_leader",  ":defender_party", -1, ":defender_faction"),
	  (else_try),
	    (party_get_template_id, ":template", ":defender_party"),
	    (neq, ":template", "pt_kingdom_hero_party"),
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_faction_name, s5, ":defender_faction"),
			(display_message, "@{!}DEbug - {s5} caravan attacked"),
		(try_end),
      
	    (call_script, "script_add_log_entry", logent_caravan_accosted, ":attacker_leader",  -1, -1, ":defender_faction"),
	  (try_end),

	  (store_add, ":slot_truce_days", ":attacker_faction", "slot_faction_provocation_days_with_factions_begin"),
	  (val_sub, ":slot_truce_days", kingdoms_begin),
	  (faction_set_slot, ":defender_faction", ":slot_truce_days", 0),
	  
	  (store_add, ":slot_provocation_days", ":attacker_faction", "slot_faction_provocation_days_with_factions_begin"),
	  (val_sub, ":slot_provocation_days", kingdoms_begin),
	  (try_begin),
	    (neq, ":diplomatic_status", -2),
		(faction_slot_eq, ":defender_faction", ":slot_provocation_days", 0),
		(faction_set_slot, ":defender_faction", ":slot_provocation_days", 30),
	  (try_end),	  
	]),
	
  # script_party_calculate_and_set_nearby_friend_enemy_follower_strengths
  # Input: party_no
  # Output: none
  ("party_calculate_and_set_nearby_friend_enemy_follower_strengths",
    [
      (store_script_param, ":party_no", 1),
      (assign, ":follower_strength", 0),
      (assign, ":friend_strength", 0),
      (assign, ":enemy_strength", 0),
      (store_faction_of_party, ":party_faction", ":party_no"),

      (store_add, ":end_cond", active_npcs_end, 1),      
      (try_for_range, ":iteration", active_npcs_begin, ":end_cond"),
        (try_begin),
          (eq, ":iteration", active_npcs_end),
          (assign, ":cur_troop", "trp_player"),
        (else_try),
          (assign, ":cur_troop", ":iteration"),
        (try_end),

        (troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
        (troop_get_slot, ":cur_troop_party", ":cur_troop", "slot_troop_leaded_party"),
        (ge, ":cur_troop_party", 0),
        (party_is_active, ":cur_troop_party"),

         
        #I moved these lines here from (*1) to faster process, ozan.
        (store_troop_faction, ":army_faction", ":cur_troop"),
        (store_relation, ":relation", ":army_faction", ":party_faction"),        
        (this_or_next|neq, ":relation", 0),
        (eq, ":army_faction", ":party_faction"),
        #ozan end


        (neq, ":party_no", ":cur_troop_party"),
        (party_get_slot, ":str", ":cur_troop_party", "slot_party_cached_strength"),
        (try_begin),
          (neg|is_between, ":party_no", centers_begin, centers_end),
          (this_or_next|party_slot_eq, ":cur_troop_party", "slot_party_ai_state", spai_screening_army),	#MOTO don't forget screeners
          (party_slot_eq, ":cur_troop_party", "slot_party_ai_state", spai_accompanying_army),
          (party_get_slot, ":commander_party", ":cur_troop_party", "slot_party_ai_object"),
          (eq, ":commander_party", ":party_no"),
          (val_add, ":follower_strength", ":str"),
        (else_try),
          (store_distance_to_party_from_party, ":distance", ":cur_troop_party", ":party_no"),
          (lt, ":distance", 20),
        
          #(*1)
          
          (try_begin),
            (lt, ":distance", 5),
            (assign, ":str_divided", ":str"),
          (else_try),
            (lt, ":distance", 10),
            (store_div, ":str_divided", ":str", 2),
          (else_try),
            (lt, ":distance", 15),
            (store_div, ":str_divided", ":str", 4),
          (else_try),
            (store_div, ":str_divided", ":str", 8),
          (try_end),
        
          (try_begin),
            (this_or_next|eq, ":army_faction", ":party_faction"),
            (gt, ":relation", 0),
            (val_add, ":friend_strength", ":str_divided"),
          (else_try),
            (lt, ":relation", 0),
            (val_add, ":enemy_strength", ":str_divided"),
          (try_end),
        (try_end),
      (try_end),
      
      (party_set_slot, ":party_no", "slot_party_follower_strength", ":follower_strength"),
      (party_set_slot, ":party_no", "slot_party_nearby_friend_strength", ":friend_strength"),
      (party_set_slot, ":party_no", "slot_party_nearby_enemy_strength", ":enemy_strength"),
      ]),
  
  # script_init_ai_calculation
  # Input: none
  # Output: none
  ("init_ai_calculation",
    [
       ##diplomacy start+ chief
	  #(assign, ":real_party_strength"),
	  ##If terrain advantage is enabled, use it to calculate troop strengths.
      (try_begin),
         (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_ENABLE),
		 
		 #First update all lords
     (try_for_range, ":cur_troop", heroes_begin, heroes_end),
            (troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
            (troop_get_slot, ":cur_party", ":cur_troop", "slot_troop_leaded_party"),
			(gt, ":cur_party", 0),
            (party_is_active, ":cur_party"),
            
		    (party_get_current_terrain, ":terrain_code", ":cur_party"),
			
			(party_get_attached_to, ":attachment", ":cur_party"),			
			(try_begin),
				(ge, ":attachment", 0),
				(is_between, ":attachment", centers_begin, centers_end),
				(assign, ":terrain_code", dplmc_terrain_code_siege),#siege constant defined in header_terrain_types.py
			(try_end),
			
            (call_script, "script_dplmc_party_calculate_strength_in_terrain", ":cur_party", ":terrain_code", 0, 1), #will update "slot_party_cached_strength"
         (try_end),
		 
		 #Then update player
		 (party_get_current_terrain, ":terrain_code", "p_main_party"),
		 
		 (party_get_attached_to, ":attachment", "p_main_party"),			
			(try_begin),
				(ge, ":attachment", 0),
				(is_between, ":attachment", centers_begin, centers_end),
				(assign, ":terrain_code", dplmc_terrain_code_siege),#siege constant defined in header_terrain_types.py
			(try_end),
		 
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_main_party", ":terrain_code", 0, 1), #will update "slot_party_cached_strength"
		 
         (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
		    #Update with walled center alterations
            (call_script, "script_dplmc_party_calculate_strength_in_terrain", ":cur_center", -2, 0, 1),
         (try_end),
      (else_try),
	   #The old behavior, unchanged:
         (try_for_range, ":cur_troop", heroes_begin, heroes_end),
        (troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
        (troop_get_slot, ":cur_party", ":cur_troop", "slot_troop_leaded_party"),
        (party_is_active, ":cur_party"),
        (call_script, "script_party_calculate_strength", ":cur_party", 0), #will update "slot_party_cached_strength"
      (try_end),
      (call_script, "script_party_calculate_strength", "p_main_party", 0), #will update "slot_party_cached_strength"
      (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
        (call_script, "script_party_calculate_strength", ":cur_center", 0), #will update "slot_party_cached_strength"
      (try_end),
      (try_end),
      ##diplomacy end+

      # (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
      (try_for_range, ":cur_center", centers_begin, centers_end),	#MOTO chief include villages
        (call_script, "script_party_calculate_and_set_nearby_friend_enemy_follower_strengths", ":cur_center"),
      (try_end),

      (try_for_range, ":cur_troop", heroes_begin, heroes_end),
        (troop_get_slot, ":cur_troop_party", ":cur_troop", "slot_troop_leaded_party"),
        (gt, ":cur_troop_party", 0),
        (party_is_active, ":cur_troop_party"),
        (call_script, "script_party_calculate_and_set_nearby_friend_enemy_follower_strengths", ":cur_troop_party"),
      (try_end),
      (call_script, "script_party_calculate_and_set_nearby_friend_enemy_follower_strengths", "p_main_party"),
      ]),


  # script_recalculate_ais
  # Input: none
  # Output: none
  
  #When a lord changes factions
  #When a center changes factions
  #When a center is captured
  #When a marshal is defeated
  #Every 23 hours
    ("recalculate_ais",
    [
      (call_script, "script_init_ai_calculation"),
            
      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
      (assign, reg8, ":faction_no"),
        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
        #(neg|faction_slot_eq, ":faction_no",  "slot_faction_marshall", "trp_player"),
        (call_script, "script_decide_faction_ai", ":faction_no"),
      (try_end),
      
      (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
        (store_troop_faction, ":faction_no", ":troop_no"),        
        (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
        (call_script, "script_calculate_troop_ai", ":troop_no"),
      (try_end),	  
    ]),

  # script_calculate_troop_ai
  # Input: troop_no
  # Output: none
  #Now called directly from scripts
  ("calculate_troop_ai",
    [
      (store_script_param, ":troop_no", 1),

      (try_begin),
        (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
        (neg|troop_slot_ge, ":troop_no", "slot_troop_prisoner_of_party", 0),
        (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
        (gt, ":party_no", 0),
		(party_is_active, ":party_no"),

		(call_script, "script_npc_decision_checklist_party_ai", ":troop_no"), #This handles AI for both marshal and other parties		
		(call_script, "script_party_set_ai_state", ":party_no", reg0, reg1),
      (try_end),			
    ]),

  ("event_kingdom_make_peace_with_kingdom",
    [
      (store_script_param_1, ":source_kingdom"),
      (store_script_param_2, ":target_kingdom"),
      (try_begin),
        (check_quest_active, "qst_capture_prisoners"),
        (try_begin),
          (eq, "$players_kingdom", ":source_kingdom"),
          (quest_slot_eq, "qst_capture_prisoners", "slot_quest_target_faction", ":target_kingdom"),
          (call_script, "script_cancel_quest", "qst_capture_prisoners"),
        (else_try),
          (eq, "$players_kingdom", ":target_kingdom"),
          (quest_slot_eq, "qst_capture_prisoners", "slot_quest_target_faction", ":source_kingdom"),
          (call_script, "script_cancel_quest", "qst_capture_prisoners"),
        (try_end),
      (try_end),
	  
      (try_begin),
        (check_quest_active, "qst_capture_enemy_hero"),
        (try_begin),
          (eq, "$players_kingdom", ":source_kingdom"),
          (quest_slot_eq, "qst_capture_enemy_hero", "slot_quest_target_faction", ":target_kingdom"),
          (call_script, "script_cancel_quest", "qst_capture_enemy_hero"),
        (else_try),
          (eq, "$players_kingdom", ":target_kingdom"),
          (quest_slot_eq, "qst_capture_enemy_hero", "slot_quest_target_faction", ":source_kingdom"),
          (call_script, "script_cancel_quest", "qst_capture_enemy_hero"),
        (try_end),
      (try_end),
	  
	  
	  
      (try_begin),
        (check_quest_active, "qst_persuade_lords_to_make_peace"),
	    (quest_get_slot, ":lord_1", "qst_persuade_lords_to_make_peace", "slot_quest_target_troop"),
	    (quest_get_slot, ":lord_2", "qst_persuade_lords_to_make_peace", "slot_quest_object_troop"),
		
		(try_begin),
			(lt, ":lord_1", 0),
			(val_mul, ":lord_1", -1),
		(try_end),
		(try_begin),
			(lt, ":lord_2", 0),
			(val_mul, ":lord_2", -1),
		(try_end),
		
		
	    (store_faction_of_troop, ":lord_1_faction", ":lord_1"),
	    (store_faction_of_troop, ":lord_2_faction", ":lord_2"),	  
	  
	    (this_or_next|eq, ":lord_1_faction", ":source_kingdom"),
			(eq, ":lord_2_faction", ":source_kingdom"),

	    (this_or_next|eq, ":lord_1_faction", ":target_kingdom"),
			(eq, ":lord_2_faction", ":target_kingdom"),

        (call_script, "script_cancel_quest", "qst_persuade_lords_to_make_peace"),
			
	  (try_end),
	  
	  #Rescue prisoners cancelled in simple_triggers
	  
	  (try_begin),
		(this_or_next|faction_slot_eq, ":target_kingdom", "slot_faction_leader", "trp_player"),
		(faction_slot_eq, ":source_kingdom", "slot_faction_leader", "trp_player"),
	  
	    (call_script, "script_change_player_right_to_rule", 5),#gdw additional 3 in dialogs for now pay
	  (try_end),
	  
  ]),


    # script_count_wars_and_pacts by Motomataru chief
  # Input: acting faction, faction considered
  # Output: reg0 = 0 + 2 x common wars - 2 x other wars + 1 x common pacts - 1 x other pacts
  #         reg1 = number agreements that would contradict a defensive pact or alliance

  ("count_wars_and_pacts", [
	(store_script_param_1, ":cur_kingdom"),
	(store_script_param_2, ":cur_kingdom_2"),
	
	(assign, reg0, 0),
	(assign, reg1, 0),
	(try_for_range, ":third_kingdom", kingdoms_begin, kingdoms_end),
		(neq, ":third_kingdom", ":cur_kingdom"),
		(neq, ":third_kingdom", ":cur_kingdom_2"),
		(faction_slot_eq, ":third_kingdom", "slot_faction_state", sfs_active),

		(store_relation, ":cur_relation", ":cur_kingdom", ":third_kingdom"),
		(store_relation, ":cur_relation_2", ":cur_kingdom_2", ":third_kingdom"),
		(try_begin),
			(lt, ":cur_relation", 0),
			
			(try_begin),
				(lt, ":cur_relation_2", 0),	#common war?
				(val_add, reg0, 1),
			(else_try),
				(val_sub, reg0, 2),
			(try_end),
		(try_end),

		(try_begin),
			(lt, ":cur_relation_2", 0),
			
			(try_begin),
				(lt, ":cur_relation", 0),	#common war?
				(val_add, reg0, 1),
			(else_try),
				(val_sub, reg0, 2),
			(try_end),
		(try_end),

		(store_add, ":truce_slot", ":third_kingdom", "slot_faction_truce_days_with_factions_begin"),
		(val_sub, ":truce_slot", kingdoms_begin),
		(faction_get_slot, ":truce_days", ":cur_kingdom", ":truce_slot"),
		(faction_get_slot, ":truce_days_2", ":cur_kingdom_2", ":truce_slot"),
		(try_begin),
			(gt, ":truce_days", dplmc_treaty_defense_days_expire),
			
			(try_begin),
				(gt, ":truce_days_2", dplmc_treaty_defense_days_expire),	#common pact?
				(val_add, reg0, 1),
			(else_try),
				(val_sub, reg0, 1),
			(try_end),
		(try_end),

		(try_begin),
			(gt, ":truce_days_2", dplmc_treaty_defense_days_expire),
			
			(try_begin),
				(gt, ":truce_days", dplmc_treaty_defense_days_expire),	#common pact?
				# (val_add, reg0, 1),	#already done in last section
			(else_try),
				(val_sub, reg0, 1),
			(try_end),
		(try_end),

		(try_begin),
			(gt, ":truce_days", 0),
			(lt, ":cur_relation_2", 0),
			(val_add, reg1, 1),
		(try_end),

		(try_begin),
			(gt, ":truce_days_2", 0),
			(lt, ":cur_relation", 0),
			(val_add, reg1, 1),
		(try_end),
	(try_end),
  ]),


 # script_find_neighbors by Motomataru
 # Input: none
 # Output: none

 ("find_neighbors", [
	(store_sub, reg0, kingdoms_end, kingdoms_begin),
	(try_for_range, ":faction_1", kingdoms_begin, kingdoms_end),
		(try_for_range, ":faction_2", 0, reg0),
			(store_add, ":slot", "slot_faction_neighbors_begin", ":faction_2"),
			(faction_set_slot, ":faction_1", ":slot", 0),
		(try_end),
	(try_end),
	(try_for_range, ":center_1", centers_begin, centers_end),
		(store_faction_of_party, ":faction_1", ":center_1"),
		(store_add, ":already_done", ":center_1", 1),
		(try_for_range, ":center_2", ":already_done", centers_end),
			(store_faction_of_party, ":faction_2", ":center_2"),
			(store_add, ":slot", "slot_faction_neighbors_begin", ":faction_2"),
			(val_sub, ":slot", kingdoms_begin),
			(faction_slot_eq, ":faction_1", ":slot", 0),
			(store_distance_to_party_from_party, ":distance", ":center_2", ":center_1"),
			(lt, ":distance", 25),
			(faction_set_slot, ":faction_1", ":slot", 1),
			
			#set for OTHER neighbor
			(store_add, ":slot", "slot_faction_neighbors_begin", ":faction_1"),
			(val_sub, ":slot", kingdoms_begin),
			(faction_set_slot, ":faction_2", ":slot", 1),
		(try_end),
	(try_end),
	]),


 # script_randomly_start_war_peace
 # Input: arg1 = initializing_war_peace_cond (1 = true, 0 = false)
 # Output: none

 #Aims to introduce a slightly simpler system in which the AI kings' reasoning could be made more  transparent to the player. At the start of the game, this may lead to less variation in outcomes, though
	 
  # script_randomly_start_war_peace
  # Input: arg1 = initializing_war_peace_cond (1 = true, 0 = false)
  # Output: none
#  ("randomly_start_war_peace",
#    [
#      (store_script_param_1, ":initializing_war_peace_cond"),
#      (assign, ":total_resources", 0),
#      (assign, ":total_active_kingdoms", 0),
#      (try_for_range, ":cur_kingdom", kingdoms_begin, kingdoms_end),
#        (faction_slot_eq, ":cur_kingdom", "slot_faction_state", sfs_active),
#        (val_add, ":total_active_kingdoms", 1),
#        (faction_get_slot, ":num_towns", ":cur_kingdom", "slot_faction_num_towns"),
#        (store_mul, ":kingdom_resources_value", ":num_towns", 2),
#        (faction_get_slot, ":num_castles", ":cur_kingdom", "slot_faction_num_castles"),
#        (val_add, ":kingdom_resources_value", ":num_castles"),
#        (val_mul, ":kingdom_resources_value", 10),
#        (val_max, ":kingdom_resources_value", 1),
#        (val_mul, ":kingdom_resources_value", 1000),
#        (faction_get_slot, ":num_armies", ":cur_kingdom", "slot_faction_num_armies"),
#        (val_max, ":num_armies", 1),
#        (val_div, ":kingdom_resources_value", ":num_armies"),
#        (val_add, ":total_resources", ":kingdom_resources_value"),
#      (try_end),
#      (val_max, ":total_active_kingdoms", 1),
#      (store_div, ":average_resources", ":total_resources", ":total_active_kingdoms"),

#      (try_for_range, ":cur_kingdom", kingdoms_begin, kingdoms_end),
 ##       (neq, ":cur_kingdom", "fac_player_supporters_faction"),
#        (faction_slot_eq, ":cur_kingdom", "slot_faction_state", sfs_active),
#        (assign, ":num_ongoing_wars", 0),
#        (try_for_range, ":other_kingdom", kingdoms_begin, kingdoms_end),
#          (faction_slot_eq, ":other_kingdom", "slot_faction_state", sfs_active),
#          (store_relation, ":other_relation", ":cur_kingdom", ":other_kingdom"),
#          (lt, ":other_relation", 0),
#          (val_add, ":num_ongoing_wars", 1),
#        (try_end),

#        (faction_get_slot, ":num_towns", ":cur_kingdom", "slot_faction_num_towns"),
#        (store_mul, ":kingdom_1_resources_value", ":num_towns", 2),
#        (faction_get_slot, ":num_castles", ":cur_kingdom", "slot_faction_num_castles"),
#        (val_add, ":kingdom_1_resources_value", ":num_castles"),
#        (val_mul, ":kingdom_1_resources_value", 10),
#        (val_max, ":kingdom_1_resources_value", 1),
#        (val_mul, ":kingdom_1_resources_value", 1000),
#        (faction_get_slot, ":num_armies", ":cur_kingdom", "slot_faction_num_armies"),
#        (val_max, ":num_armies", 1),
#        (val_div, ":kingdom_1_resources_value", ":num_armies"),

#        (store_add, ":start_cond", ":cur_kingdom", 1),
#        (try_for_range, ":cur_kingdom_2", ":start_cond", kingdoms_end),
 ##         (neq, ":cur_kingdom", "fac_player_supporters_faction"),
#          (faction_slot_eq, ":cur_kingdom_2", "slot_faction_state", sfs_active),

#          (assign, ":num_ongoing_wars_2", 0),
#          (try_for_range, ":other_kingdom", kingdoms_begin, kingdoms_end),
#            (faction_slot_eq, ":other_kingdom", "slot_faction_state", sfs_active),
#            (store_relation, ":other_relation", ":cur_kingdom_2", ":other_kingdom"),
#            (lt, ":other_relation", 0),
#            (val_add, ":num_ongoing_wars_2", 1),
#          (try_end),

#          (store_add, ":total_ongoing_wars", ":num_ongoing_wars", ":num_ongoing_wars_2"),

#          (faction_get_slot, ":num_towns", ":cur_kingdom_2", "slot_faction_num_towns"),
#          (store_mul, ":kingdom_2_resources_value", ":num_towns", 2),
#          (faction_get_slot, ":num_castles", ":cur_kingdom_2", "slot_faction_num_castles"),
#          (val_add, ":kingdom_2_resources_value", ":num_castles"),
#          (val_mul, ":kingdom_2_resources_value", 10),
#          (val_max, ":kingdom_2_resources_value", 1),
#          (val_mul, ":kingdom_2_resources_value", 1000),
#          (faction_get_slot, ":num_armies", ":cur_kingdom_2", "slot_faction_num_armies"),
#          (val_max, ":num_armies", 1),
#          (val_div, ":kingdom_2_resources_value", ":num_armies"),

#          (assign, ":max_resources_value", ":kingdom_1_resources_value"),
#          (val_max, ":max_resources_value", ":kingdom_2_resources_value"),
#          (val_mul, ":max_resources_value", 100),
#          (val_div, ":max_resources_value", ":average_resources"),

#          (assign, ":cur_king", -1),
#          (try_begin),
#            (eq, ":cur_kingdom", "fac_player_supporters_faction"),
#            (faction_get_slot, ":cur_king", ":cur_kingdom_2", "slot_faction_leader"),
#            (assign, ":cur_relation", reg0),
#            (store_sub, ":relation_effect", 200, ":cur_relation"),
#            (val_mul, ":kingdom_1_resources_value", ":relation_effect"),
#            (val_div, ":kingdom_1_resources_value", 200),
#          (else_try),
#            (eq, ":cur_kingdom_2", "fac_player_supporters_faction"),
#            (faction_get_slot, ":cur_king", ":cur_kingdom", "slot_faction_leader"),
#          (try_end),

#          (try_begin),
#            (ge, ":cur_king", 0),
#            (call_script, "script_troop_get_player_relation", ":cur_king"),
#            (assign, ":cur_relation", reg0),
#            (store_sub, ":relation_effect", 200, ":cur_relation"),
#            (val_mul, ":max_resources_value", ":relation_effect"),
#            (val_div, ":max_resources_value", 200),
#          (try_end),

          #max_resources_value is the obtained value that gives us how tempting the kingdom's values are
          #average is 100
 #         (val_clamp, ":max_resources_value", 20, 500),
          #not letting more than 5 times higher chance of declaring war or peace

  #        (store_random_in_range, ":random_no", 0, 10000),
 #         (store_relation, ":cur_relation", ":cur_kingdom", ":cur_kingdom_2"),
 #         (try_begin),
 #           (lt, ":cur_relation", 0), #AT WAR
 #           (store_mul, ":chance_to_make_peace", ":total_ongoing_wars", 50),
 #           (val_mul, ":chance_to_make_peace", 100),
 #           (val_div, ":chance_to_make_peace", ":max_resources_value"),
 #           (try_begin),
              #disable random peace for special conditions
 #             (this_or_next|eq, ":cur_kingdom", "fac_player_supporters_faction"),
 #             (eq, ":cur_kingdom_2", "fac_player_supporters_faction"),
 #             (assign, ":continue", 0),
          #    (try_begin),
           #     (gt, "$supported_pretender", 0),
            #    (this_or_next|eq, ":cur_kingdom", "$supported_pretender_old_faction"),
           #     (eq, ":cur_kingdom_2", "$supported_pretender_old_faction"),
          #      (assign, ":continue", 1),
         #     (else_try),
       #         (is_between, "$players_oath_renounced_against_kingdom", kingdoms_begin, kingdoms_end),
      #          (this_or_next|eq, ":cur_kingdom", "$players_oath_renounced_against_kingdom"),
     #           (eq, ":cur_kingdom_2", "$players_oath_renounced_against_kingdom"),
    #            (assign, ":continue", 1),
   #           (try_end),
         #     (eq, ":continue", 1),
        #      (assign, ":chance_to_make_peace", 0),
       #     (try_end),
      #      (try_begin),
     #         (lt, ":random_no", ":chance_to_make_peace"),
    #          (assign, ":continue", 1),
   #           (try_begin),
  #              (check_quest_active, "qst_persuade_lords_to_make_peace"),
              #  (quest_get_slot, ":quest_target_faction", "qst_persuade_lords_to_make_peace", "slot_quest_target_faction"),
             #   (quest_get_slot, ":quest_object_faction", "qst_persuade_lords_to_make_peace", "slot_quest_object_faction"),
            #    (this_or_next|eq, ":cur_kingdom", ":quest_target_faction"),
           #     (eq, ":cur_kingdom", ":quest_object_faction"),
          #      (this_or_next|eq, ":cur_kingdom_2", ":quest_target_faction"),
         #       (eq, ":cur_kingdom_2", ":quest_object_faction"),
        #        (assign, ":continue", 0), #Do not declare war if the quest is active for the specific kingdoms
       #       (try_end),
      #        (eq, ":continue", 1),
     #         (try_begin),
    #            (eq, ":cur_kingdom", "fac_player_supporters_faction"),
   #             (call_script, "script_add_notification_menu", "mnu_question_peace_offer", ":cur_kingdom_2", 0),
  #            (else_try),
            #    (eq, ":cur_kingdom_2", "fac_player_supporters_faction"),
           #     (call_script, "script_add_notification_menu", "mnu_question_peace_offer", ":cur_kingdom", 0),
          #    (else_try),
         #       (call_script, "script_diplomacy_start_peace_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
        #      (try_end),
       #     (try_end),
      #    (else_try), # AT PEACE
     #       (assign, ":chance_to_declare_war", 6),
    #        (val_sub, ":chance_to_declare_war", ":total_ongoing_wars"),
   #         (val_mul, ":chance_to_declare_war", 50),
          #  (val_mul, ":chance_to_declare_war", ":max_resources_value"),
         #   (val_div, ":chance_to_declare_war", 100),
        #    (try_begin),
       #       (lt, ":random_no", ":chance_to_declare_war"),
      #        (assign, ":continue", 1),
     #         (try_begin),
    #            (check_quest_active, "qst_raid_caravan_to_start_war"),
               # (quest_get_slot, ":quest_target_faction", "qst_raid_caravan_to_start_war", "slot_quest_target_faction"),
              #  (quest_get_slot, ":quest_object_faction", "qst_raid_caravan_to_start_war", "slot_quest_object_faction"),
             #   (this_or_next|eq, ":cur_kingdom", ":quest_target_faction"),
            #    (eq, ":cur_kingdom", ":quest_object_faction"),
           #     (this_or_next|eq, ":cur_kingdom_2", ":quest_target_faction"),
          #      (eq, ":cur_kingdom_2", ":quest_object_faction"),
         #       (assign, ":continue", 0), #Do not declare war if the quest is active for the specific kingdoms
        #      (try_end),
       #       (eq, ":continue", 1),
      #        (call_script, "script_diplomacy_start_war_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
     #       (try_end),
    #      (try_end),
   #     (try_end),
  #    (try_end),
 #    ]),

	 
	 
# script_exchange_prisoners_between_factions
# Input: arg1 = faction_no_1, arg2 = faction_no_2
  ("exchange_prisoners_between_factions",
   [
       (store_script_param_1, ":faction_no_1"),
       (store_script_param_2, ":faction_no_2"),
       (assign, ":faction_no_3", -1),
       (assign, ":faction_no_4", -1),
       (assign, ":free_companions_too", 0),
       (try_begin),
         (this_or_next|eq, "$players_kingdom", ":faction_no_1"),
         (eq, "$players_kingdom", ":faction_no_2"),
         (assign, ":faction_no_3", "fac_player_faction"),
         (assign, ":faction_no_4", "fac_player_supporters_faction"),
         (assign, ":free_companions_too", 1),
       (try_end),
	   
       (try_for_parties, ":party_no"),
         (store_faction_of_party, ":party_faction", ":party_no"),
         (this_or_next|eq, ":party_faction", ":faction_no_1"),
         (this_or_next|eq, ":party_faction", ":faction_no_2"),
         (this_or_next|eq, ":party_faction", ":faction_no_3"),
         (eq, ":party_faction", ":faction_no_4"),
         (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
         (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
           (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":party_no", ":troop_iterator"),                                                                             
           
           (assign, ":continue", 0),
           (try_begin),
             (is_between, ":cur_troop_id", companions_begin, companions_end),
             (eq, ":free_companions_too", 1),
             (assign, ":continue", 1),
           (else_try),                        
             (neg|is_between, ":cur_troop_id", companions_begin, companions_end),             
             (store_troop_faction, ":cur_faction", ":cur_troop_id"),
             (this_or_next|eq, ":cur_faction", ":faction_no_1"),
             (this_or_next|eq, ":cur_faction", ":faction_no_2"),
             (this_or_next|eq, ":cur_faction", ":faction_no_3"),
             (eq, ":cur_faction", ":faction_no_4"),
             (assign, ":continue", 1),
           (try_end),                        
           (eq, ":continue", 1),
           
           (try_begin),
             (troop_is_hero, ":cur_troop_id"),
             (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
           (try_end),
           (party_prisoner_stack_get_size, ":stack_size", ":party_no", ":troop_iterator"),
           (party_remove_prisoners, ":party_no", ":cur_troop_id", ":stack_size"),
         (try_end),
       (try_end),
	   
    ]),

  # script_add_notification_menu
  # Input: arg1 = menu_no, arg2 = menu_var_1, arg3 = menu_var_2
  # Output: none
  ("add_notification_menu",
    [
      (try_begin),        
        (eq, "$g_infinite_camping", 0),
        (store_script_param, ":menu_no", 1),
        (store_script_param, ":menu_var_1", 2),
        (store_script_param, ":menu_var_2", 3),
        (assign, ":end_cond", 1),      
        (try_for_range, ":cur_slot", 0, ":end_cond"),
          (try_begin),
            (troop_slot_ge, "trp_notification_menu_types", ":cur_slot", 1),
            (val_add, ":end_cond", 1),
          (else_try),
            (troop_set_slot, "trp_notification_menu_types", ":cur_slot", ":menu_no"),
            (troop_set_slot, "trp_notification_menu_var1", ":cur_slot", ":menu_var_1"),
            (troop_set_slot, "trp_notification_menu_var2", ":cur_slot", ":menu_var_2"),
          (try_end),
        (try_end),
      (try_end),
      ]),
  
  # script_finish_quest
  # Input: arg1 = quest_no, arg2 = finish_percentage
  # Output: none
  ("finish_quest",
    [
      (store_script_param_1, ":quest_no"),
      (store_script_param_2, ":finish_percentage"),
      
      (quest_get_slot, ":quest_giver", ":quest_no", "slot_quest_giver_troop"),
      (quest_get_slot, ":quest_importance", ":quest_no", "slot_quest_importance"),
      (quest_get_slot, ":quest_xp_reward", ":quest_no", "slot_quest_xp_reward"),
      (quest_get_slot, ":quest_gold_reward", ":quest_no", "slot_quest_gold_reward"),
      
      (try_begin),
        (lt, ":finish_percentage", 100),
        (val_mul, ":quest_xp_reward", ":finish_percentage"),
        (val_div, ":quest_xp_reward", 100),
        (val_mul, ":quest_gold_reward", ":finish_percentage"),
        (val_div, ":quest_gold_reward", 100),
        #Changing the relation factor. Negative relation if less than 75% of the quest is finished.
        #Positive relation if more than 75% of the quest is finished.
        (assign, ":importance_multiplier", ":finish_percentage"),
        (val_sub, ":importance_multiplier", 75),
        (val_mul, ":quest_importance", ":importance_multiplier"),
        (val_div, ":quest_importance", 100),
      (else_try),
        (ge, ":finish_percentage", 100), # TML Added to allow quests to give bonus rewards. F123 - Submod -> 1.41
        (val_mul, ":quest_xp_reward", ":finish_percentage"),
        (val_div, ":quest_xp_reward", 80),#gdw100
        (val_mul, ":quest_gold_reward", ":finish_percentage"),
        (val_div, ":quest_gold_reward", 90), #gdw100
        (val_mul, ":quest_importance", ":finish_percentage"),
        (val_div, ":quest_importance", 100), # TML changes end.
        
        
        (val_mul, ":quest_importance", 4), #was div 4. Relation was increasing very less. I changed it to mul 4.
        (val_add, ":quest_importance", 1),
        (call_script, "script_change_player_relation_with_troop", ":quest_giver", ":quest_importance"),
      (try_end),
      
      (add_xp_as_reward, ":quest_xp_reward"),
      (call_script, "script_troop_add_gold", "trp_player", ":quest_gold_reward"),
      (call_script, "script_end_quest", ":quest_no"),
  ]),
  
  
  # script_get_information_about_troops_position
  # Input: arg1 = troop_no, arg2 = time (0 if present tense, 1 if past tense)
  # Output: s1 = String, reg0 = knows-or-not
  ("get_information_about_troops_position",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, reg3),
## Gender fix chief altura
      (troop_get_type, reg4, ":troop_no"),
## Gender fix
(val_mod, reg4, 2),
####gender fix chief
      (str_store_troop_name, s2, ":troop_no"),
      
      (assign, ":found", 0),
      (troop_get_slot, ":center_no", ":troop_no", "slot_troop_cur_center"),
      (try_begin),
        (gt, ":center_no", 0),
        (is_between, ":center_no", centers_begin, centers_end),
        (str_store_party_name_link, s3, ":center_no"),
        (str_store_string, s1, "@{s2} {reg3?was:is currently} at {s3}."),
        (assign, ":found", 1),
      (else_try),
        (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
        (gt, ":party_no", 0),
        (call_script, "script_get_troop_attached_party", ":troop_no"),
        (assign, ":center_no", reg0),
        (try_begin),
          (is_between, ":center_no", centers_begin, centers_end),
          (str_store_party_name_link, s3, ":center_no"),
          (str_store_string, s1, "@{s2} {reg3?was:is currently} at {s3}."),
          (assign, ":found", 1),
        (else_try),
          (get_party_ai_behavior, ":ai_behavior", ":party_no"),
          (eq, ":ai_behavior", ai_bhvr_travel_to_party),
          (get_party_ai_object, ":ai_object", ":party_no"),
          (is_between, ":ai_object", centers_begin, centers_end),
          (call_script, "script_get_closest_center", ":party_no"),
          (str_store_party_name_link, s4, reg0),
          (str_store_party_name_link, s3, ":ai_object"),
          (str_store_string, s1, "@{s2} {reg3?was:is} travelling to {s3} and {reg4?she:he} {reg3?was:should be} close to {s4}{reg3?: at the moment}."),
          (assign, ":found", 1),
        (else_try),
          (call_script, "script_get_closest_center", ":party_no"),
          (str_store_party_name_link, s3, reg0),
          (str_store_string, s1, "@{s2} {reg3?was:is} in the field and {reg4?she:he} {reg3?was:should be} close to {s3}{reg3?: at the moment}."),
          (assign, ":found", 1),
        (try_end),
      (else_try),
        #(troop_slot_ge, ":troop_no", "slot_troop_is_prisoner", 1),
        (troop_slot_ge, ":troop_no", "slot_troop_prisoner_of_party", 0),
        (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
          (party_count_prisoners_of_type, ":num_prisoners", ":center_no", ":troop_no"),
          (gt, ":num_prisoners", 0),
          (assign, ":found", 1),
          (str_store_party_name_link, s3, ":center_no"),
          (str_store_string, s1, "@{s2} {reg3?was:is} being held captive at {s3}."),
        (try_end),
        (try_begin),
          (eq, ":found", 0),
          (str_store_string, s1, "@{s2} {reg3?was:has been} taken captive by {reg4?her:his} enemies."),
          (assign, ":found", 1),
        (try_end),
      (try_end),
      (try_begin),
        (eq, ":found", 0),
        (str_store_string, s1, "@{reg3?{s2}'s location was unknown:I don't know where {s2} is}."),
      (try_end),
      (assign, reg0, ":found"),
  ]),

#TEMPERED chief CHANGED SCRIPT FOR CAMP ENTRENCHMENT
  # script_setup_random_scene
  # Input: arg1 = center_no, arg2 = mission_template_no
  # Output: none
  ("setup_random_scene",
    [
      (party_get_current_terrain, ":terrain_type", "p_main_party"),
	  (party_get_slot,":entrench","p_main_party","slot_party_entrenched"),
	  (assign, ":scene_to_use", "scn_random_scene"),
	  (try_begin),
		(eq,"$duel_encounter",1),
		(set_jump_mission,"mt_wilderness_duel"),
			(try_begin),
				(eq, ":terrain_type", rt_steppe),
				(assign, ":scene_to_use", "scn_duel_steppe"),
			(else_try),
				(eq, ":terrain_type", rt_plain),
				(assign, ":scene_to_use", "scn_duel_plain"),
			(else_try),
				(eq, ":terrain_type", rt_snow),
				(assign, ":scene_to_use", "scn_duel_snow"),
			(else_try),
				(eq, ":terrain_type", rt_desert),
				(assign, ":scene_to_use", "scn_duel_desert"),
			(else_try),
				(eq, ":terrain_type", rt_steppe_forest),
				(assign, ":scene_to_use", "scn_duel_steppe_forest"),
			(else_try),
				(eq, ":terrain_type", rt_forest),
				(assign, ":scene_to_use", "scn_duel_plain_forest"),
			(else_try),
				(eq, ":terrain_type", rt_snow_forest),
				(assign, ":scene_to_use", "scn_duel_snow_forest"),
			(else_try),
				(eq, ":terrain_type", rt_desert_forest),
				(assign, ":scene_to_use", "scn_duel_desert_forest"),
			(try_end),
	  (else_try),
			(this_or_next|eq,":entrench",1),#entrenched camp
			(party_slot_eq,"p_main_party","slot_party_siege_camp",1),#entrenched siege camp
			(set_jump_mission,"mt_entrenched_encounter"),
			(assign,"$camp_supply",1), #Tempered  reset camp supplies before a battle
			(try_begin),
				(eq, ":terrain_type", rt_steppe),
				(assign, ":scene_to_use", "scn_entrenched_steppe"),
			(else_try),
				(eq, ":terrain_type", rt_plain),
				(assign, ":scene_to_use", "scn_entrenched_plain"),
			(else_try),
				(eq, ":terrain_type", rt_snow),
				(assign, ":scene_to_use", "scn_entrenched_snow"),
			(else_try),
				(eq, ":terrain_type", rt_desert),
				(assign, ":scene_to_use", "scn_entrenched_desert"),
			(else_try),
				(eq, ":terrain_type", rt_steppe_forest),
				(assign, ":scene_to_use", "scn_entrenched_steppe_forest"),
			(else_try),
				(eq, ":terrain_type", rt_forest),
				(assign, ":scene_to_use", "scn_entrenched_plain_forest"),
			(else_try),
				(eq, ":terrain_type", rt_snow_forest),
				(assign, ":scene_to_use", "scn_entrenched_snow_forest"),
			(else_try),
				(eq, ":terrain_type", rt_desert_forest),
				(assign, ":scene_to_use", "scn_entrenched_desert_forest"),
			(try_end),			
		(else_try),
			(eq,"$g_camp_mode", 1),#camping
			(neq,":entrench",1),#not entrenched
			(set_jump_mission,"mt_entrenched_encounter"),
			(assign,"$camp_supply",1), #Tempered  reset camp supplies before a battle
			(try_begin),
				(eq, ":terrain_type", rt_steppe),
				(assign, ":scene_to_use", "scn_not_entrenched_steppe"),
			(else_try),
				(eq, ":terrain_type", rt_plain),
				(assign, ":scene_to_use", "scn_not_entrenched_plain"),
			(else_try),
				(eq, ":terrain_type", rt_snow),
				(assign, ":scene_to_use", "scn_not_entrenched_snow"),
			(else_try),
				(eq, ":terrain_type", rt_desert),
				(assign, ":scene_to_use", "scn_not_entrenched_desert"),
			(else_try),
				(eq, ":terrain_type", rt_steppe_forest),
				(assign, ":scene_to_use", "scn_not_entrenched_steppe_forest"),
			(else_try),
				(eq, ":terrain_type", rt_forest),
				(assign, ":scene_to_use", "scn_not_entrenched_plain_forest"),
			(else_try),
				(eq, ":terrain_type", rt_snow_forest),
				(assign, ":scene_to_use", "scn_not_entrenched_snow_forest"),
			(else_try),
				(eq, ":terrain_type", rt_desert_forest),
				(assign, ":scene_to_use", "scn_not_entrenched_desert_forest"),
			(try_end),
		(else_try),
		(eq,":entrench",0),
		(lt,"$duel_encounter",1),
		(eq,"$g_camp_mode", 0),
      (try_begin),
        (eq, ":terrain_type", rt_steppe),
        (assign, ":scene_to_use", "scn_random_scene_steppe"),
      (else_try),
        (eq, ":terrain_type", rt_plain),
        (assign, ":scene_to_use", "scn_random_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_snow),
        (assign, ":scene_to_use", "scn_random_scene_snow"),
      (else_try),
        (eq, ":terrain_type", rt_desert),
        (assign, ":scene_to_use", "scn_random_scene_desert"),
      (else_try),
        (eq, ":terrain_type", rt_steppe_forest),
        (assign, ":scene_to_use", "scn_random_scene_steppe_forest"),
      (else_try),
        (eq, ":terrain_type", rt_forest),
        (assign, ":scene_to_use", "scn_random_scene_plain_forest"),
      (else_try),
        (eq, ":terrain_type", rt_snow_forest),
        (assign, ":scene_to_use", "scn_random_scene_snow_forest"),
      (else_try),
        (eq, ":terrain_type", rt_desert_forest),
        (assign, ":scene_to_use", "scn_random_scene_desert_forest"),
      (else_try),
        (eq, ":terrain_type", rt_water),
        (assign, ":scene_to_use", "scn_water"),
      (else_try),
        (eq, ":terrain_type", rt_bridge),
        (assign, ":scene_to_use", "scn_random_scene_plain"),
      (try_end),
		(try_end),
	  (modify_visitors_at_site,":scene_to_use"),
	  (reset_visitors),
      (jump_to_scene,":scene_to_use"),
	  (try_begin),
		(eq,"$duel_encounter",1),
		(call_script,"script_wilderness_duel_init",":scene_to_use"),
	  (try_end),
  ]),
#TEMPERED chief CHANGES END

  # script_enter_dungeon
  # Input: arg1 = center_no, arg2 = mission_template_no
  # Output: none
  ("enter_dungeon",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":mission_template_no"),
      
      (set_jump_mission,":mission_template_no"),
      #new added...
      (mission_tpl_entry_set_override_flags, ":mission_template_no", 0, af_override_horse),
      (try_begin),
        (eq, "$sneaked_into_town", 1),
        (mission_tpl_entry_set_override_flags, ":mission_template_no", 0, af_override_all),                
        
        (mission_tpl_entry_clear_override_items, ":mission_template_no", 0),
        (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_pilgrim_hood"),
        (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_pilgrim_disguise"),
        (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_practice_staff"),
        (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_throwing_daggers"),
      (try_end),   
      #new added end              

      (party_get_slot, ":dungeon_scene", ":center_no", "slot_town_prison"),
      
      (modify_visitors_at_site,":dungeon_scene"),
      (reset_visitors),
      (assign, ":cur_pos", 16),
	  
	  
      (call_script, "script_get_heroes_attached_to_center_as_prisoner", ":center_no", "p_temp_party"),
      (party_get_num_companion_stacks, ":num_stacks","p_temp_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop","p_temp_party",":i_stack"),

		(assign, ":prisoner_offered_parole", 0),
		(try_begin),
			(party_slot_eq, ":center_no", "slot_town_lord", "trp_player"),
		(else_try),
			(call_script, "script_cf_prisoner_offered_parole", ":stack_troop"),
			(assign, ":prisoner_offered_parole", 1),
		(else_try),
			(assign, ":prisoner_offered_parole", 0),
		(try_end),
		(eq, ":prisoner_offered_parole", 0),
		
        (lt, ":cur_pos", 32), # spawn up to entry point 32
        (set_visitor, ":cur_pos", ":stack_troop"),
        (val_add,":cur_pos", 1),
      (try_end),
      	 
#	  (set_visitor, ":cur_pos", "trp_npclady1"),
#	  (troop_set_slot, "trp_npclady1", "slot_troop_prisoner_of_party", "$g_encountered_party"),
	  
      (set_jump_entry, 0),
      (jump_to_scene,":dungeon_scene"),
      (scene_set_slot, ":dungeon_scene", "slot_scene_visited", 1),
      (change_screen_mission),
  ]),
  
  # script_enter_court
  # Input: arg1 = center_no
  # Output: none
  #other search term: setup_court
  ("enter_court",
    [
      (store_script_param_1, ":center_no"),
      
      (assign, "$talk_context", tc_court_talk),

      (set_jump_mission,"mt_visit_town_castle"),
         
      (mission_tpl_entry_clear_override_items, "mt_visit_town_castle", 0),
      #(mission_tpl_entry_set_override_flags, "mt_visit_town_castle", 0, af_override_all),
      
      (party_get_slot, ":castle_scene", ":center_no", "slot_town_castle"),
      (modify_visitors_at_site,":castle_scene"),
      (reset_visitors),
      #Adding guards
      (store_faction_of_party, ":center_faction", ":center_no"),
      (faction_get_slot, ":guard_troop", ":center_faction", "slot_faction_guard_troop"),
      ##diplomacy begin
      (try_begin),
         (eq, ":center_faction", "$players_kingdom"),
         (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
         (faction_get_slot, ":guard_troop", "$g_player_culture", "slot_faction_guard_troop"),
	  ##nested diplomacy start+
	  (else_try),
	     #Reflect multicultural empires.
		 (party_get_slot, ":town_lord", ":center_no", "slot_town_lord"),
		 (gt, ":town_lord", "trp_player"),
		 (troop_get_slot, ":lord_original_faction", ":town_lord", "slot_troop_original_faction"),
		 (neq, ":lord_original_faction", ":center_faction"),
		 (is_between, ":lord_original_faction", npc_kingdoms_begin, npc_kingdoms_end),
		 (this_or_next|party_slot_eq, ":center_no", "slot_center_original_faction", ":lord_original_faction"),
			(troop_slot_eq, ":town_lord", "slot_troop_home", ":center_no"),
		 (faction_get_slot, ":guard_troop", ":lord_original_faction", "slot_faction_guard_troop"),
	  ##nested diplomacy end+
      (try_end),
      ##diplomacy end
      (try_begin),
        (le, ":guard_troop", 0),
		#diplomacy start+
		#rubik changes this in Custom Commander, and I agree: the "generic" guard
		#should be non-faction-specific.
		##OLD:
        #(assign, ":guard_troop", "trp_briton_skirmishert4"),
		##NEW:
		(assign, ":guard_troop", "trp_merc_infantryt5"),
		##diplomacy end+
      (try_end),
      (set_visitor, 6, ":guard_troop"),
      (set_visitor, 7, ":guard_troop"),

      (assign, ":cur_pos", 16),

	  (try_begin),
		(troop_get_slot, ":player_spouse", "trp_player", "slot_troop_spouse"),
	    (gt, ":player_spouse", 0),
		(troop_slot_eq, ":player_spouse", "slot_troop_cur_center", ":center_no"),
        (set_visitor, ":cur_pos", ":player_spouse"),
        (val_add,":cur_pos", 1),
	  (else_try),	
		(troop_get_slot, ":player_betrothed", "trp_player", "slot_troop_betrothed"),
	    (gt, ":player_betrothed", 0),
		(troop_slot_eq, ":player_betrothed", "slot_troop_cur_center", ":center_no"),
        (set_visitor, ":cur_pos", ":player_betrothed"),
        (val_add,":cur_pos", 1),
	  (try_end),
	  
	minister.court_visitor,
    ##diplomacy chief begin
    (try_begin),
      (gt, "$g_player_chamberlain", 0),
      (call_script, "script_dplmc_appoint_chamberlain"),  #fix for wrong troops after update
      (party_get_slot, ":town_lord", ":center_no", "slot_town_lord"),
      (eq, ":town_lord", "trp_player"),
      (set_visitor, ":cur_pos", "$g_player_chamberlain"),
      (val_add,":cur_pos", 1),
    (try_end),

    constable.court_visitor,

    (try_begin),
      (gt, "$g_player_chancellor", 0),
      (call_script, "script_dplmc_appoint_chancellor"), #fix for wrong troops after update
      (party_get_slot, ":town_lord", ":center_no", "slot_town_lord"),
      (eq, ":town_lord", "trp_player"),
      (set_visitor, ":cur_pos", "$g_player_chancellor"),
      (val_add,":cur_pos", 1),
    (try_end),
    ##diplomacy chief end
	  
	  #Lords wishing to pledge allegiance - inactive, but part of player faction
	  (try_begin),
		(eq, "$g_player_court", ":center_no"),
	    (faction_slot_eq, ":center_faction", "slot_faction_leader", "trp_player"),
	    (try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
	      (store_faction_of_troop, ":active_npc_faction", ":active_npc"),
	      (eq, ":active_npc_faction", "fac_player_supporters_faction"),
	      (troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_inactive),
	      (neg|troop_slot_ge, ":active_npc", "slot_troop_prisoner_of_party", 0), #if he/she is not prisoner in any center.
	      (neq, ":active_npc", "$g_player_minister"),
	      (set_visitor, ":cur_pos", ":active_npc"),	      
	      (val_add,":cur_pos", 1),
		(try_end),
	  (try_end),	  
	  
      ##diplomacy start+
      #Show heroes you haven't seen recently first, to deal with crowded feast halls
      #(call_script, "script_get_heroes_attached_to_center", ":center_no", "p_temp_party"),
      (call_script, "script_dplmc_time_sorted_heroes_for_center", ":center_no", "p_temp_party"),
	  #Reserve a certain number of feast positions for ladies, both for practical
	  #reasons of courtship and for visual variety.
	  (try_begin),
		#If the player is unmarried, reserve zero to 8 slots for women
		(lt, ":player_spouse", 1),
		(store_random_in_range, ":reserved", 0, 9),
	  (else_try),
		#If the player is married, reserve zero to four slots for women
		(store_random_in_range, ":reserved", 0, 5),
	  (try_end),
	  (store_sub, ":non_lady_max", 32, ":reserved"),
      #diplomacy end+
      (party_get_num_companion_stacks, ":num_stacks","p_temp_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop","p_temp_party",":i_stack"),
       (gt, ":stack_troop", 0), ####BUGFIX LINE freelancer chief
		##diplomacy start+
        #(lt, ":cur_pos", 32), # spawn up to entry point 32 - is it possible to add another 10 spots?
		(lt, ":cur_pos", ":non_lady_max"),#Leave some room for ladies in huge feasts
		##diplomacy end+
      (set_visitor, ":cur_pos", ":stack_troop"),
        (val_add,":cur_pos", 1),
      (try_end),
      (try_for_range, ":cur_troop", kingdom_ladies_begin, kingdom_ladies_end),
	    (neq, ":cur_troop", "trp_knight_1_1_wife"), #The one who should not appear in game
        (troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_lady),
        (troop_slot_eq, ":cur_troop", "slot_troop_cur_center", ":center_no"),
		
		(assign, ":lady_meets_visitors", 0),
		(try_begin),
			(this_or_next|troop_slot_eq, "trp_player", "slot_troop_spouse", ":cur_troop"), #player spouse goes in position of honor
			(this_or_next|troop_slot_eq, "trp_player", "slot_troop_betrothed", ":cur_troop"), #player spouse goes in position of honor
			(this_or_next|troop_slot_eq, ":cur_troop", "slot_troop_spouse", "trp_player"), #player spouse goes in position of honor
				(troop_slot_eq, ":cur_troop", "slot_troop_betrothed", "trp_player"),
				
			(assign, ":lady_meets_visitors", 0), #She is already in the place of honor
		
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "str_s4_is_present_at_the_center_and_in_place_of_honor"),
			(try_end),
		
		(else_try), #lady is troop
			(store_faction_of_troop, ":lady_faction", ":cur_troop"),
			(neq, ":lady_faction", ":center_faction"),
			
			(assign, ":lady_meets_visitors", 1),
			
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "str_s4_is_present_at_the_center_as_a_refugee"),
			(try_end),

		(else_try),
			(troop_slot_ge, ":cur_troop", "slot_troop_spouse", 1),
			
			(try_begin),
			 #married ladies at a feast will not mingle - this is ahistorical, as married women and widows probably had much more freedom than unmarried ones, at least in the West, but the game needs to leave slots for them to show off their unmarried daughters
				(faction_slot_eq, ":center_faction", "slot_faction_ai_state", sfai_feast),
				(faction_slot_eq, ":center_faction", "slot_faction_ai_object", ":center_no"),
				(assign, ":lady_meets_visitors", 0),
				
				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_troop_name, s4, ":cur_troop"),
					(display_message, "str_s4_is_present_at_the_center_and_not_attending_the_feast"),
				(try_end),				
			(else_try),
				(assign, ":lady_meets_visitors", 1),
				
				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_troop_name, s4, ":cur_troop"),
					(display_message, "str_s4_is_present_at_the_center_and_is_married"),
				(try_end),				
			(try_end),
			
		(else_try), #feast is in progress			
			(faction_slot_eq, ":center_faction", "slot_faction_ai_state", sfai_feast),
			(faction_slot_eq, ":center_faction", "slot_faction_ai_object", ":center_no"),
			(assign, ":lady_meets_visitors", 1),
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "@{!}DEBUG -- {s4} is present at the center and is attending the feast"),
			(try_end),
						
		(else_try), #already met - awaits in private
			(troop_slot_ge, ":cur_troop", "slot_troop_met", 2),
			(assign, ":lady_meets_visitors", 0),
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "@{!}DEBUG -- {s4} is present at the center and is awaiting the player in private"),
			(try_end),
			
		(else_try),	
			(call_script, "script_get_kingdom_lady_social_determinants", ":cur_troop"),
			(call_script, "script_npc_decision_checklist_male_guardian_assess_suitor", reg0, "trp_player"),
			(gt, reg0, 0),
			(assign, ":lady_meets_visitors", 1),
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "@{!}DEBUG -- {s4} is_present_at_the_center_and_is_allowed_to_meet_the_player"),
			(try_end),
			
		(else_try),	
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "@{!}DEBUG -- {s4}is_present_at_the_center_and_is_not_allowed_to_meet_the_player"),
			(try_end),
		
		(try_end),				

		(eq, ":lady_meets_visitors", 1),
		
        (lt, ":cur_pos", 32), # spawn up to entry point 32
        (set_visitor, ":cur_pos", ":cur_troop"),
        (val_add,":cur_pos", 1),
      (try_end),
      
      (set_jump_entry, 0),
      
      (jump_to_scene,":castle_scene"),
      (scene_set_slot, ":castle_scene", "slot_scene_visited", 1),
      (change_screen_mission),
  ]),


   ("setup_meet_lady",
    [
      (store_script_param_1, ":lady_no"), 
      (store_script_param_2, ":center_no"), 
    
      #(mission_tpl_entry_set_override_flags, "mt_visit_town_castle", 0, af_override_horse),
      (troop_set_slot, ":lady_no", "slot_lady_last_suitor", "trp_player"),
	  
      (set_jump_mission,"mt_visit_town_castle"),
      (party_get_slot, ":castle_scene", ":center_no", "slot_town_castle"),
      (modify_visitors_at_site,":castle_scene"),
      (reset_visitors),

	  (troop_set_age, "trp_nurse_for_lady", 100),
      (set_visitor, 7, "trp_nurse_for_lady"),

      (assign, ":cur_pos", 16),
	  (set_visitor, ":cur_pos", ":lady_no"),

      (assign, "$talk_context", tc_garden),
	  
      (jump_to_scene,":castle_scene"),
      (scene_set_slot, ":castle_scene", "slot_scene_visited", 1),
      (change_screen_mission),	  
	]),  
  
  # script_find_high_ground_around_pos1
  # Input: pos1 should hold center_position_no
  #        arg1: team_no
  #        arg2: search_radius (in meters)
  # Output: pos52 contains highest ground within <search_radius> meters of team leader
  # Destroys position registers: pos10, pos11, pos15
  ("find_high_ground_around_pos1",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":search_radius", 2),
      (val_mul, ":search_radius", 100),
      (get_scene_boundaries, pos10,pos11),
      (team_get_leader, ":ai_leader", ":team_no"),
      (agent_get_position, pos1, ":ai_leader"),
      (set_fixed_point_multiplier, 100),
      (position_get_x, ":o_x", pos1),
      (position_get_y, ":o_y", pos1),
      (store_sub, ":min_x", ":o_x", ":search_radius"),
      (store_sub, ":min_y", ":o_y", ":search_radius"),
      (store_add, ":max_x", ":o_x", ":search_radius"),
      (store_add, ":max_y", ":o_y", ":search_radius"),
      (position_get_x, ":scene_min_x", pos10),
      (position_get_x, ":scene_max_x", pos11),
      (position_get_y, ":scene_min_y", pos10),
      (position_get_y, ":scene_max_y", pos11),
      #do not find positions close to borders (20 m)
      (val_add, ":scene_min_x", 2000),
      (val_sub, ":scene_max_x", 2000),
      (val_add, ":scene_min_y", 2000),
      (val_sub, ":scene_max_y", 2000),
      (val_max, ":min_x", ":scene_min_x"),
      (val_max, ":min_y", ":scene_min_y"),
      (val_min, ":max_x", ":scene_max_x"),
      (val_min, ":max_y", ":scene_max_y"),
      
      (store_div, ":min_x_meters", ":min_x", 100),
      (store_div, ":min_y_meters", ":min_y", 100),
      (store_div, ":max_x_meters", ":max_x", 100),
      (store_div, ":max_y_meters", ":max_y", 100),
      
      (assign, ":highest_pos_z", -10000),
      (copy_position, pos52, pos1),
      (init_position, pos15),
      
      (try_for_range, ":i_x", ":min_x_meters", ":max_x_meters"),
        (store_mul, ":i_x_cm", ":i_x", 100),
        (try_for_range, ":i_y", ":min_y_meters", ":max_y_meters"),
          (store_mul, ":i_y_cm", ":i_y", 100),
          (position_set_x, pos15, ":i_x_cm"),
          (position_set_y, pos15, ":i_y_cm"),
          (position_set_z, pos15, 10000),
          (position_set_z_to_ground_level, pos15),
          (position_get_z, ":cur_pos_z", pos15),
          (try_begin),
            (gt, ":cur_pos_z", ":highest_pos_z"),
            (copy_position, pos52, pos15),
            (assign, ":highest_pos_z", ":cur_pos_z"),
          (try_end),
        (try_end),
      (try_end),
  ]),
  
  # script_select_battle_tactic
  # Input: none
  # Output: none
  ("select_battle_tactic",
    [
      (assign, "$ai_team_1_battle_tactic", 0),
      (get_player_agent_no, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),
      (try_begin),
        (num_active_teams_le, 2),
        (try_begin),
          (eq, ":player_team", 0),
          (assign, "$ai_team_1", 1),
        (else_try),
          (assign, "$ai_team_1", 0),
        (try_end),
        (assign, "$ai_team_2", -1),
      (else_try),
        (try_begin),
          (eq, ":player_team", 0),
          (assign, "$ai_team_1", 1),
        (else_try),
          (assign, "$ai_team_1", 0),
        (try_end),
        (store_add, "$ai_team_2", ":player_team", 2),
      (try_end),
      (call_script, "script_select_battle_tactic_aux", "$ai_team_1", 0),
      (assign, "$ai_team_1_battle_tactic", reg0),
      (try_begin),
        (ge, "$ai_team_2", 0),
        (assign, ":defense_not_an_option", 0),
        (try_begin),
          (eq, "$ai_team_1_battle_tactic", btactic_hold),
          (assign, ":defense_not_an_option", 1), #don't let two AI defend at the same time
        (try_end),
        (call_script, "script_select_battle_tactic_aux", "$ai_team_2", ":defense_not_an_option"),
        (assign, "$ai_team_2_battle_tactic", reg0),
      (try_end),
  ]),

  # script_select_battle_tactic_aux
  # Input: team_no
  # Output: battle_tactic
  ("select_battle_tactic_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":defense_not_an_option", 2),
      (assign, ":battle_tactic", 0),
      (get_player_agent_no, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),
#      (try_begin), #tempered chief off
#        (eq, "$cant_leave_encounter", 1), #tempered chief off
#TEMPERED chief CHANGED FOR PLAYER ENTRENCHMENT
	  (party_get_slot,":entrench","p_main_party","slot_party_entrenched"),
	  (try_begin),
		(party_slot_eq,"p_main_party","slot_party_siege_camp",1),
        (teams_are_enemies, ":team_no", ":player_team"),
        (assign, ":defense_not_an_option", 1),		
	  (try_end),
      (try_begin),
        (this_or_next|eq, "$cant_leave_encounter", 1),
		(eq,":entrench",1),
#TEMPERED CHANGES END
         (teams_are_enemies, ":team_no", ":player_team"),
        (assign, ":defense_not_an_option", 1),
      (try_end),
      (call_script, "script_team_get_class_percentages", ":team_no", 0),
      #      (assign, ":ai_perc_infantry", reg0),
      (assign, ":ai_perc_archers",  reg1),
      (assign, ":ai_perc_cavalry",  reg2),
      (call_script, "script_team_get_class_percentages", ":team_no", 1),#enemies of the ai_team
      #      (assign, ":enemy_perc_infantry", reg0),
      #      (assign, ":enemy_perc_archers",  reg1),
      #      (assign, ":enemy_perc_cavalry",  reg2),

      (store_random_in_range, ":rand", 0, 100),      
      (try_begin),
        (this_or_next|lt, ":rand", 20),
        (assign, ":continue", 0),
        (try_begin),
          (teams_are_enemies, ":team_no", ":player_team"),
          (party_slot_eq, "$g_enemy_party", "slot_party_type", spt_kingdom_hero_party),
          (assign, ":continue", 1),
        (else_try),
          (neg|teams_are_enemies, ":team_no", ":player_team"),
          (gt, "$g_ally_party", 0),
          (party_slot_eq, "$g_ally_party", "slot_party_type", spt_kingdom_hero_party),
          (assign, ":continue", 1),
        (try_end),
        (eq, ":continue", 1),
        (try_begin),
          (eq, ":defense_not_an_option", 0),
          (gt, ":ai_perc_archers", 50),
          (lt, ":ai_perc_cavalry", 35),
          (assign, ":battle_tactic", btactic_hold),
        (else_try),
          (lt, ":rand", 80),
          (assign, ":battle_tactic", btactic_follow_leader),
        (try_end),
      (try_end),
      (assign, reg0, ":battle_tactic"),
  ]),
  
  # script_battle_calculate_initial_powers
  # Input: none
  # Output: none
  #("battle_calculate_initial_powers",
  #  [        
  #    (try_for_agents, ":agent_no"),
  #      (agent_is_human, ":agent_no"),
  #      
  #      (call_script, "script_calculate_team_powers", ":agent_no"),
  #      (assign, ":ally_power", reg0),
  #      (assign, ":enemy_power", reg1),
  #      
  #      (agent_set_slot, ":agent_no", "slot_agent_initial_ally_power", ":ally_power"),
  #      (agent_set_slot, ":agent_no", "slot_agent_initial_enemy_power", ":enemy_power"),
  #    (try_end),
  #]),

  # script_battle_tactic_init
  # Input: none
  # Output: none
  ("battle_tactic_init",
    [
      (call_script, "script_battle_tactic_init_aux", "$ai_team_1", "$ai_team_1_battle_tactic"),
      (try_begin),
        (ge, "$ai_team_2", 0),
        (call_script, "script_battle_tactic_init_aux", "$ai_team_2", "$ai_team_2_battle_tactic"),
      (try_end),

      (try_for_agents, ":cur_agent"),
        (agent_set_slot, ":cur_agent",  "slot_agent_is_running_away", 0), #initially nobody is running away.
      (try_end),
      (assign, "$g_fire_arrow_mode_enemy", 1), #fire arrow chief
  ]),

  # script_battle_tactic_init chief campamentos modificado
  # Input: none
  # Output: none
  ("battle_tactic_init2",
    [
      (call_script, "script_orig_battle_tactic_init_aux", "$ai_team_1", "$ai_team_1_battle_tactic"),
      (try_begin),
        (ge, "$ai_team_2", 0),
        (call_script, "script_orig_battle_tactic_init_aux", "$ai_team_2", "$ai_team_2_battle_tactic"),
      (try_end),

      (try_for_agents, ":cur_agent"),
        (agent_set_slot, ":cur_agent",  "slot_agent_is_running_away", 0), #initially nobody is running away.
      (try_end),
  ]),
  # script_battle_tactic_init_aux
  # Input: team_no, battle_tactic
  # Output: none
  #chief cambia nombre de script
  ("orig_battle_tactic_init_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
      (team_get_leader, ":ai_leader", ":team_no"),
      (try_begin),
        (eq, ":battle_tactic", btactic_hold),
        (agent_get_position, pos1, ":ai_leader"),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30),
        (copy_position, pos1, pos52),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30), # call again just in case we are not at peak point.
        (copy_position, pos1, pos52),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30), # call again just in case we are not at peak point.
        (team_give_order, ":team_no", grc_everyone, mordr_hold),
        (team_set_order_position, ":team_no", grc_everyone, pos52),
        (team_give_order, ":team_no", grc_archers, mordr_advance),
        (team_give_order, ":team_no", grc_archers, mordr_advance),
      (else_try),
        (eq, ":battle_tactic", btactic_follow_leader),
        (team_get_leader, ":ai_leader", ":team_no"),
        (ge, ":ai_leader", 0),
        (agent_set_speed_limit, ":ai_leader", 8),
        (agent_get_position, pos60, ":ai_leader"),
        (team_give_order, ":team_no", grc_everyone, mordr_hold),
        (team_set_order_position, ":team_no", grc_everyone, pos60),
      (try_end),
  ]),

  # script_calculate_team_powers
  # Input: none
  # Output: ally_power, enemy_power
  ("calculate_team_powers",
     [
       (store_script_param, ":agent_no", 1),

       (try_begin),
         (assign, ":agent_side", 0),
         (agent_is_ally, ":agent_no"),
         (assign, ":agent_side", 1),
       (try_end),

       (assign, ":ally_power", 0),
       (assign, ":enemy_power", 0),
       
       (try_for_agents, ":cur_agent"),
         (agent_is_human, ":cur_agent"),
         (agent_is_alive, ":cur_agent"),
       
         (try_begin),
           (assign, ":agent_side_cur", 0),
           (agent_is_ally, ":cur_agent"),
           (assign, ":agent_side_cur", 1),
         (try_end),

         (try_begin),
           (agent_get_horse, ":agent_horse_id", ":cur_agent"),
           (neq, ":agent_horse_id", -1),
           (assign, ":agent_power", 2), #if this agent is horseman then his power effect is 2
         (else_try),
           (assign, ":agent_power", 1), #if this agent is walker then his power effect is 1
         (try_end),
       
         (try_begin),
           (eq, ":agent_side", ":agent_side_cur"),
           (val_add, ":ally_power", ":agent_power"),
         (else_try),
           (val_add, ":enemy_power", ":agent_power"),       
         (try_end),
       (try_end),
          
       (assign, reg0, ":ally_power"),         
       (assign, reg1, ":enemy_power"),         
  ]), #ozan

  # script_apply_effect_of_other_people_on_courage_scores
  # Input: none
  # Output: none
  ("apply_effect_of_other_people_on_courage_scores",
    [
      (get_player_agent_no, ":player_agent"),

      (try_for_agents, ":centered_agent_no"),
        (agent_is_human, ":centered_agent_no"),
        (agent_is_alive, ":centered_agent_no"),
        (neq, ":centered_agent_no", ":player_agent"),
        (agent_get_position, pos0, ":centered_agent_no"),
        (try_begin),
          (agent_is_ally, ":centered_agent_no"),
          (assign, ":is_centered_agent_ally", 1),
        (else_try),
          (assign, ":is_centered_agent_ally", 0),
        (try_end),
       
        (try_for_agents, ":agent_no"),
          (agent_is_human, ":agent_no"),
          (agent_is_alive, ":agent_no"),
          (neq, ":centered_agent_no", ":agent_no"),      

          (try_begin),
            (agent_is_ally, ":agent_no"),
            (assign, ":is_agent_ally", 1),
          (else_try),
            (assign, ":is_agent_ally", 0),
          (try_end),

          (eq, ":is_centered_agent_ally", ":is_agent_ally"), #if centered agent and other agent is at same team then continue.
          (agent_get_slot, ":agent_is_running_away_or_not", ":agent_no", "slot_agent_is_running_away"),

          (try_begin),
            (eq, ":agent_no", ":player_agent"),
            (assign, ":agent_delta_courage_score", 6),
          (else_try),
            (agent_get_troop_id, ":troop_id", ":agent_no"),
            (troop_is_hero, ":troop_id"),
      
            #Hero Agent : if near agent (hero, agent_no) is not running away his positive effect on centered agent (centered_agent_no) fighting at his side is effected by his hit points.
            (try_begin),      
              (neq, ":agent_is_running_away_or_not", 1), #if agent is not running away
              (store_agent_hit_points, ":agent_hit_points", ":agent_no"),
              (try_begin),
                (eq, ":agent_hit_points", 100),
                (assign, ":agent_delta_courage_score", 6),
              (else_try),
                (ge, ":agent_hit_points", 75),
                (assign, ":agent_delta_courage_score", 5),
              (else_try),
                (ge, ":agent_hit_points", 60),
                (assign, ":agent_delta_courage_score", 4),
              (else_try),
                (ge, ":agent_hit_points", 45),
                (assign, ":agent_delta_courage_score", 3),
              (else_try),
                (ge, ":agent_hit_points", 30),
                (assign, ":agent_delta_courage_score", 2),
              (else_try),
                (ge, ":agent_hit_points", 15),
                (assign, ":agent_delta_courage_score", 1),
              (end_try),
            (else_try),
              (assign, ":agent_delta_courage_score", 4),
            (end_try),
          (else_try),
            #Normal Agent : if near agent (agent_no) is not running away his positive effect on centered agent (centered_agent_no) fighting at his side is effected by his hit points.
            (try_begin),      
              (neq, ":agent_is_running_away_or_not", 1), # if agent is not running away
              (store_agent_hit_points, ":agent_hit_points", ":agent_no"),
              (try_begin),
                (eq, ":agent_hit_points", 100),
                (assign, ":agent_delta_courage_score", 4),
              (else_try),
                (ge, ":agent_hit_points", 75),
                (assign, ":agent_delta_courage_score", 3),
              (else_try),
                (ge, ":agent_hit_points", 50),
                (assign, ":agent_delta_courage_score", 2),
              (else_try),
                (ge, ":agent_hit_points", 25),
                (assign, ":agent_delta_courage_score", 1),
              (try_end),
              (try_begin), # to make our warrior run away easier we decrease one, because they have player_agent (+6) advantage.
                (agent_is_ally, ":agent_no"),
                (val_sub, ":agent_delta_courage_score", 1),
              (try_end),
            (else_try),
              (assign, ":agent_delta_courage_score", 2),
            (end_try),
          (try_end),
      
          (try_begin),
            (neq, ":agent_is_running_away_or_not", 1),
            (val_mul, ":agent_delta_courage_score", 1),
            (try_begin), # centered agent not running away cannot take positive courage score from one another agent not running away.
              (agent_get_slot, ":agent_is_running_away_or_not", ":centered_agent_no", "slot_agent_is_running_away"),
              (eq, ":agent_is_running_away_or_not", 0),
              (val_mul, ":agent_delta_courage_score", 0),
            (try_end),
          (else_try),
            (try_begin), 
              (agent_get_slot, ":agent_is_running_away_or_not", ":agent_no", "slot_agent_is_running_away"),
              (eq, ":agent_is_running_away_or_not", 0),
              (val_mul, ":agent_delta_courage_score", -2), # running away agent fears not running away agent more.
            (else_try),
              (val_mul, ":agent_delta_courage_score", -1),
            (try_end),
          (try_end),

          (neq, ":agent_delta_courage_score", 0),

          (agent_get_position, pos1, ":agent_no"),
          (get_distance_between_positions, ":dist", pos0, pos1),

          (try_begin),
            (ge, ":agent_delta_courage_score", 0),
            (try_begin),
              (lt, ":dist", 2000), #0-20 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 50),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 4000), #21-40 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 40),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
           (else_try),
              (lt, ":dist", 7000), #41-70 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 30),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 11000), #71-110 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 20),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),      
              (lt, ":dist", 16000), # 111-160 meter, assumed that eye can see agents friendly at most 160 meters far while fighting. 
                                    # this is more than below limit (108 meters) because we hear that allies come from further.
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 10),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (try_end),      
          (else_try),                                               # negative effect of running agent on other ally agents are lower then positive effects above, to avoid starting  
            (try_begin),                                            # run away of all agents at a moment. I want to see agents running away one by one during battle, not all together.
              (lt, ":dist", 200), #1-2 meter,                       # this would create better game play.
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 15),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 400), #3-4 meter, 
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 13),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 600), #5-6 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 11),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 800), #7-8 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 9),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 1200), #9-12 meters
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 7),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 2400), #13-24 meters
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 5),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 4800), #25-48 meters
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 3),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 9600), #49-98 meters, assumed that eye can see agents running away at most 98 meters far while fighting.
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", "slot_agent_courage_score"),
              (val_mul, ":agent_delta_courage_score", 1),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", "slot_agent_courage_score", ":agent_courage_score"),
            (try_end),      
          (try_end),
        (try_end),            
      (try_end),
  ]), #ozan

  
  # script_apply_death_effect_on_courage_scores
  # Input: dead agent id, killer agent id
  # Output: none
  ("apply_death_effect_on_courage_scores",
    [
      (store_script_param, ":dead_agent_no", 1),
      (store_script_param, ":killer_agent_no", 2),
      
      (try_begin),
        (agent_is_human, ":dead_agent_no"),

        (try_begin),
          (agent_is_ally, ":dead_agent_no"),
          (assign, ":is_dead_agent_ally", 1),
        (else_try),
          (assign, ":is_dead_agent_ally", 0),
        (try_end),

        (agent_get_position, pos0, ":dead_agent_no"),
        (assign, ":number_of_near_allies_to_dead_agent", 0),

        (try_for_agents, ":agent_no"),
          (agent_is_human, ":agent_no"),
          (agent_is_alive, ":agent_no"),

          (agent_get_position, pos1, ":agent_no"), 
          (get_distance_between_positions, ":dist", pos0, pos1),

          (le, ":dist", 2300), # to count number of allies within 23 meters to dead agent. #Chief cambiado

          (try_begin),
            (agent_is_ally, ":agent_no"),
            (assign, ":is_agent_ally", 1),
          (else_try),
            (assign, ":is_agent_ally", 0),
          (try_end),

          (try_begin), 
            (eq, ":is_dead_agent_ally", ":is_agent_ally"),
            (val_add, ":number_of_near_allies_to_dead_agent", 1), # (number_of_near_allies_to_dead_agent) is counted because if there are 
          (try_end),                                              # many allies of dead agent around him, negative courage effect become less.
        (try_end),
                
        (try_for_agents, ":agent_no"),
          (agent_is_human, ":agent_no"),
          (agent_is_alive, ":agent_no"),
           
          (try_begin),
            (agent_is_ally, ":agent_no"),
            (assign, ":is_agent_ally", 1),
          (else_try),
            (assign, ":is_agent_ally", 0),
          (try_end),
   
          (try_begin), # each agent is effected by a killed agent positively if he is rival or negatively if he is ally.
            (neq, ":is_dead_agent_ally", ":is_agent_ally"), 
            (assign, ":agent_delta_courage_score", 20),  # if killed agent is agent of rival side, add points to fear score #chief cambiado
          (else_try),          
            (assign, ":agent_delta_courage_score", -35), # if killed agent is agent of our side, decrease points from fear score #chief cambiado
            (val_add, ":agent_delta_courage_score", ":number_of_near_allies_to_dead_agent"), # ":number_of_near_allies_to_dead_agent" is added because if there are many
            (try_begin),                                                                     # allies of dead agent around him, negative courage effect become less.
              (gt, ":agent_delta_courage_score", -15), #chief cambiado
              (assign, ":agent_delta_courage_score", -15), #chief cambiado
            (try_end),

            (agent_get_slot, ":dead_agent_was_running_away_or_not", ":dead_agent_no",  "slot_agent_is_running_away"), #look dead agent was running away or not.
            (try_begin),
              (eq, ":dead_agent_was_running_away_or_not", 1),      
              (val_div, ":agent_delta_courage_score", 3),  # if killed agent was running away his negative effect on ally courage scores become very less. This added because
            (try_end),                                     # running away agents are easily killed and courage scores become very in a running away group after a time, and
          (try_end),                                       # they do not stop running away althought they pass near a new powerfull ally party.                 
          (agent_get_position, pos1, ":agent_no"), 
          (get_distance_between_positions, ":dist", pos0, pos1),

          (try_begin),
            (eq, ":killer_agent_no", ":agent_no"),
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 20),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (try_end),
        
          (try_begin),
            (lt, ":dist", 100), #0-1 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 150),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 200), #2 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 120),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 300), #3 meter
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 100),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 400), #4 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 90),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 600), #5-6 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 80),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 800), #7-8 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 70),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 1000), #9-10 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 60),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 1500), #11-15 meter
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 50),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 2500), #16-25 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 40),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 4000), #26-40 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 30),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 6500), #41-65 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 20),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 10000), #61-100 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", "slot_agent_courage_score"),
            (val_mul, ":agent_delta_courage_score", 10),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", "slot_agent_courage_score", ":agent_courage_score"),
          (try_end),
        (try_end),
      (try_end),
      ]), #ozan

  # script_decide_run_away_or_not
  # Input: agent, mission timer
  # Output: none
  #cambios formaciones
  ("decide_run_away_or_not",
    [
      (store_script_param, ":cur_agent", 1),
      (store_script_param, ":mission_time", 2),
      
      (assign, ":force_retreat", 0),
      (agent_get_team, ":agent_team", ":cur_agent"),
      (agent_get_division, ":agent_division", ":cur_agent"),
      (try_begin),
        (lt, ":agent_division", 9), #static classes
        (team_get_movement_order, ":agent_movement_order", ":agent_team", ":agent_division"),
        (eq, ":agent_movement_order", mordr_retreat),
        (assign, ":force_retreat", 1),
      (try_end),

      (agent_get_slot, ":is_cur_agent_running_away", ":cur_agent", "slot_agent_is_running_away"),
      (try_begin),
        (eq, ":is_cur_agent_running_away", 0),
        (try_begin),
          (eq, ":force_retreat", 1),
          (agent_clear_scripted_mode, ":cur_agent"),	#handle scripted mode troops - motomataru
          (agent_start_running_away, ":cur_agent"),
          (agent_set_slot, ":cur_agent",  "slot_agent_is_running_away", 1),
        (else_try),
          (ge, ":mission_time", 180), #first 45 seconds anyone does not run away whatever happens. Chief cambia a 180 segundos
          (agent_get_slot, ":agent_courage_score", ":cur_agent",  "slot_agent_courage_score"),
          (store_agent_hit_points, ":agent_hit_points", ":cur_agent"),
          (val_mul, ":agent_hit_points", 5), #chief cambiado
          ## CC chief
          (try_begin),
            (agent_is_ally, ":cur_agent"),
            (val_sub, ":agent_hit_points", 88), #ally agents will be more tend to run away, to make game more funnier/harder#gdw100
            (val_mul, ":agent_hit_points", 10),
          (else_try),
            (options_get_campaign_ai, ":reduce_campaign_ai"),
            (try_begin),
              (eq, ":reduce_campaign_ai", 0), # hard
              (val_mul, ":agent_hit_points", 21),#gdw20
            (else_try),
              (eq, ":reduce_campaign_ai", 1), # normal
              (val_mul, ":agent_hit_points", 15),
            (else_try),
              (val_mul, ":agent_hit_points", 8), # gdw10easy
            (try_end),
          (try_end),
          ## CC chief
          (store_sub, ":start_running_away_courage_score_limit", 3000, ":agent_hit_points"), #chief cambiado
          (lt, ":agent_courage_score", ":start_running_away_courage_score_limit"), #if (courage score < 3500 - (agent hit points * 40)) and (agent is not running away) then start running away, average hit points : 50, average running away limit = 1500

          (agent_get_troop_id, ":troop_id", ":cur_agent"), #for now do not let heroes to run away from battle
          (neg|troop_is_hero, ":troop_id"),
                                
          (agent_clear_scripted_mode, ":cur_agent"),	#handle scripted mode troops - motomataru chief
          (agent_start_running_away, ":cur_agent"),
          (agent_set_slot, ":cur_agent",  "slot_agent_is_running_away", 1),
        (try_end),
      (else_try),
        (neq, ":force_retreat", 1),
        (agent_get_slot, ":agent_courage_score", ":cur_agent",  "slot_agent_courage_score"),
        (store_agent_hit_points, ":agent_hit_points", ":cur_agent"),      
        (val_mul, ":agent_hit_points", 5), #chief cambia
##CC chief
        (try_begin),
          (agent_is_ally, ":cur_agent"),
          (val_sub, ":agent_hit_points", 88), #ally agents will be more tend to run away, to make game more funnier/harder#gdw100
          (val_mul, ":agent_hit_points", 10),
        (else_try),
          (options_get_campaign_ai, ":reduce_campaign_ai"),
          (try_begin),
            (eq, ":reduce_campaign_ai", 0), # hard
            (val_mul, ":agent_hit_points", 21),#gdw20
          (else_try),
            (eq, ":reduce_campaign_ai", 1), # normal
            (val_mul, ":agent_hit_points", 15),
          (else_try),
            (val_mul, ":agent_hit_points", 8), # easy#gdw10
          (try_end),
        (try_end),
        ## CC chief
        (store_sub, ":stop_running_away_courage_score_limit", 3200, ":agent_hit_points"),  #chief cambia
        (ge, ":agent_courage_score", ":stop_running_away_courage_score_limit"), #if (courage score > 3700 - agent hit points) and (agent is running away) then stop running away, average hit points : 50, average running away limit = 1700
        (agent_stop_running_away, ":cur_agent"),
        (agent_set_slot, ":cur_agent",  "slot_agent_is_running_away", 0),
      (try_end),      
  ]), #ozan
  
  # script_battle_tactic_apply
  # Input: none
  # Output: none
  ("battle_tactic_apply",
    [
      (call_script, "script_battle_tactic_apply_aux", "$ai_team_1", "$ai_team_1_battle_tactic"),
      (assign, "$ai_team_1_battle_tactic", reg0),
      (try_begin),
        (ge, "$ai_team_2", 0),
        (call_script, "script_battle_tactic_apply_aux", "$ai_team_2", "$ai_team_2_battle_tactic"),
        (assign, "$ai_team_2_battle_tactic", reg0),
      (try_end),
  ]),

#chief anadido para batalla campamento
  # script_battle_tactic_apply
  # Input: none
  # Output: none
  ("battle_tactic_apply2",
    [
      (call_script, "script_orig_battle_tactic_apply_aux", "$ai_team_1", "$ai_team_1_battle_tactic"),
      (assign, "$ai_team_1_battle_tactic", reg0),
      (try_begin),
        (ge, "$ai_team_2", 0),
        (call_script, "script_orig_battle_tactic_apply_aux", "$ai_team_2", "$ai_team_2_battle_tactic"),
        (assign, "$ai_team_2_battle_tactic", reg0),
      (try_end),
  ]),
  # script_battle_tactic_apply_aux
  # Input: team_no, battle_tactic
  # Output: battle_tactic
  #chief cambia nombre script con orig_
  ("orig_battle_tactic_apply_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
      (store_mission_timer_a, ":mission_time"),
      (try_begin),
        (eq, ":battle_tactic", btactic_hold),
        (copy_position, pos1, pos52),
        (call_script, "script_get_closest3_distance_of_enemies_at_pos1", ":team_no", 1),
        (assign, ":avg_dist", reg0),
        (assign, ":min_dist", reg1),
        (try_begin),
          (this_or_next|lt, ":min_dist", 1000),
          (lt, ":avg_dist", 4000),
          (assign, ":battle_tactic", 0),
          (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (try_end),
      (else_try),
        (eq, ":battle_tactic", btactic_follow_leader),
        (team_get_leader, ":ai_leader", ":team_no"),
        (try_begin),
          (ge, ":ai_leader", 0),
          (agent_is_alive, ":ai_leader"),
          (agent_set_speed_limit, ":ai_leader", 9),
          (call_script, "script_team_get_average_position_of_enemies", ":team_no"),
          (copy_position, pos60, pos0),
          (agent_get_position, pos61, ":ai_leader"),
          (position_transform_position_to_local, pos62, pos61, pos60), #pos62 = vector to enemy w.r.t leader
          (position_normalize_origin, ":distance_to_enemy", pos62),
          (convert_from_fixed_point, ":distance_to_enemy"),
          (assign, reg17, ":distance_to_enemy"),
          (position_get_x, ":dir_x", pos62),
          (position_get_y, ":dir_y", pos62),
          (val_mul, ":dir_x", 23),
          (val_mul, ":dir_y", 23), #move 23 meters
          (position_set_x, pos62, ":dir_x"),
          (position_set_y, pos62, ":dir_y"),
        
          (position_transform_position_to_parent, pos63, pos61, pos62), #pos63 is 23m away from leader in the direction of the enemy.
          (position_set_z_to_ground_level, pos63),
        
          (team_give_order, ":team_no", grc_everyone, mordr_hold),
          (team_set_order_position, ":team_no", grc_everyone, pos63),
          (agent_get_position, pos1, ":ai_leader"),
          (try_begin),
            (lt, ":distance_to_enemy", 50),
            (ge, ":mission_time", 30),
            (assign, ":battle_tactic", 0),
            (team_give_order, ":team_no", grc_everyone, mordr_charge),
            (agent_set_speed_limit, ":ai_leader", 60),
          (try_end),
        (else_try),
          (assign, ":battle_tactic", 0),
          (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (try_end),
      (try_end),
      
      (try_begin), # charge everyone after a while
        (neq, ":battle_tactic", 0),
        (ge, ":mission_time", 300),
        (assign, ":battle_tactic", 0),
        (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (team_get_leader, ":ai_leader", ":team_no"),
        (agent_set_speed_limit, ":ai_leader", 60),
      (try_end),
      (assign, reg0, ":battle_tactic"),
  ]),

  
##  # script_siege_defender_tactic_apply
##  # Input: none
##  # Output: none
##  ("siege_defender_tactic_apply",
##    [
##      (try_begin),
##        (eq, "$defender_team", 1),
##        (ge, "$belfry_positioned", 2),
##        
##        (assign, ":enemy_too_weak", 0),
##        (try_begin),
##          (ge, "$attacker_reinforcement_stage", 2),
##          (call_script, "script_calculate_team_strength", "$defender_team"),
##          (assign, ":defender_strength", reg0),
##          (call_script, "script_calculate_team_strength", "$attacker_team"),
##          (assign, ":attacker_strength", reg0),
##          (store_mul, ":attacker_strength_multiplied", ":attacker_strength", 2),
##          (ge, ":defender_strength", ":attacker_strength_multiplied"),
##          (assign, ":enemy_too_weak", 1),
##        (try_end),
##        
##        (try_begin),
##          (eq, ":enemy_too_weak", 1),
##          (neq, "$ai_battle_tactic", btactic_charge),
##          (assign, "$ai_battle_tactic", btactic_charge),
##          (team_give_order, "$defender_team", grc_infantry, mordr_charge),
##        (else_try),
##          (neq, "$ai_battle_tactic", btactic_charge),
##          (neq, "$ai_battle_tactic", btactic_hold),
##          (assign, "$ai_battle_tactic", btactic_hold),
##          (team_give_order, "$defender_team", grc_infantry, mordr_hold),
##          (team_give_order, "$defender_team", grc_heroes, mordr_hold),
##          (entry_point_get_position,pos1,10),
##          (team_set_order_position, "$defender_team", grc_infantry, pos1),
##          (team_set_order_position, "$defender_team", grc_heroes, pos1),
##        (try_end),
##      (try_end),
##  ]),
  
  
  # script_team_get_class_percentages
  # Input: arg1: team_no, arg2: try for team's enemies
  # Output: reg0: percentage infantry, reg1: percentage archers, reg2: percentage cavalry
  ("team_get_class_percentages",
    [
      (assign, ":num_infantry", 0),
      (assign, ":num_archers", 0),
      (assign, ":num_cavalry", 0),
      (assign, ":num_total", 0),
      (store_script_param, ":team_no", 1),
      (store_script_param, ":negate", 2),
      (try_for_agents,":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_get_team, ":agent_team", ":cur_agent"),
        (assign, ":continue", 0),
        (try_begin),
          (eq, ":negate", 1),
          (teams_are_enemies, ":agent_team", ":team_no"),
          (assign, ":continue", 1),
        (else_try),
          (eq, ":agent_team", ":team_no"),
          (assign, ":continue", 1),
        (try_end),
        (eq, ":continue", 1),
        (val_add, ":num_total", 1),
        (agent_get_class, ":agent_class", ":cur_agent"),
        (try_begin),
          (eq, ":agent_class", grc_infantry),
          (val_add,  ":num_infantry", 1),
        (else_try),
          (eq, ":agent_class", grc_archers),
          (val_add,  ":num_archers", 1),
        (else_try),
          (eq, ":agent_class", grc_cavalry),
          (val_add,  ":num_cavalry", 1),
        (try_end),
      (try_end),
      (try_begin),
        (eq,  ":num_total", 0),
        (assign,  ":num_total", 1),
      (try_end),
      (store_mul, ":perc_infantry",":num_infantry",100),
      (val_div, ":perc_infantry",":num_total"),
      (store_mul, ":perc_archers",":num_archers",100),
      (val_div, ":perc_archers",":num_total"),
      (store_mul, ":perc_cavalry",":num_cavalry",100),
      (val_div, ":perc_cavalry",":num_total"),
      (assign, reg0, ":perc_infantry"),
      (assign, reg1, ":perc_archers"),
      (assign, reg2, ":perc_cavalry"),
  ]),
  
  # script_get_closest3_distance_of_enemies_at_pos1
  # Input: arg1: team_no, pos1
  # Output: reg0: distance in cms.
  ("get_closest3_distance_of_enemies_at_pos1",
    [
      (assign, ":min_distance_1", 100000),
      (assign, ":min_distance_2", 100000),
      (assign, ":min_distance_3", 100000),
      
      (store_script_param, ":team_no", 1),
      (try_for_agents,":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_get_team, ":agent_team", ":cur_agent"),
        (teams_are_enemies, ":agent_team", ":team_no"),
       
        (agent_get_position, pos2, ":cur_agent"),
        (get_distance_between_positions,":cur_dist",pos2,pos1),
        (try_begin),
          (lt, ":cur_dist", ":min_distance_1"),
          (assign, ":min_distance_3", ":min_distance_2"),
          (assign, ":min_distance_2", ":min_distance_1"),
          (assign, ":min_distance_1", ":cur_dist"),
        (else_try),
          (lt, ":cur_dist", ":min_distance_2"),
          (assign, ":min_distance_3", ":min_distance_2"),
          (assign, ":min_distance_2", ":cur_dist"),
        (else_try),
          (lt, ":cur_dist", ":min_distance_3"),
          (assign, ":min_distance_3", ":cur_dist"),
        (try_end),
      (try_end),
      
      (assign, ":total_distance", 0),
      (assign, ":total_count", 0),
      (try_begin),
        (lt, ":min_distance_1", 100000),
        (val_add, ":total_distance", ":min_distance_1"),
        (val_add, ":total_count", 1),
      (try_end),
      (try_begin),
        (lt, ":min_distance_2", 100000),
        (val_add, ":total_distance", ":min_distance_2"),
        (val_add, ":total_count", 1),
      (try_end),
      (try_begin),
        (lt, ":min_distance_3", 100000),
        (val_add, ":total_distance", ":min_distance_3"),
        (val_add, ":total_count", 1),
      (try_end),
      (assign, ":average_distance", 100000),
      (try_begin),
        (gt, ":total_count", 0),
        (store_div, ":average_distance", ":total_distance", ":total_count"),
      (try_end),
      (assign, reg0, ":average_distance"),
      (assign, reg1, ":min_distance_1"),
      (assign, reg2, ":min_distance_2"),
      (assign, reg3, ":min_distance_3"),
  ]),

  # script_team_get_average_position_of_enemies
  # Input: arg1: team_no, 
  # Output: pos0: average position.
  ("team_get_average_position_of_enemies",
    [
      (store_script_param_1, ":team_no"),
      (init_position, pos0),
      (assign, ":num_enemies", 0),
      (assign, ":accum_x", 0),
      (assign, ":accum_y", 0),
      (assign, ":accum_z", 0),
      (try_for_agents,":enemy_agent"),
        (agent_is_alive, ":enemy_agent"),
        (agent_is_human, ":enemy_agent"),
        (agent_get_team, ":enemy_team", ":enemy_agent"),
        (teams_are_enemies, ":team_no", ":enemy_team"),
      
        (agent_get_position, pos62, ":enemy_agent"),
      
        (position_get_x, ":x", pos62),
        (position_get_y, ":y", pos62),
        (position_get_z, ":z", pos62),
      
        (val_add, ":accum_x", ":x"),
        (val_add, ":accum_y", ":y"),
        (val_add, ":accum_z", ":z"),
        (val_add, ":num_enemies", 1),
      (try_end),
      
      (try_begin), #to avoid division by zeros at below division part.
        (le, ":num_enemies", 0),
        (assign, ":num_enemies", 1),
      (try_end),
      
      (store_div, ":average_x", ":accum_x", ":num_enemies"),
      (store_div, ":average_y", ":accum_y", ":num_enemies"),
      (store_div, ":average_z", ":accum_z", ":num_enemies"),

      (position_set_x, pos0, ":average_x"),
      (position_set_y, pos0, ":average_y"),
      (position_set_z, pos0, ":average_z"),
      
      (assign, reg0, ":num_enemies"),
  ]),
  
  
  # script_search_troop_prisoner_of_party
  # Input: arg1 = troop_no
  # Output: reg0 = party_no (-1 if troop is not a prisoner.)
  ("search_troop_prisoner_of_party",
    [
      (store_script_param_1, ":troop_no"),
      (assign, ":prisoner_of", -1),
      (try_for_parties, ":party_no"),
        (eq,  ":prisoner_of", -1),
        (this_or_next|eq, ":party_no", "p_main_party"),
        (ge, ":party_no", centers_begin),
        (party_count_prisoners_of_type, ":troop_found", ":party_no", ":troop_no"),
        (gt, ":troop_found", 0),
        (assign, ":prisoner_of", ":party_no"),
      (try_end),
      (assign, reg0, ":prisoner_of"),
  ]),
  
  
##  # script_clear_last_quest
##  # Input: arg1 = troop_no
##  # Output: none
##  ("clear_last_quest",
##    [
##      (store_script_param_1, ":troop_no"),
##      
##      (troop_set_slot, ":troop_no","slot_troop_last_quest", 0),
##      (troop_set_slot, ":troop_no","slot_troop_last_quest_betrayed", 0)
##  ]),
  
  
  
  # script_change_debt_to_troop
  # Input: arg1 = troop_no, arg2 = new debt amount
  # Output: none
  ("change_debt_to_troop",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":new_debt"),
      
      (troop_get_slot, ":cur_debt", ":troop_no", "slot_troop_player_debt"),
      (assign, reg1, ":cur_debt"),
      (val_add, ":cur_debt", ":new_debt"),
      (assign, reg2, ":cur_debt"),
      (troop_set_slot, ":troop_no", "slot_troop_player_debt", ":cur_debt"),
      (str_store_troop_name_link, s1, ":troop_no"),
      (display_message, "@You now owe {reg2} scillingas to {s1}."),
  ]),
  
  
  
  
  # script_abort_quest
  # Input: arg1 = quest_no, arg2 = apply relation penalty
  # Output: none
  ("abort_quest",
    [
      (store_script_param_1, ":quest_no"),
      (store_script_param_2, ":abort_type"), #0=aborted by event, 1=abort by talking 2=abort by expire

      (assign, ":quest_return_penalty", -1),
      (assign, ":quest_expire_penalty", -2),
      
#      (quest_get_slot, ":quest_object_troop", ":quest_no", "slot_quest_object_troop"),
      (try_begin),
        (this_or_next|eq, ":quest_no", "qst_deliver_message"),
        (eq, ":quest_no", "qst_deliver_message_to_enemy_lord"),
        (assign, ":quest_return_penalty", -2),
        (assign, ":quest_expire_penalty", -3),
      (else_try),
        (eq, ":quest_no", "qst_kidnapped_girl"),
        (party_remove_members, "p_main_party", "trp_kidnapped_girl", 1),
        (quest_get_slot, ":quest_target_party", "qst_kidnapped_girl", "slot_quest_target_party"),
        (try_begin),
          (party_is_active, ":quest_target_party"),
          (remove_party, ":quest_target_party"),
        (try_end),
      (else_try),
        (eq, ":quest_no", "qst_escort_lady"),
        (quest_get_slot, ":quest_object_troop", "qst_escort_lady", "slot_quest_object_troop"),
        (party_remove_members, "p_main_party", ":quest_object_troop", 1),
        (assign, ":quest_return_penalty", -2),
        (assign, ":quest_expire_penalty", -3),
##      (else_try),
##        (eq, ":quest_no", "qst_rescue_lady_under_siege"),
##        (party_remove_members, "p_main_party", ":quest_object_troop", 1),
##      (else_try),
##        (eq, ":quest_no", "qst_deliver_message_to_lover"),
##      (else_try),
##        (eq, ":quest_no", "qst_bring_prisoners_to_enemy"),
##        (try_begin),
##          (check_quest_succeeded, ":quest_no"),
##          (quest_get_slot, ":quest_target_amount", ":quest_no", "slot_quest_target_amount"),
##          (quest_get_slot, ":quest_object_troop", ":quest_no", "slot_quest_object_troop"),
##          (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
##          (call_script, "script_game_get_join_cost", ":quest_object_troop"),
##          (assign, ":reward", reg0),
##          (val_mul, ":reward", ":quest_target_amount"),
##          (val_div, ":reward", 2),
##        (else_try),
##          (quest_get_slot, ":reward", ":quest_no", "slot_quest_target_amount"),
##        (try_end),
##        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", ":reward"),
##      (else_try),
##        (eq, ":quest_no", "qst_bring_reinforcements_to_siege"),
##        (quest_get_slot, ":quest_target_amount", ":quest_no", "slot_quest_target_amount"),
##        (quest_get_slot, ":quest_object_troop", ":quest_no", "slot_quest_object_troop"),
##        (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
##        (call_script, "script_game_get_join_cost", ":quest_object_troop"),
##        (assign, ":reward", reg0),
##        (val_mul, ":reward", ":quest_target_amount"),
##        (val_mul, ":reward", 2),
##        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", ":reward"),
##      (else_try),
##        (eq, ":quest_no", "qst_deliver_supply_to_center_under_siege"),
##        (quest_get_slot, ":quest_target_amount", ":quest_no", "slot_quest_target_amount"),
##        (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
##        (store_item_value, ":reward", "itm_siege_supply"),
##        (val_mul, ":reward", ":quest_target_amount"),
##        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", ":reward"),
      (else_try),
        (eq, ":quest_no", "qst_raise_troops"),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", 100),
        (assign, ":quest_return_penalty", -4),
        (assign, ":quest_expire_penalty", -5),
      (else_try),
        (eq, ":quest_no", "qst_deal_with_looters"),
        (try_for_parties, ":cur_party_no"),
          (party_get_template_id, ":cur_party_template", ":cur_party_no"),
          (eq, ":cur_party_template", "pt_looters"),
          (party_set_flags, ":cur_party_no", pf_quest_party, 0),
        (try_end),
        (assign, ":quest_return_penalty", -4),
        (assign, ":quest_expire_penalty", -5),
      (else_try),
        (eq, ":quest_no", "qst_deal_with_bandits_at_lords_village"),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", 200),
        (assign, ":quest_return_penalty", -5),
        (assign, ":quest_expire_penalty", -6),
      (else_try),
        (eq, ":quest_no", "qst_collect_taxes"),
        (quest_get_slot, ":gold_reward", ":quest_no", "slot_quest_gold_reward"),
        (quest_set_slot, ":quest_no", "slot_quest_gold_reward", 0),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", ":gold_reward"),
        (assign, ":quest_return_penalty", -4),
        (assign, ":quest_expire_penalty", -6),
##      (else_try),
##        (eq, ":quest_no", "qst_capture_messenger"),
##      (else_try),
##        (eq, ":quest_no", "qst_bring_back_deserters"),
      (else_try),
        (eq, ":quest_no", "qst_hunt_down_fugitive"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -4),
      (else_try),
        (eq, ":quest_no", "qst_kill_local_merchant"),
      (else_try),
        (eq, ":quest_no", "qst_bring_back_runaway_serfs"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -1),
      (else_try),
        (eq, ":quest_no", "qst_lend_companion"),
      (else_try),
        (eq, ":quest_no", "qst_collect_debt"),
        (try_begin),
          (quest_slot_eq, "qst_collect_debt", "slot_quest_current_state", 1), #debt collected but not delivered
          (quest_get_slot, ":debt", "qst_collect_debt", "slot_quest_target_amount"),
          (quest_get_slot, ":quest_giver", "qst_collect_debt", "slot_quest_giver_troop"),
          (call_script, "script_change_debt_to_troop", ":quest_giver", ":debt"),
          (assign, ":quest_return_penalty", -3),
          (assign, ":quest_expire_penalty", -6),
        (else_try),
          (assign, ":quest_return_penalty", -3),
          (assign, ":quest_expire_penalty", -4),
        (try_end),
      (else_try),
        (eq, ":quest_no", "qst_deal_with_bandits_at_lords_village"),
        (assign, ":quest_return_penalty", -6),
        (assign, ":quest_expire_penalty", -6),
      (else_try),
        (eq, ":quest_no", "qst_cause_provocation"),
        (assign, ":quest_return_penalty", -9),
        (assign, ":quest_expire_penalty", -12),
      (else_try),
        (eq, ":quest_no", "qst_persuade_lords_to_make_peace"),
        (assign, ":quest_return_penalty", -9),
        (assign, ":quest_expire_penalty", -12),
      (else_try),
        (eq, ":quest_no", "qst_deal_with_night_bandits"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -1),
      
      (else_try),
        (eq, ":quest_no", "qst_follow_spy"),
        (assign, ":quest_return_penalty", -2),
        (assign, ":quest_expire_penalty", -3),
        (try_begin),
          (party_is_active, "$qst_follow_spy_spy_party"),
          (remove_party, "$qst_follow_spy_spy_party"),
        (try_end),
        (try_begin),
          (party_is_active, "$qst_follow_spy_spy_partners_party"),
          (remove_party, "$qst_follow_spy_spy_partners_party"),
        (try_end),
      (else_try),
        (eq, ":quest_no", "qst_capture_enemy_hero"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -4),
      (else_try),
        (eq, ":quest_no", "qst_lend_companion"),
        (quest_get_slot, ":quest_target_troop", "qst_lend_companion", "slot_quest_target_troop"),
        (troop_set_slot, ":quest_target_troop", "slot_troop_current_mission", npc_mission_rejoin_when_possible),
	    (troop_set_slot, ":quest_target_troop", "slot_troop_days_on_mission", 0),
      (else_try),
        (eq, ":quest_no", "qst_lend_surgeon"),
        (quest_get_slot, ":quest_target_troop", "qst_lend_surgeon", "slot_quest_target_troop"),
        (troop_set_slot, ":quest_target_troop", "slot_troop_current_mission", npc_mission_rejoin_when_possible),
	    (troop_set_slot, ":quest_target_troop", "slot_troop_days_on_mission", 0),
##        (party_add_members, "p_main_party", ":quest_target_troop", 1),
##      (else_try),
##        (eq, ":quest_no", "qst_capture_conspirators"),
##      (else_try),
##        (eq, ":quest_no", "qst_defend_nobles_against_peasants"),
      (else_try),
        (eq, ":quest_no", "qst_incriminate_loyal_commander"),
        (assign, ":quest_return_penalty", -5),
        (assign, ":quest_expire_penalty", -6),
##      (else_try),
##        (eq, ":quest_no", "qst_hunt_down_raiders"),
##      (else_try),
##        (eq, ":quest_no", "qst_capture_prisoners"),
##        #Enemy lord quests
      (else_try),
        (eq, ":quest_no", "qst_lend_surgeon"),

        #Kingdom lady quests
      (else_try),
        (eq, ":quest_no", "qst_rescue_lord_by_replace"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -1),
      (else_try),
        (eq, ":quest_no", "qst_deliver_message_to_prisoner_lord"),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", -1),
      (else_try),
        (eq, ":quest_no", "qst_duel_for_lady"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -1),
      
      #Kingdom Army quests
      (else_try),
        (eq, ":quest_no", "qst_follow_army"),
        (assign, ":quest_return_penalty", 0), #was -4 
        (assign, ":quest_expire_penalty", 0), #was -5
      (else_try),
        (eq, ":quest_no", "qst_deliver_cattle_to_army"),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", 0),
      (else_try),
        (eq, ":quest_no", "qst_join_siege_with_army"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -2),
      (else_try),
        (eq, ":quest_no", "qst_scout_waypoints"),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", 0),
      
      #Village Elder quests
      (else_try),
        (eq, ":quest_no", "qst_deliver_grain"),
        (assign, ":quest_return_penalty", -6),
        (assign, ":quest_expire_penalty", -7),
      (else_try),
        (eq, ":quest_no", "qst_deliver_cattle"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -4),
      (else_try),
        (eq, ":quest_no", "qst_train_peasants_against_bandits"),
        (assign, ":quest_return_penalty", -4),
        (assign, ":quest_expire_penalty", -5),

      #Mayor quests
      (else_try),
        (eq, ":quest_no", "qst_deliver_wine"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -3),
        (val_add, "$debt_to_merchants_guild", "$qst_deliver_wine_debt"),
      (else_try),
        (eq, ":quest_no", "qst_move_cattle_herd1"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -3),
      (else_try),
        (eq, ":quest_no", "qst_escort_merchant_caravan"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -3),
      (else_try), #anadido chief para quest de obispo
        (eq, ":quest_no", "qst_escort_bishop"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -3),
      (else_try),
        (eq, ":quest_no", "qst_troublesome_bandits"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -2),
      #Other quests
      (else_try),
        (eq, ":quest_no", "qst_join_faction"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -3),
        (try_begin),
          (call_script, "script_get_number_of_hero_centers", "trp_player"),
          (gt, reg0, 0),
          (call_script, "script_change_player_relation_with_faction", "$g_invite_faction", -10),
        (try_end),
		
		
		(try_begin), #if the vassalage is part of a surrender option, then the faction returns to a state of war
		  (quest_slot_eq, "qst_join_faction", "slot_quest_failure_consequence", 1),
		  (call_script, "script_diplomacy_start_war_between_kingdoms", "fac_player_supporters_faction", "$g_invite_faction", logent_player_faction_declares_war),	#MOTO chief pass log entries
#		  (call_script, "script_diplomacy_start_war_between_kingdoms", "fac_player_supporters_faction", "$g_invite_faction", 0),
		  (call_script, "script_change_player_honor", -5),
		  (quest_set_slot, "qst_join_faction", "slot_quest_failure_consequence", 0),
		(try_end),
		
		
        (assign, "$g_invite_faction", 0),
        (assign, "$g_invite_faction_lord", 0),
        (assign, "$g_invite_offered_center", 0),
      (else_try),
        (eq, ":quest_no", "qst_eliminate_bandits_infesting_village"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -3),
	  (else_try),
        (ge, ":quest_no", "qst_resolve_dispute"),
		(assign, ":authority_loss", -2),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", 0),
	  (else_try),
        (ge, ":quest_no", "qst_consult_with_minister"),
		(assign, ":authority_loss", -2),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", 0),
	  (try_end),
	  
      (try_begin),
        (gt, ":abort_type", 0),
        (lt, ":quest_no", "qst_resolve_dispute"),
		
        (quest_get_slot, ":quest_giver", ":quest_no", "slot_quest_giver_troop"),
        (assign, ":relation_penalty", ":quest_return_penalty"),
        (try_begin),
          (eq, ":abort_type", 2),
          (assign, ":relation_penalty", ":quest_expire_penalty"),
        (try_end),
        (try_begin),
          (this_or_next|is_between, ":quest_giver", village_elders_begin, village_elders_end),
          (is_between, ":quest_giver", mayors_begin, mayors_end),
          (quest_get_slot, ":quest_giver_center", ":quest_no", "slot_quest_giver_center"),
          (call_script, "script_change_player_relation_with_center", ":quest_giver_center", ":relation_penalty"),
        (else_try),
          (call_script, "script_change_player_relation_with_troop", ":quest_giver", ":relation_penalty"),
        (try_end),
      (try_end),

      (fail_quest, ":quest_no"),

#NPC companion changes begin
      (try_begin),
        (gt, ":abort_type", 0),
		(neq, ":quest_no", "qst_consult_with_minister"),
		(neq, ":quest_no", "qst_resolve_dispute"),
		(neq, ":quest_no", "qst_visit_lady"),
		(neq, ":quest_no", "qst_formal_marriage_proposal"),
		(neq, ":quest_no", "qst_duel_courtship_rival"),
		(neq, ":quest_no", "qst_follow_army"),
		(neq, ":quest_no", "qst_denounce_lord"),
		(neq, ":quest_no", "qst_intrigue_against_lord"),
		(neq, ":quest_no", "qst_offer_gift"),
		(neq, ":quest_no", "qst_organize_feast"),
		
        (call_script, "script_objectionable_action", tmt_honest, "str_fail_quest"),
      (try_end),
#NPC companion changes end

	  (try_begin),
		(eq, ":quest_no", "qst_resolve_dispute"),
		(faction_slot_eq, "$players_kingdom", "slot_faction_leader", "trp_player"),
		(call_script, "script_change_player_right_to_rule", ":authority_loss"),
		(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":lord_faction", ":lord"),
			(eq, ":lord_faction", "fac_player_supporters_faction"),
			(call_script, "script_troop_change_relation_with_troop", ":lord", "trp_player", ":authority_loss"),
	    (try_end),
	  (try_end),
	  

	  (try_begin),
		(eq, ":quest_no", "qst_organize_feast"),
		(call_script, "script_add_notification_menu", "mnu_notification_feast_quest_expired", 0, 0),
	  (try_end),
	  
	  
      (call_script, "script_end_quest", ":quest_no"),
  ]),
  
  
##  # script_event_center_captured
##  # Input: arg1 = center_no, arg2 = old_faction_no
##  # Output: none
##  ("event_center_captured",
##    [
##      #      (store_script_param_1, ":center_no"),
##      #       (store_script_param_2, ":old_faction_no"),
##      #       (store_faction_of_party, ":faction_no"),
##      
##      (try_begin),
##        (check_quest_active, "qst_deliver_message"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_escort_lady"),
##        (quest_slot_eq, "qst_escort_lady", "slot_quest_target_center", ":center_no"),
##        (call_script, "script_abort_quest", "qst_escort_lady"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_rescue_lady_under_siege"),
##        (quest_slot_eq, "qst_rescue_lady_under_siege", "slot_quest_target_center", ":center_no"),
##        (quest_slot_eq, "qst_rescue_lady_under_siege", "slot_quest_current_state", 0),
##        (call_script, "script_abort_quest", "qst_rescue_lady_under_siege", 1),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_deliver_message_to_lover"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_deliver_message_to_enemy_lord"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_bring_prisoners_to_enemy"),
##        (quest_slot_eq, "qst_bring_prisoners_to_enemy", "slot_quest_target_center", ":center_no"),
##        (neg|check_quest_succeeded, "qst_bring_prisoners_to_enemy"),
##        (call_script, "script_abort_quest", "qst_bring_prisoners_to_enemy"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_bring_reinforcements_to_siege"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_deliver_supply_to_center_under_siege"),
##        (quest_slot_eq, "qst_deliver_supply_to_center_under_siege", "slot_quest_target_center", ":center_no"),
##        (call_script, "script_abort_quest", "qst_deliver_supply_to_center_under_siege", 1),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_raise_troops"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_capture_messenger"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_bring_back_deserters"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_kill_local_merchant"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_bring_back_runaway_serfs"),
##        (quest_slot_eq, "qst_bring_back_runaway_serfs", "slot_quest_object_center", ":center_no"),
##        (neg|check_quest_succeeded, "qst_bring_back_runaway_serfs"),
##        (neg|check_quest_failed, "qst_bring_back_runaway_serfs"),
##        (call_script, "script_abort_quest", "qst_bring_back_runaway_serfs"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_follow_spy"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_capture_enemy_hero"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_lend_companion"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_capture_conspirators"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_defend_nobles_against_peasants"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_incriminate_loyal_commander"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_hunt_down_raiders"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_capture_prisoners"),
##      (try_end),
##      #Enemy lord quests
##      (try_begin),
##        (check_quest_active, "qst_lend_surgeon"),
##      (try_end),
##      #Kingdom lady quests
##      (try_begin),
##        (check_quest_active, "qst_rescue_lord_by_replace"),
##        (quest_get_slot, ":quest_target_troop", "qst_rescue_lord_by_replace", "slot_quest_target_troop"),
##        (troop_slot_eq, ":quest_target_troop", "slot_troop_is_prisoner", 0),
##        (neg|check_quest_succeeded, "qst_rescue_lord_by_replace"),
##        (call_script, "script_abort_quest", "qst_rescue_lord_by_replace"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_deliver_message_to_prisoner_lord"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_duel_for_lady"),
##      (try_end),
##  ]),

  # script_cf_is_quest_troop
  # Input: arg1 = troop_no
  # Output: none (can fail)
  ("cf_is_quest_troop",
    [
      (store_script_param_1, ":troop_no"),
      (assign, ":is_quest_troop", 0),
      (try_for_range, ":cur_quest", all_quests_begin, all_quests_end),
        (check_quest_active, ":cur_quest"),
        (quest_get_slot, ":quest_troop_1", ":cur_quest", "slot_quest_target_troop"),
        (quest_get_slot, ":quest_troop_2", ":cur_quest", "slot_quest_object_troop"),
        (quest_get_slot, ":quest_troop_3", ":cur_quest", "slot_quest_giver_troop"),
        (this_or_next|eq, ":quest_troop_1", ":troop_no"),
        (this_or_next|eq, ":quest_troop_2", ":troop_no"),
        (eq, ":quest_troop_3", ":troop_no"),
        (assign, ":is_quest_troop", 1),
      (try_end),
      (eq, ":is_quest_troop", 1),
  ]),

  
##  # script_calculate_team_strength
##  # Input: arg1 = team_no
##  # Output: strength
##  ("calculate_team_strength",
##    [
##      (store_script_param_1, ":team_no"),
##      (assign, ":total_strength", 0),
##      (try_for_agents, ":cur_agent"),
##        (agent_get_team, ":agent_team", ":cur_agent"),
##        (eq, ":team_no", ":agent_team"),
##        (agent_is_human, ":cur_agent"),
##        (agent_is_alive, ":cur_agent"),
##        
##        (agent_get_troop_id, ":cur_troop", ":cur_agent"),
##        (store_character_level, ":cur_level", ":cur_troop"),
##        (val_add, ":cur_level", 5),
##        (try_begin),
##          (troop_is_hero, ":cur_troop"),
##          (val_add, ":cur_level", 5),
##        (try_end),
##        (val_add, ":total_strength", ":cur_level"),
##      (try_end),
##      (assign, reg0, ":total_strength"),
##  ]),

  # script_check_friendly_kills
  # Input: none
  # Output: none (changes the morale of the player's party)
  ("check_friendly_kills",
    [(get_player_agent_own_troop_kill_count, ":count"),
     (try_begin),
       (neq, "$g_player_current_own_troop_kills", ":count"),
       (val_sub, ":count", "$g_player_current_own_troop_kills"),
       (val_add, "$g_player_current_own_troop_kills", ":count"),
       (val_mul, ":count", -1),
       (call_script, "script_change_player_party_morale", ":count"),
     (try_end),
   ]),

  # script_simulate_retreat
  # Input: arg1 = players_side_damage, arg2 = enemy_side_damage, arg3 = continue_battle s5 = title_string
  # Output: none
  ("simulate_retreat",
    [
      (call_script, "script_music_set_situation_with_culture", mtf_sit_killed),
      (set_show_messages, 0),
      (store_script_param, ":players_side_damage", 1),
      (store_script_param, ":enemy_side_damage", 2),
      (store_script_param, ":continue_battle", 3),

      (assign, ":players_side_strength", 0),
      (assign, ":enemy_side_strength", 0),
      
      (assign, ":do_calculate", 1),
      (try_begin),
        (try_for_agents, ":cur_agent"),
          (agent_is_human, ":cur_agent"),
          (agent_is_alive, ":cur_agent"),
          (agent_set_slot, ":cur_agent", "slot_agent_is_alive_before_retreat", 1),#needed for simulation

          (agent_get_troop_id, ":cur_troop", ":cur_agent"),
          (store_character_level, ":cur_level", ":cur_troop"),
          (val_add, ":cur_level", 5),
          (try_begin),
            (troop_is_hero, ":cur_troop"),
            (val_add, ":cur_level", 5),
          (try_end),
          (try_begin),
            (agent_is_ally, ":cur_agent"),
            (val_add, ":players_side_strength", ":cur_level"),
          (else_try),
            (val_add, ":enemy_side_strength", ":cur_level"),
          (try_end),
        (try_end),
        (eq, "$pin_player_fallen", 0),
        (lt, ":enemy_side_strength", ":players_side_strength"),
        (eq, ":continue_battle", 1),
        (assign, ":do_calculate", 0),
      (try_end),
      
      (try_begin),
        (eq, ":do_calculate", 1),
        
        (assign, "$g_last_mission_player_damage", 0),
        (party_clear, "p_temp_party"),
        (party_clear, "p_temp_party_2"),
        (call_script, "script_simulate_battle_with_agents_aux", 0, ":players_side_damage"),
        (call_script, "script_simulate_battle_with_agents_aux", 1, ":enemy_side_damage"),
        
        (assign, ":display_casualties", 0),
        
        (try_begin),
          (gt, "$g_last_mission_player_damage", 0),
          (assign, ":display_casualties", 1),
          (assign, reg1, "$g_last_mission_player_damage"),
          (str_store_string, s12, "str_casualty_display_hp"),
        (else_try),
          (str_clear, s12),
        (try_end),
        
        (call_script, "script_print_casualties_to_s0", "p_temp_party", 1),
        (try_begin),
          (party_get_num_companion_stacks, ":num_stacks", "p_temp_party"),
          (gt, ":num_stacks", 0),
          (assign, ":display_casualties", 1),
        (try_end),
        (str_store_string_reg, s10, s0),
        
        (call_script, "script_print_casualties_to_s0", "p_temp_party_2", 1),
        (try_begin),
          (party_get_num_companion_stacks, ":num_stacks", "p_temp_party_2"),
          (gt, ":num_stacks", 0),
          (assign, ":display_casualties", 1),
        (try_end),
        (str_store_string_reg, s11, s0),
        (try_begin),
          (eq, ":display_casualties", 1),
          (dialog_box,"str_casualty_display", s5),
        (try_end),
      (try_end),
      (set_show_messages, 1),

      #Calculating morale penalty (can be between 0-30)
      (assign, ":ally_casualties", 0),
      (assign, ":enemy_casualties", 0),
      (assign, ":total_allies", 0),
      
      (try_for_agents, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (try_begin),
          (agent_is_ally, ":cur_agent"),
          (val_add, ":total_allies", 1),
          (try_begin),
            (neg|agent_is_alive, ":cur_agent"),
            (val_add, ":ally_casualties", 1),
          (try_end),
        (else_try),
          (neg|agent_is_alive, ":cur_agent"),
          (val_add, ":enemy_casualties", 1),
        (try_end),
      (try_end),
      (store_add, ":total_casualties", ":ally_casualties", ":enemy_casualties"),
      (try_begin),
        (gt, ":total_casualties", 1),
        (store_mul, ":morale_adder", ":ally_casualties", 100),
        (val_div, ":morale_adder", ":total_casualties"),
        (val_mul, ":morale_adder", ":ally_casualties"),
        (val_div, ":morale_adder", ":total_allies"),
        (val_mul, ":morale_adder", -30),
        (val_div, ":morale_adder", 100),
        (call_script, "script_change_player_party_morale", ":morale_adder"),
      (else_try),
         (le, ":total_casualties", 1),
         (call_script, "script_change_player_party_morale", -17),
      (try_end),
  ]),

  
  
  # script_simulate_battle_with_agents_aux
  # For internal use only
  # Input: arg1 = attacker_side (0 = ally, 1 = enemy), arg2 = damage amount
  # Output: none
  ("simulate_battle_with_agents_aux",
    [
      (store_script_param_1, ":attacker_side"),
      (store_script_param_2, ":damage"),
      
      (get_player_agent_no, ":player_agent"),
      (try_for_agents, ":cur_agent"),
        (neq, ":player_agent", ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        #do not check agent_is_alive, check "slot_agent_is_alive_before_retreat" instead, so that dead agents can still hit enemies
        (agent_slot_eq, ":cur_agent", "slot_agent_is_alive_before_retreat", 1),
        (try_begin),
          (agent_is_ally, ":cur_agent"),
          (assign, ":cur_agents_side", 0),
        (else_try),
          (assign, ":cur_agents_side", 1),
        (try_end),
        (eq, ":cur_agents_side", ":attacker_side"),
        (agent_get_position, pos2, ":cur_agent"),
        (assign, ":closest_agent", -1),
        (assign, ":min_distance", 100000),
        (try_for_agents, ":cur_agent_2"),
          (agent_is_human, ":cur_agent_2"),
          (agent_is_alive, ":cur_agent_2"),
          (try_begin),
            (agent_is_ally, ":cur_agent_2"),
            (assign, ":cur_agents_side_2", 0),
          (else_try),
            (assign, ":cur_agents_side_2", 1),
          (try_end),
          (this_or_next|neq, ":cur_agent_2", ":player_agent"),
          (eq, "$pin_player_fallen", 0),
          (neq, ":attacker_side", ":cur_agents_side_2"),
          (agent_get_position, pos3, ":cur_agent_2"),
          (get_distance_between_positions, ":cur_distance", pos2, pos3),
          (lt, ":cur_distance", ":min_distance"),
          (assign, ":min_distance", ":cur_distance"),
          (assign, ":closest_agent", ":cur_agent_2"),
        (try_end),
        (ge, ":closest_agent", 0),
        #Fight
        (agent_get_class, ":agent_class", ":cur_agent"), 
        (assign, ":agents_speed", 1),
        (assign, ":agents_additional_hit", 0),
        (try_begin),
          (eq, ":agent_class", grc_archers),
          (assign, ":agents_additional_hit", 2),
        (else_try),
          (eq, ":agent_class", grc_cavalry),
          (assign, ":agents_speed", 2),
        (try_end),
        (agent_get_class, ":agent_class", ":closest_agent"),
        (assign, ":agents_speed_2", 1),
        (try_begin),
          (eq, ":agent_class", grc_cavalry),
          (assign, ":agents_speed_2", 2),
        (try_end),
        (assign, ":agents_hit", 18000),
        (val_add, ":min_distance", 3000),
        (val_div, ":agents_hit", ":min_distance"),
        (val_mul, ":agents_hit", 2),# max 10, min 2 hits within 150 meters
        
        (val_mul, ":agents_hit", ":agents_speed"),
        (val_div, ":agents_hit", ":agents_speed_2"),
        (val_add, ":agents_hit", ":agents_additional_hit"),
        
        (assign, ":cur_damage", ":damage"),
        (agent_get_troop_id, ":closest_troop", ":closest_agent"),
        (agent_get_troop_id, ":cur_troop", ":cur_agent"),
        (store_character_level, ":closest_level", ":closest_troop"),
        (store_character_level, ":cur_level", ":cur_troop"),
        (store_sub, ":level_dif", ":cur_level", ":closest_level"),
        (val_div, ":level_dif", 5),
        (val_add, ":cur_damage", ":level_dif"),
        
        (try_begin),
          (eq, ":closest_agent", ":player_agent"),
          (val_div, ":cur_damage", 2),
          (store_agent_hit_points, ":init_player_hit_points", ":player_agent", 1),
        (try_end),
        
        (try_for_range, ":unused", 0, ":agents_hit"),
          (store_random_in_range, ":random_damage", 0, 100),
          (lt, ":random_damage", ":cur_damage"),
          (agent_deliver_damage_to_agent, ":cur_agent", ":closest_agent"),
        (try_end),
        
        (try_begin),
          (eq, ":closest_agent", ":player_agent"),
          (store_agent_hit_points, ":final_player_hit_points", ":player_agent", 1),
          (store_sub, ":hit_points_difference", ":init_player_hit_points", ":final_player_hit_points"),
          (val_add, "$g_last_mission_player_damage", ":hit_points_difference"),
        (try_end),
        
        (neg|agent_is_alive, ":closest_agent"),
        (try_begin),
          (eq, ":attacker_side", 1),
          (party_add_members, "p_temp_party", ":closest_troop", 1),
          (try_begin),
            (agent_is_wounded, ":closest_agent"),
            (party_wound_members, "p_temp_party", ":closest_troop", 1),
          (try_end),
        (else_try),
          (party_add_members, "p_temp_party_2", ":closest_troop", 1),
          (try_begin),
            (agent_is_wounded, ":closest_agent"),
            (party_wound_members, "p_temp_party_2", ":closest_troop", 1),
          (try_end),
        (try_end),
      (try_end),
  ]),
  
  
  # script_map_get_random_position_around_position_within_range
  # Input: arg1 = minimum_distance in km, arg2 = maximum_distance in km, pos1 = origin position
  # Output: pos2 = result position
  ("map_get_random_position_around_position_within_range",
    [
      (store_script_param_1, ":min_distance"),
      (store_script_param_2, ":max_distance"),
      (val_mul, ":min_distance", 100),
      (assign, ":continue", 1),
      (try_for_range, ":unused", 0, 20),
        (eq, ":continue", 1),
        (map_get_random_position_around_position, pos2, pos1, ":max_distance"),
        (get_distance_between_positions, ":distance", pos2, pos1),
        (ge, ":distance", ":min_distance"),
        (assign, ":continue", 0),
      (try_end),
  ]),
  
  
  # script_get_number_of_unclaimed_centers_by_player
  # Input: none
  # Output: reg0 = number of unclaimed centers, reg1 = last unclaimed center_no
  ("get_number_of_unclaimed_centers_by_player",
    [
      (assign, ":unclaimed_centers", 0),
      (assign, reg1, -1),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_faction_of_party, ":faction_no", ":center_no"),
        (eq, ":faction_no", "fac_player_supporters_faction"),
        #(party_slot_eq, ":center_no", "slot_town_claimed_by_player", 0),
        (party_get_num_companion_stacks, ":num_stacks", ":center_no"),
        (ge, ":num_stacks", 1), #castle is garrisoned
        (assign, reg1, ":center_no"),
        (val_add, ":unclaimed_centers", 1),
      (try_end),
      (assign, reg0, ":unclaimed_centers"),
  ]),
  
  # script_troop_count_number_of_enemy_troops
  # Input: arg1 = troop_no
  # Output: reg0 = number_of_enemy_troops
#  ("troop_count_number_of_enemy_troops",
#    [
#      (store_script_param_1, ":troop_no"),
#      (assign, ":enemy_count", 0),
#      (try_for_range, ":i_enemy_slot", "slot_troop_enemies_begin", "slot_troop_enemies_end"),
#        (troop_slot_ge, ":troop_no", ":i_enemy_slot", 1),
#        (val_add, ":enemy_count", 1),
#      (try_end),
#      (assign, reg0, ":enemy_count"),
#  ]),
  
  
  # script_cf_troop_check_troop_is_enemy
  # Input: arg1 = troop_no, arg2 = checked_troop_no
  # Output: none (Can fail)
  ("cf_troop_check_troop_is_enemy",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":checked_troop_no"),
	  (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":checked_troop_no"),
	  (lt, reg0, -10),
 ]),
  
  
  # script_troop_get_leaded_center_with_index
  # Input: arg1 = troop_no, arg2 = center index within range between zero and the number of centers that troop owns
  # Output: reg0 = center_no
  ("troop_get_leaded_center_with_index",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":random_center"),
      (assign, ":result", -1),
      (assign, ":center_count", 0),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (eq, ":result", -1),
        (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
        (val_add, ":center_count", 1),
        (gt, ":center_count", ":random_center"),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),
  
  # script_cf_troop_get_random_leaded_walled_center_with_less_strength_priority
  # Input: arg1 = troop_no, arg2 = preferred_center_no
  # Output: reg0 = center_no (Can fail)
  ("cf_troop_get_random_leaded_walled_center_with_less_strength_priority",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":preferred_center_no", 2),

      (assign, ":num_centers", 0),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
        (party_slot_eq, ":center_no", "slot_center_is_besieged_by", -1),
        (val_add, ":num_centers", 1),
        (try_begin),
          (eq, ":center_no", ":preferred_center_no"),
          (val_add, ":num_centers", 99),
        (try_end),
##        (call_script, "script_party_calculate_regular_strength", ":center_no"),
##        (assign, ":strength", reg0),
##        (lt, ":strength", 80),
##        (store_sub, ":strength", 100, ":strength"),
##        (val_div, ":strength", 20),
##        (val_add, ":num_centers", ":strength"),
      (try_end),
      (gt, ":num_centers", 0),
      (store_random_in_range, ":random_center", 0, ":num_centers"),
      (assign, ":result", -1),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
        (party_slot_eq, ":center_no", "slot_center_is_besieged_by", -1),
        (val_sub, ":random_center", 1),
        (try_begin),
          (eq, ":center_no", ":preferred_center_no"),
          (val_sub, ":random_center", 99),
        (try_end),
##        (try_begin),
##          (call_script, "script_party_calculate_regular_strength", ":center_no"),
##          (assign, ":strength", reg0),
##          (lt, ":strength", 80),
##          (store_sub, ":strength", 100, ":strength"),
##          (val_div, ":strength", 20),
##          (val_sub, ":random_center", ":strength"),
##        (try_end),
        (lt, ":random_center", 0),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  # script_cf_troop_get_random_leaded_town_or_village_except_center
  # Input: arg1 = troop_no, arg2 = except_center_no
  # Output: reg0 = center_no (Can fail)
  ("cf_troop_get_random_leaded_town_or_village_except_center",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":except_center_no"),

      (assign, ":num_centers", 0),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (neg|party_slot_eq, ":center_no", "slot_party_type", spt_castle),
        (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
        (neq, ":center_no", ":except_center_no"),
        (val_add, ":num_centers", 1),
      (try_end),

      (gt, ":num_centers", 0),
      (store_random_in_range, ":random_center", 0, ":num_centers"),
      (assign, ":end_cond", centers_end),
      (try_for_range, ":center_no", centers_begin, ":end_cond"),
        (neg|party_slot_eq, ":center_no", "slot_party_type", spt_castle),
        (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
        (neq, ":center_no", ":except_center_no"),
        (val_sub, ":random_center", 1),
        (lt, ":random_center", 0),
        (assign, ":target_center", ":center_no"),
        (assign, ":end_cond", 0),
      (try_end),
      (assign, reg0, ":target_center"),
  ]),

  # script_troop_write_owned_centers_to_s2
  # Input: arg1 = troop_no
  # Output: none
  ("troop_write_owned_centers_to_s2",
    [
      (store_script_param_1, ":troop_no"),
      
      (call_script, "script_get_number_of_hero_centers", ":troop_no"),
      (assign, ":no_centers", reg0),
      
      (str_store_troop_name, s5, ":troop_no"),
      
      (try_begin),
        (gt, ":no_centers", 1),
        (try_for_range, ":i_center", 1, ":no_centers"),
          (call_script, "script_troop_get_leaded_center_with_index", ":troop_no", ":i_center"),
          (str_store_party_name_link, s50, reg0),
          (try_begin),
            (eq, ":i_center", 1),
            (call_script, "script_troop_get_leaded_center_with_index", ":troop_no", 0),
            (str_store_party_name_link, s51, reg0),
            (str_store_string, s51, "str_s50_and_s51"),
          (else_try),
            (str_store_string, s51, "str_s50_comma_s51"),
          (try_end),
        (try_end),
        (str_store_string, s2, "str_s5_is_the_ruler_of_s51"),
      (else_try),
        (eq, ":no_centers", 1),
        (call_script, "script_troop_get_leaded_center_with_index", ":troop_no", 0),
        (str_store_party_name_link, s51, reg0),
        (str_store_string, s2, "str_s5_is_the_ruler_of_s51"),
      (else_try),
        (store_troop_faction, ":faction_no", ":troop_no"),
        (str_store_faction_name_link, s6, ":faction_no"),
        (str_store_string, s2, "str_s5_is_a_nobleman_of_s6"),
      (try_end),
  ]),
  
     ###gdw floris mod 081515
   ("troop_get_family_relation_to_troop",
		[
		(store_script_param_1, ":troop_1"),
		(store_script_param_2, ":troop_2"),
	
	    (troop_get_type, ":gender_1", ":troop_1"),
       (val_mod, ":gender_1", 2),    #gender fix chief moto
        #(troop_get_type, ":gender_1", ":troop_1"),
      ####gdw Floris script below
		# (call_script, "script_dplmc_store_troop_is_female", ":troop_1"),
		#(assign, ":gender_1", reg0),##gdw Don't use this. it will cause ladies to call themselves sons of 
		##diplomacy end+
		(assign, ":relation_strength", 0),

		(troop_get_slot, ":spouse_of_1", ":troop_1", "slot_troop_spouse"),
		(troop_get_slot, ":spouse_of_2", ":troop_2", "slot_troop_spouse"),

		(try_begin),
			(gt, ":spouse_of_1", -1),
			(troop_get_slot, ":father_of_spouse_of_1", ":spouse_of_1", "slot_troop_father"),
		(else_try),
			(assign, ":father_of_spouse_of_1", -1),
		(try_end),

		(try_begin),
			(gt, ":spouse_of_2", -1),
			(troop_get_slot, ":father_of_spouse_of_2", ":spouse_of_2", "slot_troop_father"),
		(else_try),
			(assign, ":father_of_spouse_of_2", -1),
		(try_end),

		(try_begin),
			(gt, ":spouse_of_2", -1),
			(troop_get_slot, ":mother_of_spouse_of_2", ":spouse_of_2", "slot_troop_mother"),
		(else_try),
			(assign, ":mother_of_spouse_of_2", -1),
		(try_end),

		(troop_get_slot, ":father_of_1", ":troop_1", "slot_troop_father"),
		(troop_get_slot, ":father_of_2", ":troop_2", "slot_troop_father"),

		#For the sake of simplicity, we can assume that all male aristocrats in prior generations either married commoners or procured their brides from the Old Country, thus discounting intermarriage
		(troop_get_slot, ":mother_of_1", ":troop_1", "slot_troop_mother"),
		(troop_get_slot, ":mother_of_2", ":troop_2", "slot_troop_mother"),

		##diplomacy start+
		#Fix a native bug where daughters are their own mothers
			#(fixed in this mod, but still affects old saved games)
			#REMOVED - Instead this occurs once in simple triggers

		##Adding paternal grandmother (begin mostly-unaltered section)
		(try_begin),
			(this_or_next|eq, ":father_of_1", "trp_player"),#dplmc+ added
			(is_between, ":father_of_1", companions_begin, kingdom_ladies_end),
			(troop_get_slot, ":paternal_grandfather_of_1", ":father_of_1", "slot_troop_father"),
			(troop_get_slot, ":paternal_grandmother_of_1", ":father_of_1", "slot_troop_mother"),#added
		(else_try),
			(assign, ":paternal_grandfather_of_1", -1),
			(assign, ":paternal_grandmother_of_1", -1),#added
		(try_end),

		(try_begin),
			(this_or_next|eq, ":father_of_2", "trp_player"),#dplmc+ added
			(is_between, ":father_of_2", companions_begin, kingdom_ladies_end),
			(troop_get_slot, ":paternal_grandfather_of_2", ":father_of_2", "slot_troop_father"),
			(troop_get_slot, ":paternal_grandmother_of_2", ":father_of_2", "slot_troop_mother"),#added
		(else_try),
			(assign, ":paternal_grandfather_of_2", -1),
			(assign, ":paternal_grandmother_of_2", -1),#added
		(try_end),
		#(end mostly-unaltered section)

		##Adding maternal grandfather and maternal grandmother
		(try_begin),
			(this_or_next|eq, ":mother_of_1", "trp_player"),#dplmc+ added
			(is_between, ":mother_of_1", companions_begin, kingdom_ladies_end),
			(troop_get_slot, ":maternal_grandfather_of_1", ":mother_of_1", "slot_troop_father"),
			(troop_get_slot, ":maternal_grandmother_of_1", ":mother_of_1", "slot_troop_mother"),
		(else_try),
			(assign, ":maternal_grandfather_of_1", -1),
			(assign, ":maternal_grandmother_of_1", -1),
		(try_end),

		(try_begin),
			(this_or_next|eq, ":mother_of_2", "trp_player"),#dplmc+ added
			(is_between, ":mother_of_2", companions_begin, kingdom_ladies_end),
			(troop_get_slot, ":maternal_grandfather_of_2", ":mother_of_2", "slot_troop_father"),
			(troop_get_slot, ":maternal_grandmother_of_2", ":mother_of_2", "slot_troop_mother"),
		(else_try),
			(assign, ":maternal_grandfather_of_2", -1),
			(assign, ":maternal_grandmother_of_2", -1),
		(try_end),
		##diplomacy end+

		(troop_get_slot, ":guardian_of_1", ":troop_1", "slot_troop_guardian"),
		(troop_get_slot, ":guardian_of_2", ":troop_2", "slot_troop_guardian"),

		(str_store_string, s11, "str_no_relation"),

		(try_begin),
		  (eq, ":troop_1", ":troop_2"),
		  #self
		(else_try),
		  ##diplomacy start+
		  (this_or_next|eq, ":spouse_of_2", ":troop_1"),#polygamy helper
		  ##diplomacy end+
		  (eq, ":spouse_of_1", ":troop_2"),
		  (assign, ":relation_strength", 24),##gdw15
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_wife"),
		  (else_try),
			(str_store_string, s11, "str_husband"),
		  (try_end),
		(else_try),
		  (eq, ":father_of_2", ":troop_1"),
		  (assign, ":relation_strength", 24),##gdw15
		  (str_store_string, s11, "str_father"),
		(else_try),
		  (eq, ":mother_of_2", ":troop_1"),
		  (assign, ":relation_strength", 24),##gdw15
		  (str_store_string, s11, "str_mother"),
		(else_try),
		  (this_or_next|eq, ":father_of_1", ":troop_2"),
		  (eq, ":mother_of_1", ":troop_2"),
		  (assign, ":relation_strength", 24),##gdw15
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_daughter"),
		  (else_try),
			(str_store_string, s11, "str_son"),
		  (try_end),
		##diplomacy start+
		(else_try),
		   #Check for half-siblings: sharing a father
		   (neq, ":father_of_1", -1),
		   (eq, ":father_of_1", ":father_of_2"),
		   (neq, ":mother_of_1", ":mother_of_2"),
		   (assign, ":relation_strength", 17),##gdw10
		   (try_begin),
			 (eq, ":gender_1", 1),
			 (str_store_string, s11, "str_dplmc_half_sister"),
		   (else_try),
			 (str_store_string, s11, "str_dplmc_half_brother"),
		   (try_end),
	   (else_try),
		   #Check for half-siblings: sharing a mother
		   (neq, ":mother_of_1", -1),
		   (eq, ":mother_of_1", ":mother_of_2"),
		   (neq, ":father_of_1", ":father_of_2"),
		   (assign, ":relation_strength", 17),##gdw10
		   (try_begin),
			 (eq, ":gender_1", 1),
			 (str_store_string, s11, "str_dplmc_half_sister"),
		   (else_try),
			 (str_store_string, s11, "str_dplmc_half_brother"),
		   (try_end),
		##diplomacy end+
		(else_try),
		  #(gt, ":father_of_1", -1), #necessary, as some lords do not have the father registered #dplmc+ replaced
		  (neq, ":father_of_1", -1), #dplmc+ added
		  (eq, ":father_of_1", ":father_of_2"),
		  (assign, ":relation_strength", 17),##gdw10
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_sister"),
		  (else_try),
			(str_store_string, s11, "str_brother"),
		  (try_end),
		(else_try),
		  (eq, ":guardian_of_2", ":troop_1"),
		  (assign, ":relation_strength", 17),  ##gdw10
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_sister"),
		  (else_try),
			(str_store_string, s11, "str_brother"),
		  (try_end),
		(else_try),
		  (eq, ":guardian_of_1", ":troop_2"),
		  (assign, ":relation_strength", 17), ##gdw10
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_sister"),
		  (else_try),
			(str_store_string, s11, "str_brother"),
		  (try_end),
		##diplomacy start+
		(else_try),#polygamy, between two people married to the same person
		   (neq, ":spouse_of_1", -1),
		   (eq, ":spouse_of_2", ":spouse_of_1"),
		   (assign, ":relation_strength", 17),  ##gdw10
		   (try_begin),
			  (eq, ":gender_1", 1),
			  (str_store_string, s11, "str_dplmc_sister_wife"),
		   (else_try),
			  (str_store_string, s11, "str_dplmc_co_husband"),
		   (try_end),
		##diplomacy end+
		(else_try),
		  #(gt, ":paternal_grandfather_of_1", -1),#dplmc+ replaced
		  (neq, ":father_of_2", -1),#dplmc+ added
		  (this_or_next|eq, ":maternal_grandfather_of_1", ":father_of_2"),#dplmc+ added
		  (eq, ":paternal_grandfather_of_1", ":father_of_2"),
		  (assign, ":relation_strength", 8),  ##gdw4
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_niece"),
		  (else_try),
			(str_store_string, s11, "str_nephew"),
		  (try_end),
		##diplomacy start+: add niece/nephew through mother
		(else_try),
		  (neq, ":mother_of_2", -1),
		  (this_or_next|eq, ":maternal_grandmother_of_1", ":mother_of_2"),
		  (eq, ":paternal_grandmother_of_1", ":mother_of_2"),
		  (assign, ":relation_strength", 8),  ##gdw4
		  (try_begin),
			(eq, ":gender_1", tf_female),
			(str_store_string, s11, "str_niece"),
		  (else_try),
			(str_store_string, s11, "str_nephew"),
		  (try_end),
		##diplomacy end+
		(else_try), #specifically aunt and uncle by blood -- i assume that in a medieval society with lots of internal family conflicts, they would not include aunts and uncles by marriage
		  #(gt, ":paternal_grandfather_of_2", -1),#dplmc+ replaced
		  (neq, ":father_of_1", -1),#dplmc+ added
		  (this_or_next|eq, ":maternal_grandfather_of_2", ":father_of_1"),#dplmc+ added
		  (eq, ":paternal_grandfather_of_2", ":father_of_1"),
		  (assign, ":relation_strength", 8),  ##gdw4
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_aunt"),
		  (else_try),
			(str_store_string, s11, "str_uncle"),
		  (try_end),
		##diplomacy start+
		#blood uncles & blood aunts, continued (via mother)
		(else_try),
		  (neq, ":mother_of_1", -1),
		  (this_or_next|eq, ":maternal_grandmother_of_2", ":mother_of_1"),
		  (eq, ":paternal_grandmother_of_2", ":mother_of_1"),
		  (assign, ":relation_strength", 8), ##gdw4
		  (try_begin),
			(eq, ":gender_1", tf_female),
			(str_store_string, s11, "str_aunt"),
		  (else_try),
			(str_store_string, s11, "str_uncle"),
		  (try_end),
		##diplomacy end+
		(else_try),
		  #(gt, ":paternal_grandfather_of_1", 0),#dplmc+ replaced (why was this one "gt 0" but the previous "gt -1"?)
		  (neq, ":paternal_grandfather_of_1", -1),#dplmc+ added
		  (this_or_next|eq, ":maternal_grandfather_of_2", ":paternal_grandfather_of_1"),#dplmc+ added
		  (eq, ":paternal_grandfather_of_2", ":paternal_grandfather_of_1"),
		  (assign, ":relation_strength", 4),  ##gdw2
		  (str_store_string, s11, "str_cousin"),
		##diplomacy start+
		#Add cousin via paternal grandmother or maternal grandparents
		(else_try),
		  (neq, ":maternal_grandfather_of_1", -1),
		  (this_or_next|eq, ":maternal_grandfather_of_2", ":maternal_grandfather_of_1"),
		  (eq, ":paternal_grandfather_of_2", ":maternal_grandfather_of_1"),
		  (assign, ":relation_strength", 4),  ##gdw2
		  (str_store_string, s11, "str_cousin"),
		(else_try),
		  (neq, ":paternal_grandmother_of_1", -1),
		  (this_or_next|eq, ":maternal_grandmother_of_2", ":paternal_grandmother_of_1"),
		  (eq, ":paternal_grandmother_of_2", ":paternal_grandmother_of_1"),
		  (assign, ":relation_strength", 4),  ##gdw2
		  (str_store_string, s11, "str_cousin"),
		(else_try),
		  (neq, ":maternal_grandmother_of_1", -1),
		  (this_or_next|eq, ":maternal_grandmother_of_2", ":maternal_grandmother_of_1"),
		  (eq, ":paternal_grandmother_of_2", ":maternal_grandmother_of_1"),
		  (assign, ":relation_strength", 4),  ##gdw2
		  (str_store_string, s11, "str_cousin"),
		##diplomacy end+
		(else_try),
		  (eq, ":father_of_spouse_of_1", ":troop_2"),
		  (assign, ":relation_strength", 10),  ##gdw5
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_daughterinlaw"),
		  (else_try),
			(str_store_string, s11, "str_soninlaw"),
		  (try_end),
		(else_try),
		  (eq, ":father_of_spouse_of_2", ":troop_1"),
		  (assign, ":relation_strength", 10),  ##gdw5
		  (str_store_string, s11, "str_fatherinlaw"),
		(else_try),
		  (eq, ":mother_of_spouse_of_2", ":troop_1"),
		  (neq, ":mother_of_spouse_of_2", "trp_player"), #May be necessary if mother for troops not set to -1
		  (assign, ":relation_strength", 10),  ##gdw2
		  (str_store_string, s11, "str_motherinlaw"),

		(else_try),
		  #(gt, ":father_of_spouse_of_1", -1), #necessary #dplmc+ replaced
		  (neq, ":father_of_spouse_of_1", -1), #dplmc+ added
		  (eq, ":father_of_spouse_of_1", ":father_of_2"),
		  (assign, ":relation_strength", 10),  ##gdw5
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_sisterinlaw"),
		  (else_try),
			(str_store_string, s11, "str_brotherinlaw"),
		  (try_end),
		(else_try),
		  #(gt, ":father_of_spouse_of_2", -1), #necessary #dplmc+ replaced
		  (neq, ":father_of_spouse_of_2", -1), #dplmc+ added
		  (eq, ":father_of_spouse_of_2", ":father_of_1"),
		  (assign, ":relation_strength", 10),  ##gdw5
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_sisterinlaw"),
		  (else_try),
			(str_store_string, s11, "str_brotherinlaw"),
		  (try_end),
		(else_try),
	#	  (gt, ":spouse_of_2", -1), #necessary to avoid bug #dplmc+ replaced
		  (neq, ":spouse_of_2", -1), #dplmc+ added
		  (troop_slot_eq, ":spouse_of_2", "slot_troop_guardian", ":troop_1"),
		  (assign, ":relation_strength", 10),  ##gdw5
		  (try_begin),
			#(eq, ":gender_1", 1),#dplmc+ replaced
			(eq, ":gender_1", tf_female),#dplmc+ added
			(str_store_string, s11, "str_sisterinlaw"),
		  (else_try),
			(str_store_string, s11, "str_brotherinlaw"),
		  (try_end),
		(else_try),
		  #(gt, ":spouse_of_1", -1), #necessary to avoid bug #dplmc+ replaced
		  (neq, ":spouse_of_1", -1), #dplmc+ added
		  (troop_slot_eq, ":spouse_of_1", "slot_troop_guardian", ":troop_2"),
		  (assign, ":relation_strength", 10),  ##gdw5
		  (try_begin),
			(eq, ":gender_1", 1),
			(str_store_string, s11, "str_sisterinlaw"),
		  (else_try),
			(str_store_string, s11, "str_brotherinlaw"),
		  (try_end),
		(else_try),
		  #grandchild
		  (neq, ":troop_2", -1),
		   (this_or_next|eq, ":paternal_grandfather_of_1", ":troop_2"),
		   (this_or_next|eq, ":maternal_grandfather_of_1", ":troop_2"),
		   (this_or_next|eq, ":paternal_grandmother_of_1", ":troop_2"),
			   (eq, ":maternal_grandmother_of_1", ":troop_2"),
		   (assign, ":relation_strength", 8),  ##gdw4
		  (try_begin),
			(eq, ":gender_1", tf_female),
			(str_store_string, s11, "str_dplmc_granddaughter"),
		  (else_try),
			(str_store_string, s11, "str_dplmc_grandson"),
		  (try_end),
		(else_try),
		   #grandparent
		   (neq, ":troop_1", -1),
		   (this_or_next|eq, ":paternal_grandfather_of_2", ":troop_1"),
		   (this_or_next|eq, ":maternal_grandfather_of_2", ":troop_1"),
		   (this_or_next|eq, ":paternal_grandmother_of_2", ":troop_1"),
			   (eq, ":maternal_grandmother_of_2", ":troop_1"),
		  (assign, ":relation_strength", 8),  ##gdw4
		  (try_begin),
			(eq, ":gender_1", tf_female),
			(str_store_string, s11, "str_dplmc_grandmother"),
		  (else_try),
			(str_store_string, s11, "str_dplmc_grandfather"),
		  (try_end),
		(try_end),

		##diplomacy start+
		##Add relations for rulers not already encoded
		(try_begin),
			(eq, ":relation_strength", 0),
			(neq, ":troop_1", ":troop_2"),
			(try_begin),
				#Lady Isolla of Suno's father King Esterich was King Harlaus's cousin,
				#making them first cousins once removed.  Assign a weight of "1"
				#to this (for reference, the lowest value normally given in Native is 2).
				(this_or_next|eq, ":troop_1", "trp_kingdom_1_lord"),
					(eq, ":troop_1", "trp_kingdom_1_pretender"),
				(this_or_next|eq, ":troop_2", "trp_kingdom_1_lord"),
					(eq, ":troop_2", "trp_kingdom_1_pretender"),
				(assign, ":relation_strength", 3),    ##gdw1
				(str_store_string, s11, "str_cousin"),
			(else_try),
				#Prince Valdym's uncle was Regent Burelek, father of King Yaroglek,
				#making the two of them first cousins.
				(this_or_next|eq, ":troop_1", "trp_kingdom_2_lord"),
					(eq, ":troop_1", "trp_kingdom_2_pretender"),
				(this_or_next|eq, ":troop_2", "trp_kingdom_2_lord"),
					(eq, ":troop_2", "trp_kingdom_2_pretender"),
				(assign, ":relation_strength", 5),  ##gdw2
				(str_store_string, s11, "str_cousin"),
			(else_try),
				#Sanjar Khan and Dustum Khan were both sons of Janakir Khan
				#(although by different mothers) making them half-brothers.
				(this_or_next|eq, ":troop_1", "trp_kingdom_3_lord"),
					(eq, ":troop_1", "trp_kingdom_3_pretender"),
				(this_or_next|eq, ":troop_2", "trp_kingdom_3_lord"),
					(eq, ":troop_2", "trp_kingdom_3_pretender"),
				(assign, ":relation_strength", 17),   ##gdw10
				(str_store_string, s11, "str_dplmc_half_brother"),
				#Adjust their parentage to make this work automatically
				(try_begin),
					(troop_slot_eq, ":troop_1", "slot_troop_father", -1),
					(troop_slot_eq, ":troop_2", "slot_troop_father", -1),
					#Set their "father" slot to a number guaranteed not to have spurious collisions
					(store_mul, ":janakir_khan", "trp_kingdom_3_lord", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),#defined in module_constants.py
					(val_add, ":janakir_khan", DPLMC_VIRTUAL_RELATIVE_FATHER_OFFSET),#defined in module_constants.py
					(troop_set_slot, ":troop_1", "slot_troop_father", ":janakir_khan"),
					(troop_set_slot, ":troop_2", "slot_troop_father", ":janakir_khan"),
					#Differentiate their mothers, so they are half-brothers instead of full-brothers
					(try_begin),
						(troop_slot_eq, ":troop_1", "slot_troop_mother", -1),
						(store_mul, reg0, ":troop_1", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
						(val_add, reg0, DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
						(troop_set_slot, ":troop_1", "slot_troop_mother", reg0),
					(try_end),
					(try_begin),
						(troop_slot_eq, ":troop_2", "slot_troop_mother", -1),
						(store_mul, reg0, ":troop_2", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
						(val_add, reg0, DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
						(troop_set_slot, ":troop_2", "slot_troop_mother", reg0),
					(try_end),
				(try_end),
			(try_end),
		(try_end),
		##Add uncles and aunts by marriage.
		##In Native, the relation strength for blood uncles/aunts is 4, and for cousins is 2.
		##In light of this I've decided to set the relation strength for aunts/uncles by marriage to 2.
		(try_begin),
			(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
			#Test if troop_1 is married to a sibling of one of troop_2's parents, pt. 1
			(ge, ":spouse_of_1", 0),
			(neg|troop_slot_eq, ":spouse_of_1", "slot_troop_father", -1),
			(this_or_next|troop_slot_eq, ":spouse_of_1", "slot_troop_father", ":paternal_grandfather_of_2"),
				(troop_slot_eq, ":spouse_of_1", "slot_troop_father", ":maternal_grandfather_of_2"),
			(assign, ":relation_strength", 2),
			(try_begin),
				(eq, ":gender_1", tf_female),
				(str_store_string, s11, "str_aunt"),
			(else_try),
				(str_store_string, s11, "str_uncle"),
			(try_end),
		(else_try),
			(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
			#Test if troop_1 is married to a sibling of one of troop_2's parents, pt. 2
			(ge, ":spouse_of_1", 0),
			(neg|troop_slot_eq, ":spouse_of_1", "slot_troop_mother", -1),
			(this_or_next|troop_slot_eq, ":spouse_of_1", "slot_troop_mother", ":paternal_grandmother_of_2"),
				(troop_slot_eq, ":spouse_of_1", "slot_troop_mother", ":maternal_grandmother_of_2"),
			(assign, ":relation_strength", 2),
			(try_begin),
				(eq, ":gender_1", tf_female),
				(str_store_string, s11, "str_aunt"),
			(else_try),
				(str_store_string, s11, "str_uncle"),
			(try_end),
		(else_try),
			(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
			#Test if troop_2 is married to a sibling of one of troop_1's parents, pt. 1
			(ge, ":spouse_of_2", 0),
			(neg|troop_slot_eq, ":spouse_of_2", "slot_troop_father", -1),
			(this_or_next|troop_slot_eq, ":spouse_of_2", "slot_troop_father", ":paternal_grandfather_of_1"),
				(troop_slot_eq, ":spouse_of_2", "slot_troop_father", ":maternal_grandfather_of_1"),
			(assign, ":relation_strength", 2),
			(try_begin),
				(eq, ":gender_1", tf_female),
				(str_store_string, s11, "str_niece"),
			(else_try),
				(str_store_string, s11, "str_nephew"),
			(try_end),
		(else_try),
			(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
			#Test if troop_2 is married to a sibling of one of troop_1's parents, pt. 2
			(ge, ":spouse_of_2", 0),
			(neg|troop_slot_eq, ":spouse_of_2", "slot_troop_mother", -1),
			(this_or_next|troop_slot_eq, ":spouse_of_2", "slot_troop_mother", ":paternal_grandmother_of_1"),
				(troop_slot_eq, ":spouse_of_2", "slot_troop_mother", ":maternal_grandmother_of_1"),
			(assign, ":relation_strength", 2),
			(try_begin),
				(eq, ":gender_1", tf_female),
				(str_store_string, s11, "str_niece"),
			(else_try),
				(str_store_string, s11, "str_nephew"),
			(try_end),
		(try_end),
		##diplomacy end+
		(assign, reg4, ":gender_1"),
		(assign, reg0, ":relation_strength"),
	]),
  
  
  # script_complete_family_relations
  # Inputs: none
  # Outputs: none
  
  #complete family relations removed
  
  # script_collect_friendly_parties
  # Fills the party p_collective_friends with the members of parties attached to main_party and ally_party_no
  ("collect_friendly_parties",
    [
      (party_collect_attachments_to_party, "p_main_party", "p_collective_friends"),
      (try_begin),
        (gt, "$g_ally_party", 0),
        (party_collect_attachments_to_party, "$g_ally_party", "p_temp_party"),
        (assign, "$g_move_heroes", 1),
        (call_script, "script_party_add_party", "p_collective_friends", "p_temp_party"),
      (try_end),
  ]),

  # script_encounter_calculate_fit
  # Input: arg1 = troop_no
  # Output: none
  ("encounter_calculate_fit",
    [
      #(assign, "$g_enemy_fit_for_battle_old",  "$g_enemy_fit_for_battle"),
      #(assign, "$g_friend_fit_for_battle_old", "$g_friend_fit_for_battle"),
      #(assign, "$g_main_party_fit_for_battle_old", "$g_main_party_fit_for_battle"),
      (call_script, "script_party_count_fit_for_battle", "p_main_party"),
      #(assign, "$g_main_party_fit_for_battle", reg(0)),
      (call_script, "script_collect_friendly_parties"),
      (call_script, "script_party_count_fit_for_battle", "p_collective_friends"),
      (assign, "$g_friend_fit_for_battle", reg(0)),

      (party_clear, "p_collective_ally"),
      (try_begin),
        (gt, "$g_ally_party", 0),
        (party_is_active, "$g_ally_party"),
        (party_collect_attachments_to_party, "$g_ally_party", "p_collective_ally"),
        #(call_script, "script_party_count_fit_for_battle", "p_collective_ally"),
        #(val_add, "$g_friend_fit_for_battle", reg(0)),
      (try_end),

      (party_clear, "p_collective_enemy"),
      (try_begin),
        (party_is_active, "$g_enemy_party"),
        (party_collect_attachments_to_party, "$g_enemy_party", "p_collective_enemy"),
      (try_end),
      (call_script, "script_party_count_fit_for_battle", "p_collective_enemy"),
      (assign, "$g_enemy_fit_for_battle", reg(0)),
      (assign, reg11, "$g_enemy_fit_for_battle"),
      (assign, reg10, "$g_friend_fit_for_battle"),
  ]),
  
  # script_encounter_init_variables
  # Input: arg1 = troop_no
  # Output: none
  ("encounter_init_variables",
    [
      (assign, "$capture_screen_shown", 0),
      (assign, "$loot_screen_shown", 0),
      (assign, "$thanked_by_ally_leader", 0),
      (assign, "$g_battle_result", 0),
      (assign, "$cant_leave_encounter", 0),
      (assign, "$cant_talk_to_enemy", 0),
      (assign, "$last_defeated_hero", 0),
      (assign, "$last_freed_hero", 0),

      (call_script, "script_encounter_calculate_fit"),
      (call_script, "script_party_copy", "p_main_party_backup", "p_main_party"),
	  ##diplomacy start+
	  #If terrain advantage is enabled, use it to initialize the variables.
	  (assign, ":terrain_code", -1),
	  (try_begin),
	     (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_ENABLE),
		 (lt, "$g_encounter_is_in_village", 1),#Do not apply to village encounters
	     (try_begin),
	        (encountered_party_is_attacker),
		    (call_script, "script_dplmc_get_terrain_code_for_battle", "$g_encountered_party", "p_main_party"),
	     (else_try),
	        (call_script, "script_dplmc_get_terrain_code_for_battle", "p_main_party", "$g_encountered_party"),
		 (try_end),
		 (assign, ":terrain_code", reg0),
		 #calculate party strength with terrain
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_main_party", ":terrain_code", 0, 1),
		 (assign, "$g_starting_strength_main_party", reg0),
		 (try_begin),
			#Print debug Message
		    (ge, "$cheat_mode", 1),
		    (assign, reg2, ":terrain_code"),
			(display_message, "@{!}DEBUG - Main party raw strength {reg1}, terrain code {reg2}, modified strength {reg0}"),
		 (try_end),
		 #calculate enemy strength with terrain
		 (call_script, "script_party_copy", "p_encountered_party_backup", "p_collective_enemy"),
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_enemy", ":terrain_code", 0, 1),
		 (assign, "$g_starting_strength_enemy_party", reg0),
		 (assign, "$g_strength_contribution_of_player", 100),
		 (try_begin),
		    (ge, "$cheat_mode", 1),#debug
		    (assign, reg2, ":terrain_code"),
			(display_message, "@{!} DEBUG - Enemy party raw strength {reg1}, terrain code {reg2}, modified strength {reg0}"),
		 (try_end),
		 #calculate friends strength with terrain
		 (call_script, "script_party_copy", "p_collective_friends_backup", "p_collective_friends"),
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_friends", ":terrain_code", 0, 1),
		 (assign, "$g_starting_strength_friends", reg0),
	  (else_try),
	     ##Calculate all party strengths without terrain:
	     #calculate main party strength
         (call_script, "script_party_calculate_strength", "p_main_party", 0),
         (assign, "$g_starting_strength_main_party", reg0),
		 #calculate enemy strength
         (call_script, "script_party_copy", "p_encountered_party_backup", "p_collective_enemy"),
         (call_script, "script_party_calculate_strength", "p_collective_enemy", 0),
         (assign, "$g_starting_strength_enemy_party", reg0),
         (assign, "$g_strength_contribution_of_player", 100),
		 #calculate friends strength
         (call_script, "script_party_copy", "p_collective_friends_backup", "p_collective_friends"),
         (call_script, "script_party_calculate_strength", "p_collective_friends", 0),
         (assign, "$g_starting_strength_friends", reg0),
	  (try_end),
	  ##diplomacy end+ chief

      (store_mul, "$g_strength_contribution_of_player","$g_starting_strength_main_party", 100), # reduce contribution if we are helping someone.
	  
	  (try_begin),
      #Caba freelancer fixes chief
		(eq, "$freelancer_state", 1),
			(store_character_level, "$g_strength_contribution_of_player", "$player_cur_troop"),
			(val_div, "$g_strength_contribution_of_player", 2),
			(val_max, "$g_strength_contribution_of_player", 5), #contribution(scale 0-100) = level/2, min 5 (so about 5-25)
			#(store_character_level, ":freelancer_player_contribution", "$player_cur_troop"),
			#(val_mul, ":freelancer_player_contribution", 6),
			#(val_div, ":freelancer_player_contribution", 5), #level * 1.2 (for a bit of a scaling bump)
			#(val_max, ":freelancer_player_contribution", 10), #and to give a base line
			#(assign, "$g_strength_contribution_of_player", ":freelancer_player_contribution"),
      (else_try),
      #Caba freelancer fixes end
		(gt, "$g_starting_strength_friends", 0), #this new to prevent occasional div by zero error 
		(val_div, "$g_strength_contribution_of_player","$g_starting_strength_friends"),
	  (else_try),
		(assign, "$g_strength_contribution_of_player", 100), #Or zero, maybe
	  (try_end),
	  
      (party_clear, "p_routed_enemies"), #new
      (assign, "$num_routed_us", 0),#newtoday
      (assign, "$num_routed_allies", 0),#newtoday
      (assign, "$num_routed_enemies", 0),#newtoday      
      (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop_id", "p_main_party", ":i_stack"),
        (try_begin),
          (troop_set_slot, ":stack_troop_id", "slot_troop_player_routed_agents", 0),
          #(troop_set_slot, ":stack_troop_id", "slot_troop_enemy_routed_agents", 0),
          #(troop_set_slot, ":stack_troop_id", "slot_troop_ally_routed_agents", 0),
        (try_end),
      (try_end),  

      (party_get_num_companion_stacks, ":num_stacks", "p_collective_friends"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop_id", "p_collective_friends", ":i_stack"),
        (try_begin),
          #(troop_set_slot, ":stack_troop_id", "slot_troop_player_routed_agents", 0),
          #(troop_set_slot, ":stack_troop_id", "slot_troop_enemy_routed_agents", 0),
          (troop_set_slot, ":stack_troop_id", "slot_troop_ally_routed_agents", 0),
        (try_end),
      (try_end),  

      (party_get_num_companion_stacks, ":num_stacks", "p_collective_enemy"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop_id", "p_collective_enemy", ":i_stack"),
        (try_begin),
          #(troop_set_slot, ":stack_troop_id", "slot_troop_player_routed_agents", 0),
          (troop_set_slot, ":stack_troop_id", "slot_troop_enemy_routed_agents", 0),
          #(troop_set_slot, ":stack_troop_id", "slot_troop_ally_routed_agents", 0),
        (try_end),
      (try_end),  

      (try_for_range, ":cur_faction", "fac_kingdom_1", "fac_kingdoms_end"),
        (faction_set_slot, ":cur_faction", "slot_faction_num_routed_agents", 0),
      (try_end),
      
      (assign, "$routed_party_added", 0), #new
      (party_clear, "p_total_enemy_casualties"), #new
      
#      (try_begin),
#        (gt, "$g_ally_party", 0),
#        (call_script, "script_party_copy", "p_ally_party_backup", "p_collective_ally"),
#        (call_script, "script_party_calculate_strength", "p_collective_ally"),
#        (assign, "$g_starting_strength_ally_party", reg0),
#        (store_add, ":starting_strength_factor_combined","$g_starting_strength_ally_party","$g_starting_strength_main_party"),
#         (store_mul, "$g_strength_contribution_of_player","$g_starting_strength_main_party", 80), #reduce contribution if we are helping someone.
#        (val_div, "$g_strength_contribution_of_player",":starting_strength_factor_combined"),
#      (try_end),
  ]),
  
  # script_calculate_renown_value
  # Input: arg1 = troop_no
  # Output: fills $battle_renown_value
  ("calculate_renown_value",
   [
    ##diplomacy start+ chief
	  #If terrain advantage is enabled, use it to avoid messing up cached
	  #strength values, but do not take it into consideration for renown
	  #granted.
	  (assign, ":main_party_strength", 1),
	  (assign, ":enemy_strength", 1),
	  (assign, ":friends_strength", 1),
	  (assign, ":terrain_code", -1),
	  (try_begin),
	     (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_ENABLE),
	     (try_begin),
	        (encountered_party_is_attacker),
		    (call_script, "script_dplmc_get_terrain_code_for_battle", "$g_encountered_party", "p_main_party"),
	     (else_try),
	        (call_script, "script_dplmc_get_terrain_code_for_battle", "p_main_party", "$g_encountered_party"),
		 (try_end),
		 (assign, ":terrain_code", reg0),
		 ##Alternate option: calculate with terrain, but don't use it for renown
		 #(but do use it to update the cached strength for the party)
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_main_party", ":terrain_code",0,1),
		 (assign, ":main_party_strength", reg1),#use non-terrain version!
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_enemy", ":terrain_code",0,1),
		 (assign, ":enemy_strength", reg1),#use non-terrain version!
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_friends", ":terrain_code",0,1),
		 (assign, ":friends_strength", reg1),#use non-terrain version!
	  (else_try),
	      ##Original option: calculate without terrain
		  (call_script, "script_party_calculate_strength", "p_main_party", 0),
		  (assign, ":main_party_strength", reg0),
		  (call_script, "script_party_calculate_strength", "p_collective_enemy", 0),
		  (assign, ":enemy_strength", reg0),
		  (call_script, "script_party_calculate_strength", "p_collective_friends", 0),
		  (assign, ":friends_strength", reg0),
	  (try_end),
	  ##diplomacy end+

      (val_add, ":friends_strength", 1),
      (store_mul, ":enemy_strength_ratio", ":enemy_strength", 100),
      (val_div, ":enemy_strength_ratio", ":friends_strength"),

      (assign, ":renown_val", ":enemy_strength"),
      (val_mul, ":renown_val", ":enemy_strength_ratio"),
      (val_div, ":renown_val", 100),

      (val_mul, ":renown_val", ":main_party_strength"),
      (val_div, ":renown_val",":friends_strength"),

      (store_div, "$battle_renown_value", ":renown_val", 5),
      (val_min, "$battle_renown_value", 2500),
      (convert_to_fixed_point, "$battle_renown_value"),
      (store_sqrt, "$battle_renown_value", "$battle_renown_value"),
      (convert_from_fixed_point, "$battle_renown_value"),
      (assign, reg8, "$battle_renown_value"),
      (display_message, "@Renown value for this battle is {reg8}.",0xFFFFFFFF),
  ]),
       
  
  ##  # script_calculate_weekly_wage_for_player
  ##  # Input: none
  ##  # Output: none
  ##  ("calculate_weekly_wage_for_player",
  ##    [
  ##        (call_script, "script_calculate_weekly_party_wage", "p_main_party"),
  ##        (assign, ":result", reg0),
  ##        (try_for_parties, ":party_no"),
  ##          (store_faction_of_party, ":party_faction", ":party_no"),
  ##          (eq, ":party_faction", "fac_player_supporters_faction"),
  ##          (call_script, "script_calculate_weekly_party_wage", ":party_no"),
  ##          (val_add, ":result", reg0),
  ##        (try_end),
  ##        (assign, reg0, ":result"),
  ##  ]),
  
  
  # script_get_first_agent_with_troop_id
  # Input: arg1 = troop_no
  # Output: agent_id
  ("cf_get_first_agent_with_troop_id",
    [
      (store_script_param_1, ":troop_no"),
      #      (store_script_param_2, ":agent_no_to_begin_searching_after"),
      (assign, ":result", -1),
      (try_for_agents, ":cur_agent"),
        (eq, ":result", -1),
        ##        (try_begin),
        ##          (eq, ":cur_agent", ":agent_no_to_begin_searching_after"),
        ##          (assign, ":agent_no_to_begin_searching_after", -1),
        ##        (try_end),
        ##        (eq, ":agent_no_to_begin_searching_after", -1),
        (agent_get_troop_id, ":cur_troop_no", ":cur_agent"),
        (eq, ":cur_troop_no", ":troop_no"),
        (assign, ":result", ":cur_agent"),
      (try_end),
      (assign, reg0, ":result"),
      (neq, reg0, -1),
  ]),
  
  
  # script_cf_team_get_average_position_of_agents_with_type_to_pos1
  # Input: arg1 = team_no, arg2 = class_no (grc_everyone, grc_infantry, grc_cavalry, grc_archers, grc_heroes)
  # Output: none, pos1 = average_position (0,0,0 if there are no matching agents)
  ("cf_team_get_average_position_of_agents_with_type_to_pos1",
    [
      (store_script_param_1, ":team_no"),
      (store_script_param_2, ":division_no"),
      (assign, ":total_pos_x", 0),
      (assign, ":total_pos_y", 0),
      (assign, ":total_pos_z", 0),
      (assign, ":num_agents", 0),
      (set_fixed_point_multiplier, 100),
      (try_for_agents, ":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_get_team, ":cur_team_no", ":cur_agent"),
        (eq, ":cur_team_no", ":team_no"),
        (agent_get_division, ":cur_agent_division", ":cur_agent"),
        (this_or_next|eq, ":division_no", grc_everyone),
        (eq, ":division_no", ":cur_agent_division"),
        (agent_get_position, pos1, ":cur_agent"),
        (position_get_x, ":cur_pos_x", pos1),
        (val_add, ":total_pos_x", ":cur_pos_x"),
        (position_get_y, ":cur_pos_y", pos1),
        (val_add, ":total_pos_y", ":cur_pos_y"),
        (position_get_z, ":cur_pos_z", pos1),
        (val_add, ":total_pos_z", ":cur_pos_z"),
        (val_add, ":num_agents", 1),
      (try_end),
      (gt, ":num_agents", 1),
      (val_div, ":total_pos_x", ":num_agents"),
      (val_div, ":total_pos_y", ":num_agents"),
      (val_div, ":total_pos_z", ":num_agents"),
      (init_position, pos1),
      (position_move_x, pos1, ":total_pos_x"),
      (position_move_y, pos1, ":total_pos_y"),
      (position_move_z, pos1, ":total_pos_z"),
  ]),
  
  # script_cf_turn_windmill_fans
  # Input: arg1 = instance_no (none = 0)
  # Output: none
  ("cf_turn_windmill_fans",
    [(store_script_param_1, ":instance_no"),
      (scene_prop_get_instance, ":windmill_fan_object", "spr_windmill_fan_turning", ":instance_no"),
      (ge, ":windmill_fan_object", 0),
      (prop_instance_get_position, pos1, ":windmill_fan_object"),
      (position_rotate_y, pos1, 10),
      (prop_instance_animate_to_position, ":windmill_fan_object", pos1, 100),
      (val_add, ":instance_no", 1),
      (call_script, "script_cf_turn_windmill_fans", ":instance_no"),
  ]),
  
  # script_print_party_members
  # Input: arg1 = party_no
  # Output: s51 = output string. "noone" if the party is empty
  ("print_party_members",
    [  
      (store_script_param_1, ":party_no"),
      (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
      (assign, reg10, ":num_stacks"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
        (troop_is_hero, ":stack_troop"),
        (try_begin),
          (eq, ":i_stack", 0),
          (str_store_troop_name, s51, ":stack_troop"),
        (try_end),
        (str_store_troop_name, s52, ":stack_troop"),
        (try_begin),
          (eq, ":i_stack", 1),
          (str_store_string, s51, "str_s52_and_s51"),
        (else_try),
          (gt, ":i_stack", 1),
          (str_store_string, s51, "str_s52_comma_s51"),
        (try_end),
      (try_end),
      (try_begin),
        (eq, ":num_stacks", 0),
        (str_store_string, s51, "str_noone"),
      (try_end),
  ]),

  # script_round_value
  # Input: arg1 = value
  # Output: reg0 = rounded_value
  ("round_value",
    [
      (store_script_param_1, ":value"),
      (try_begin),
        (lt, ":value", 100),
        (neq, ":value", 0),
        (val_add, ":value", 5),
        (val_div, ":value", 10),
        (val_mul, ":value", 10),
        (try_begin),
          (eq, ":value", 0),
          (assign, ":value", 5),
        (try_end),
      (else_try),
        (lt, ":value", 300),
        (val_add, ":value", 25),
        (val_div, ":value", 50),
        (val_mul, ":value", 50),
      (else_try),
        (val_add, ":value", 50),
        (val_div, ":value", 100),
        (val_mul, ":value", 100),
      (try_end),
      (assign, reg0, ":value"),
  ]),
    
  # script_change_banners_and_chest
  # Input: none
  # Output: none
  ("change_banners_and_chest",
    [(party_get_slot, ":cur_leader", "$g_encountered_party", "slot_town_lord"),
     (try_begin),
       (ge, ":cur_leader", 0),
#normal_banner_begin
       (troop_get_slot, ":troop_banner_object", ":cur_leader", "slot_troop_banner_scene_prop"),
       (gt, ":troop_banner_object", 0),
       (replace_scene_props, banner_scene_props_begin, ":troop_banner_object"),
     (else_try),
       (replace_scene_props, banner_scene_props_begin, "spr_empty"),
     (try_end),
     (try_begin),
       (neq, ":cur_leader", "trp_player"),
       (replace_scene_props, "spr_player_chest", "spr_locked_player_chest"),
     (try_end),
     ]),


  # script_remove_siege_objects
  # Input: none
  # Output: none
  ("remove_siege_objects",
    [
      (replace_scene_props, "spr_battlement_a_destroyed", "spr_battlement_a"),
      (replace_scene_props, "spr_snowy_castle_battlement_a_destroyed", "spr_snowy_castle_battlement_a"),
      (replace_scene_props, "spr_castle_e_battlement_a_destroyed", "spr_castle_e_battlement_a"),
      (replace_scene_props, "spr_castle_battlement_a_destroyed", "spr_castle_battlement_a"),
      (replace_scene_props, "spr_castle_battlement_b_destroyed", "spr_castle_battlement_b"),
      (replace_scene_props, "spr_earth_wall_a2", "spr_earth_wall_a"),
      (replace_scene_props, "spr_earth_wall_b2", "spr_earth_wall_b"),
      (replace_scene_props, "spr_belfry_platform_b", "spr_empty"),
      (replace_scene_props, "spr_belfry_platform_a", "spr_empty"),
      (replace_scene_props, "spr_belfry_a", "spr_empty"),
      (replace_scene_props, "spr_belfry_wheel", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_6m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_8m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_10m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_12m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_14m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_12m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_14m", "spr_empty"),
      (replace_scene_props, "spr_mangonel", "spr_empty"),
      (replace_scene_props, "spr_trebuchet_old", "spr_empty"),
      (replace_scene_props, "spr_trebuchet_new", "spr_empty"),
      (replace_scene_props, "spr_stone_ball", "spr_empty"),
      (replace_scene_props, "spr_Village_fire_big", "spr_empty"),
      (replace_scene_props, "spr_ram_body", "spr_empty"), #chief battering ram
      (replace_scene_props, "spr_ram_shaft", "spr_empty"), #chief battering ram
      (replace_scene_props, "spr_ram_wheel", "spr_empty"), #chief battering ram
      ]),
  # script_describe_relation_to_s63
  # Input: arg1 = relation (-100 .. 100)
  # Output: none
  ("describe_relation_to_s63",
    [(store_script_param_1, ":relation"),
      (store_add, ":normalized_relation", ":relation", 100),
      (val_add, ":normalized_relation", 5),
      (store_div, ":str_offset", ":normalized_relation", 10),
      (val_clamp, ":str_offset", 0, 20),
      (store_add, ":str_id", "str_relation_mnus_100",  ":str_offset"),
      (str_store_string, s63, ":str_id"),
  ]),
  
  # script_describe_center_relation_to_s3
  # Input: arg1 = relation (-100 .. 100)
  # Output: none
  ("describe_center_relation_to_s3",
    [(store_script_param_1, ":relation"),
      (store_add, ":normalized_relation", ":relation", 100),
      (val_add, ":normalized_relation", 5),
      (store_div, ":str_offset", ":normalized_relation", 10),
      (val_clamp, ":str_offset", 0, 20),
      (store_add, ":str_id", "str_center_relation_mnus_100",  ":str_offset"),
      (str_store_string, s3, ":str_id"),
  ]),


  # script_center_ambiance_sounds
  # Input: none
  # Output: none
  # to be called every two seconds
  ("center_ambiance_sounds",
    [
        (assign, ":sound_1", -1),
        (assign, ":sound_2", -1),
        (assign, ":sound_3", -1),
        (assign, ":sound_4", -1),
        (assign, ":sound_5", -1),
        (try_begin),
          (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_village),
          (try_begin),
            (neg|is_currently_night),
            (assign, ":sound_3", "snd_distant_dog_bark"),
            (assign, ":sound_3", "snd_distant_chicken"),
          (else_try),
            (assign, ":sound_1", "snd_distant_dog_bark"),
            (assign, ":sound_2", "snd_distant_owl"),
          (try_end),
        (else_try),
          (party_slot_eq, "$g_encountered_party", "slot_party_type", spt_town),
          (try_begin),
            (neg|is_currently_night),
            (assign, ":sound_1", "snd_distant_carpenter"),
            (assign, ":sound_2", "snd_distant_blacksmith"),
            (assign, ":sound_3", "snd_distant_dog_bark"),
          (else_try),
            (assign, ":sound_1", "snd_distant_dog_bark"),
          (try_end),
        (try_end),
        (try_begin),
          (store_random_in_range, ":r", 0, 7),
          (try_begin),
            (eq, ":r", 1),
            (ge, ":sound_1", 0),
            (play_sound, ":sound_1"),
          (else_try),
            (eq, ":r", 2),
            (ge, ":sound_2", 0),
            (play_sound, ":sound_2"),
          (else_try),
            (eq, ":r", 3),
            (ge, ":sound_3", 0),
            (play_sound, ":sound_3"),
          (else_try),
            (eq, ":r", 4),
            (ge, ":sound_4", 0),
            (play_sound, ":sound_4"),
          (else_try),
            (eq, ":r", 5),
            (ge, ":sound_5", 0),
            (play_sound, ":sound_5"),
          (try_end),
        (try_end),
  ]),

  # script_center_set_walker_to_type
  # Input: arg1 = center_no, arg2 = walker_no, arg3 = walker_type, 
  # Output: none
  ("center_set_walker_to_type",
   [
       (store_script_param, ":center_no", 1),
       (store_script_param, ":walker_no", 2),
       (store_script_param, ":walker_type", 3),
       (store_add, ":type_slot", "slot_center_walker_0_type", ":walker_no"),
       (party_set_slot, ":center_no", ":type_slot", ":walker_type"),
       (party_get_slot, ":center_faction", ":center_no", "slot_center_original_faction"),
       (faction_get_slot, ":center_culture", ":center_faction", "slot_faction_culture"),
       (store_random_in_range, ":walker_troop_slot", 0, 2), 
       (try_begin),
         (party_slot_eq, ":center_no", "slot_party_type", spt_village),
         (val_add, ":walker_troop_slot", "slot_faction_village_walker_male_troop"),
       (else_try), #anadido chief castle walkers
         (party_slot_eq, ":center_no", "slot_party_type", spt_castle),
         (val_add, ":walker_troop_slot", "slot_faction_village_walker_male_troop"),
       (else_try),
       (val_add, ":walker_troop_slot", "slot_faction_town_walker_male_troop"),
       (try_end),
       (try_begin),
         (eq,":walker_type", walkert_spy),
         (assign,":original_walker_slot",":walker_troop_slot"),
         (val_add,":walker_troop_slot",4), # select spy troop id slot
       (try_end),
       (faction_get_slot, ":walker_troop_id", ":center_culture", ":walker_troop_slot"),
       (try_begin),
         (eq,":walker_type", walkert_spy),
         (faction_get_slot, ":original_walker", ":center_culture", ":original_walker_slot"),
         # restore spy inventory
         (try_for_range,":item_no","itm_horse_meat","itm_club_stick"),
            (store_item_kind_count,":num_items",":item_no",":original_walker"),
            (ge,":num_items",1),
            (store_item_kind_count,":num_items",":item_no",":walker_troop_id"),
            (lt,":num_items",1),
            (troop_add_items,":walker_troop_id",":item_no",1),
         (try_end),
         # determine spy recognition item
         (store_random_in_range,":spy_item_type",itp_type_head_armor,itp_type_hand_armor),
         (assign,":num",0),
         (try_for_range,":item_no","itm_horse_meat","itm_club_stick"),
            (store_item_kind_count,":num_items",":item_no",":walker_troop_id"),
            (ge,":num_items",1),
            (item_get_type, ":itp", ":item_no"),
            (eq,":itp",":spy_item_type"),
            (val_add,":num",1),
            (troop_remove_items,":walker_troop_id",":item_no",":num_items"),
         (try_end),
         (store_random_in_range,":random_item",0,":num"),
         (assign,":num",-1),
         (try_for_range,":item_no","itm_horse_meat","itm_club_stick"),
            (store_item_kind_count,":num_items",":item_no",":original_walker"),
            (ge,":num_items",1),
            (item_get_type, ":itp", ":item_no"),
            (eq,":itp",":spy_item_type"),
            (val_add,":num",1),
            (eq,":num",":random_item"),
            (troop_add_items,":walker_troop_id",":item_no",1),
            (assign,":spy_item",":item_no"),
         (try_end),
         (assign,"$spy_item_worn",":spy_item"),
         (assign,"$spy_quest_troop",":walker_troop_id"),
         (troop_equip_items,":walker_troop_id"),
       (try_end),

#####altura
##     (store_random_in_range, ":is_alto", 1, 3), #XENOARGH chief anade ninos y aprovechamos para alto y bajo
##(try_begin),
##(eq, ":is_alto", 1),
##(store_random_in_range, ":alto_type", 1, 2),
##(troop_get_type, ":troop_gender", ":walker_troop_id"),
##(try_begin),
##(eq, ":alto_type", 1),
##(try_begin),
##    (eq, ":troop_gender", 1),
##      (troop_set_type, ":walker_troop_id", tf_baja),
##(else_try),
##      (troop_set_type, ":walker_troop_id", tf_bajo),
##(try_end),
##(else_try),
##(eq, ":alto_type", 2),
##(try_begin),
##    (eq, ":troop_gender", 1),
##    (troop_set_type, ":walker_troop_id", tf_alta),
##(else_try),
##      (troop_set_type, ":walker_troop_id", tf_alto),
##(try_end),
##(try_end),
##(try_end),
####altura acaba chief

       (store_add, ":troop_slot", "slot_center_walker_0_troop", ":walker_no"),
       (party_set_slot, ":center_no", ":troop_slot", ":walker_troop_id"),
       (store_random_in_range, ":walker_dna", 0, 1000000),
       (store_add, ":dna_slot", "slot_center_walker_0_dna", ":walker_no"),
       (party_set_slot, ":center_no", ":dna_slot", ":walker_dna"),
     ]),


  # script_cf_center_get_free_walker
  # Input: arg1 = center_no
  # Output: reg0 = walker no (can fail)
  ("cf_center_get_free_walker",
   [
       (store_script_param, ":center_no", 1),
       (assign, ":num_free_walkers", 0),
       (try_for_range, ":walker_no", 0, num_town_walkers),
         (store_add, ":type_slot", "slot_center_walker_0_type", ":walker_no"),
         (party_slot_eq, ":center_no", ":type_slot", walkert_default),
         (val_add, ":num_free_walkers", 1),
       (try_end),
       (gt, ":num_free_walkers", 0),
       (assign, reg0, -1),
       (store_random_in_range, ":random_rank", 0, ":num_free_walkers"),
       (try_for_range, ":walker_no", 0, num_town_walkers),
         (store_add, ":type_slot", "slot_center_walker_0_type", ":walker_no"),
         (party_slot_eq, ":center_no", ":type_slot", walkert_default),
         (val_sub, ":num_free_walkers", 1),
         (eq, ":num_free_walkers", ":random_rank"),
         (assign, reg0, ":walker_no"),
       (try_end),
     ]),
    
  # script_center_remove_walker_type_from_walkers
  # Input: arg1 = center_no, arg2 = walker_type, 
  # Output: reg0 = 1 if comment found, 0 otherwise; s61 will contain comment string if found
  ("center_remove_walker_type_from_walkers",
   [
       (store_script_param, ":center_no", 1),
       (store_script_param, ":walker_type", 2),
       (try_for_range, ":walker_no", 0, num_town_walkers),
         (store_add, ":type_slot", "slot_center_walker_0_type", ":walker_no"),
         (party_slot_eq, ":center_no", ":type_slot", ":walker_type"),
         (call_script, "script_center_set_walker_to_type", ":center_no", ":walker_no", walkert_default),
       (try_end),
     ]),
  
          
  # script_init_town_walkers
  # Input: none
  # Output: none
  ("init_town_walkers",
  [
    (try_begin),
      (eq, "$town_nighttime", 0),
      (try_for_range, ":walker_no", 0, num_town_walkers),
        (store_add, ":troop_slot", "slot_center_walker_0_troop", ":walker_no"),
        (party_get_slot, ":walker_troop_id", "$current_town", ":troop_slot"),
        (gt, ":walker_troop_id", 0),
        (store_add, ":entry_no", town_walker_entries_start, ":walker_no"),
#        (set_visitor, ":entry_no", ":walker_troop_id"),
		   (set_visitors,":entry_no", ":walker_troop_id",2), #XENOARGH chief anade mas

(store_random_in_range, ":is_child", 1, 4),
(try_begin),
(eq, ":is_child", 1),
(store_random_in_range, ":child_type", 1, 3),
(try_begin),
(eq, ":child_type", 1),
(set_visitors,":entry_no", "trp_walker_boy",2),
(else_try),
(set_visitors,":entry_no", "trp_walker_boy",2),
(try_end),
(try_end),
    
    (try_end),  
    (try_end),  
  ]),


##  # script_init_town_walkers
##  # Input: none
##  # Output: none
##  ("init_town_walkers",
##  [
##    (try_begin),
##      (eq, "$town_nighttime", 0),
##      (try_for_range, ":walker_no", 0, num_town_walkers),
##        (store_add, ":troop_slot", "slot_center_walker_0_troop", ":walker_no"),
##        (party_get_slot, ":walker_troop_id", "$current_town", ":troop_slot"),
##        (gt, ":walker_troop_id", 0),
##        (store_add, ":entry_no", town_walker_entries_start, ":walker_no"),
##        (set_visitor, ":entry_no", ":walker_troop_id"),
##      (try_end),  
##    (try_end),  
##  ]),

  
  # script_cf_enter_center_location_bandit_check
  # Input: none
  # Output: none
  ("cf_enter_center_location_bandit_check",
    [
      (neq, "$town_nighttime", 0),
      (party_slot_ge, "$current_town", "slot_center_has_bandits", 1),
      (eq, "$g_defending_against_siege", 0),#Skip if the center is under siege (because of resting)
      (eq, "$sneaked_into_town", 0),#Skip if sneaked
      (try_begin),
        (party_slot_eq, "$current_town", "slot_party_type", spt_village),
        (party_get_slot, ":cur_scene", "$current_town", "slot_castle_exterior"),
      (else_try),
        (party_get_slot, ":cur_scene", "$current_town", "slot_town_center"),
      (try_end),
      (modify_visitors_at_site, ":cur_scene"),
      (reset_visitors),
      (party_get_slot, ":bandit_troop", "$current_town", "slot_center_has_bandits"),
      (store_character_level, ":level", "trp_player"),

      (set_jump_mission, "mt_bandits_at_night"),
      (try_begin),
        (party_slot_eq, "$current_town", "slot_party_type", spt_village),
        (assign, ":spawn_amount", 2),
        (store_div, ":level_fac",  ":level", 10),
        (val_add, ":spawn_amount", ":level_fac"),
        (try_for_range, ":unused", 0, 3),
          (gt, ":level", 10),
          (store_random_in_range, ":random_no", 0, 100),
          (lt, ":random_no", ":level"),
          (val_add, ":spawn_amount", 1),
        (try_end),
        (set_visitors, 4, ":bandit_troop", ":spawn_amount"),
        (assign, "$num_center_bandits", ":spawn_amount"),
        (set_jump_entry, 2),
      (else_try),
        (assign, ":spawn_amount", 1),
        (assign, "$num_center_bandits", 0),
        (try_begin),
          (gt, ":level", 15),
          (store_random_in_range, ":random_no", 0, 100),
          (lt, ":random_no", ":level"),
          (assign, ":spawn_amount", 2),
        (try_end),
        (val_add, "$num_center_bandits",  ":spawn_amount"),
        (set_visitors, 11, ":bandit_troop", ":spawn_amount"),
        (assign, ":spawn_amount", 1),
        (try_begin),
          (gt, ":level", 20),
          (store_random_in_range, ":random_no", 0, 100),
          (lt, ":random_no", ":level"),
          (assign, ":spawn_amount", 2),
        (try_end),
        (set_visitors, 27, ":bandit_troop", ":spawn_amount"),
        (val_add, "$num_center_bandits",  ":spawn_amount"),
        (try_begin),
          (gt, ":level", 9),
          (assign, ":spawn_amount", 1),
          (try_begin),
            (gt, ":level", 25),
            (store_random_in_range, ":random_no", 0, 100),
            (lt, ":random_no", ":level"),
            (assign, ":spawn_amount", 2),
          (try_end),
          (set_visitors, 28, ":bandit_troop", ":spawn_amount"),
          (val_add, "$num_center_bandits",  ":spawn_amount"),
        (try_end),
        (assign, "$town_entered", 1),
        (assign, "$all_doors_locked", 1),
      (try_end),

      (display_message, "@You have run into a trap!", 0xFFFF2222),
      (display_message, "@You are attacked by a group of bandits!", 0xFFFF2222),

      (jump_to_scene, ":cur_scene"),
      (change_screen_mission),
      ]),
  
  # script_init_town_agent
  # Input: none
  # Output: none
  ("init_town_agent",
    [
      (store_script_param, ":agent_no", 1),
      (agent_get_troop_id, ":troop_no", ":agent_no"),
      (set_fixed_point_multiplier, 100),
      (assign, ":stand_animation", -1),
      (try_begin),
        (this_or_next|is_between, ":troop_no", armor_merchants_begin, armor_merchants_end),
        (is_between, ":troop_no", weapon_merchants_begin, weapon_merchants_end),
        (try_begin),
          (troop_get_type, ":cur_troop_gender", ":troop_no"),
###gender fix chief
       (this_or_next|eq, ":cur_troop_gender", 0), #male
       (this_or_next|eq, ":cur_troop_gender", 2), #male
       (this_or_next|eq, ":cur_troop_gender", 4), #male
       (eq, ":cur_troop_gender", 6), #male
#gender fix chief acaba
          (agent_set_animation, ":agent_no", "anim_stand_townguard"),
        (else_try),
          (agent_set_animation, ":agent_no", "anim_stand_townguard"),
        (end_try),
      (else_try),
        (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
        (assign, ":stand_animation", "anim_stand_lady"),
      (else_try),
        (is_between, ":troop_no", active_npcs_begin, active_npcs_end),
        (assign, ":stand_animation", "anim_stand_lord"),
      (else_try),
        (is_between, ":troop_no", soldiers_begin, soldiers_end),
        (assign, ":stand_animation", "anim_stand_townguard"),
      (try_end),
      (try_begin),
        (ge, ":stand_animation", 0),
        (agent_set_stand_animation, ":agent_no", ":stand_animation"),
        (agent_set_animation, ":agent_no", ":stand_animation"),
        (store_random_in_range, ":random_no", 0, 100),
        (agent_set_animation_progress, ":agent_no", ":random_no"),
      (try_end),
      ]),

  # script_init_town_walker_agents
  # Input: none
  # Output: none
  ("init_town_walker_agents",
    [(assign, ":num_walkers", 0),
     (try_for_agents, ":cur_agent"),
       (agent_get_troop_id, ":cur_troop", ":cur_agent"),
       (is_between, ":cur_troop", walkers_begin, walkers_end),

       (val_add, ":num_walkers", 1),
       (agent_get_position, pos1, ":cur_agent"),
       (try_for_range, ":i_e_p", 9, 40),#Entry points
         (entry_point_get_position, pos2, ":i_e_p"),
         (get_distance_between_positions, ":distance", pos1, pos2),
         (lt, ":distance", 200),
         (agent_set_slot, ":cur_agent", 0, ":i_e_p"),
       (try_end),
       (call_script, "script_set_town_walker_destination", ":cur_agent"),
     (try_end),
  ]),

  # script_agent_get_town_walker_details
  # This script assumes this is one of town walkers. 
  # Input: agent_id
  # Output: reg0: town_walker_type, reg1: town_walker_dna
  ("agent_get_town_walker_details",
    [(store_script_param, ":agent_no", 1),
     (agent_get_entry_no, ":entry_no", ":agent_no"),
     (store_sub, ":walker_no", ":entry_no", town_walker_entries_start),

     (store_add, ":type_slot", "slot_center_walker_0_type", ":walker_no"),
     (party_get_slot, ":walker_type", "$current_town", ":type_slot"),
     (store_add, ":dna_slot", "slot_center_walker_0_dna",  ":walker_no"),
     (party_get_slot, ":walker_dna", "$current_town", ":dna_slot"),
     (assign, reg0, ":walker_type"),
     (assign, reg1, ":walker_dna"),
     (assign, reg2, ":walker_no"),
  ]),


  ("town_walker_occupation_string_to_s14",
    [	
	(store_script_param, ":agent_no", 1),
	
	#Cairo, approx 1799:
	#adult males = 114,000
	#military, 10,400
	#civil, including religious 5,000
	#commerce 3,500
	#merchants 4,500
	#coffee shops, 1,500 (maybe broaden to inns and taverns)
	#artisans 21,800
	#workmen 4,300
	#itinerants 8,600
	#servants (inc water carriers) 26,400
	(assign, ":check_for_good_price", 0),
	(str_store_string, s14, "str_i_take_what_work_i_can_sirmadame_i_carry_water_or_help_the_merchants_with_their_loads_or_help_build_things_if_theres_things_to_be_built"),
	
	(call_script, "script_agent_get_town_walker_details", ":agent_no"),	
	(assign, ":type", reg0),
	(assign, ":walker_dna", reg1),
	
	(assign, ":item", -1),
	(assign, ":total_item_production", 0),
	(try_for_range, ":trade_good", trade_goods_begin, trade_goods_end),
		(call_script, "script_center_get_production", "$g_encountered_party", ":trade_good"),
		(val_add, ":total_item_production", reg0),
	(try_end),

	(val_max, ":total_item_production", 1),
	
	(store_mod, ":semi_random_number", ":walker_dna", ":total_item_production"),
	
	
	(try_begin),
		(eq, "$cheat_mode", 1),
		(assign, reg4, ":walker_dna"),
		(assign, reg5, ":total_item_production"),
		(assign, reg7, ":semi_random_number"), 
		(display_message, "str_dna_reg4_total_production_reg5_modula_reg7"),
	(try_end),
	
	(try_for_range, ":trade_good", trade_goods_begin, trade_goods_end),
		(gt, ":semi_random_number", -1),
		(call_script, "script_center_get_production", "$g_encountered_party", ":trade_good"),
		(val_sub, ":semi_random_number", reg0),
		(lt, ":semi_random_number", 0),
                (try_begin),
                  (eq, "$cheat_mode", 1),
		  (str_store_item_name, s9, ":trade_good"),
		  (display_message, "str_agent_produces_s9"),
                (try_end),
		(assign, ":item", ":trade_good"),
	(try_end),	
	
	
	(try_begin),
		(eq, ":type", walkert_needs_money),
		(is_between, "$g_encountered_party", towns_begin, towns_end),
		(str_store_string, s14, "str_im_not_doing_anything_sirmadame_theres_no_work_to_be_had_around_here_these_days"),
	(else_try),	
		(eq, ":type", walkert_needs_money),
		(str_store_string, s14, "str_im_not_doing_anything_sirmadame_i_have_no_land_of_my_own_and_theres_no_work_to_be_had_around_here_these_days"),
	(else_try),	
		(eq, ":type", walkert_needs_money_helped),
		(str_store_string, s14, "str_why_im_still_living_off_of_your_kindness_and_goodness_sirmadame_hopefully_there_will_be_work_shortly"),
	(else_try),
		(eq, ":item", "itm_grain"),
		(is_between, "$g_encountered_party", towns_begin, towns_end),
		(str_store_string, s14, "str_i_work_in_the_fields_just_outside_the_walls_where_they_grow_grain_we_dont_quite_grow_enough_to_meet_our_needs_though_and_have_to_import_grain_from_the_surrounding_countryside"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),
		(eq, ":item", "itm_grain"),
		(str_store_string, s14, "str_i_work_mostly_in_the_fields_growing_grain_in_the_town_they_grind_it_to_make_bread_or_ale_and_we_can_also_boil_it_as_a_porridge"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_ale"),
		(str_store_string, s14, "str_i_work_in_the_breweries_making_ale_the_poor_folk_drink_a_lot_of_it_as_its_cheaper_than_wine_we_make_it_with_grain_brought_in_from_the_countryside"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_bread"),
		(str_store_string, s14, "str_i_work_in_a_mill_grinding_flour_to_make_bread_bread_is_cheap_keeps_well_and_fills_the_stomach"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_dried_meat"),
		(str_store_string, s14, "str_i_tend_cattle_we_dry_and_salt_meat_to_preserve_it_and_make_cheese_from_the_milk"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_cheese"),
		(str_store_string, s14, "str_i_tend_cattle_we_dry_and_salt_meat_to_preserve_it_and_make_cheese_from_the_milk_so_it_doesnt_spoil"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_butter"),
		(str_store_string, s14, "str_i_tend_cattle_we_dry_and_salt_meat_to_preserve_it_and_make_cheese_from_the_milk_so_it_doesnt_spoil"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_wool"),
		(str_store_string, s14, "str_i_tend_sheep_we_send_the_wool_to_the_cities_to_be_woven_into_cloth_and_make_mutton_sausage_when_we_cull_the_herds"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_sausages"),
		(str_store_string, s14, "str_i_tend_sheep_we_send_the_wool_to_the_cities_to_be_woven_into_cloth_and_make_mutton_sausage_when_we_cull_the_herds"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_wool_cloth"),
		(str_store_string, s14, "str_i_work_at_a_loom_spinning_cloth_from_wool_wool_is_some_of_the_cheapest_cloth_you_can_buy_but_it_will_still_keep_you_warm"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_smoked_fish"),
		(str_store_string, s14, "str_i_crew_a_fishing_boat_we_salt_and_smoke_the_flesh_to_sell_it_far_inland"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_salt"),
		(str_store_string, s14, "str_i_sift_salt_from_a_nearby_flat_they_need_salt_everywhere_to_preserve_meat_and_fish"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_iron"),
		(str_store_string, s14, "str_i_mine_iron_from_a_vein_in_a_nearby_cliffside_they_use_it_to_make_tools_arms_and_other_goods"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_pottery"),
		(str_store_string, s14, "str_i_make_pottery_which_people_use_to_store_grain_and_carry_water"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_tools"),
		(str_store_string, s14, "str_trade_explanation_tools"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_oil"),
		(str_store_string, s14, "str_trade_explanation_oil"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_linen"),
		(str_store_string, s14, "str_trade_explanation_linen"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_velvet"),
		(str_store_string, s14, "str_trade_explanation_velvet"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_spice"),
		(str_store_string, s14, "str_trade_explanation_spice"),
		(assign, ":check_for_good_price", 1),
		
	(else_try),	
		(eq, ":item", "itm_apples"),
		(str_store_string, s14, "str_trade_explanation_apples"),
		(assign, ":check_for_good_price", 1),
		
	(try_end),
	
	
	(try_begin),
		(eq, ":check_for_good_price", 1),
	
		(assign, ":trade_destination", -1),
		(store_skill_level, ":trade_skill", "skl_trade", "trp_player"),
	
		(try_begin),
			(is_between, "$g_encountered_party", villages_begin, villages_end),
			(party_get_slot, ":trade_town", "$g_encountered_party", "slot_village_market_town"),
		(else_try),	
			(assign, ":trade_town", "$g_encountered_party"),
		(try_end),
		
		(store_sub, ":item_to_price_slot", "slot_town_trade_good_prices_begin", trade_goods_begin),
		(store_add, ":cur_good_price_slot", ":item", ":item_to_price_slot"),
		(party_get_slot, ":score_to_beat", ":trade_town", ":cur_good_price_slot"),
		(val_add, ":score_to_beat", 400),
		(store_mul, ":deduction_for_trade_skill", ":trade_skill", 39),#gdw35
		(try_begin),
			(is_between, "$g_encountered_party", villages_begin, villages_end),
			(val_add, ":score_to_beat", 200),
		(try_end),
		(val_sub, ":score_to_beat", ":deduction_for_trade_skill"),
		
		(try_for_range, ":trade_route_slot", "slot_town_trade_routes_begin", "slot_town_trade_routes_end"),
			(party_get_slot, ":other_town", ":trade_town", ":trade_route_slot"),
			(party_get_slot, ":price_in_other_town", ":other_town", ":cur_good_price_slot"),
			
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(assign, reg4, ":price_in_other_town"),
				(assign, reg5, ":score_to_beat"),
				(str_store_party_name, s10, ":other_town"),
				(display_message, "str_s10_has_reg4_needs_reg5"),
			(try_end),
			
			(gt, ":price_in_other_town", ":score_to_beat"),
		
			(assign, ":trade_destination", ":other_town"),
			(assign, ":score_to_beat", ":price_in_other_town"),
		(try_end),
		
		(is_between, ":trade_destination", centers_begin, centers_end),
		
		(str_store_party_name, s15, ":trade_destination"),
		(str_store_string, s14, "str_s14_i_hear_that_you_can_find_a_good_price_for_it_in_s15"),
		
		#Reasons -- raw material
		#Reason -- road cut
		#Reason -- villages looted
		
	(try_end),
	
	
	]),

  
  # script_tick_town_walkers
  # Input: none
  # Output: none
  ("tick_town_walkers",
    [(try_for_agents, ":cur_agent"),
       (agent_get_troop_id, ":cur_troop", ":cur_agent"),
       (is_between, ":cur_troop", walkers_begin, walkers_end),

       (agent_get_slot, ":target_entry_point", ":cur_agent", 0),
       (entry_point_get_position, pos1, ":target_entry_point"),
       (try_begin),
         (lt, ":target_entry_point", 32),
         (init_position, pos2),
         (position_set_y, pos2, 250),
         (position_transform_position_to_parent, pos1, pos1, pos2),
       (try_end),
       (agent_get_position, pos2, ":cur_agent"),
       (get_distance_between_positions, ":distance", pos1, pos2),
       (lt, ":distance", 400),
       (assign, ":random_no", 0),
       (try_begin),
         (lt, ":target_entry_point", 32),
         (store_random_in_range, ":random_no", 0, 100),
       (try_end),
       (lt, ":random_no", 20),
       (call_script, "script_set_town_walker_destination", ":cur_agent"),
     (try_end),
  ]),

#########################CHIEF XENOARGH anade mas walkers moviendose
  
##  # script_set_town_walker_destination
##  # Input: arg1 = agent_no
##  # Output: none
##  ("set_town_walker_destination",
##    [(store_script_param_1, ":agent_no"),
##     (assign, reg0, 9),
##     (assign, reg1, 10),
##     (assign, reg2, 12),
##     (assign, reg3, 32),
##     (assign, reg4, 33),
##     (assign, reg5, 34),
##     (assign, reg6, 35),
##     (assign, reg7, 36),
##     (assign, reg8, 37),
##     (assign, reg9, 38),
##     (assign, reg10, 39),
##     (try_for_agents, ":cur_agent"),
##       (agent_get_troop_id, ":cur_troop", ":cur_agent"),
##       (is_between, ":cur_troop", walkers_begin, walkers_end),
##       (agent_get_slot, ":target_entry_point", ":cur_agent", 0),
##       (try_begin),
##         (eq, ":target_entry_point", 9),
##         (assign, reg0, 0),
##       (else_try),
##         (eq, ":target_entry_point", 10),
##         (assign, reg1, 0),
##       (else_try),
##         (eq, ":target_entry_point", 12),
##         (assign, reg2, 0),
##       (else_try),
##         (eq, ":target_entry_point", 32),
##         (assign, reg3, 0),
##       (else_try),
##         (eq, ":target_entry_point", 33),
##         (assign, reg4, 0),
##       (else_try),
##         (eq, ":target_entry_point", 34),
##         (assign, reg5, 0),
##       (else_try),
##         (eq, ":target_entry_point", 35),
##         (assign, reg6, 0),
##       (else_try),
##         (eq, ":target_entry_point", 36),
##         (assign, reg7, 0),
##       (else_try),
##         (eq, ":target_entry_point", 37),
##         (assign, reg8, 0),
##       (else_try),
##         (eq, ":target_entry_point", 38),
##         (assign, reg9, 0),
##       (else_try),
##         (eq, ":target_entry_point", 39),
##         (assign, reg10, 0),
##       (try_end),
##     (try_end),
##     (assign, ":try_limit", 100),
##     (assign, ":target_entry_point", 0),
##     (try_for_range, ":unused", 0, ":try_limit"),
##       (shuffle_range, 0, 11),
##       (gt, reg0, 0),
##       (assign, ":target_entry_point", reg0),
##       (assign, ":try_limit", 0),
##     (try_end),
##     (try_begin),
##       (gt, ":target_entry_point", 0),
##       (agent_set_slot, ":agent_no", 0, ":target_entry_point"),
##       (entry_point_get_position, pos1, ":target_entry_point"),
##       (try_begin),
##         (lt, ":target_entry_point", 32),
##         (init_position, pos2),
##         (position_set_y, pos2, 250),
##         (position_transform_position_to_parent, pos1, pos1, pos2),
##       (try_end),
##       (agent_set_scripted_destination, ":agent_no", pos1, 0),
##       (agent_set_speed_limit, ":agent_no", 5),
##     (try_end),
##  ]),

          # script_set_town_walker_destination
          # Input: arg1 = agent_no
          # Output: none
          ("set_town_walker_destination",
            [(store_script_param_1, ":agent_no"),	  
			(store_random_in_range, ":rand_dest", 1 ,12),
			
            (try_begin),
				(eq, ":rand_dest", 1),
				(assign, ":target_entry_point", 9),
			(else_try),	
				(eq, ":rand_dest", 2),
				(assign, ":target_entry_point", 10),
			(else_try),	
				(eq, ":rand_dest", 3),
				(assign, ":target_entry_point", 12),	
			(else_try),	
				(eq, ":rand_dest", 4),
				(assign, ":target_entry_point", 32),	
			(else_try),	
				(eq, ":rand_dest", 2),
				(assign, ":target_entry_point", 33),	
			(else_try),	
				(eq, ":rand_dest", 5),
				(assign, ":target_entry_point", 34),	
			(else_try),	
				(eq, ":rand_dest", 6),
				(assign, ":target_entry_point", 35),	
			(else_try),	
				(eq, ":rand_dest", 7),
				(assign, ":target_entry_point", 36),	
			(else_try),	
				(eq, ":rand_dest", 8),
				(assign, ":target_entry_point", 37),	
			(else_try),	
				(eq, ":rand_dest", 9),
				(assign, ":target_entry_point", 38),	
			(else_try),	
				(eq, ":rand_dest", 10),
				(assign, ":target_entry_point", 39),	
			(else_try),	
				(assign, ":target_entry_point", 10),					
			(try_end),
			  
              (try_begin),
                (agent_set_slot, ":agent_no", 0, ":target_entry_point"),
                (entry_point_get_position, pos1, ":target_entry_point"),
                (try_begin),
                  (init_position, pos2),
                  (position_set_y, pos2, 250),
                  (position_transform_position_to_parent, pos1, pos1, pos2),
                (try_end),
                (agent_set_scripted_destination, ":agent_no", pos1, 0),
                (agent_set_speed_limit, ":agent_no", 5),
              (try_end),
          ]),

  ##################CHIEF XENOARGH anade mas walkers acaba

  # script_town_init_doors
  # Input: door_state (-1 = closed, 1 = open, 0 = use $town_nighttime)
  # Output: none (required for siege mission templates)
  ("town_init_doors",
   [(store_script_param, ":door_state", 1),
    (try_begin),
      (assign, ":continue", 0),
      (try_begin),
        (eq, ":door_state", 1),
        (assign, ":continue", 1),
      (else_try),
        (eq, ":door_state", 0),
        (eq, "$town_nighttime", 0),
        (assign, ":continue", 1),
      (try_end),
      (eq, ":continue", 1),# open doors
      (assign, ":end_cond", 1),
      (try_for_range, ":i_instance", 0, ":end_cond"),
        (scene_prop_get_instance, ":object", "spr_towngate_door_left", ":i_instance"),
        (ge, ":object", 0),
        (val_add, ":end_cond", 1),
        (prop_instance_get_position, pos1, ":object"),
        (position_rotate_z, pos1, -100),
        (prop_instance_animate_to_position, ":object", pos1, 1),
      (try_end),
      (assign, ":end_cond", 1),
      (try_for_range, ":i_instance", 0, ":end_cond"),
        (scene_prop_get_instance, ":object", "spr_towngate_rectangle_door_left", ":i_instance"),
        (ge, ":object", 0),
        (val_add, ":end_cond", 1),
        (prop_instance_get_position, pos1, ":object"),
        (position_rotate_z, pos1, -80),
        (prop_instance_animate_to_position, ":object", pos1, 1),
      (try_end),
      (assign, ":end_cond", 1),
      (try_for_range, ":i_instance", 0, ":end_cond"),
        (scene_prop_get_instance, ":object", "spr_towngate_door_right", ":i_instance"),
        (ge, ":object", 0),
        (val_add, ":end_cond", 1),
        (prop_instance_get_position, pos1, ":object"),
        (position_rotate_z, pos1, 100),
        (prop_instance_animate_to_position, ":object", pos1, 1),
      (try_end),
      (assign, ":end_cond", 1),
      (try_for_range, ":i_instance", 0, ":end_cond"),
        (scene_prop_get_instance, ":object", "spr_towngate_rectangle_door_right", ":i_instance"),
        (ge, ":object", 0),
        (val_add, ":end_cond", 1),
        (prop_instance_get_position, pos1, ":object"),
        (position_rotate_z, pos1, 80),
        (prop_instance_animate_to_position, ":object", pos1, 1),
      (try_end),
    (try_end),
  ]),

  # script_siege_init_ai_and_belfry
  # Input: none
  # Output: none (required for siege mission templates)
  ("siege_init_ai_and_belfry",
   [(assign, "$cur_belfry_pos", 50),
    (assign, ":cur_belfry_object_pos", "slot_scene_belfry_props_begin"),
    (store_current_scene, ":cur_scene"),
    #Collecting belfry objects
    (try_for_range, ":i_belfry_instance", 0, 3),
      (scene_prop_get_instance, ":belfry_object", "spr_belfry_a", ":i_belfry_instance"),
      (ge, ":belfry_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_belfry_object_pos", ":belfry_object"),
      (val_add, ":cur_belfry_object_pos", 1),
    (try_end),
    (try_for_range, ":i_belfry_instance", 0, 3),
      (scene_prop_get_instance, ":belfry_object", "spr_belfry_platform_a", ":i_belfry_instance"),
      (ge, ":belfry_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_belfry_object_pos", ":belfry_object"),
      (val_add, ":cur_belfry_object_pos", 1),
    (try_end),
    (try_for_range, ":i_belfry_instance", 0, 3),
      (scene_prop_get_instance, ":belfry_object", "spr_belfry_platform_b", ":i_belfry_instance"),
      (ge, ":belfry_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_belfry_object_pos", ":belfry_object"),
      (val_add, ":cur_belfry_object_pos", 1),
    (try_end),
    (assign, "$belfry_rotating_objects_begin", ":cur_belfry_object_pos"),
    (try_for_range, ":i_belfry_instance", 0, 5),
      (scene_prop_get_instance, ":belfry_object", "spr_belfry_wheel", ":i_belfry_instance"),
      (ge, ":belfry_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_belfry_object_pos", ":belfry_object"),
      (val_add, ":cur_belfry_object_pos", 1),
    (try_end),
    (assign, "$last_belfry_object_pos", ":cur_belfry_object_pos"),

    #Lifting up the platform  at the beginning
    (try_begin),
      (scene_prop_get_instance, ":belfry_object_to_rotate", "spr_belfry_platform_a", 0),
    (try_end),
    
    #Moving the belfry objects to their starting position
    (entry_point_get_position,pos1,55),
    (entry_point_get_position,pos3,50),
    (try_for_range, ":i_belfry_object_pos", "slot_scene_belfry_props_begin", "$last_belfry_object_pos"),
      (assign, ":pos_no", pos_belfry_begin),
      (val_add, ":pos_no", ":i_belfry_object_pos"),
      (val_sub, ":pos_no", "slot_scene_belfry_props_begin"),
      (scene_get_slot, ":cur_belfry_object", ":cur_scene", ":i_belfry_object_pos"),
      (prop_instance_get_position, pos2, ":cur_belfry_object"),
      (try_begin),
        (eq, ":cur_belfry_object", ":belfry_object_to_rotate"),
        (position_rotate_x, pos2, 90),
      (try_end),
      (position_transform_position_to_local, ":pos_no", pos1, pos2),
      (position_transform_position_to_parent, pos4, pos3, ":pos_no"),
      (prop_instance_animate_to_position, ":cur_belfry_object", pos4, 1),
    (try_end),
    (assign, "$belfry_positioned", 0),
    (assign, "$belfry_num_slots_positioned", 0),
    (assign, "$belfry_num_men_pushing", 0),

    (set_show_messages, 0),
    (team_give_order, "$attacker_team", grc_everyone, mordr_stand_ground),
    (team_give_order, "$attacker_team_2", grc_everyone, mordr_stand_ground),
    (set_show_messages, 1),
  ]),

  # script_cf_siege_move_belfry
  # Input: none
  # Output: none (required for siege mission templates)
  ("cf_siege_move_belfry",
   [(neq, "$last_belfry_object_pos", "slot_scene_belfry_props_begin"),
     (eq, "$g_belfry_was_destroyed", 0), #fire arrow chief
    (entry_point_get_position,pos1,50),
    (entry_point_get_position,pos4,55),
    (get_distance_between_positions, ":total_distance", pos4, pos1),
    (store_current_scene, ":cur_scene"),
    (scene_get_slot, ":first_belfry_object", ":cur_scene", "slot_scene_belfry_props_begin"),
    (prop_instance_get_position, pos2, ":first_belfry_object"),
    (entry_point_get_position,pos1,"$cur_belfry_pos"),
    (position_transform_position_to_parent, pos3, pos1, pos_belfry_begin),
    (position_transform_position_to_parent, pos5, pos4, pos_belfry_begin),
    (get_distance_between_positions, ":cur_distance", pos2, pos3),
    (get_distance_between_positions, ":distance_left", pos2, pos5),
    (try_begin),
      (le, ":cur_distance", 10),
      (val_add, "$cur_belfry_pos", 1),
      (entry_point_get_position,pos1,"$cur_belfry_pos"),
      (position_transform_position_to_parent, pos3, pos1, pos_belfry_begin),
      (get_distance_between_positions, ":cur_distance", pos2, pos3),
    (try_end),
    (neq, "$cur_belfry_pos", 50),

    (assign, ":base_speed", 20),
    (store_div, ":slow_range", ":total_distance", 60),
    (store_sub, ":distance_moved", ":total_distance", ":distance_left"),

    (try_begin),
      (lt, ":distance_moved", ":slow_range"),
      (store_mul, ":base_speed", ":distance_moved", -60),
      (val_div, ":base_speed", ":slow_range"),
      (val_add, ":base_speed", 80),
    (else_try),
      (lt, ":distance_left", ":slow_range"),
      (store_mul, ":base_speed", ":distance_left", -60),
      (val_div, ":base_speed", ":slow_range"),
      (val_add, ":base_speed", 80),
    (try_end),
    (store_mul, ":belfry_speed", ":cur_distance", ":base_speed"),
    (try_begin),
      (eq, "$belfry_num_men_pushing", 0),
      (assign, ":belfry_speed", 1000000),
    (else_try),
      (val_div, ":belfry_speed", "$belfry_num_men_pushing"),
    (try_end),

    (try_begin),
      (le, "$cur_belfry_pos", 55),
      (init_position, pos3),
      (position_rotate_x, pos3, ":distance_moved"),
      (scene_get_slot, ":base_belfry_object", ":cur_scene", "slot_scene_belfry_props_begin"),
      (prop_instance_get_position, pos4, ":base_belfry_object"),
      (entry_point_get_position,pos1,"$cur_belfry_pos"),
      (try_for_range, ":i_belfry_object_pos", "slot_scene_belfry_props_begin", "$last_belfry_object_pos"),
        (scene_get_slot, ":cur_belfry_object", ":cur_scene", ":i_belfry_object_pos"),
        (try_begin),
          (ge, ":i_belfry_object_pos", "$belfry_rotating_objects_begin"),
          (prop_instance_get_starting_position, pos5, ":base_belfry_object"),
          (prop_instance_get_starting_position, pos6, ":cur_belfry_object"),
          (position_transform_position_to_local, pos7, pos5, pos6),
          (position_transform_position_to_parent, pos5, pos4, pos7),
          (position_transform_position_to_parent, pos6, pos5, pos3),
          (prop_instance_set_position, ":cur_belfry_object", pos6),
        (else_try),
          (assign, ":pos_no", pos_belfry_begin),
          (val_add, ":pos_no", ":i_belfry_object_pos"),
          (val_sub, ":pos_no", "slot_scene_belfry_props_begin"),
          (position_transform_position_to_parent, pos2, pos1, ":pos_no"),
          (prop_instance_animate_to_position, ":cur_belfry_object", pos2, ":belfry_speed"),
        (try_end),
      (try_end),
    (try_end),
    (gt, "$cur_belfry_pos", 55),
    (assign, "$belfry_positioned", 1),
  ]),

  # script_cf_siege_rotate_belfry_platform
  # Input: none
  # Output: none (required for siege mission templates)
  ("cf_siege_rotate_belfry_platform",
   [(eq, "$belfry_positioned", 1),
     (eq, "$g_belfry_was_destroyed", 0), #fire arrow chief
    (scene_prop_get_instance, ":belfry_object", "spr_belfry_platform_a", 0),
    (prop_instance_get_position, pos1, ":belfry_object"),
    (position_rotate_x, pos1, -90),
    (prop_instance_animate_to_position, ":belfry_object", pos1, 400),
    (assign, "$belfry_positioned", 2),
  ]),

  # script_cf_siege_assign_men_to_belfry
  # Input: none
  # Output: none (required for siege mission templates)
  ("cf_siege_assign_men_to_belfry",
   [
##    (store_mission_timer_a, ":cur_seconds"),
    (neq, "$last_belfry_object_pos", "slot_scene_belfry_props_begin"),
    (assign, ":end_trigger", 0),
    (try_begin),
      (eq, "$g_belfry_was_destroyed", 0), #fire arrow chief
    (lt, "$belfry_positioned", 3),
      (get_player_agent_no, ":player_agent"),
      (store_current_scene, ":cur_scene"),
      (scene_get_slot, ":first_belfry_object", ":cur_scene", "slot_scene_belfry_props_begin"),
      (prop_instance_get_position, pos2, ":first_belfry_object"),
      (assign, ":slot_1_positioned", 0),
      (assign, ":slot_2_positioned", 0),
      (assign, ":slot_3_positioned", 0),
      (assign, ":slot_4_positioned", 0),
      (assign, ":slot_5_positioned", 0),
      (assign, ":slot_6_positioned", 0),
      (assign, "$belfry_num_slots_positioned", 0),
      (assign, "$belfry_num_men_pushing", 0),
      (try_for_agents, ":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (try_begin),
          (agent_get_slot, ":x_pos", ":cur_agent", "slot_agent_target_x_pos"),
          (neq, ":x_pos", 0),
          (agent_get_slot, ":y_pos", ":cur_agent", "slot_agent_target_y_pos"),
          (try_begin),
            (eq, ":x_pos", -600),
            (try_begin),
              (eq, ":y_pos", 0),
              (assign, ":slot_1_positioned", 1),
            (else_try),
              (eq, ":y_pos", -200),
              (assign, ":slot_2_positioned", 1),
            (else_try),
              (assign, ":slot_3_positioned", 1),
            (try_end),
          (else_try),
            (try_begin),
              (eq, ":y_pos", 0),
              (assign, ":slot_4_positioned", 1),
            (else_try),
              (eq, ":y_pos", -200),
              (assign, ":slot_5_positioned", 1),
            (else_try),
              (assign, ":slot_6_positioned", 1),
            (try_end),
          (try_end),
          (val_add, "$belfry_num_slots_positioned", 1),
          (init_position, pos1),
          (position_move_x, pos1, ":x_pos"),
          (position_move_y, pos1, ":y_pos"),
          (init_position, pos3),
          (position_move_x, pos3, ":x_pos"),
          (position_move_y, pos3, -1000),
          (position_transform_position_to_parent, pos4, pos2, pos1),
          (position_transform_position_to_parent, pos5, pos2, pos3),
          (agent_get_position, pos6, ":cur_agent"),
          (get_distance_between_positions, ":target_distance", pos6, pos4),
          (get_distance_between_positions, ":waypoint_distance", pos6, pos5),
          (try_begin),
            (this_or_next|lt, ":target_distance", ":waypoint_distance"),
            (lt, ":waypoint_distance", 600),
            (agent_set_scripted_destination, ":cur_agent", pos4, 1),
          (else_try),
            (agent_set_scripted_destination, ":cur_agent", pos5, 1),
          (try_end),
          (try_begin),
            (le, ":target_distance", 300),
            (val_add, "$belfry_num_men_pushing", 1),
          (try_end),
##        (else_try),
##          (agent_get_team, ":cur_agent_team", ":cur_agent"),
##          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
##          (             eq, "$attacker_team_2", ":cur_agent_team"),
##          (try_begin),
##            (gt, ":cur_seconds", 20),
##            (agent_get_position, pos1, ":cur_agent"),
##            (agent_set_scripted_destination, ":cur_agent", pos1, 0),
##          (else_try),
##            (try_begin),
##              (team_get_movement_order, ":order1", "$attacker_team", grc_infantry),
##              (team_get_movement_order, ":order2", "$attacker_team", grc_cavalry),
##              (team_get_movement_order, ":order3", "$attacker_team", grc_archers),
##              (this_or_next|neq, ":order1", mordr_stand_ground),
##              (this_or_next|neq, ":order2", mordr_stand_ground),
##              (neq, ":order3", mordr_stand_ground),
##              (set_show_messages, 0),
##              (team_give_order, "$attacker_team", grc_everyone, mordr_stand_ground),
##              (set_show_messages, 1),
##            (try_end),
##          (try_end),
        (try_end),
      (try_end),
      (try_begin),
        (lt, "$belfry_num_slots_positioned", 6),
        (try_for_agents, ":cur_agent"),
          (agent_is_alive, ":cur_agent"),
          (agent_get_team, ":cur_agent_team", ":cur_agent"),
          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
          (eq, "$attacker_team_2", ":cur_agent_team"),
          (neq, ":player_agent", ":cur_agent"),
          (agent_get_class, ":agent_class", ":cur_agent"),
          (this_or_next|eq, ":agent_class", grc_infantry),
          (eq, ":agent_class", grc_cavalry),
          (agent_get_slot, ":x_pos", ":cur_agent", 1),
          (eq, ":x_pos", 0),
          (assign, ":y_pos", 0),
          (try_begin),
            (eq, ":slot_1_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_1_positioned", 1),
          (else_try),
            (eq, ":slot_2_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_2_positioned", 1),
          (else_try),
            (eq, ":slot_3_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_3_positioned", 1),
          (else_try),
            (eq, ":slot_4_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_4_positioned", 1),
          (else_try),
            (eq, ":slot_5_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_5_positioned", 1),
          (else_try),
            (eq, ":slot_6_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_6_positioned", 1),
          (try_end),
          (val_add, "$belfry_num_slots_positioned", 1),
          (agent_set_slot, ":cur_agent", 1, ":x_pos"),
          (agent_set_slot, ":cur_agent", 2, ":y_pos"),
        (try_end),
      (try_end),
      (try_begin),
        (store_mission_timer_a, ":cur_timer"),
        (gt, ":cur_timer", 20),
        (lt, "$belfry_num_slots_positioned", 6),
        (try_for_agents, ":cur_agent"),
          (agent_is_alive, ":cur_agent"),
          (agent_get_team, ":cur_agent_team", ":cur_agent"),
          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
          (             eq, "$attacker_team_2", ":cur_agent_team"),
          (neq, ":player_agent", ":cur_agent"),
          (agent_get_slot, ":x_pos", ":cur_agent", 1),
          (eq, ":x_pos", 0),
          (assign, ":y_pos", 0),
          (try_begin),
            (eq, ":slot_1_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_1_positioned", 1),
          (else_try),
            (eq, ":slot_2_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_2_positioned", 1),
          (else_try),
            (eq, ":slot_3_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_3_positioned", 1),
          (else_try),
            (eq, ":slot_4_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_4_positioned", 1),
          (else_try),
            (eq, ":slot_5_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_5_positioned", 1),
          (else_try),
            (eq, ":slot_6_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_6_positioned", 1),
          (try_end),
          (val_add, "$belfry_num_slots_positioned", 1),
          (agent_set_slot, ":cur_agent", 1, ":x_pos"),
          (agent_set_slot, ":cur_agent", 2, ":y_pos"),
        (try_end),
      (try_end),
    (else_try),
      (assign, ":end_trigger", 1),
      (try_for_agents, ":cur_agent"),
        (agent_clear_scripted_mode, ":cur_agent"),
      (try_end),
      (set_show_messages, 0),
      (team_give_order, "$attacker_team", grc_everyone, mordr_charge),
      (set_show_messages, 1),
    (try_end),
    (eq, ":end_trigger", 1),
  ]),

  # script_siege_move_archers_to_archer_positions
  # Input: none
  # Output: none
##  ("siege_move_archers_to_archer_positions",
##   [
##     (try_for_agents, ":agent_no"),
##       (agent_is_alive, ":agent_no"),
##       (agent_slot_eq, ":agent_no", "slot_agent_is_not_reinforcement", 0),
##       (agent_is_defender, ":agent_no"),
##       (agent_get_class, ":agent_class", ":agent_no"),
##       (agent_get_troop_id, ":agent_troop", ":agent_no"),
##       (eq, ":agent_class", grc_archers),
##       (try_begin),
##         (agent_slot_eq, ":agent_no", "slot_agent_target_entry_point", 0),
##         (store_random_in_range, ":random_entry_point", 40, 44),
##         (agent_set_slot, ":agent_no", "slot_agent_target_entry_point", ":random_entry_point"),
##       (try_end),
##       (try_begin),
##         (agent_get_position, pos0, ":agent_no"),
##         (entry_point_get_position, pos1, ":random_entry_point"),
##         (get_distance_between_positions, ":dist", pos0, pos1),
##         (lt, ":dist", 300),
##         (agent_clear_scripted_mode, ":agent_no"),
##         (agent_set_slot, ":agent_no", "slot_agent_is_in_scripted_mode", 0),
##         (agent_set_slot, ":agent_no", "slot_agent_is_not_reinforcement", 1),
##         (str_store_troop_name, s1, ":agent_troop"),
##         (assign, reg0, ":agent_no"),
###         (display_message, "@{s1} ({reg0}) reached pos"),
##       (else_try),
##         (agent_get_simple_behavior, ":agent_sb", ":agent_no"),
##         (agent_get_combat_state, ":agent_cs", ":agent_no"),
##         (this_or_next|eq, ":agent_sb", aisb_ranged),
##         (eq, ":agent_sb", aisb_go_to_pos),#scripted mode
##         (eq, ":agent_cs", 7), # 7 = no visible targets (state for ranged units)
##         (try_begin),
##           (agent_slot_eq, ":agent_no", "slot_agent_is_in_scripted_mode", 0),
##           (agent_set_scripted_destination, ":agent_no", pos1, 0),
##           (agent_set_slot, ":agent_no", "slot_agent_is_in_scripted_mode", 1),
##           (str_store_troop_name, s1, ":agent_troop"),
##           (assign, reg0, ":agent_no"),
###           (display_message, "@{s1} ({reg0}) moving to pos"),
##         (try_end),
##       (else_try),
##         (try_begin),
##           (agent_slot_eq, ":agent_no", "slot_agent_is_in_scripted_mode", 1),
##           (agent_clear_scripted_mode, ":agent_no"),
##           (agent_set_slot, ":agent_no", "slot_agent_is_in_scripted_mode", 0),
##           (str_store_troop_name, s1, ":agent_troop"),
##           (assign, reg0, ":agent_no"),
###           (display_message, "@{s1} ({reg0}) seeing target or changed mode"),
##         (try_end),
##       (try_end),
##     (try_end),
##     ]),

###nuevo por abhuva chief
  ("siege_move_archers_to_archer_positions",
   [
     (try_for_agents, ":agent_no"),
       (agent_is_alive, ":agent_no"),
       (agent_slot_eq, ":agent_no", "slot_agent_is_not_reinforcement", 0), #Note: could be changed from eq 0 to lt 1 to fix an issue if there was one here.
       (agent_is_defender, ":agent_no"),
       (agent_get_class, ":agent_class", ":agent_no"),
     #  (agent_get_troop_id, ":agent_troop", ":agent_no"),
       (eq, ":agent_class", grc_archers),             
               (agent_get_position, pos0, ":agent_no"), #JL PoP 3.4: new code for determining the position of the current archer.
               (assign, ":danger_to_cur_archer", 0), #JL PoP 3.4: added a flag for dangers to the defender current archer agent
             
               #JL PoP 3.4: new code for determining enemy nearest agent position and assigning danger variable relative to current defender archer agent:

               (try_for_agents, ":enemy_agent"), #go through all agents again .. (n^2)
                         (agent_is_alive, ":enemy_agent"),
                         (agent_is_human, ":enemy_agent"), # added this just in case ...
                         (neg|agent_is_defender, ":enemy_agent"), #agent is attacker
                         (agent_get_class, ":enemy_agent_class", ":enemy_agent"),
                         (agent_get_position, pos1, ":enemy_agent"),       
                         (get_distance_between_positions, ":distance_to_enemy_agent", pos0, pos1), #compare current archer distance to current enemy agent distance

                                    (try_begin), #if the enemy agent is an archer then there is danger if he is within 50m range
                                                (eq, ":enemy_agent_class", grc_archers),
                                                (agent_get_ammo,":ammo_count",":enemy_agent", 1), #count the ammo of the enemy's wielded weapon
                                                (gt, ":ammo_count", 0), #if the enemy has ammo for its wielded weapon and
                                                (lt, ":distance_to_enemy_agent", 750), #less than 7.5 m means danger changed by Abhuva
                                                (assign, ":danger_to_cur_archer", 1), #a break from loop would be good after this line ...

                                    (else_try), #otherwise there is a danger if a non-archer is within 15 m range
                                                (lt, ":distance_to_enemy_agent", 750), #less than 7.5 m means danger, changed by Abhuva
                                                (assign, ":danger_to_cur_archer", 1), #a break from loop would be good after this line ...

                                    (try_end),                     

               (try_end),

               #End of additional code for PoP 3.4
                     
       (try_begin),
         (agent_slot_eq, ":agent_no", "slot_agent_target_entry_point", 0),
         (store_random_in_range, ":random_entry_point", 40, 44),
         (agent_set_slot, ":agent_no", "slot_agent_target_entry_point", ":random_entry_point"),

       (try_end),

       (try_begin),

         (agent_get_position, pos0, ":agent_no"),
         (entry_point_get_position, pos1, ":random_entry_point"),
         (get_distance_between_positions, ":dist", pos0, pos1),
         (lt, ":dist", 300),
         (agent_clear_scripted_mode, ":agent_no"),
         (agent_set_slot, ":agent_no", "slot_agent_is_in_scripted_mode", 0),
         (agent_set_slot, ":agent_no", "slot_agent_is_not_reinforcement", 1),

       (else_try),

         (agent_get_simple_behavior, ":agent_sb", ":agent_no"),
         #(agent_get_combat_state, ":agent_cs", ":agent_no"), #JL Pop 3.303: commented out because of the line that is also commented out below.

         (this_or_next|eq, ":agent_sb", aisb_ranged),
         (eq, ":agent_sb", aisb_go_to_pos),#scripted mode
         (eq, ":danger_to_cur_archer", 0), #JL PoP 3.303: added a danger flag to relace combat state flag, since combat state is unknown for "visible target".
         #(eq, ":agent_cs", 7), # 7 = no visible targets (state for ranged units) <-- commented out because this seems to not be the right value ... Abhuva PoP 3.303

         (try_begin),
           (agent_slot_eq, ":agent_no", "slot_agent_is_in_scripted_mode", 0),
           (agent_set_scripted_destination, ":agent_no", pos1, 0),
           (agent_set_slot, ":agent_no", "slot_agent_is_in_scripted_mode", 1),
         (try_end),

   (else_try),

         (try_begin),
             (agent_slot_eq, ":agent_no", "slot_agent_is_in_scripted_mode", 1),
             (agent_clear_scripted_mode, ":agent_no"),
             (agent_set_slot, ":agent_no", "slot_agent_is_in_scripted_mode", 0),
          (try_end),

       (try_end),
         

     (try_end),

     ]),
  #chief abhuva acaba

 # script_set_town_picture
  # Input: none
  # Output: none
  ("set_town_picture",
   [
        (try_begin),
          (party_get_current_terrain, ":cur_terrain", "$current_town"),
          (party_slot_eq,"$current_town","slot_party_type", spt_town),
          (try_begin),
            (this_or_next|eq, ":cur_terrain", rt_steppe),
            (this_or_next|eq, ":cur_terrain", rt_steppe_forest),
            (this_or_next|eq, ":cur_terrain", rt_desert),
            (             eq, ":cur_terrain", rt_desert_forest),
            (set_background_mesh, "mesh_pic_extra_town1"),
          (else_try),
            (this_or_next|eq, ":cur_terrain", rt_snow),
            (             eq, ":cur_terrain", rt_snow_forest),
            (set_background_mesh, "mesh_pic_extra_town1"),
          (else_try),
            (set_background_mesh, "mesh_pic_extra_town1"),
          (try_end),
        (else_try),
          (try_begin),
            (this_or_next|eq, ":cur_terrain", rt_steppe),
            (this_or_next|eq, ":cur_terrain", rt_steppe_forest),
            (this_or_next|eq, ":cur_terrain", rt_desert),
            (             eq, ":cur_terrain", rt_desert_forest),
            (set_background_mesh, "mesh_pic_extra_town2"),
          (else_try),
            (this_or_next|eq, ":cur_terrain", rt_snow),
            (             eq, ":cur_terrain", rt_snow_forest),
            (set_background_mesh, "mesh_pic_extra_town2"),
          (else_try),
            (set_background_mesh, "mesh_pic_extra_town2"),
          (try_end),
        (try_end),
    ]),


  # script_consume_food
  # Input: arg1: order of the food to be consumed
  # Output: none
  ("consume_food",
   [(store_script_param, ":selected_food", 1),
    (troop_get_inventory_capacity, ":capacity", "trp_player"),
    (try_for_range, ":cur_slot", 0, ":capacity"),
      (troop_get_inventory_slot, ":cur_item", "trp_player", ":cur_slot"),
      (this_or_next|is_between, ":cur_item", bebidas_begin, bebidas_end), #chief anade para bebidas consumo
      (is_between, ":cur_item", food_begin, food_end),
      (troop_get_inventory_slot_modifier, ":item_modifier", "trp_player", ":cur_slot"),
      (neq, ":item_modifier", imod_rotten),
      (item_slot_eq, ":cur_item", "slot_item_is_checked", 0),
      (item_set_slot, ":cur_item", "slot_item_is_checked", 1),
      (val_sub, ":selected_food", 1),
      (lt, ":selected_food", 0),
      (assign, ":capacity", 0),
      (troop_inventory_slot_get_item_amount, ":cur_amount", "trp_player", ":cur_slot"),
      (val_sub, ":cur_amount", 1),
      (troop_inventory_slot_set_item_amount, "trp_player", ":cur_slot", ":cur_amount"),
    (try_end),
    ]),

	
	
  # script_calculate_troop_score_for_center
  # Input: arg1 = troop_no, arg2 = center_no
  # Output: reg0 = score
  ("calculate_troop_score_for_center",
   [(store_script_param, ":troop_no", 1),
    (store_script_param, ":center_no", 2),
    (assign, ":num_center_points", 1),
    (try_for_range, ":cur_center", centers_begin, centers_end),
      (assign, ":center_owned", 0),
      (try_begin),
        (eq, ":troop_no", "trp_player"),
        (party_slot_eq, ":cur_center", "slot_town_lord", stl_reserved_for_player),
        (assign, ":center_owned", 1),
      (try_end),
      (this_or_next|party_slot_eq, ":cur_center", "slot_town_lord", ":troop_no"),
		(eq, ":center_owned", 1),
      (try_begin),
        (party_slot_eq, ":cur_center", "slot_party_type", spt_town),
        (val_add, ":num_center_points", 4),
      (else_try),
        (party_slot_eq, ":cur_center", "slot_party_type", spt_castle),
        (val_add, ":num_center_points", 2),
      (else_try),
        (val_add, ":num_center_points", 1),
      (try_end),
    (try_end),
    (troop_get_slot, ":troop_renown", ":troop_no", "slot_troop_renown"),
    (store_add, ":score", 500, ":troop_renown"),
    (val_div, ":score", ":num_center_points"),
    (store_random_in_range, ":random", 50, 100),
    (val_mul, ":score", ":random"),
    (try_begin),
      (party_slot_eq, ":center_no", "slot_center_last_taken_by_troop", ":troop_no"),
      (val_mul, ":score", 3),
      (val_div, ":score", 2),
    (try_end),
    (try_begin),
      (eq, ":troop_no", "trp_player"),
      (faction_get_slot, ":faction_leader", "$players_kingdom"),
      (call_script, "script_troop_get_player_relation", ":faction_leader"),
      (assign, ":leader_relation", reg0),
      #(troop_get_slot, ":leader_relation", ":faction_leader", "slot_troop_player_relation"),
      (val_mul, ":leader_relation", 2),
      (val_add, ":score", ":leader_relation"),
    (try_end),
    (assign, reg0, ":score"),
    ]),
  

  # script_assign_lords_to_empty_centers
  # Input: none
  # Output: none
  #Now ONLY called from the start
  ("assign_lords_to_empty_centers",
   [
   
    (try_begin),
		(eq, "$cheat_mode", 1),		
		(display_message, "str_assigning_lords_to_empty_centers"),
		(str_store_string, s65, "str_assign_lords_to_empty_centers_just_happened"),
		(call_script, "script_add_notification_menu", "mnu_debug_alert_from_s65", 0, 0),
    (try_end),
   
	(try_for_range, ":faction", kingdoms_begin, kingdoms_end),
		(faction_set_slot, ":faction", "slot_faction_temp_slot", 0),
    (try_end),

	(try_for_range, ":active_npc", 0, active_npcs_end),
		(troop_set_slot, ":active_npc", "slot_troop_temp_slot", 0),
    (try_end),
   
    #Factions will keep one unassigned center in reserve, unless they have landless lords
    (try_for_range, ":cur_center", centers_begin, centers_end),
	    (party_get_slot, ":center_lord", ":cur_center", "slot_town_lord"),
		(try_begin),
			(this_or_next|eq, ":center_lord", stl_unassigned),
				(eq, ":center_lord", stl_rejected_by_player),
			(store_faction_of_party, ":center_faction", ":cur_center"),
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_party_name, s4, ":cur_center"),
				(str_store_faction_name, s5, ":center_faction"),
				(display_message, "str_s4_of_the_s5_is_unassigned"),
			(try_end),
		
			(faction_get_slot, ":number_of_unassigned_centers_plus_landless_lords", ":center_faction", "slot_faction_temp_slot"),
			(val_add, ":number_of_unassigned_centers_plus_landless_lords", 1),
			(faction_set_slot,  ":center_faction", "slot_faction_temp_slot", ":number_of_unassigned_centers_plus_landless_lords"),
		(else_try),
			(eq, ":center_lord", stl_reserved_for_player),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_party_name, s4, ":cur_center"),
				(str_store_faction_name, s5, ":center_faction"),
				(display_message, "str_s4_of_the_s5_is_reserved_for_player"),
			(try_end),
			
		(else_try),
			(ge, ":center_lord", 0),
			(troop_set_slot, ":center_lord", "slot_troop_temp_slot", 1),
		(try_end),	
	(try_end),
   
	(try_for_range, ":active_npc", 0, active_npcs_end),
		(troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_kingdom_hero),
		(this_or_next|gt, ":active_npc", "trp_player"),
			(eq, "$player_has_homage", 1),
			
		(troop_slot_eq, ":active_npc", "slot_troop_temp_slot", 0),
		(store_faction_of_troop, ":npc_faction", ":active_npc"),

		(is_between, ":npc_faction", npc_kingdoms_begin, npc_kingdoms_end),
	
		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":active_npc"),
			(str_store_faction_name, s5, ":npc_faction"),
			(display_message, "str_s4_of_the_s5_has_no_fiefs"),
		(try_end),
	
		(faction_get_slot, ":number_of_unassigned_centers_plus_landless_lords", ":npc_faction", "slot_faction_temp_slot"),
		(val_add, ":number_of_unassigned_centers_plus_landless_lords", 1),
		(faction_set_slot,  ":npc_faction", "slot_faction_temp_slot", ":number_of_unassigned_centers_plus_landless_lords"),
	(try_end),
   
   	(try_begin),
	  (eq, "$cheat_mode", 1),
 	  (try_for_range, ":faction", kingdoms_begin, kingdoms_end),
		(faction_get_slot, reg4, ":faction", "slot_faction_temp_slot"),
		(str_store_faction_name, s4, ":faction"),
		(display_message, "str_s4_unassigned_centers_plus_landless_lords_=_reg4"),
	  (try_end),
    (try_end),
   
	(try_for_range, ":cur_center", centers_begin, centers_end),
		(party_get_slot, ":center_lord", ":cur_center", "slot_town_lord"),
        (this_or_next|eq, ":center_lord", stl_unassigned),
			(eq, ":center_lord", stl_rejected_by_player),
    
        (store_faction_of_party, ":center_faction", ":cur_center"),
        (is_between, ":center_faction", kingdoms_begin, kingdoms_end),
        (neg|faction_slot_eq, ":center_faction", "slot_faction_leader", "trp_player"),
        
        (try_begin),
	      (eq, "$cheat_mode", 1),
		  (str_store_party_name, s5, ":cur_center"),
	      (try_begin),
			(neg|faction_slot_ge, ":center_faction", "slot_faction_temp_slot", 2),
			(str_store_faction_name, s4, ":center_faction"),
			(display_message, "str_s4_holds_s5_in_reserve"),
		  (try_end),
        (try_end),
	  
		(faction_slot_ge, ":center_faction", "slot_faction_temp_slot", 2),
		
		#(display_message, "@Considering grant of {s5}"),

		(assign, ":best_lord", -1),
		(assign, ":best_lord_score", -1),
		(try_begin),
			(eq, ":center_lord", stl_unassigned),
			(try_begin),
				(eq, "$players_kingdom", ":center_faction"),
				(eq, "$player_has_homage", 1),
				(assign, ":best_lord", stl_reserved_for_player),
				(call_script, "script_calculate_troop_score_for_center", "trp_player", ":cur_center"),
				(assign, ":best_lord_score", reg0),
			(try_end),
		(try_end),
    
		(try_for_range, ":cur_troop", active_npcs_begin, active_npcs_end),
			(troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
			(store_troop_faction, ":troop_faction", ":cur_troop"),
			(eq, ":troop_faction", ":center_faction"),

			(call_script, "script_calculate_troop_score_for_center", ":cur_troop", ":cur_center"),
			(assign, ":score", reg0),

			#This prioritizes granting of centers for troops which do not already have one
			(try_begin),
				(troop_slot_eq, ":cur_troop", "slot_troop_temp_slot", 0),
				(is_between, ":cur_center", villages_begin, villages_end),
				(val_mul, ":score", 10),
			(try_end),
			
			(gt, ":score", ":best_lord_score"),
			(assign, ":best_lord_score", ":score"),
			(assign, ":best_lord", ":cur_troop"),
		(try_end),
	  
	    #Adjust count of centers and lords
 		(try_begin),
			(this_or_next|ge, ":best_lord", 0),
				(eq, ":best_lord", stl_reserved_for_player),
				
			(faction_get_slot, ":landless_lords_plus_unassigned_centers", ":center_faction", "slot_faction_temp_slot"),
			(val_sub, ":landless_lords_plus_unassigned_centers", 1),
			
			(try_begin),
				(eq, ":best_lord", stl_reserved_for_player),
				(troop_slot_eq, "trp_player", "slot_troop_temp_slot", 0),
				(troop_set_slot, "trp_player", "slot_troop_temp_slot", 1),
				(val_sub, ":landless_lords_plus_unassigned_centers", 1), 			
			(else_try),
				(troop_slot_eq, ":best_lord", "slot_troop_temp_slot", 0),
				(troop_set_slot, ":best_lord", "slot_troop_temp_slot", 1),
				(val_sub, ":landless_lords_plus_unassigned_centers", 1), 			
			(try_end),
			
			(faction_set_slot, ":center_faction", "slot_faction_temp_slot", ":landless_lords_plus_unassigned_centers"),
		(try_end),
	  
	    #Give the center to the lord
		(try_begin),
			(ge, ":best_lord", 0),
			(call_script, "script_give_center_to_lord", ":cur_center", ":best_lord", 1),
		(else_try),
			(eq, ":best_lord", stl_reserved_for_player),
			(party_set_slot, ":cur_center", "slot_town_lord", stl_reserved_for_player),
			(try_begin), #grant bound villages to player, if granting a castle
				(party_slot_eq, ":cur_center", "slot_party_type", spt_castle),
#				(assign, ":give_at_least_one_village", 0),
				(try_for_range, ":cur_village", villages_begin, villages_end),
#					(eq, ":give_at_least_one_village", 0),
					(party_slot_eq, ":cur_village", "slot_village_bound_center", ":cur_center"),
					(party_slot_eq, ":cur_village", "slot_town_lord", stl_unassigned),
					(party_set_slot, ":cur_village", "slot_town_lord", stl_reserved_for_player),
#					(assign, ":give_at_least_one_village", 1),
				(try_end),
			(try_end),
		(try_end),
    (try_end),
    ]),

  #script_player_join_faction
  # INPUT: arg1 = faction_no
  # OUTPUT: none
  ("player_join_faction",
    [
      (store_script_param, ":faction_no", 1),
      (assign,"$players_kingdom",":faction_no"),
      (faction_set_slot, "fac_player_supporters_faction", "slot_faction_ai_state", sfai_default),
      (assign, "$players_oath_renounced_against_kingdom", 0),
      (assign, "$players_oath_renounced_given_center", 0),
      (assign, "$players_oath_renounced_begin_time", 0),

      (try_for_range,":other_kingdom",kingdoms_begin,kingdoms_end),
        (faction_slot_eq, ":other_kingdom", "slot_faction_state", sfs_active),
        (neq, ":other_kingdom", "fac_player_supporters_faction"),
        (try_begin),
          (neq, ":other_kingdom", ":faction_no"),
          (store_relation, ":other_kingdom_reln", ":other_kingdom", ":faction_no"),
        (else_try),
          (store_relation, ":other_kingdom_reln", "fac_player_supporters_faction", ":other_kingdom"),
          (val_max, ":other_kingdom_reln", 12),
        (try_end),
        (call_script, "script_set_player_relation_with_faction", ":other_kingdom", ":other_kingdom_reln"),
      (try_end),
      
      (try_for_range, ":cur_center", centers_begin, centers_end),
        #Give center to kingdom if player is the owner
        (party_slot_eq, ":cur_center", "slot_town_lord", "trp_player"),
        (call_script, "script_give_center_to_faction_while_maintaining_lord", ":cur_center", ":faction_no"),
	  (else_try),
        #Give center to kingdom if part of player faction
     	(store_faction_of_party, ":cur_center_faction", ":cur_center"),
		(eq, ":cur_center_faction", "fac_player_supporters_faction"),
        (call_script, "script_give_center_to_faction_while_maintaining_lord", ":cur_center", ":faction_no"),
      (try_end),
      
      (try_for_range, ":quest_no", lord_quests_begin, lord_quests_end),
        (check_quest_active, ":quest_no"),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
        (store_troop_faction, ":quest_giver_faction", ":quest_giver_troop"),
        (store_relation, ":quest_giver_faction_relation", "fac_player_supporters_faction", ":quest_giver_faction"),
        (lt, ":quest_giver_faction_relation", 0),
        (call_script, "script_abort_quest", ":quest_no", 0),
      (try_end),
      (try_for_range, ":quest_no", lord_quests_begin_2, lord_quests_end_2),
        (check_quest_active, ":quest_no"),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
        (store_troop_faction, ":quest_giver_faction", ":quest_giver_troop"),
        (store_relation, ":quest_giver_faction_relation", "fac_player_supporters_faction", ":quest_giver_faction"),
        (lt, ":quest_giver_faction_relation", 0),
        (call_script, "script_abort_quest", ":quest_no", 0),
      (try_end),
      (try_begin),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (faction_set_slot, "fac_player_supporters_faction", "slot_faction_state", sfs_inactive),
        (faction_set_slot, "fac_player_supporters_faction", "slot_faction_leader", "trp_player"),
      (try_end),
	  
	  (try_begin),
		(troop_get_slot, ":spouse", "trp_player", "slot_troop_spouse"),
	    (is_between, ":spouse", kingdom_ladies_begin, kingdom_ladies_end),
		
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":spouse"),
			(display_message, "@{!}DEBUG - {s4} faction changed by marriage, case 1"), 
		(try_end),
		
	    (troop_set_faction, ":spouse", "$players_kingdom"),
	  (try_end),
	  	  
	  (try_for_range, ":center", centers_begin, centers_end),
	    (store_faction_of_party, ":center_faction", ":faction_no"),
		(neq, ":center_faction", "$players_kingdom"),
		(party_slot_eq, ":center", "slot_town_lord", stl_reserved_for_player),
#		(party_set_slot, ":center", "slot_town_lord", stl_unassigned),
	  (try_end),
	  
	  (troop_set_slot, "trp_player", "slot_troop_stance_on_faction_issue", -1),
	  
	  #remove prisoners of player's faction if he was member of his own faction. And free companions which is prisoned in that faction.
      (try_for_parties, ":party_no"),
        (store_faction_of_party, ":party_faction", ":party_no"),
        (eq, ":party_faction", ":faction_no"),
        
        (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
        (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
          (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":party_no", ":troop_iterator"),                                 
          (store_troop_faction, ":cur_faction", ":cur_troop_id"),
                      
          (this_or_next|eq, ":cur_faction", "fac_player_supporters_faction"),
          (this_or_next|eq, ":cur_faction", ":faction_no"),
          (is_between, ":cur_troop_id", companions_begin, companions_end),
            
          (try_begin),
            (troop_is_hero, ":cur_troop_id"),
            (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
          (try_end),
          
          (party_prisoner_stack_get_size, ":stack_size", ":party_no", ":troop_iterator"),
          (party_remove_prisoners, ":party_no", ":cur_troop_id", ":stack_size"),
          
          (try_begin),
            (is_between, ":cur_troop_id", companions_begin, companions_end),
            
            (try_begin),
              (is_between, ":party_no", towns_begin, towns_end),
              (troop_set_slot, ":cur_troop_id", "slot_troop_cur_center", ":party_no"),
            (else_try),
              (store_random_in_range, ":random_town_no", towns_begin, towns_end),       
              (troop_set_slot, ":cur_troop_id", "slot_troop_cur_center", ":random_town_no"),
            (try_end),  
          (try_end),
        (try_end),
      (try_end),
      #remove prisoners end.

      #(call_script, "script_store_average_center_value_per_faction"),
      (call_script, "script_update_all_notes"),
      (assign, "$g_recalculate_ais", 1),
      ]),

  #script_player_leave_faction
  # INPUT: arg1 = give_back_fiefs
  # OUTPUT: none
  ("player_leave_faction",
    [
      (store_script_param, ":give_back_fiefs", 1),
	  
      (call_script, "script_check_and_finish_active_army_quests_for_faction", "$players_kingdom"),
      (assign, ":old_kingdom", "$players_kingdom"),
      (assign, ":old_has_homage", "$player_has_homage"),
      (assign, "$players_kingdom", 0),
      (assign, "$player_has_homage", 0),
	  
      (try_begin),
        (neq, ":give_back_fiefs", 0), #ie, give back fiefs = 1, thereby do it
        (try_for_range, ":cur_center", centers_begin, centers_end),
          (party_slot_eq, ":cur_center", "slot_town_lord", "trp_player"),
          ##diplomacy chief begin
          #native bug fix when giving back fiefs
          (call_script, "script_give_center_to_faction", ":cur_center", "fac_neutral"),
          ##diplomacy end
          (call_script, "script_give_center_to_faction", ":cur_center", ":old_kingdom"),
		  
		  #The following line also occurs when a lord is stripped of his fiefs by an indictment
		  (party_set_slot, ":cur_center", "slot_town_lord", stl_unassigned),
        (try_end),		
      (else_try),
	    #If you retain the fiefs
        (try_for_range, ":cur_center", centers_begin, centers_end),
          (party_slot_eq, ":cur_center", "slot_town_lord", "trp_player"),
          (call_script, "script_give_center_to_faction", ":cur_center", "fac_player_supporters_faction"),
		  (party_set_slot, ":cur_center", "slot_town_lord", "trp_player"),
          (troop_get_slot, ":cur_banner", "trp_player", "slot_troop_banner_scene_prop"),
          (gt, ":cur_banner", 0),
          (val_sub, ":cur_banner", banner_scene_props_begin),
          (val_add, ":cur_banner", banner_map_icons_begin),
          (party_set_banner_icon, ":cur_center", ":cur_banner"),		  		  
        (try_end),
        
        (try_for_range, ":cur_center", villages_begin, villages_end),
          (party_get_slot, ":cur_bound_center", ":cur_center", "slot_village_bound_center"),
          (party_slot_eq, ":cur_center", "slot_town_lord", "trp_player"),
          (neg|party_slot_eq, ":cur_bound_center", "slot_town_lord", "trp_player"),
          (call_script, "script_give_center_to_faction", ":cur_center", ":old_kingdom"),
        (try_end),
	  
		(is_between, ":old_kingdom", kingdoms_begin, kingdoms_end),
		(neq, ":old_kingdom", "fac_player_supporters_faction"),		
        (store_relation, ":reln", "fac_player_supporters_faction", ":old_kingdom"),
        (store_sub, ":req_dif", -40, ":reln"),
        (call_script, "script_change_player_relation_with_faction", ":old_kingdom", ":req_dif"),
      (try_end),
	  
      (try_begin),
        (eq, ":old_has_homage", 1),
        (faction_get_slot, ":faction_leader", ":old_kingdom", "slot_faction_leader"),
        (call_script, "script_change_player_relation_with_troop", ":faction_leader", -20),
      (try_end),
	  
	  (try_begin),
		(troop_get_slot, ":spouse", "trp_player", "slot_troop_spouse"),
	    (is_between, ":spouse", kingdom_ladies_begin, kingdom_ladies_end),
		
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":spouse"),
			(display_message, "@{!}DEBUG - {s4} faction changed by marriage, case 3"), 
		(try_end),
		
	    (troop_set_faction, ":spouse", "fac_player_supporters_faction"),
	  (try_end),
	  
	  #Change relations with players_kingdom when player changes factions
	  (try_for_range, ":kingdom", kingdoms_begin, kingdoms_end),
	    (neq, ":kingdom", "fac_player_supporters_faction"),
	    (store_relation, ":relation_with_old_faction", ":old_kingdom", ":kingdom"),
	    (store_relation, ":relation_with_player_faction", "fac_player_faction", ":kingdom"),
	    
	    (try_begin),
	      (eq, ":old_kingdom", ":kingdom"),
	      (val_min, ":relation_with_player_faction", 0),
	    (else_try),	
	      (lt, ":relation_with_old_faction", 0),
	      (val_max, ":relation_with_player_faction", 0),
	    (try_end),
	    (set_relation, "fac_player_faction", ":kingdom", ":relation_with_player_faction"),
	    (set_relation, "fac_player_supporters_faction", ":kingdom", ":relation_with_player_faction"),
	  (try_end),
	  
	  (call_script, "script_update_all_notes"),
	  (assign, "$g_recalculate_ais", 1),

      patrols.consequences_player_disbands,
     ]),

	  
    ("deactivate_player_faction",
    [
	(faction_set_slot, "fac_player_supporters_faction", "slot_faction_state", sfs_inactive),
    (faction_set_slot, "fac_player_supporters_faction", "slot_faction_leader", "trp_player"),
    (assign, "$players_kingdom", 0),
    (assign, "$players_oath_renounced_against_kingdom", 0),
    (assign, "$players_oath_renounced_given_center", 0),
    (assign, "$players_oath_renounced_begin_time", 0),
    #(call_script, "script_store_average_center_value_per_faction"),
    (call_script, "script_update_all_notes"),

	minister.consequences_deactivate_faction,
	
    (call_script, "script_add_notification_menu", "mnu_notification_player_faction_deactive", 0, 0),
    ]),

	
  #script_activate_player_faction
  # INPUT: arg1 = last_interaction_with_faction
  # OUTPUT: none
  
  #When a player convinces her husband to rebel
  #When a player proclaims herself queen
  #When a player seizes control of a center  
  #When a player recruits a lord through intrigue
  #When a player 
    ("activate_player_faction",
    [
    (store_script_param, ":liege", 1),

	#This moved to top, so that mnu_notification does not occur twice
	(try_begin),
		(faction_slot_eq, "fac_player_supporters_faction", "slot_faction_state", sfs_inactive),
		(neg|is_between, ":liege", pretenders_begin, pretenders_end),
		(call_script, "script_add_notification_menu", "mnu_notification_player_faction_active", 0, 0),
		##diplomacy begin
		(call_script, "script_add_notification_menu", "mnu_dplmc_domestic_policy", 0, 0),
		##diplomacy end
	(try_end),

	
    (faction_set_slot, "fac_player_supporters_faction", "slot_faction_state", sfs_active),
    (faction_set_slot, "fac_player_supporters_faction", "slot_faction_leader", ":liege"),

	(assign, ":original_kingdom", "$players_kingdom"),
	
	(try_begin),
		(is_between, ":original_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		(call_script, "script_player_leave_faction", 0), #Ends quests, transfers control of centers
	(try_end),
	
	#Name faction
	(try_begin),
		(is_between, ":liege", active_npcs_begin, active_npcs_end),
		(store_faction_of_troop, ":liege_faction"),
		(is_between, ":liege_faction", npc_kingdoms_begin, npc_kingdoms_end),
		(faction_get_slot, ":adjective_string", ":liege_faction", "slot_faction_adjective"),
		(str_store_string, s1, ":adjective_string"),
		(faction_set_name, "fac_player_supporters_faction", "@{s1} Rebels"),
	(else_try),
		(str_store_troop_name, s2, ":liege"),
        (str_store_string, s1, "str_s2s_rebellion"),
	(try_end),	
    (faction_set_color, "fac_player_supporters_faction", 0xFF0000),
	
    (assign, "$players_kingdom", "fac_player_supporters_faction"),
    (assign, "$g_player_banner_granted", 1),
	
	
	
	#Any oaths renounced?
	(try_begin),
		(is_between, ":original_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		
        (faction_get_slot, ":old_leader", ":original_kingdom", "slot_faction_leader"),
        (call_script, "script_add_log_entry", logent_renounced_allegiance,   "trp_player",  -1, ":old_leader", "$players_kingdom"),

        #Initializing renounce war variables
        (assign, "$players_oath_renounced_against_kingdom", ":original_kingdom"),
        (assign, "$players_oath_renounced_given_center", 0),
        (store_current_hours, "$players_oath_renounced_begin_time"),
        
        (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
          (store_faction_of_party, ":cur_center_faction", ":cur_center"),
          (party_set_slot, ":cur_center", "slot_center_faction_when_oath_renounced", ":cur_center_faction"),
        (try_end),
        (party_set_slot, "$g_center_to_give_to_player", "slot_center_faction_when_oath_renounced", "$players_oath_renounced_against_kingdom"),
		
		(store_relation, ":relation", ":original_kingdom", "fac_player_supporters_faction"),
		(ge, ":relation", 0),
		(call_script, "script_diplomacy_start_war_between_kingdoms", ":original_kingdom", "fac_player_supporters_faction", logent_faction_declares_war_out_of_personal_enmity),	#MOTO chief pass log entries
#		(call_script, "script_diplomacy_start_war_between_kingdoms", ":original_kingdom", "fac_player_supporters_faction", 1),
	(try_end),
	
	
	(try_begin),
		(troop_get_slot, ":spouse", "trp_player", "slot_troop_spouse"),
	    (is_between, ":spouse", kingdom_ladies_begin, kingdom_ladies_end),
				
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":spouse"),
			(display_message, "@{!}DEBUG - {s4} faction changed by marriage, case 2"), 
		(try_end),
		
	    (troop_set_faction, ":spouse", "fac_player_supporters_faction"),
	(try_end),
		 	
	
    #(call_script, "script_store_average_center_value_per_faction"),
    (call_script, "script_update_all_notes"),
	(assign, "$g_recalculate_ais", 1),
	
    ]),



  #script_agent_reassign_team
  # INPUT: arg1 = agent_no
  # OUTPUT: none
  ("agent_reassign_team",
    [
      (store_script_param, ":agent_no", 1),
      (get_player_agent_no, ":player_agent"),
      (try_begin),
        (ge, ":player_agent", 0),
        (agent_is_human, ":agent_no"),
        (agent_is_ally, ":agent_no"),
        (agent_get_party_id, ":party_no", ":agent_no"),
        (neq, ":party_no", "p_main_party"),
        (assign, ":continue", 1),
        (store_faction_of_party, ":party_faction", ":party_no"),
        (try_begin),
          (eq, ":party_faction", "$players_kingdom"),
          (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
          (faction_slot_eq, "$players_kingdom", "slot_faction_marshall", "trp_player"),
          (assign, ":continue", 0),
        (else_try),
           (neq, "$freelancer_state", 1),	#Caba freelancer fixes chief
        (party_stack_get_troop_id, ":leader_troop_id", ":party_no", 0),
          (neg|is_between, ":leader_troop_id", active_npcs_begin, active_npcs_end),
          (assign, ":continue", 0),
        (try_end),
        (eq, ":continue", 1),
        (agent_get_team, ":player_team", ":player_agent"),
        (val_add, ":player_team", 2),
        (agent_set_team, ":agent_no", ":player_team"),
      (try_end),
      ]),

  #script_start_quest
  # INPUT: arg1 = quest_no, arg2 = giver_troop_no, s2 = description_text
  # OUTPUT: none
  ("start_quest",
    [(store_script_param, ":quest_no", 1),
     (store_script_param, ":giver_troop_no", 2),
	 
	 (quest_set_slot, ":quest_no", "slot_quest_giver_troop", ":giver_troop_no"),
	 
     (try_begin),
	   (eq, ":giver_troop_no", -1),
       (str_store_string, s63, "str_political_suggestion"),
	 (else_try),
       (is_between, ":giver_troop_no", active_npcs_begin, active_npcs_end),
       (str_store_troop_name_link, s62, ":giver_troop_no"),
       (str_store_string, s63, "@Given by: {s62}"),
     (else_try),
       (str_store_troop_name, s62, ":giver_troop_no"),
       (str_store_string, s63, "@Given by: {s62}"),
     (try_end),
     (store_current_hours, ":cur_hours"),          
     (str_store_date, s60, ":cur_hours"),
     (str_store_string, s60, "@Given on: {s60}"),
     (add_quest_note_from_sreg, ":quest_no", 0, s60, 0),
     (add_quest_note_from_sreg, ":quest_no", 1, s63, 0),
     (add_quest_note_from_sreg, ":quest_no", 2, s2, 0),

     (try_begin),
       (quest_slot_ge, ":quest_no", "slot_quest_expiration_days", 1),
       (quest_get_slot, reg0, ":quest_no", "slot_quest_expiration_days"),
       (add_quest_note_from_sreg, ":quest_no", 7, "@You have {reg0} days to finish this quest.", 0),
     (try_end),

     #Adding dont_give_again_for_days value
     (try_begin),
       (quest_slot_ge, ":quest_no", "slot_quest_dont_give_again_period", 1),
       (quest_get_slot, ":dont_give_again_period", ":quest_no", "slot_quest_dont_give_again_period"),
       (quest_set_slot, ":quest_no", "slot_quest_dont_give_again_remaining_days", ":dont_give_again_period"),
     (try_end),
     (start_quest, ":quest_no", ":giver_troop_no"),
     
     (try_begin),
       (eq, ":quest_no", "qst_report_to_army"),
       (assign, "$number_of_report_to_army_quest_notes", 8),
       (faction_get_slot, ":faction_ai_state", "$players_kingdom", "slot_faction_ai_state"),
       (call_script, "script_update_report_to_army_quest_note", "$players_kingdom", ":faction_ai_state", -1),     
     (try_end),  
	 
     (display_message, "str_quest_log_updated"),
   ]),

  #script_conclude_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("conclude_quest",
    [
      (store_script_param, ":quest_no", 1),
      (conclude_quest, ":quest_no"),
      (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
      (str_store_troop_name, s59, ":quest_giver_troop"),
      (add_quest_note_from_sreg, ":quest_no", 7, "@This quest has been concluded. Talk to {s59} to finish it.", 0),
    ]),

  #script_succeed_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("succeed_quest",
    [
      (store_script_param, ":quest_no", 1),
      (succeed_quest, ":quest_no"),
      (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
      (str_store_troop_name, s59, ":quest_giver_troop"),
      (add_quest_note_from_sreg, ":quest_no", 7, "@This quest has been successfully completed. Talk to {s59} to claim your reward.", 0),
    ]),

  #script_fail_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("fail_quest",
    [
      (store_script_param, ":quest_no", 1),
      (fail_quest, ":quest_no"),
      (quest_get_slot, ":quest_giver_troop", ":quest_no", "slot_quest_giver_troop"),
      (str_store_troop_name, s59, ":quest_giver_troop"),
      (add_quest_note_from_sreg, ":quest_no", 7, "@This quest has failed. Talk to {s59} to explain the situation.", 0),
    ]),

  #script_report_quest_troop_positions
  # INPUT: arg1 = quest_no, arg2 = troop_no, arg3 = note_index
  # OUTPUT: none
  ("report_quest_troop_positions",
    [
      (store_script_param, ":quest_no", 1),
      (store_script_param, ":troop_no", 2),
      (store_script_param, ":note_index", 3),
      (call_script, "script_get_information_about_troops_position", ":troop_no", 1),
      (str_store_string, s5, "@At the time quest was given:^{s1}"),
      (add_quest_note_from_sreg, ":quest_no", ":note_index", s5, 1),
      (call_script, "script_update_troop_location_notes", ":troop_no", 1),
    ]),
   
  #script_end_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("end_quest",
    [
      (store_script_param, ":quest_no", 1),
      (str_clear, s1),
      (add_quest_note_from_sreg, ":quest_no", 0, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 1, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 2, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 3, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 4, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 5, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 6, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 7, s1, 0),
      (try_begin),
        (neg|check_quest_failed, ":quest_no"),
        (val_add, "$g_total_quests_completed", 1),
      (try_end),
	  (try_begin),
	    (eq, ":quest_no", "qst_consult_with_minister"),
	    (assign, "$g_minister_notification_quest", 0),
	  (try_end),
	  (complete_quest, ":quest_no"),
      (try_begin),
        (is_between, ":quest_no", mayor_quests_begin, mayor_quests_end),
        (assign, "$merchant_quest_last_offerer", -1),
        (assign, "$merchant_offered_quest", -1),
      (try_end),
    ]),

  #script_cancel_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("cancel_quest",
    [(store_script_param, ":quest_no", 1),
     (str_clear, s1),
     (add_quest_note_from_sreg, ":quest_no", 0, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 1, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 2, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 3, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 4, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 5, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 6, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 7, s1, 0),
     (cancel_quest, ":quest_no"),
     (try_begin),
       (is_between, ":quest_no", mayor_quests_begin, mayor_quests_end),
       (assign, "$merchant_quest_last_offerer", -1),
       (assign, "$merchant_offered_quest", -1),
     (try_end),
     ]),

##  #script_get_available_mercenary_troop_and_amount_of_center
##  # INPUT: arg1 = center_no
##  # OUTPUT: reg0 = mercenary_troop_type, reg1 = amount
##  ("get_available_mercenary_troop_and_amount_of_center",
##    [(store_script_param, ":center_no", 1),
##     (party_get_slot, ":mercenary_troop", ":center_no", "slot_center_mercenary_troop_type"),
##     (party_get_slot, ":mercenary_amount", ":center_no", "slot_center_mercenary_troop_amount"),
##     (party_get_free_companions_capacity, ":free_capacity", "p_main_party"),
##     (val_min, ":mercenary_amount", ":free_capacity"),
##     (store_troop_gold, ":cur_gold", "trp_player"),
##     (call_script, "script_game_get_join_cost", ":mercenary_troop"),
##     (assign, ":join_cost", reg0),
##     (try_begin),
##       (gt, ":join_cost", 0),
##       (val_div, ":cur_gold", ":join_cost"),
##       (val_min, ":mercenary_amount", ":cur_gold"),
##     (try_end),
##     (assign, reg0, ":mercenary_troop"),
##     (assign, reg1, ":mercenary_amount"),
##     ]),
##

  #script_update_village_market_towns
  # INPUT: none
  # OUTPUT: none
  ("update_village_market_towns",
    [(try_for_range, ":cur_village", villages_begin, villages_end),
       (store_faction_of_party, ":village_faction", ":cur_village"),
       (assign, ":min_dist", 999999),
       (assign, ":min_dist_town", -1),
       (try_for_range, ":cur_town", towns_begin, towns_end),
         (store_faction_of_party, ":town_faction", ":cur_town"),
         (eq, ":town_faction", ":village_faction"),
         (store_distance_to_party_from_party, ":cur_dist", ":cur_village", ":cur_town"),
         (lt, ":cur_dist", ":min_dist"),
         (assign, ":min_dist", ":cur_dist"),
         (assign, ":min_dist_town", ":cur_town"),
       (try_end),
	   
	   (try_begin),
		(gt, ":min_dist_town", -1),
		(party_set_slot, ":cur_village", "slot_village_market_town", ":min_dist_town"),
	   (else_try),
		(assign, ":min_dist", 999999),
		(assign, ":min_dist_town", -1),
		(try_for_range, ":cur_town", towns_begin, towns_end),
			(store_faction_of_party, ":town_faction", ":cur_town"),
			(store_relation, ":relation", ":town_faction", ":village_faction"),
			(ge, ":relation", 0),
			(store_distance_to_party_from_party, ":cur_dist", ":cur_village", ":cur_town"),
			(lt, ":cur_dist", ":min_dist"),
			(assign, ":min_dist", ":cur_dist"),
			(assign, ":min_dist_town", ":cur_town"),
		(try_end),
		(gt, ":min_dist_town", -1),
		(party_set_slot, ":cur_village", "slot_village_market_town", ":min_dist_town"),
	   (try_end),
     (try_end),
     ]),

 ##bw gdw102015     
#script_update_mercenary_units_of_towns
  # INPUT: none
#   # OUTPUT: none
	("update_mercenary_units_of_towns",
      [(try_for_range, ":town_no", towns_begin, towns_end),
		  (store_random_in_range,":troop_no", mercenary_troops_begin, mercenary_troops_end),
          (party_set_slot, ":town_no", "slot_center_mercenary_troop_type", ":troop_no"),
          (store_random_in_range, ":amount", 2, 8),#min and max mercs,change as you want
          #(party_set_slot, ":town_no", "slot_center_mercenary_troop_amount", ":amount"), #This adds a second mercenary to the tavern
          #chief cambia para los capitanes mercenarios
		    (try_begin),
		      (eq, ":troop_no", "trp_mercenary_leader"),
		      #(store_random_in_range, ":amount", 1, 2), #script chief cambia el numero de mercenarios reclutables
		      (eq, ":amount", 1),
		       (else_try),
		      (store_random_in_range, ":amount", 3, 6), #script chief cambia el numero de mercenarios reclutables
		    (try_end),
		    ##diplomacy start+ chief
	  #OPTIONAL CHANGE: The same way that lord party sizes increase as the player
	  #progresses, also increase mercenary party sizes to maintain their relevance.
	  (try_begin),
		 (store_character_level, ":level", "trp_player"), #increase limits a little bit as the game progresses.
		 (store_add, ":level_factor", 80, ":level"),
         (val_mul, ":amount", ":level_factor"),
         (val_div, ":amount", 80),
	  (try_end),
	  ##diplomacy end+
		  (party_set_slot, ":town_no", "slot_center_mercenary_troop_amount", ":amount"),
					(try_begin),
                        (ge, "$cheat_mode", 1),
                        (display_message, "@{!}DEBUG: update mercs set 1 "),
                    (try_end),
          (store_random_in_range, ":troop_no2", mercenary_troops2_begin, mercenary_troops2_end),
          (party_set_slot, ":town_no", "slot_center_mercenary_troop_type_2", ":troop_no2"),
          (store_random_in_range, ":amount2", 2, 7),#min and max mercs,change as you want
          (party_set_slot, ":town_no", "slot_center_mercenary_troop_amount_2", ":amount2"),
          (try_begin),
                        (ge, "$cheat_mode", 1),
                        (display_message, "@{!}DEBUG: update  mercs set 2 "),
           (try_end),
    (try_end),
     ]),
  #script_update_mercenary_units_of_towns
  # INPUT: none
  # OUTPUT: none
  ##this script from Floris
  # ("update_mercenary_units_of_towns",
  #         [(try_for_range, ":town_no", towns_begin, towns_end),
		# 		(troop_get_slot, ":merc_townsman", "$troop_trees", slot_mercenary_townsman),
		# 		(troop_get_slot, ":merc_ritter", "$troop_trees", slot_mercenary_hochmeister),
		# 	  (store_random_in_range, ":troop_no", mercenary_troops_begin, mercenary_troops_end),
  #             (party_set_slot, ":town_no", "slot_center_mercenary_troop_type", ":troop_no"),
  #             (store_random_in_range, ":amount", 3, 12),
  #             (party_set_slot, ":town_no", "slot_center_mercenary_troop_amount", ":amount"), #This adds a second mercanery to the tavern
				
		# 		(troop_get_slot, ":merc_ritter", "$troop_trees", slot_woman_refugee),
		# 		(troop_get_slot, ":merc_extra1", "$troop_trees", slot_woman_walkure),
		# 	  (store_random_in_range, ":troop_no2", mercenary_troops_begin, mercenary_troops_end),
  #             (party_set_slot, ":town_no", "slot_center_mercenary_troop_type_2", ":troop_no2"),
  #             (store_random_in_range, ":amount2", 3, 12),
  #             (party_set_slot, ":town_no", "slot_center_mercenary_troop_amount_2", ":amount2"),
		# 	(try_end),
		# 	#diplomacy start+ chief
	 #  #OPTIONAL CHANGE: The same way that lord party sizes increase as the player
	 #  #progresses, also increase mercenary party sizes to maintain their relevance.
  #       (try_begin),
		#  (store_character_level, ":level", "trp_player"), #increase limits a little bit as the game progresses.
		#  (store_add, ":level_factor", 80, ":level"),
 	# 	 (val_mul, ":amount", ":level_factor"),
 	# 	 (val_div, ":amount", 80),
	 #   (try_end),
  #      ]),
    ###this is from floris and seems to get the parties appearing in taverns
   #  ("start_update_mercenary_units_of_towns",
   #        [(try_for_range, ":town_no", towns_begin, towns_end),
			# (troop_get_slot, ":merc_townsman", "$troop_trees", slot_mercenary_townsman),
			# 	(troop_get_slot, ":merc_ritter", "$troop_trees", slot_mercenary_hochmeister),
			#   (store_random_in_range, ":troop_no", ":merc_townsman", ":merc_ritter"),
   #            (party_set_slot, ":town_no", "slot_center_mercenary_troop_type", ":troop_no"),
   #            (store_random_in_range, ":amount", 3, 12),
   #            (party_set_slot, ":town_no", "slot_center_mercenary_troop_amount", ":amount"), #This adds a second mercanery to the tavern
			# 	(troop_get_slot, ":merc_ritter", "$troop_trees", slot_woman_refugee),
			# 	(troop_get_slot, ":merc_extra1", "$troop_trees", slot_woman_walkure),
			#   (store_random_in_range, ":troop_no2", ":merc_ritter", ":merc_extra1"),
   #            (party_set_slot, ":town_no", "slot_center_mercenary_troop_type_2", ":troop_no2"),
   #            (store_random_in_range, ":amount2", 3, 15),
   #            (party_set_slot, ":town_no", "slot_center_mercenary_troop_amount_2", ":amount2"),
   #          (try_end),
   #      ]),

  #script_update_ransom_brokers
  # INPUT: none
  # OUTPUT: none
  ("update_ransom_brokers",
    [(try_for_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", "slot_center_ransom_broker", 0),#gdw perkalarhan
     (try_end),
     
     (try_for_range, ":troop_no", ransom_brokers_begin, ransom_brokers_end),
       (store_random_in_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", "slot_center_ransom_broker", ":troop_no"),
     (try_end),

     (party_set_slot,"p_town_2","slot_center_ransom_broker","trp_ramun_the_slave_trader"),
     (party_set_slot,"p_town_20","slot_center_ransom_broker","trp_ransom_broker_16"),#gdwloidis
     (party_set_slot,"p_town_34","slot_center_ransom_broker","trp_ransom_broker_17"),#gdwtemair
     (party_set_slot,"p_town_36","slot_center_ransom_broker","trp_ransom_broker_18"),#gdwcaisel
     (party_set_slot,"p_town_31","slot_center_ransom_broker","trp_ransom_broker_19"),#gdwmonidcribh
     (party_set_slot,"p_town_41","slot_center_ransom_broker","trp_ransom_broker_20"),#gdwirrencester
     ]),

  #script_update_tavern_travellers
  # INPUT: none
  # OUTPUT: none
  ("update_tavern_travellers",
    [(try_for_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", "slot_center_tavern_traveler", 0),
     (try_end),
     
     (try_for_range, ":troop_no", tavern_travelers_begin, tavern_travelers_end),
       (store_random_in_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", "slot_center_tavern_traveler", ":troop_no"),
       (assign, ":end_cond", 15),
       (try_for_range, ":unused", 0, ":end_cond"),
         (store_random_in_range, ":info_faction", kingdoms_begin, kingdoms_end),
         (faction_slot_eq, ":info_faction", "slot_faction_state", sfs_active),
         (neq, ":info_faction", "$players_kingdom"),
         (neq, ":info_faction", "fac_player_supporters_faction"),
         (party_set_slot, ":town_no", "slot_center_traveler_info_faction", ":info_faction"),
         (assign, ":end_cond", 0),
       (try_end),
     (try_end),
	 
	 (troop_set_slot, "trp_belligerent_drunk", "slot_troop_cur_center", "p_town_1"),
     ]),

  #script_update_booksellers
  # INPUT: none
  # OUTPUT: none
  ("update_booksellers",
    [(try_for_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", "slot_center_tavern_bookseller", 0),
     (try_end),
     
     (try_for_range, ":troop_no", tavern_booksellers_begin, tavern_booksellers_end),
       (store_random_in_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", "slot_center_tavern_bookseller", ":troop_no"),
     (try_end),
	 

	 
     ]),
     
  #script_update_tavern_minstels
  # INPUT: none
  # OUTPUT: none
  ("update_tavern_minstrels",
    [(try_for_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", "slot_center_tavern_minstrel", 0),
     (try_end),
     
     (try_for_range, ":troop_no", tavern_minstrels_begin, tavern_minstrels_end),
       (store_random_in_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", "slot_center_tavern_minstrel", ":troop_no"),
	   (try_begin),
		(eq, "$cheat_mode", 1),
		(str_store_troop_name, s4, ":troop_no"),
		(str_store_party_name, s5, ":town_no"),
		
	    (display_message, "str_s4_is_at_s5"),
	   (try_end),	
     (try_end),
	 
	 
     ]),
 
  ("update_other_taverngoers", 
  [
	(store_random_in_range, ":fight_promoter_tavern", towns_begin, towns_end),
	(troop_set_slot, "trp_fight_promoter", "slot_troop_cur_center", ":fight_promoter_tavern"),
	
	(store_random_in_range, ":belligerent_drunk_tavern", towns_begin, towns_end),
	(troop_set_slot, "trp_belligerent_drunk", "slot_troop_cur_center", ":belligerent_drunk_tavern"),
	]), 

  #script_agent_troop_get_banner_mesh
  # INPUT: agent_no, troop_no
  # OUTPUT: banner_mesh
  ("agent_troop_get_banner_mesh",
    [
       (store_script_param, ":agent_no", 1),
       (store_script_param, ":troop_no", 2),
       (assign, ":banner_troop", -1),
       (assign, ":banner_mesh", "mesh_banners_default_b"),
       (try_begin),
         (lt, ":agent_no", 0),
         (try_begin),
           (ge, ":troop_no", 0),
           (this_or_next|troop_slot_ge, ":troop_no", "slot_troop_banner_scene_prop", 1),
           (eq, ":troop_no", "trp_player"),
           (assign, ":banner_troop", ":troop_no"),
         (else_try),
           (is_between, ":troop_no", companions_begin, companions_end),
           (assign, ":banner_troop", "trp_player"),
         (else_try),
           (assign, ":banner_mesh", "mesh_banners_default_a"),
         (try_end),
       (else_try),
         (eq, "$g_is_quick_battle", 1),
         (agent_get_team, ":agent_team", ":agent_no"),
         (try_begin),
           (eq, ":agent_team", 0),
           (assign, ":banner_mesh", "$g_quick_battle_team_0_banner"),
         (else_try),
           (assign, ":banner_mesh", "$g_quick_battle_team_1_banner"),
         (try_end),
       (else_try),
         (game_in_multiplayer_mode),
         (agent_get_group, ":agent_group", ":agent_no"),
         (try_begin),
           (neg|player_is_active, ":agent_group"),
           (agent_get_player_id, ":agent_group", ":agent_no"),
         (try_end),
         (try_begin),
           #if player banners are not allowed, use the default banner mesh
           (eq, "$g_multiplayer_allow_player_banners", 1),
           (player_is_active, ":agent_group"),
           (player_get_banner_id, ":player_banner", ":agent_group"),
           (ge, ":player_banner", 0),
           (store_add, ":banner_mesh", ":player_banner", arms_meshes_begin),
           (assign, ":already_used", 0),
           (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end), #wrong client data check
             (faction_slot_eq, ":cur_faction", "slot_faction_banner", ":banner_mesh"),
             (assign, ":already_used", 1),
           (try_end),
           (eq, ":already_used", 0), #otherwise use the default banner mesh
         (else_try),
           (agent_get_team, ":agent_team", ":agent_no"),
           (team_get_faction, ":team_faction_no", ":agent_team"),

           (try_begin),
             (agent_is_human, ":agent_no"),
             (faction_get_slot, ":banner_mesh", ":team_faction_no", "slot_faction_banner"),
           (else_try),
             (agent_get_rider, ":rider_agent_no", ":agent_no"),
             #(agent_get_position, pos1, ":agent_no"),
             #(position_get_x, ":pos_x", pos1),
             #(position_get_y, ":pos_y", pos1),
             #(assign, reg0, ":pos_x"),
             #(assign, reg1, ":pos_y"),
             #(assign, reg2, ":agent_no"),
             #(display_message, "@{!}agent_no:{reg2}, pos_x:{reg0} , posy:{reg1}"),
             (try_begin),
               (ge, ":rider_agent_no", 0),
               (agent_is_active, ":rider_agent_no"),
               (agent_get_team, ":rider_agent_team", ":rider_agent_no"),
               (team_get_faction, ":rider_team_faction_no", ":rider_agent_team"),
               (faction_get_slot, ":banner_mesh", ":rider_team_faction_no", "slot_faction_banner"),
             (else_try),
               (assign, ":banner_mesh", "mesh_banners_default_c"),
             (try_end),                   
           (try_end),             
         (try_end),
#COOP use banner from server chief ####################################	
         (try_begin),
           (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_coop_battle),
           (eq, "$g_multiplayer_game_type", multiplayer_game_type_coop_siege),
           (agent_get_slot, ":agent_banner",":agent_no", "slot_agent_coop_banner"),
           (try_begin),
              (gt, ":agent_banner", 0),
              (assign, ":banner_mesh", ":agent_banner"),	
           (else_try),
              (gt, "$coop_agent_banner", 0),
              (assign, ":banner_mesh", "$coop_agent_banner"),	
           (try_end),  
         (try_end),
#################################################################
       (else_try),
         (agent_get_troop_id, ":troop_id", ":agent_no"),
         (this_or_next|troop_slot_ge,  ":troop_id", "slot_troop_banner_scene_prop", 1),
         (eq, ":troop_no", "trp_player"),
         (assign, ":banner_troop", ":troop_id"),
       (else_try),
         (agent_get_party_id, ":agent_party", ":agent_no"),
         (try_begin),
           (lt, ":agent_party", 0),
           (is_between, ":troop_id", companions_begin, companions_end),
           (main_party_has_troop, ":troop_id"),
           (assign, ":agent_party", "p_main_party"),
         (try_end),
         (ge, ":agent_party", 0),
         (party_get_template_id, ":party_template", ":agent_party"),
         (try_begin),
           (eq, ":party_template", "pt_deserters"),
           (assign, ":banner_mesh", "mesh_banners_default_c"),
         (else_try),
           (is_between, ":agent_party", centers_begin, centers_end),
           (is_between, ":troop_id", companions_begin, companions_end),
           (neq, "$talk_context", tc_tavern_talk),
           #this should be a captured companion in prison
           (assign, ":banner_troop", "trp_player"),
         (else_try),
           (is_between, ":agent_party", centers_begin, centers_end),
           (party_get_slot, ":town_lord", "$g_encountered_party", "slot_town_lord"),
           (ge, ":town_lord", 0),
           (assign, ":banner_troop", ":town_lord"),
         (else_try),
           (this_or_next|party_slot_eq, ":agent_party", "slot_party_type", spt_kingdom_hero_party),
           (eq, ":agent_party", "p_main_party"),
           (party_get_num_companion_stacks, ":num_stacks", ":agent_party"),
           (gt, ":num_stacks", 0),
           (party_stack_get_troop_id, ":leader_troop_id", ":agent_party", 0),
           (this_or_next|troop_slot_ge,  ":leader_troop_id", "slot_troop_banner_scene_prop", 1),
           (eq, ":leader_troop_id", "trp_player"),
           (assign, ":banner_troop", ":leader_troop_id"),
         (try_end),
       (else_try), #Check if we are in a tavern
         (eq, "$talk_context", tc_tavern_talk),
         (neq, ":troop_no", "trp_player"),
         (assign, ":banner_mesh", "mesh_banners_default_d"),
       (else_try), #can't find party, this can be a town guard
         (neq, ":troop_no", "trp_player"),
         (is_between, "$g_encountered_party", walled_centers_begin, walled_centers_end),
         (party_get_slot, ":town_lord", "$g_encountered_party", "slot_town_lord"),
         (ge, ":town_lord", 0),
         (assign, ":banner_troop", ":town_lord"),
       (try_end),
       (try_begin),
         (ge, ":banner_troop", 0),
         (try_begin),
           (neg|troop_slot_ge, ":banner_troop", "slot_troop_banner_scene_prop", 1),
           (assign, ":banner_mesh", "mesh_banners_default_b"),
         (else_try), 
           (troop_get_slot, ":banner_spr", ":banner_troop", "slot_troop_banner_scene_prop"),
           (store_add, ":banner_scene_props_end", banner_scene_props_end_minus_one, 1),
           (is_between, ":banner_spr", banner_scene_props_begin, ":banner_scene_props_end"),
           (val_sub, ":banner_spr", banner_scene_props_begin),
           (store_add, ":banner_mesh", ":banner_spr", arms_meshes_begin),
         (try_end),
       (try_end),
       (assign, reg0, ":banner_mesh"),
     ]),
  
#script_shield_item_set_banner
      # INPUT: agent_no
      # OUTPUT: none
      ("shield_item_set_banner",
        [
           (store_script_param, ":tableau_no",1),
           (store_script_param, ":agent_no", 2),
           (store_script_param, ":troop_no", 3),
           
           #MOTO bug fix chief
           (try_begin),
           (agent_is_active, ":agent_no"),
           (call_script, "script_agent_troop_get_banner_mesh",    ":agent_no", ":troop_no"),

           (else_try),
           (call_script, "script_agent_troop_get_banner_mesh", -1,    ":troop_no"),
           (try_end),
           (cur_item_set_tableau_material, ":tableau_no", reg0),

           #MOTO bug fix end
           ]),
  
  #script_troop_agent_set_banner
      # INPUT: agent_no
      # OUTPUT: none
      ("troop_agent_set_banner",
        [
           (store_script_param, ":tableau_no",1),
           (store_script_param, ":agent_no", 2),
           (store_script_param, ":troop_no", 3),
           
           #MOTO bug fix chief
           (try_begin),
           (agent_is_active, ":agent_no"),
           (call_script, "script_agent_troop_get_banner_mesh",    ":agent_no", ":troop_no"),

           (else_try),
           (call_script, "script_agent_troop_get_banner_mesh", -1,    ":troop_no"),
           (try_end),
           (cur_agent_set_banner_tableau_material, ":tableau_no", reg0),
             #MOTO bug fix end
       ]),

##  #script_shield_item_set_banner
##  # INPUT: agent_no
##  # OUTPUT: none
##  ("shield_item_set_banner",
##    [
##       (store_script_param, ":tableau_no",1),
##       (store_script_param, ":agent_no", 2),
##       (store_script_param, ":troop_no", 3),
##       (assign, ":banner_troop", -1),
##       (try_begin),
##         (lt, ":agent_no", 0),
##         (try_begin),
##           (ge, ":troop_no", 0),
##           (troop_slot_ge, ":troop_no", "slot_troop_banner_scene_prop", 0),
##           (assign, ":banner_troop", ":troop_no"),
##         (else_try),
##           (assign, ":banner_troop", -2),
##         (try_end),
##       (else_try),
##         (agent_get_troop_id, ":troop_id", ":agent_no"),
##         (troop_slot_ge,  ":troop_id", "slot_troop_custom_banner_flag_type", 0),
##         (assign, ":banner_troop", ":troop_id"),
##       (else_try),
##         (agent_get_party_id, ":agent_party", ":agent_no"),
##         (try_begin),
##           (lt, ":agent_party", 0),
##           (is_between, ":troop_id", companions_begin, companions_end),
##           (main_party_has_troop, ":troop_id"),
##           (assign, ":agent_party", "p_main_party"),
##         (try_end),
##         (ge, ":agent_party", 0),
##         (party_get_template_id, ":party_template", ":agent_party"),
##         (try_begin),
##           (eq, ":party_template", "pt_deserters"),
##           (assign, ":banner_troop", -3),
##         (else_try),
##           (is_between, ":agent_party", centers_begin, centers_end),
##           (party_get_slot, ":town_lord", "$g_encountered_party", "slot_town_lord"),
##           (ge, ":town_lord", 0),
##           (assign, ":banner_troop", ":town_lord"),
##         (else_try),
##           (this_or_next|party_slot_eq, ":agent_party", "slot_party_type", spt_kingdom_hero_party),
##           (             eq, ":agent_party", "p_main_party"),
##           (party_get_num_companion_stacks, ":num_stacks", ":agent_party"),
##           (gt, ":num_stacks", 0),
##           (party_stack_get_troop_id, ":leader_troop_id", ":agent_party", 0),
##           (troop_slot_ge,  ":leader_troop_id", "slot_troop_banner_scene_prop", 1),
##           (assign, ":banner_troop", ":leader_troop_id"),
##         (try_end),
##       (else_try), #Check if we are in a tavern
##         (eq, "$talk_context", tc_tavern_talk),
##         (neq, ":troop_no", "trp_player"),
##         (assign, ":banner_troop", -4),
##       (else_try), #can't find party, this can be a town guard
##         (neq, ":troop_no", "trp_player"),
##         (is_between, "$g_encountered_party", walled_centers_begin, walled_centers_end),
##         (party_get_slot, ":town_lord", "$g_encountered_party", "slot_town_lord"),
##         (ge, ":town_lord", 0),
##         (assign, ":banner_troop", ":town_lord"),
##       (try_end),
##       (cur_item_set_tableau_material, ":tableau_no", ":banner_troop"),
##     ]),

  #script_add_troop_to_cur_tableau
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau",
    [
       (store_script_param, ":troop_no",1),

       (set_fixed_point_multiplier, 100),
       (assign, ":banner_mesh", -1),
       (troop_get_slot, ":banner_spr", ":troop_no", "slot_troop_banner_scene_prop"),
       (store_add, ":banner_scene_props_end", banner_scene_props_end_minus_one, 1),
       (try_begin),
         (is_between, ":banner_spr", banner_scene_props_begin, ":banner_scene_props_end"),
         (val_sub, ":banner_spr", banner_scene_props_begin),
         (store_add, ":banner_mesh", ":banner_spr", banner_meshes_begin),
       (try_end),

       (cur_tableau_clear_override_items),
       
#       (cur_tableau_set_override_flags, af_override_fullhelm),
       (cur_tableau_set_override_flags, af_override_head|af_override_weapons),
       
       (init_position, pos2),
       (cur_tableau_set_camera_parameters, 1, 6, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":eye_height", 162),
       (store_mul, ":camera_distance", ":troop_no", 87323),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 139),
       (store_mul, ":camera_yaw", ":troop_no", 124337),
       (val_mod, ":camera_yaw", 50),
       (val_add, ":camera_yaw", -25),
       (store_mul, ":camera_pitch", ":troop_no", 98123),
       (val_mod, ":camera_pitch", 20),
       (val_add, ":camera_pitch", -14),
       (assign, ":animation", "anim_stand_man"),
       
##       (troop_get_inventory_slot, ":horse_item", ":troop_no", ek_horse),
##       (try_begin),
##         (gt, ":horse_item", 0),
##         (assign, ":eye_height", 210),
##         (cur_tableau_add_horse, ":horse_item", pos2, "anim_horse_stand", 0),
##         (assign, ":animation", "anim_ride_0"),
##         (position_set_z, pos5, 125),
##         (try_begin),
##           (is_between, ":camera_yaw", -10, 10), #make sure horse head doesn't obstruct face.
##           (val_min, ":camera_pitch", -5),
##         (try_end),
##       (try_end),
       (position_set_z, pos5, ":eye_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (try_begin),
         (ge, ":banner_mesh", 0),

         (init_position, pos1),
         (position_set_z, pos1, -1500),
         (position_set_x, pos1, 265),
         (position_set_y, pos1, 400),
         (position_transform_position_to_parent, pos3, pos5, pos1),
         (cur_tableau_add_mesh, ":banner_mesh", pos3, 400, 0),
       (try_end),
       (cur_tableau_add_troop, ":troop_no", pos2, ":animation" , 0),

       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30), 
       (position_rotate_x, pos8, -60), 
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_add_troop_to_cur_tableau_for_character
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_character",
    [
       (store_script_param, ":troop_no",1),

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),
       (cur_tableau_set_override_flags, af_override_fullhelm),
##       (cur_tableau_set_override_flags, af_override_head|af_override_weapons),
       
       (init_position, pos2),
       (cur_tableau_set_camera_parameters, 1, 4, 8, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 150),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 360),
       (assign, ":camera_yaw", -15),
       (assign, ":camera_pitch", -18),
       (assign, ":animation", "anim_stand_man"),
########## JEDEDIAH Q chief START ########################
	(try_begin),
	(eq, "$jq_override", 1),
	(cur_tableau_clear_override_items),
	(cur_tableau_set_override_flags, af_override_horse),
	(assign, ":animation", "anim_stand_lord"),
	(assign, ":camera_distance", 360),
	(assign, ":camera_yaw", -15),
        (assign, ":camera_pitch", -7),
        (try_end), 
 ########## JEDEDIAH Q END ##########################
       
       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (try_begin),
         (troop_is_hero, ":troop_no"),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30), 
       (position_rotate_x, pos8, -60), 
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_add_troop_to_cur_tableau_for_inventory
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_inventory",
    [
       (store_script_param, ":troop_no",1),
       (store_mod, ":side", ":troop_no", 4), #side flag is inside troop_no value
       (val_div, ":troop_no", 4), #removing the flag bit
       (val_mul, ":side", 90), #to degrees

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),
       
       (init_position, pos2),
       (position_rotate_z, pos2, ":side"),
       (cur_tableau_set_camera_parameters, 1, 4, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 105),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 380),
       (assign, ":camera_yaw", -15),
       (assign, ":camera_pitch", -18),
       (assign, ":animation", "anim_stand_man"),
       
       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (try_begin),
         (troop_is_hero, ":troop_no"),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30), 
       (position_rotate_x, pos8, -60), 
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_add_troop_to_cur_tableau_for_profile
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_profile",
    [
       (store_script_param, ":troop_no",1),

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),
       
       (cur_tableau_set_camera_parameters, 1, 4, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 105),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 380),
       (assign, ":camera_yaw", -15),
       (assign, ":camera_pitch", -18),
       (assign, ":animation", "anim_stand_man"),
       
       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (profile_get_banner_id, ":profile_banner"),
       (try_begin),
         (ge, ":profile_banner", 0),
         (init_position, pos2),
         (val_add, ":profile_banner", banner_meshes_begin),
         (position_set_x, pos2, -175),
         (position_set_y, pos2, -300),
         (position_set_z, pos2, 180),
         (position_rotate_x, pos2, 90),
         (position_rotate_y, pos2, -15),
         (cur_tableau_add_mesh, ":profile_banner", pos2, 0, 0),
       (try_end),

       (init_position, pos2),
       (try_begin),
         (troop_is_hero, ":troop_no"),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30), 
       (position_rotate_x, pos8, -60), 
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_add_troop_to_cur_tableau_for_retirement
  # INPUT: type
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_retirement", [
    (store_script_param, ":type", 1),
    (cur_tableau_set_override_flags, af_override_everything),

    (try_begin),
      (eq, ":type", 0),
      (cur_tableau_add_override_item, "itm_pilgrim_hood"),
      (cur_tableau_add_override_item, "itm_pilgrim_disguise"),
      (cur_tableau_add_override_item, "itm_cheap_shoes"),
      (assign, ":animation", "anim_pose_1"),
    (else_try),
      (eq, ":type", 1),
      (cur_tableau_add_override_item, "itm_pilgrim_hood"),
      (cur_tableau_add_override_item, "itm_german_tunica"),
      (cur_tableau_add_override_item, "itm_cheap_shoes"),
      (cur_tableau_add_override_item, "itm_seaxt3"),
      (assign, ":animation", "anim_pose_1"),
    (else_try),
      (eq, ":type", 2),
      (cur_tableau_add_override_item, "itm_ptunic3"),
      (cur_tableau_add_override_item, "itm_cheap_shoes"),
      (assign, ":animation", "anim_pose_2"),
    (else_try),
      (eq, ":type", 3),
      (cur_tableau_add_override_item, "itm_gaelic_jacketgray"),
      (cur_tableau_add_override_item, "itm_ankleboots"),
      (assign, ":animation", "anim_pose_2"),
    (else_try),
      (eq, ":type", 4),
      (cur_tableau_add_override_item, "itm_leather_aprontunic"),
      (cur_tableau_add_override_item, "itm_leather_boots1"),
      (assign, ":animation", "anim_pose_3"),
    (else_try),
      (eq, ":type", 5),
      (cur_tableau_add_override_item, "itm_ptunicwhite"),
      (cur_tableau_add_override_item, "itm_shoes1blue"),
      (cur_tableau_add_override_item, "itm_dena_helmgoat"),
      (assign, ":animation", "anim_pose_3"),
    (else_try),
      (eq, ":type", 6),
      (cur_tableau_add_override_item, "itm_bishop_robe1"),
      (cur_tableau_add_override_item, "itm_leather_boots1"),
      (cur_tableau_add_override_item, "itm_espada_mythic1"),
      (assign, ":animation", "anim_pose_4"),
    (else_try),
      (eq, ":type", 7),
      (cur_tableau_add_override_item, "itm_nobleman_outfit"),
      (cur_tableau_add_override_item, "itm_shoes1blue"),
      (cur_tableau_add_override_item, "itm_espada_mythic1"),
      (assign, ":animation", "anim_pose_4"),
    (else_try),
      (eq, ":type", 8),
      (cur_tableau_add_override_item, "itm_courtly_outfit"),
      (cur_tableau_add_override_item, "itm_shoes1blue"),
      (cur_tableau_add_override_item, "itm_espada_mythic1"),
      (assign, ":animation", "anim_pose_4"),
    (else_try),
##      (eq, ":type", 9),
      (cur_tableau_add_override_item, "itm_mailtunic_grey"),
      (cur_tableau_add_override_item, "itm_greaves_blue"),
      (cur_tableau_add_override_item, "itm_espada_mythic1"),
      (assign, ":animation", "anim_pose_5"),
##    (else_try), #not used
##      (cur_tableau_add_override_item, "itm_mailbyrniered"),
##      (cur_tableau_add_override_item, "itm_greaves1"),
##      (cur_tableau_add_override_item, "itm_espada_mythic1"),
##      (assign, ":animation", "anim_pose_5"),
    (try_end),

##    (set_fixed_point_multiplier, 100),
##    (cur_tableau_set_background_color, 0x00000000),
##    (cur_tableau_set_ambient_light, 10,11,15),

##     (init_position, pos8),
##     (position_set_x, pos8, -210),
##     (position_set_y, pos8, 200),
##     (position_set_z, pos8, 300),
##     (cur_tableau_add_point_light, pos8, 550,500,450),


    (set_fixed_point_multiplier, 100),
    (cur_tableau_set_camera_parameters, 1, 6, 6, 10, 10000),
    (assign, ":cam_height", 155),
    (assign, ":camera_distance", 575),
    (assign, ":camera_yaw", -5),
    (assign, ":camera_pitch", 10),

    (init_position, pos5),
    (position_set_z, pos5, ":cam_height"),
    # camera looks towards -z axis
    (position_rotate_x, pos5, -90),
    (position_rotate_z, pos5, 180),
    # now apply yaw and pitch
    (position_rotate_y, pos5, ":camera_yaw"),
    (position_rotate_x, pos5, ":camera_pitch"),
    (position_move_z, pos5, ":camera_distance", 0),
    (position_move_x, pos5, 60, 0),

    (init_position, pos2),
    (cur_tableau_add_troop, "trp_player", pos2, ":animation", 0),
    (cur_tableau_set_camera_position, pos5),

    (copy_position, pos8, pos5),
    (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
    (position_rotate_z, pos8, 30),
    (position_rotate_x, pos8, -60),
    (cur_tableau_add_sun_light, pos8, 175,150,125),
    ]),
  
  #script_add_troop_to_cur_tableau_for_party
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_party",
    [
       (store_script_param, ":troop_no",1),
       (store_mod, ":hide_weapons", ":troop_no", 2), #hide_weapons flag is inside troop_no value
       (val_div, ":troop_no", 2), #removing the flag bit

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),
       (try_begin),
         (eq, ":hide_weapons", 1),
         (cur_tableau_set_override_flags, af_override_fullhelm|af_override_head|af_override_weapons),
       (try_end),
       
       (init_position, pos2),
       (cur_tableau_set_camera_parameters, 1, 6, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 105),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 450),
       (assign, ":camera_yaw", 15),
       (assign, ":camera_pitch", -18),
       (assign, ":animation", "anim_stand_man"),
       
       (troop_get_inventory_slot, ":horse_item", ":troop_no", ek_horse),
       (try_begin),
         (gt, ":horse_item", 0),
         (eq, ":hide_weapons", 0),
         (cur_tableau_add_horse, ":horse_item", pos2, "anim_horse_stand", 0),
         (assign, ":animation", "anim_ride_0"),
         (assign, ":camera_yaw", 23),
         (assign, ":cam_height", 150),
         (assign, ":camera_distance", 550),
       (try_end),
       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (try_begin),
         (troop_is_hero, ":troop_no"),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30), 
       (position_rotate_x, pos8, -60), 
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_get_prosperity_text_to_s50
  # INPUT: center_no
  # OUTPUT: none
  ("get_prosperity_text_to_s50",
    [(store_script_param, ":center_no", 1),
     (party_get_slot, ":prosperity", ":center_no", "slot_town_prosperity"),
     (val_div, ":prosperity", 20),
     (try_begin),
       (eq, ":prosperity", 0), #0..19
       (str_store_string, s50, "@Very Poor"),
     (else_try),
       (eq, ":prosperity", 1), #20..39
       (str_store_string, s50, "@Poor"),
     (else_try),
       (eq, ":prosperity", 2), #40..59
       (str_store_string, s50, "@Average"),
     (else_try),
       (eq, ":prosperity", 3), #60..79
       (str_store_string, s50, "@Rich"),
     (else_try),
       (str_store_string, s50, "@Very Rich"), #80..99
     (try_end),
     ]),

  #script_spawn_bandits
  # INPUT: none
  # OUTPUT: none
  ("spawn_bandits",
    [
     (set_spawn_radius,1),
	
	 (try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "@{!}DEBUG : Doing spawn bandit script"),
	 (try_end),
	 
#cambios chief en sea raider
	 (party_template_set_slot, "pt_steppe_bandits", "slot_party_template_lair_type", "pt_steppe_bandit_lair"),
	 (party_template_set_slot, "pt_taiga_bandits", "slot_party_template_lair_type", "pt_taiga_bandit_lair"),
	 (party_template_set_slot, "pt_mountain_bandits", "slot_party_template_lair_type", "pt_mountain_bandit_lair"),
	 (party_template_set_slot, "pt_forest_bandits", "slot_party_template_lair_type", "pt_forest_bandit_lair"),
	 (party_template_set_slot, "pt_sea_raiders", "slot_party_template_lair_type", "pt_sea_raider_lair"),
	 (party_template_set_slot, "pt_sea_raiders2", "slot_party_template_lair_type", "pt_sea_raider_lair2"),
	 (party_template_set_slot, "pt_desert_bandits", "slot_party_template_lair_type", "pt_desert_bandit_lair"),
	
	 (party_template_set_slot, "pt_steppe_bandits", "slot_party_template_lair_spawnpoint", "p_steppe_bandit_spawn_point"),
	 (party_template_set_slot, "pt_taiga_bandits", "slot_party_template_lair_spawnpoint", "p_taiga_bandit_spawn_point"),
	 (party_template_set_slot, "pt_mountain_bandits", "slot_party_template_lair_spawnpoint", "p_mountain_bandit_spawn_point"),
	 (party_template_set_slot, "pt_forest_bandits", "slot_party_template_lair_spawnpoint", "p_forest_bandit_spawn_point"),
	 (party_template_set_slot, "pt_sea_raiders", "slot_party_template_lair_spawnpoint", "p_sea_raider_spawn_point_1"),
	 (party_template_set_slot, "pt_sea_raiders2", "slot_party_template_lair_spawnpoint", "p_sea_raider_spawn_point_2"),
	 (party_template_set_slot, "pt_desert_bandits", "slot_party_template_lair_spawnpoint", "p_desert_bandit_spawn_point"),
		
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_mountain_bandits"),
       (lt,":num_parties",10), #was 14 at mount&blade, 18 in warband, 16 last decision chief cambiado
       (store_random,":spawn_point",num_mountain_bandit_spawn_points),
       (val_add,":spawn_point","p_mountain_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_mountain_bandits"),
	   (assign,":cur_party",reg(0)),#Tempered chief added for bribery check
	   (party_set_slot,":cur_party","slot_party_hired",-1), #Tempered chief added for bribery check
     (try_end),
   (try_begin), #puesto chief empieza sea battles
     (store_num_parties_of_template, ":num_parties", "pt_sea_raiders_ships"),
     (lt,":num_parties",4),
     (store_random,":spawn_point",num_sea_pirate_spawn_points),
     (val_add,":spawn_point","p_ship_raider_spawn_point_1"),
     (set_spawn_radius, 0),
     (party_get_position, pos0, ":spawn_point"),
     (map_get_water_position_around_position, pos1, pos0, 5),
     (spawn_around_party,":spawn_point","pt_sea_raiders_ships"),
     (party_set_position, reg0, pos1),
   (try_end),
   (try_begin),
     (store_num_parties_of_template, ":num_parties", "pt_sea_raiders_ships2"),
     (lt,":num_parties",4),
     (store_random,":spawn_point",num_sea_pirate_spawn_points),
     (val_add,":spawn_point","p_ship_raider_spawn_point_3"),
     (set_spawn_radius, 0),
     (party_get_position, pos0, ":spawn_point"),
     (map_get_water_position_around_position, pos1, pos0, 5),
     (spawn_around_party,":spawn_point","pt_sea_raiders_ships2"),
     (party_set_position, reg0, pos1),
   (try_end),
   (try_begin),
     (store_num_parties_of_template, ":num_parties", "pt_sea_raiders_ships3"),
     (lt,":num_parties",4),
     (store_random,":spawn_point",num_sea_pirate_spawn_points),
     (val_add,":spawn_point","p_ship_raider_spawn_point_2"),
     (set_spawn_radius, 0),
     (party_get_position, pos0, ":spawn_point"),
     (map_get_water_position_around_position, pos1, pos0, 5),
     (spawn_around_party,":spawn_point","pt_sea_raiders_ships3"),
     (party_set_position, reg0, pos1),
   (try_end), #puesto chief acaba
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_forest_bandits"),
       (lt,":num_parties",14), #was 14 at mount&blade, 18 in warband, 16 last decision chief cambiado#gdw More forest bandits-rare now easy to access
       (store_random,":spawn_point",num_forest_bandit_spawn_points),
       (val_add,":spawn_point","p_forest_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_forest_bandits"),
	   (assign,":cur_party",reg(0)),#Tempered chief added for bribery check
	   (party_set_slot,":cur_party","slot_party_hired",-1), #Tempered chief added for bribery check
    (try_end),
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#-#-#Hunting chief Mod begin#-#-#-# Podria ser interesante cambiar spam point
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_deer_herd"),
       (lt,":num_parties",5),#gdw
       (store_random,":spawn_point",num_mountain_bandit_spawn_points),
       (val_add,":spawn_point","p_forest_bandit_spawn_point"),
       (set_spawn_radius, 35),#gdw
       (spawn_around_party,":spawn_point","pt_deer_herd"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_boar_herd"),
       (lt,":num_parties",4),#gdw
       (store_random,":spawn_point",num_mountain_bandit_spawn_points),
       (val_add,":spawn_point","p_forest_bandit_spawn_point"),
       (set_spawn_radius, 35),#gdw
       (spawn_around_party,":spawn_point","pt_boar_herd"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_wolf_herd"),
       (lt,":num_parties",2),#gdw
       (store_random,":spawn_point",num_mountain_bandit_spawn_points),
       (val_add,":spawn_point","p_forest_bandit_spawn_point"),
       (set_spawn_radius, 35),#gdw
       (spawn_around_party,":spawn_point","pt_wolf_herd"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_coat_herd"),
       (lt,":num_parties",4),#gdw
       (store_random,":spawn_point",num_mountain_bandit_spawn_points),
       (val_add,":spawn_point","p_forest_bandit_spawn_point"),
       (set_spawn_radius, 30),#gdw
       (spawn_around_party,":spawn_point","pt_coat_herd"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_coatb_herd"),
       (lt,":num_parties",4),#gdw
       (store_random,":spawn_point",num_mountain_bandit_spawn_points),
       (val_add,":spawn_point","p_forest_bandit_spawn_point"),
       (set_spawn_radius, 30),#gdw
       (spawn_around_party,":spawn_point","pt_coatb_herd"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_wilddonkey_herd"),
       (lt,":num_parties",2),#gdw
       (store_random,":spawn_point",num_mountain_bandit_spawn_points),
       (val_add,":spawn_point","p_forest_bandit_spawn_point"),
       (set_spawn_radius, 30),#gdw
       (spawn_around_party,":spawn_point","pt_wilddonkey_herd"),
     (try_end),
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#-#-#Hunting chief Mod end#-#-#-#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#sacerdotes y paganos chief
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_sacerdotes_party"),
       (lt,":num_parties",4),#gdw
       (store_random,":spawn_point",num_new_sp),
       (val_add,":spawn_point","p_new_sp"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_sacerdotes_party"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_sacerdotes_party"),
       (lt,":num_parties",4),#gdw
       (store_random,":spawn_point",num_new_sp),
       (val_add,":spawn_point","p_new_sp2"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_sacerdotes_party"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_sacerdotes_party"),
       (lt,":num_parties",3),#gdw
       (store_random,":spawn_point",num_new_sp),
       (val_add,":spawn_point","p_new_sp3"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_sacerdotes_party"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_paganos_party"),
       (lt,":num_parties",5),#gdw
       (store_random,":spawn_point",num_new_sp),
       (val_add,":spawn_point","p_new_sp4"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_paganos_party"),
     (try_end),
#cambios chief en sea raider
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_sea_raiders"),
       (lt,":num_parties",6), #was 14 at mount&blade, 18 in warband, 16 last decision chief cambiado#gdw
       (store_random,":spawn_point",num_sea_raider_spawn_points),
       (val_add,":spawn_point","p_sea_raider_spawn_point_1"),
       (set_spawn_radius, 17),
       (spawn_around_party,":spawn_point","pt_sea_raiders"),
	   (assign,":cur_party",reg(0)),#Tempered chief added for bribery check
	   (party_set_slot,":cur_party","slot_party_hired",-1), #Tempered chief added for bribery check
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_sea_raiders2"),
       (lt,":num_parties",7), #was 14 at mount&blade, 18 in warband, 16 last decision chief cambiado#gdw
       (store_random,":spawn_point",num_sea_raider_spawn_points),
       (val_add,":spawn_point","p_sea_raider_spawn_point_2"),
       (set_spawn_radius, 17),
       (spawn_around_party,":spawn_point","pt_sea_raiders2"),
	   (assign,":cur_party",reg(0)),#Tempered chief added for bribery check
	   (party_set_slot,":cur_party","slot_party_hired",-1), #Tempered chief added for bribery check
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_steppe_bandits"),
       (lt,":num_parties",7), #was 14 at mount&blade, 18 in warband, 16 last decision chief cambiado#gdw
       (store_random,":spawn_point",num_steppe_bandit_spawn_points),
       (val_add,":spawn_point","p_steppe_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_steppe_bandits"),
	   (assign,":cur_party",reg(0)),#Tempered chief added for bribery check
	   (party_set_slot,":cur_party","slot_party_hired",-1), #Tempered chief added for bribery check
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_taiga_bandits"),
       (lt,":num_parties",11), #was 14 at mount&blade, 18 in warband, 16 last decision chief cambiado#gdw
       (store_random,":spawn_point",num_taiga_bandit_spawn_points),
       (val_add,":spawn_point","p_taiga_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_taiga_bandits"),
	   (assign,":cur_party",reg(0)),#Tempered chief added for bribery check
	   (party_set_slot,":cur_party","slot_party_hired",-1), #Tempered chief added for bribery check
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_desert_bandits"),
       (lt,":num_parties",11), #was 14 at mount&blade, 18 in warband, 16 last decision chief cambiado#gdw
       (store_random,":spawn_point",num_desert_bandit_spawn_points),
       (val_add,":spawn_point","p_desert_bandit_spawn_point"),
       (set_spawn_radius, 26),
       (spawn_around_party,":spawn_point","pt_desert_bandits"),
	   (assign,":cur_party",reg(0)),#Tempered chief added for bribery check
	   (party_set_slot,":cur_party","slot_party_hired",-1), #Tempered chief added for bribery check
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_looters"),
       (lt,":num_parties",40), #was 33 at mount&blade, 50 in warband, 42 last decision chief cambiado
       (store_random_in_range,":spawn_point",villages_begin,villages_end), #spawn looters twice to have lots of them at the beginning       
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_looters"),
       (assign, ":spawned_party_id", reg0),
	   (party_set_slot,":spawned_party_id","slot_party_hired",-1),#Tempered chief added for bribery check
       (try_begin),
         (check_quest_active, "qst_deal_with_looters"),
         (party_set_flags, ":spawned_party_id", pf_quest_party, 1),
       (else_try),
         (party_set_flags, ":spawned_party_id", pf_quest_party, 0),
       (try_end),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_deserters"),
       (lt,":num_parties",15), #chief cambia tb
       (set_spawn_radius, 4),
       (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
	     (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
         (store_random_in_range, ":random_no", 0, 100),
         (lt, ":random_no", 5),
         (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
         (store_troop_faction, ":troop_faction", ":troop_no"),
         (neq, ":troop_faction", "fac_player_supporters_faction"),
         (gt, ":party_no", 0),
         (neg|party_is_in_any_town, ":party_no"),
##         (party_get_attached_to, ":attached_party_no", ":party_no"),
##         (lt, ":attached_party_no", 0),#in wilderness
         (spawn_around_party, ":party_no", "pt_deserters"),
         (assign, ":new_party", reg0),
		(party_set_slot,":new_party","slot_party_hired",-1),#Tempered chief added for bribery check
         (store_troop_faction, ":faction_no", ":troop_no"),
         (faction_get_slot, ":tier_1_troop", ":faction_no", "slot_faction_tier_1_troop"),
         (store_character_level, ":level", "trp_player"),
         (store_mul, ":max_number_to_add", ":level", 2),
         (val_add, ":max_number_to_add", 11),
         (store_random_in_range, ":number_to_add", 10, ":max_number_to_add"),
         (party_add_members, ":new_party", ":tier_1_troop", ":number_to_add"),
         (store_random_in_range, ":random_no", 1, 4),
         (try_for_range, ":unused", 0, ":random_no"),
           (party_upgrade_with_xp, ":new_party", 1000000, 0),
         (try_end),
##         (str_store_party_name, s1, ":party_no"),
##         (call_script, "script_get_closest_center", ":party_no"),
##         (try_begin),
##           (gt, reg0, 0),
##           (str_store_party_name, s2, reg0),
##         (else_try),
##           (str_store_string, s2, "@unknown place"),
##         (try_end),
##         (assign, reg1, ":number_to_add"),
##         (display_message, "@{reg1} Deserters spawned from {s1}, near {s2}."),
       (try_end),
     (try_end), #deserters ends
	 
	 
	 #Spawn bandit lairs
	(try_for_range, ":bandit_template", "pt_steppe_bandits", "pt_deserters"),
		(party_template_get_slot, ":bandit_lair_party", ":bandit_template", "slot_party_template_lair_party"),
		(le, ":bandit_lair_party", 1),
		
		(party_template_get_slot, ":bandit_lair_template", ":bandit_template", "slot_party_template_lair_type"),
		(party_template_get_slot, ":bandit_lair_template_spawnpoint", ":bandit_template", "slot_party_template_lair_spawnpoint"),
	 
		(set_spawn_radius, 10), #chief cambiado
	 
        (spawn_around_party, ":bandit_lair_template_spawnpoint", ":bandit_lair_template"),
		(assign, ":new_camp", reg0),
		
		(party_set_slot, ":new_camp", "slot_party_type", spt_bandit_lair),
		
		(str_store_party_name, s4, ":new_camp"),
		
		(party_get_position, pos4, ":new_camp"),
        #(party_set_flags, ":new_camp", pf_icon_mask, 1),
		
		(party_get_current_terrain, ":new_camp_terrain", ":new_camp"),
		(position_get_z, ":elevation", pos4),
		(position_get_y, ":lair_y", pos4),		
								
		(assign, ":center_too_close", 0),
		(try_for_range, ":center", centers_begin, centers_end),
			(eq, ":center_too_close", 0),
			(store_distance_to_party_from_party, ":distance", ":new_camp", ":center"),
			(lt, ":distance", 3),
			(assign, ":center_too_close", 1),
		(try_end),
						
		(try_begin),
			(eq, ":center_too_close", 1),
			(party_is_active, ":new_camp"),
			(remove_party, ":new_camp"),
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", 0),
		(else_try),
			(eq, ":bandit_template", "pt_sea_raiders"),
			(eq, ":new_camp_terrain", 3),
			(map_get_water_position_around_position, pos5, pos4, 4),			
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),			
#anadido chief
		(else_try),	
			(eq, ":bandit_template", "pt_sea_raiders2"),
			(eq, ":new_camp_terrain", 3),
			(map_get_water_position_around_position, pos5, pos4, 4),			
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),			
#acaba anadido chief
		(else_try),	
			(eq, ":bandit_template", "pt_mountain_bandits"),
			(eq, ":new_camp_terrain", 3),
			(gt, ":elevation", 250),			
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),			
		(else_try),
			(eq, ":bandit_template", "pt_desert_bandits"),
			(eq, ":new_camp_terrain", 3), #chief cambiado
			(gt, ":lair_y", -9000),
			(gt, ":elevation", 250), #chief cambiado			
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),			
		(else_try),	
			(eq, ":bandit_template", "pt_steppe_bandits"),
			(this_or_next|eq, ":new_camp_terrain", 11), #chief cambiado
			(eq, ":new_camp_terrain", 3), #chief cambiado
			(this_or_next|eq, ":new_camp_terrain", 3), #chief cambiado
			(gt, ":elevation", 200),
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),			
		(else_try),	
			(eq, ":bandit_template", "pt_taiga_bandits"),
			(eq, ":new_camp_terrain", 11),	#chief cambiado			
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),
		(else_try),	
			(eq, ":bandit_template", "pt_forest_bandits"),
			(eq, ":new_camp_terrain", 11),				
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),			
		(else_try),
			(party_is_active, ":new_camp"),
			(str_store_party_name, s4, ":new_camp"),
			(remove_party, ":new_camp"),
			(party_template_set_slot, ":bandit_template", "slot_party_template_lair_party", 0),
		(else_try),
		(try_end),	 	 
	(try_end),
     ]),

  #script_count_mission_casualties_from_agents
  # INPUT: none
  # OUTPUT: none
  ("count_mission_casualties_from_agents",
    [(party_clear, "p_player_casualties"),
     (party_clear, "p_enemy_casualties"),
     (party_clear, "p_ally_casualties"),
     (assign, "$any_allies_at_the_last_battle", 0),
     #(assign, "$num_routed_us", 0), #these should not assign to 0 here to protect routed agents to spawn again in next turns.
     #(assign, "$num_routed_allies", 0),
     #(assign, "$num_routed_enemies", 0),

     #initialize all routed counts of troops
     (try_for_agents, ":cur_agent"),
       (agent_is_human, ":cur_agent"),     
       (agent_get_party_id, ":agent_party", ":cur_agent"),
       (agent_get_troop_id, ":agent_troop_id", ":cur_agent"),
       (troop_set_slot, ":agent_troop_id", "slot_troop_player_routed_agents", 0),
       (troop_set_slot, ":agent_troop_id", "slot_troop_ally_routed_agents", 0),
       (troop_set_slot, ":agent_troop_id", "slot_troop_enemy_routed_agents", 0),
     (try_end),
     
     (try_for_agents, ":cur_agent"),
       (agent_is_human, ":cur_agent"),     
       (agent_get_party_id, ":agent_party", ":cur_agent"),
       (try_begin),
         (neq, ":agent_party", "p_main_party"),
         (agent_is_ally, ":cur_agent"),
         (assign, "$any_allies_at_the_last_battle", 1),
       (try_end),
       #count routed agents in player party, ally parties and enemy parties
       (try_begin),
         (agent_is_routed, ":cur_agent"),
         (agent_get_slot, ":agent_was_running_away", ":cur_agent", "slot_agent_is_running_away"),
         (eq, ":agent_was_running_away", 1),
         (try_begin),
           (agent_get_troop_id, ":routed_ag_troop_id", ":cur_agent"),
           (agent_get_party_id, ":routed_ag_party_id", ":cur_agent"),
           #only enemies
           #only regulars           
           (store_faction_of_party, ":faction_of_routed_agent_party", ":routed_ag_party_id"),
              
           (try_begin),
             (eq, ":agent_party", "p_main_party"),
             (val_add, "$num_routed_us", 1),
           (else_try),
             (agent_is_ally, ":cur_agent"),     
             (val_add, "$num_routed_allies", 1),
           (else_try),
             #for now only count and include routed enemy agents in new routed party.
             (val_add, "$num_routed_enemies", 1),
             (faction_get_slot, ":num_routed_agents_in_this_faction", ":faction_of_routed_agent_party", "slot_faction_num_routed_agents"),
             (val_add, ":num_routed_agents_in_this_faction", 1),
             (faction_set_slot, ":faction_of_routed_agent_party", "slot_faction_num_routed_agents", ":num_routed_agents_in_this_faction"),
             (party_add_members, "p_routed_enemies", ":routed_ag_troop_id", 1),     
           (try_end),
         (try_end),
         (agent_get_troop_id, ":agent_troop_id", ":cur_agent"),
         (try_begin),
           (eq, ":agent_party", "p_main_party"),
           (troop_get_slot, ":player_routed_agents", ":agent_troop_id", "slot_troop_player_routed_agents"),
           (val_add, ":player_routed_agents", 1),
           (troop_set_slot, ":agent_troop_id", "slot_troop_player_routed_agents", ":player_routed_agents"),
           
         (else_try),
           (agent_is_ally, ":cur_agent"),     
           (troop_get_slot, ":ally_routed_agents", ":agent_troop_id", "slot_troop_ally_routed_agents"),
           (val_add, ":ally_routed_agents", 1),
           (troop_set_slot, ":agent_troop_id", "slot_troop_ally_routed_agents", ":ally_routed_agents"),
           
         (else_try),
           (troop_get_slot, ":enemy_routed_agents", ":agent_troop_id", "slot_troop_enemy_routed_agents"),
           (val_add, ":enemy_routed_agents", 1),
           (troop_set_slot, ":agent_troop_id", "slot_troop_enemy_routed_agents", ":enemy_routed_agents"),

         (try_end),   
       (try_end),
       #count and save killed agents in player party, ally parties and enemy parties
      
        
          
       (neg|agent_is_alive, ":cur_agent"),
       (agent_get_troop_id, ":agent_troop_id", ":cur_agent"),
       (try_begin),
         (eq, ":agent_party", "p_main_party"),
         (party_add_members, "p_player_casualties", ":agent_troop_id", 1),
         (try_begin),
           (agent_is_wounded, ":cur_agent"),
           (party_wound_members, "p_player_casualties", ":agent_troop_id", 1),
         (try_end),
       (else_try),
         (agent_is_ally, ":cur_agent"),
         (party_add_members, "p_ally_casualties", ":agent_troop_id", 1),
         (try_begin),
           (agent_is_wounded, ":cur_agent"),
           (party_wound_members, "p_ally_casualties", ":agent_troop_id", 1),
         (try_end),
       (else_try),
       	 (party_add_members, "p_enemy_casualties", ":agent_troop_id", 1),
         (try_begin),
           (agent_is_wounded, ":cur_agent"),
           (party_wound_members, "p_enemy_casualties", ":agent_troop_id", 1),
          (try_end),
       (else_try), #themagelord chief fix
           (store_script_param_1, ":party_id"),
          (try_begin),
          (party_slot_eq, ":party_id", "slot_party_type", spt_kingdom_hero_party),
          (party_stack_get_troop_id, ":leader", ":party_id", 0),
          (is_between, ":leader", active_npcs_begin, active_npcs_end),
          
        (else_try),
         (store_script_param_2, ":party_id"),
         
          (is_between, ":party_id", walled_centers_begin, walled_centers_end),
          (ge, ":party_id", 0),
           (store_random_in_range, ":random_no", 1, 4),
           (eq,":random_no", 1),
           

           (party_wound_members, "p_enemy_casualties", ":agent_troop_id", 1),
           (party_wound_members, "p_total_enemy_casualties", ":agent_troop_id", 1),
           (party_add_members, ":agent_party", ":agent_troop_id", 1),
           (party_wound_members, ":agent_party", ":agent_troop_id", 1),
          # end addition TML
        (try_end),
       (try_end),
     (try_end),
     ]),

  #script_get_max_skill_of_player_party
  # INPUT: arg1 = skill_no
  # OUTPUT: reg0 = max_skill, reg1 = skill_owner_troop_no
  ("get_max_skill_of_player_party",
    [(store_script_param, ":skill_no", 1),
     (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
     (store_skill_level, ":max_skill", ":skill_no", "trp_player"),
     (assign, ":skill_owner", "trp_player"),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
       (troop_is_hero, ":stack_troop"),
       (neg|troop_is_wounded, ":stack_troop"),
       (store_skill_level, ":cur_skill", ":skill_no", ":stack_troop"),
       (gt, ":cur_skill", ":max_skill"),
       (assign, ":max_skill", ":cur_skill"),
       (assign, ":skill_owner", ":stack_troop"),
     (try_end),
     (party_get_skill_level, reg0, "p_main_party", ":skill_no"),
##     (assign, reg0, ":max_skill"),
     (assign, reg1, ":skill_owner"),
     ]),

  #script_upgrade_hero_party
  # INPUT: arg1 = party_id, arg2 = xp_amount
  ("upgrade_hero_party",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":xp_amount", 2),
      (party_upgrade_with_xp, ":party_no", ":xp_amount", 0),
    ]),

  #TEMPERED chief ADJUSTED ALL IMPROVEMENT COSTS, ALL CUT IN HALF
  #script_get_improvement_details
  # INPUT: arg1 = improvement
  # OUTPUT: reg0 = base_cost
  ("get_improvement_details",
    [(store_script_param, ":improvement_no", 1),
     (try_begin),
       (eq, ":improvement_no", "slot_center_has_manor"),
       (str_store_string, s0, "@Manor"),
       (str_store_string, s1, "@A manor lets you rest at the village and pay your troops half wages while you rest."),
       (assign, reg0, 2300),#gdw
     (else_try),
       (eq, ":improvement_no", "slot_center_has_fish_pond"),
       (str_store_string, s0, "@Mill"),
       (str_store_string, s1, "@A mill increases village prosperity by 5%."),
       (assign, reg0, 2400),#gdw
     (else_try),
       (eq, ":improvement_no", "slot_center_has_watch_tower"),
       (str_store_string, s0, "@Watch Tower"),
       (str_store_string, s1, "@A watch tower lets the villagers raise alarm earlier. The time it takes for enemies to loot the village increases by 35%."),
       (assign, reg0, 3100),#gdw
     (else_try),
       (eq, ":improvement_no", "slot_center_has_school"),
       (str_store_string, s0, "@School"),
       (str_store_string, s1, "@A school increases the loyality of the villagers to you by +1 every week."),#i think they forgot to change thisgdw
       (assign, reg0, 5000),#gdw
     (else_try),
       (eq, ":improvement_no", "slot_center_has_messenger_post"),
       (str_store_string, s0, "@Messenger Post"),
       (str_store_string, s1, "@A messenger post lets the inhabitants send you a message whenever enemies are nearby, even if you are far away from here."),
       (assign, reg0, 2000),
     (else_try),
       (eq, ":improvement_no", "slot_center_has_prisoner_tower"),
       (str_store_string, s0, "@Prison Tower"),
       (str_store_string, s1, "@A prison tower reduces the chance of captives held here running away successfully."),
       (assign, reg0, 4000),
#Sod BUILDINGS BEGIN chief # defninitions need to be rewrited to include building funcions
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_temple1"),
       (str_store_string, s0, "@Celtic Christian Monastery"),
       (str_store_string, s1, "@Build it and put it to work for the glory of the Christian God. (Converts and keeps the populace devout)"),
       (assign, reg0, 4000),
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_temple2"),
       (str_store_string, s0, "@Forest of the Old Celtic Gods"),
       (str_store_string, s1, "@Build it in memory of your ancestors and the glory of the Old Celtic Gods. (Converts and keeps the populace devout)"),
       (assign, reg0, 4000),
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_temple3"),
       (str_store_string, s0, "@Temple of god Woden"),
       (str_store_string, s1, "@Build it to spread the streng of Woden. (Converts and keeps the populace devout)"),
       (assign, reg0, 4000),
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_temple5"),
       (str_store_string, s0, "@Christian Monastery"),
       (str_store_string, s1, "@Build it and put it to work for the glory of the Christian God. (Converts and keeps the populace devout)"),
       (assign, reg0, 4000),
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_chapel5"),
       (str_store_string, s0, "@Christian Church"),
       (str_store_string, s1, "@Build it for the glory of the Christian God. (Converts and keeps the populace devout)"),
       (assign, reg0, 7000),
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_monastery1"),
       (str_store_string, s0, "@Celtic Christian Church"),
       (str_store_string, s1, "@Build it for the glory of the Christian God. (Converts and keeps the populace devout)"),
       (assign, reg0, 7000),
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_monastery2"),
       (str_store_string, s0, "@Temple of the Old Celtic Gods"),
       (str_store_string, s1, "@Build it and put it to work in memory of your ancestors and the glory of The Old Celtic Gods. (Converts and keeps the populace devout)"),
       (assign, reg0, 7000),
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_monastery3"),
       (str_store_string, s0, "@Shrine of Germanic Gods."),
       (str_store_string, s1, "@Build it to practice spreading the power of Woden, Wecta, Baeldaeg, Casere and Wihtlaeg. (Converts and keeps the populace devout)"),
       (assign, reg0, 7000),
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_blacksmith"),
       (str_store_string, s0, "@Blacksmith"),
       (str_store_string, s1, "@Build it to facilitate the manufacture of tools and weapons. (Add treasure)"),
       (assign, reg0, 4100),#gdw
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_guild"),
       (str_store_string, s0, "@Merchant Guild House"),
       (str_store_string, s1, "@Build it to please the merchant community and engage in trade enterprises. (Add Prosperity)"),
       (assign, reg0, 7000),#gdw
	 (else_try),
	 (eq, ":improvement_no", "slot_center_has_university"),
       (str_store_string, s0, "@Library"),
       (str_store_string, s1, "@Erect it to increase and spread knowledge in your name. (Add Renown)"),
       (assign, reg0, 7000),#gdw kind of pointless lategame adds prosperity as well
#Sod BUILDINGS END chief
     (try_end),
     ]),
  
  #script_cf_troop_agent_is_alive
  # INPUT: arg1 = troop_id
  ("cf_troop_agent_is_alive",
    [(store_script_param, ":troop_no", 1),
     (assign, ":alive_count", 0),
     (try_for_agents, ":cur_agent"),
       (agent_get_troop_id, ":cur_agent_troop", ":cur_agent"),
       (eq, ":troop_no", ":cur_agent_troop"),
       (agent_is_alive, ":cur_agent"),
       (val_add, ":alive_count", 1),
     (try_end),
     (gt, ":alive_count", 0),
     ]),

  #reclutar ciudades chief
  #script_cf_town_castle_recruit_volunteers_cond
  # INPUT: none
  # OUTPUT: none
  ("cf_town_castle_recruit_volunteers_cond",
    [(store_faction_of_party, ":town_faction", "$current_town"),
     (party_get_slot, ":center_relation", "$current_town", "slot_center_player_relation"),
     (store_relation, ":town_faction_relation", ":town_faction", "fac_player_faction"),
     (ge, ":center_relation", 0),
     (this_or_next|ge, ":center_relation", 5),
     (this_or_next|eq, ":town_faction", "$players_kingdom"),
     (this_or_next|ge, ":town_faction_relation", 0),
     (this_or_next|eq, ":town_faction", "$supported_pretender_old_faction"),
     (             eq, "$players_kingdom", 0),
     (party_slot_ge, "$current_town", "slot_center_volunteer_troop_amount", 0),
     (party_slot_ge, "$current_town", "slot_center_volunteer_troop_type", 1),
     (party_get_free_companions_capacity, ":free_capacity", "p_main_party"),
     (ge, ":free_capacity", 1),
     ]),
#reclutar acaba

#reclutar ciudades chief
      #script_town_castle_recruit_nobles_recruit
  # INPUT: none
  # OUTPUT: none
  ("town_recruit_nobles_recruit",
    [
        #(store_faction_of_party, ":cur_faction", "$current_town"),
        
                (party_get_slot, ":cur_faction", "$current_town", "slot_center_original_faction"),	
                
     (faction_get_slot, ":volunteer_troop", ":cur_faction", "slot_faction_tier_5_troop"),
    (party_get_slot, ":volunteer_amount", "$current_town", "slot_center_volunteer_troop_amount"),
     (party_get_free_companions_capacity, ":free_capacity", "p_main_party"),
     (val_min, ":volunteer_amount", ":free_capacity"),
     (store_troop_gold, ":gold", "trp_player"),
     (store_div, ":gold_capacity", ":gold", 290),#200 denars per man
     (val_min, ":volunteer_amount", ":gold_capacity"),
     (party_add_members, "p_main_party", ":volunteer_troop", ":volunteer_amount"),
     (party_set_slot, "$current_town", "slot_center_volunteer_troop_amount", -1),
     (store_mul, ":cost", ":volunteer_amount", 290),#200 denars per man
     (troop_remove_gold, "trp_player", ":cost"),
     ]),
  #reclutar ciudades acaba chief
  
  #script_get_troop_item_amount
  # INPUT: arg1 = troop_no, arg2 = item_no
  # OUTPUT: reg0 = item_amount
  ("get_troop_item_amount",
    [(store_script_param, ":troop_no", 1),
     (store_script_param, ":item_no", 2),
     (troop_get_inventory_capacity, ":inv_cap", ":troop_no"),
     (assign, ":count", 0),
     (try_for_range, ":i_slot", 0, ":inv_cap"),
       (troop_get_inventory_slot, ":cur_item", ":troop_no", ":i_slot"),
       (eq, ":cur_item", ":item_no"),
       (val_add, ":count", 1),
     (try_end),
     (assign, reg0, ":count"),
     ]),

        ##Floris/STAT chief
        #script_get_troop_amount
        # INPUT: arg1 = p_main_party, arg2 = troop_no
        # OUTPUT: reg0 = item_amount
        # script_get_party_troop_count
        # INPUT: arg1 = party_no, arg2 = troop_no
        # OUTPUT: reg0 = troop_count
        ("get_party_troop_count",
          [
            (store_script_param_1, ":party_no"),
            (store_script_param_2, ":troop_no"),
            
            (assign, ":stack_size", 0),
            (party_get_num_companion_stacks, ":num_of_stacks", ":party_no"),
            (try_for_range, ":i", 0, ":num_of_stacks"),
              (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i"),
              (eq, ":stack_troop", ":troop_no"),
              (party_stack_get_size, ":stack_size", ":party_no", ":i"),
              (party_stack_get_num_wounded, ":stack_wounded", ":party_no", ":i"),
              (val_sub, ":stack_size", ":stack_wounded"),
              (assign, ":num_of_stacks", 0), #break loop
            (try_end),
            (assign, reg0, ":stack_size"),
        ]),
        ##Floris/STAT end

  #script_get_name_from_dna_to_s50
  # INPUT: arg1 = dna
  # OUTPUT: s50 = name
  ("get_name_from_dna_to_s50",
    [(store_script_param, ":dna", 1),
     (store_sub, ":num_names", names_end, names_begin),
     (store_sub, ":num_surnames", surnames_end, surnames_begin),
     (assign, ":selected_name", ":dna"),
     (val_mod, ":selected_name", ":num_names"),
     (assign, ":selected_surname", ":dna"),
     (val_div, ":selected_surname", ":num_names"),
     (val_mod, ":selected_surname", ":num_surnames"),
     (val_add, ":selected_name", names_begin),
     (val_add, ":selected_surname", surnames_begin),
     (str_store_string, s50, ":selected_name"),
     (str_store_string, s50, ":selected_surname"),
     ]),
     
  #script_change_center_prosperity
  # INPUT: arg1 = center_no, arg2 = difference
  # OUTPUT: none
  ("change_center_prosperity",
    [(store_script_param, ":center_no", 1),
     (store_script_param, ":difference", 2),
     (party_get_slot, ":old_prosperity", ":center_no", "slot_town_prosperity"),
     (store_add, ":new_prosperity", ":old_prosperity", ":difference"),
     (val_clamp, ":new_prosperity", 0, 100),
     (store_div, ":old_state", ":old_prosperity", 20),
     (store_div, ":new_state", ":new_prosperity", 20),
	 
     (try_begin),
       (neq, ":old_state", ":new_state"),
	   (neg|is_between, ":center_no", castles_begin, castles_end),
	   
       (str_store_party_name_link, s2, ":center_no"),
       (call_script, "script_get_prosperity_text_to_s50", ":center_no"),
       (str_store_string, s3, s50),
       (party_set_slot, ":center_no", "slot_town_prosperity", ":new_prosperity"),
       (call_script, "script_get_prosperity_text_to_s50", ":center_no"),
       (str_store_string, s4, s50),
       (try_begin),
         (party_slot_eq, ":center_no", "slot_town_lord", "trp_player"),
         (display_message, "@Prosperity of {s2} has changed from {s3} to {s4}."),
       (try_end),
       (call_script, "script_update_center_notes", ":center_no"),
     (else_try),
       (party_set_slot, ":center_no", "slot_town_prosperity", ":new_prosperity"),
     (try_end),
	 
	 (try_begin),
		(store_current_hours, ":hours"),
		(gt, ":hours", 1),
		(store_sub, ":actual_difference", ":new_prosperity", ":old_prosperity"),
		(try_begin),
			(lt, ":actual_difference", 0),
			(val_add, "$newglob_total_prosperity_losses", ":actual_difference"),
	    (else_try),
			(gt, ":actual_difference", 0),
			(val_add, "$newglob_total_prosperity_gains", ":actual_difference"),
		(try_end),
	 (try_end),
	 
	 #This will add up all non-trade prosperity
	 (try_begin),
		(eq, "$cheat_mode", 3),
		(assign, reg4, "$newglob_total_prosperity_from_bandits"), 
		(assign, reg5, "$newglob_total_prosperity_from_caravan_trade"),	 
	    (assign, reg7, "$newglob_total_prosperity_from_villageloot"), 
	    (assign, reg8, "$newglob_total_prosperity_from_townloot"),	 
	    (assign, reg9, "$newglob_total_prosperity_from_village_trade"),
	    (assign, reg10, "$newglob_total_prosperity_from_convergence"),
	    (assign, reg11, "$newglob_total_prosperity_losses"),
	    (assign, reg12, "$newglob_total_prosperity_gains"),
		(display_message, "@{!}DEBUG: Total prosperity actual losses: {reg11}"),
		(display_message, "@{!}DEBUG: Total prosperity actual gains: {reg12}"),
		
		(display_message, "@{!}DEBUG: Prosperity changes from random bandits: {reg4}"),
		(display_message, "@{!}DEBUG: Prosperity changes from caravan trades: {reg5}"),
		(display_message, "@{!}DEBUG: Prosperity changes from farmer trades: {reg9}"),
		(display_message, "@{!}DEBUG: Prosperity changes from looted villages: {reg7}"),
		(display_message, "@{!}DEBUG: Prosperity changes from sieges: {reg8}"),
		(display_message, "@{!}DEBUG: Theoretical prosperity changes from convergence: {reg10}"),
	 (try_end),
	 
     ]),

  #script_get_center_ideal_prosperity
  # INPUT: arg1 = center_no
  # OUTPUT: reg0 = ideal_prosperity
  ("get_center_ideal_prosperity",
    [(store_script_param, ":center_no", 1),
     (assign, ":ideal", 65),

     (call_script, "script_center_get_goods_availability", ":center_no"),
     (store_mul, ":hardship_index", reg0, 2),
     (val_sub, ":ideal", ":hardship_index"),	 

     (try_begin),
       (is_between, ":center_no", villages_begin, villages_end),
       (party_slot_eq, ":center_no", "slot_center_has_fish_pond", 1),
       (val_add, ":ideal", 5),#gdw this was already higher than native2
     (try_end),

     (val_max, ":ideal", 0),
	
     (assign, reg0, ":ideal"),
     ]),

  #script_get_poorest_village_of_faction
  # INPUT: arg1 = center_no
  # OUTPUT: reg0 = ideal_prosperity
  ("get_poorest_village_of_faction",
    [(store_script_param, ":faction_no", 1),
     (assign, ":min_prosperity_village", -1),
     (assign, ":min_prosperity", 101),
     (try_for_range, ":village_no", villages_begin, villages_end),
       (store_faction_of_party, ":village_faction", ":village_no"),
       (eq, ":village_faction", ":faction_no"),
       (party_get_slot, ":prosperity", ":village_no", "slot_town_prosperity"),
       (lt, ":prosperity", ":min_prosperity"),
       (assign, ":min_prosperity", ":prosperity"),
       (assign, ":min_prosperity_village", ":village_no"),
     (try_end),
     (assign, reg0, ":min_prosperity_village"),
     ]),

  #script_troop_add_gold
  # INPUT: arg1 = troop_no, arg2 = amount
  # OUTPUT: none
  ("troop_add_gold",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":amount", 2),
      
      (troop_add_gold, ":troop_no", ":amount"),
      (try_begin),
        (eq, ":troop_no", "trp_player"),
        (play_sound, "snd_money_received"),
      (try_end),
     ]),     

  #script_event_player_defeated_enemy_party
  # INPUT: none
  # OUTPUT: none
  ("event_player_defeated_enemy_party",
    [(try_begin),
       (check_quest_active, "qst_raid_caravan_to_start_war"),
       (neg|check_quest_concluded, "qst_raid_caravan_to_start_war"),
       (party_slot_eq, "$g_enemy_party", "slot_party_type", spt_kingdom_caravan),
       (store_faction_of_party, ":enemy_faction", "$g_enemy_party"),
       (quest_slot_eq, "qst_raid_caravan_to_start_war", "slot_quest_target_faction", ":enemy_faction"),
       (quest_get_slot, ":cur_state", "qst_raid_caravan_to_start_war", "slot_quest_current_state"),
       (quest_get_slot, ":quest_target_amount", "qst_raid_caravan_to_start_war", "slot_quest_target_amount"),
       (val_add, ":cur_state", 1),
       (quest_set_slot, "qst_raid_caravan_to_start_war", "slot_quest_current_state", ":cur_state"),
       (try_begin),
         (ge, ":cur_state", ":quest_target_amount"),
         (quest_get_slot, ":quest_target_faction", "qst_raid_caravan_to_start_war", "slot_quest_target_faction"),
         (quest_get_slot, ":quest_giver_troop", "qst_raid_caravan_to_start_war", "slot_quest_giver_troop"),
         (store_troop_faction, ":quest_giver_faction", ":quest_giver_troop"),
         (call_script, "script_diplomacy_start_war_between_kingdoms", ":quest_target_faction", ":quest_giver_faction", logent_faction_declares_war_to_respond_to_provocation),	#MOTO chief pass log entries
#         (call_script, "script_diplomacy_start_war_between_kingdoms", ":quest_target_faction", ":quest_giver_faction", 1),
         (call_script, "script_succeed_quest", "qst_raid_caravan_to_start_war"),
       (try_end),
     (try_end),

     ]),

  #script_event_player_captured_as_prisoner
  # INPUT: none
  # OUTPUT: none
  ("event_player_captured_as_prisoner",
    [
        (try_begin),
          (check_quest_active, "qst_raid_caravan_to_start_war"),
          (neg|check_quest_concluded, "qst_raid_caravan_to_start_war"),
          (quest_get_slot, ":quest_target_faction", "qst_raid_caravan_to_start_war", "slot_quest_target_faction"),
          (store_faction_of_party, ":capturer_faction", "$capturer_party"),
          (eq, ":quest_target_faction", ":capturer_faction"),
          (call_script, "script_fail_quest", "qst_raid_caravan_to_start_war"),
        (try_end),
        #Removing followers of the player
        (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
		  (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
          (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
          (gt, ":party_no", 0),
          (party_is_active, ":party_no"),
          (this_or_next|party_slot_eq, ":party_no", "slot_party_ai_state", spai_screening_army),	#MOTO don't forget screeners
          (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
          (party_slot_eq, ":party_no", "slot_party_ai_object", "p_main_party"),
          (call_script, "script_party_set_ai_state", ":party_no", spai_undefined, -1),
          (assign, "$g_recalculate_ais", 1),
        (try_end),
     ]),

#NPC morale both returns a string and reg0 as the morale value
  ("npc_morale",
[
        (store_script_param_1, ":npc"),

        (troop_get_slot, ":morality_grievances", ":npc", "slot_troop_morality_penalties"),
        (troop_get_slot, ":personality_grievances", ":npc", "slot_troop_personalityclash_penalties"),
       
        (call_script, "script_troop_get_player_relation", ":npc"),
        (assign, ":player_relation", reg0),

        (party_get_morale, ":party_morale", "p_main_party"),

        (store_sub, ":troop_morale", ":party_morale", ":morality_grievances"),
        (val_sub, ":troop_morale", ":personality_grievances"),
        (val_add, ":troop_morale", 50),#gdw50tested they stick around much longer
        (val_add, ":troop_morale", ":player_relation"),
        (assign, reg8, ":troop_morale"),
        
		(val_mul, ":troop_morale", 3),
        (val_div, ":troop_morale", 4),
        (val_clamp, ":troop_morale", 0, 100),

        (assign, reg4, ":player_relation"),
        (assign, reg5, ":party_morale"),
        (assign, reg6, ":morality_grievances"),
        (assign, reg7, ":personality_grievances"),
        (assign, reg9, ":troop_morale"),

        (str_store_troop_name, s11, ":npc"),
        #(try_begin),
        #	(neq, ":troop_no", "trp_player"),
        #	(neg|is_between, ":troop_no", soldiers_begin, soldiers_end),
		#	(neq, ":troop_no", -1),
        	#(neq, ":difference", 0),
        

        (try_begin),
            (lt, ":morality_grievances", 3),
            (str_store_string, 7, "str_happy"),
        (else_try),
            (lt, ":morality_grievances", 15),
            (str_store_string, 7, "str_content"),
        (else_try),
            (lt, ":morality_grievances", 30),
            (str_store_string, 7, "str_concerned"),
        (else_try),
            (lt, ":morality_grievances", 45),
            (str_store_string, 7, "str_not_happy"),
        (else_try),
            (str_store_string, 7, "str_miserable"),
        (try_end),


        (try_begin),
            (lt, ":personality_grievances", 3),
            (str_store_string, 6, "str_happy"),
        (else_try),
            (lt, ":personality_grievances", 15),
            (str_store_string, 6, "str_content"),
        (else_try),
            (lt, ":personality_grievances", 30),
            (str_store_string, 6, "str_concerned"),
        (else_try),
            (lt, ":personality_grievances", 45),
            (str_store_string, 6, "str_not_happy"),
        (else_try),
            (str_store_string, 6, "str_miserable"),
        (try_end),


        (try_begin),
            (gt, ":troop_morale", 80),
            (str_store_string, 8, "str_happy"),
            (str_store_string, 63, "str_bar_enthusiastic"),
        (else_try),
            (gt, ":troop_morale", 60),
            (str_store_string, 8, "str_content"),
            (str_store_string, 63, "str_bar_content"),
        (else_try),
            (gt, ":troop_morale", 40),
            (str_store_string, 8, "str_concerned"),
            (str_store_string, 63, "str_bar_weary"),
        (else_try),
            (gt, ":troop_morale", 20),
            (str_store_string, 8, "str_not_happy"),
            (str_store_string, 63, "str_bar_disgruntled"),
        (else_try),
            (str_store_string, 8, "str_miserable"),
            (str_store_string, 63, "str_bar_miserable"),
        (try_end),


		# (try_begin),
  #       (gt, "$cheat_mode", 0),
  #       #(display_message, "@{!}DEBUG -- troop_get_player_relation: {reg0}"),
  #       #(assign, reg10, ":player_relation"),
  #       #(assign, reg11, ":npc_bonus"),
  #       (display_message, "@{!}DEBUG -- player_relation: {reg4}"), 
  #       (display_message, "@{!}DEBUG -- troop_morale: {reg9}"), 
  #       (display_message, "@{!}DEBUG -- morality_grievances: {reg6}"), 
  #       (display_message, "@{!}DEBUG -- personality_grievances: {reg7}"),
  #           (display_message, "@{!}{s11}'s morale = PM{reg5} + 50 + PR{reg4} - MG{reg6} - PG{reg7} = {reg8} x 0.75 = {reg9}"),
  #       	(try_end),
        (str_store_string, 21, "str_npc_morale_report"),
        (assign, reg0, ":troop_morale"),

     ]),
#NPC morale both returns a string and reg0 as the morale value

#Hunting scripts end

  #script_calculate_ransom_amount_for_troop
  # INPUT: arg1 = troop_no
  # OUTPUT: reg0 = ransom_amount
  ("calculate_ransom_amount_for_troop",
    [(store_script_param, ":troop_no", 1),
     (store_troop_faction, ":faction_no", ":troop_no"),
     (assign, ":ransom_amount", 400),

	 (assign, ":male_relative", -9), #for kingdom ladies, otherwise a number otherwise unused in "slot_town_lord"
     (try_begin),
       (faction_slot_eq, ":faction_no", "slot_faction_leader", ":troop_no"),
       (val_add, ":ransom_amount", 4100),
	 (else_try),  
       (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_lady),
       (val_add, ":ransom_amount", 2500), #as though a renown of 1250 -- therefore significantly higher than for roughly equivalent lords
	   (call_script, "script_get_kingdom_lady_social_determinants", ":troop_no"),
	   (assign, ":male_relative", reg0),
     (try_end),

     (assign, ":num_center_points", 0),
     (try_for_range, ":cur_center", centers_begin, centers_end),
       (this_or_next|party_slot_eq, ":cur_center", "slot_town_lord", ":troop_no"),
		 (party_slot_eq, ":cur_center", "slot_town_lord", ":male_relative"),
       (try_begin),
         (party_slot_eq, ":cur_center", "slot_party_type", spt_town),
         (val_add, ":num_center_points", 4),
       (else_try),
         (party_slot_eq, ":cur_center", "slot_party_type", spt_castle),
         (val_add, ":num_center_points", 2),
       (else_try),
         (val_add, ":num_center_points", 1),
       (try_end),
     (try_end),
     (val_mul, ":num_center_points", 500),
     (val_add, ":ransom_amount", ":num_center_points"),
     (troop_get_slot, ":renown", ":troop_no", "slot_troop_renown"),
     (val_mul, ":renown", 2),
     (val_add, ":ransom_amount", ":renown"),
     (store_mul, ":ransom_max_amount", ":ransom_amount", 3),
     (val_div, ":ransom_max_amount", 2),
     (store_random_in_range, ":random_ransom_amount", ":ransom_amount", ":ransom_max_amount"),
     (val_div, ":random_ransom_amount", 100),
     (val_mul, ":random_ransom_amount", 100),
     (assign, reg0, ":random_ransom_amount"),
     ]),  

  #script_offer_ransom_amount_to_player_for_prisoners_in_party
  # INPUT: arg1 = party_no
  # OUTPUT: reg0 = result (1 = offered, 0 = not offered)
  ("offer_ransom_amount_to_player_for_prisoners_in_party",
    [(store_script_param, ":party_no", 1),
     (assign, ":result", 0),
     (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (eq, ":result", 0),
       (party_prisoner_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
       (troop_is_hero, ":stack_troop"),
       (this_or_next|troop_slot_eq, ":stack_troop", "slot_troop_occupation", slto_kingdom_hero),
		 (troop_slot_eq, ":stack_troop", "slot_troop_occupation", slto_kingdom_lady),
       (store_troop_faction, ":stack_troop_faction", ":stack_troop"),
       (store_random_in_range, ":random_no", 0, 100),
       (try_begin),
         (faction_slot_eq, ":stack_troop_faction", "slot_faction_state", sfs_active),
         (le, ":random_no", 9),#gdw5
         (neq, "$g_ransom_offer_rejected", 1),
         (assign, ":num_stacks", 0), #break
         (assign, ":result", 1),
         (assign, "$g_ransom_offer_troop", ":stack_troop"),
         (assign, "$g_ransom_offer_party", ":party_no"),
         (jump_to_menu, "mnu_enemy_offer_ransom_for_prisoner"),
       (try_end),
     (try_end),
     (assign, reg0, ":result"),
     ]),

  # script_event_hero_taken_prisoner_by_player
  # Input: arg1 = troop_no
  # Output: none
  ("event_hero_taken_prisoner_by_player",
    [
      (store_script_param_1, ":troop_no"),
      (try_begin),
        (check_quest_active, "qst_persuade_lords_to_make_peace"),
        (try_begin),
          (quest_slot_eq, "qst_persuade_lords_to_make_peace", "slot_quest_target_troop", ":troop_no"),
          (val_mul, ":troop_no", -1),
          (quest_set_slot, "qst_persuade_lords_to_make_peace", "slot_quest_target_troop", ":troop_no"),
          (val_mul, ":troop_no", -1),
        (else_try),
          (quest_slot_eq, "qst_persuade_lords_to_make_peace", "slot_quest_object_troop", ":troop_no"),
          (val_mul, ":troop_no", -1),
          (quest_set_slot, "qst_persuade_lords_to_make_peace", "slot_quest_object_troop", ":troop_no"),
          (val_mul, ":troop_no", -1),
        (try_end),
        (neg|check_quest_concluded, "qst_persuade_lords_to_make_peace"),
        (neg|quest_slot_ge, "qst_persuade_lords_to_make_peace", "slot_quest_target_troop", 0),
        (neg|quest_slot_ge, "qst_persuade_lords_to_make_peace", "slot_quest_object_troop", 0),
        (call_script, "script_succeed_quest", "qst_persuade_lords_to_make_peace"),
      (try_end),
      (call_script, "script_update_troop_location_notes", ":troop_no", 0),
  ]),

  # script_cf_check_hero_can_escape_from_player
  # Input: arg1 = troop_no
  # Output: none (can fail)
  ("cf_check_hero_can_escape_from_player",
    [
      (store_script_param_1, ":troop_no"),
      (assign, ":quest_target", 0),
      (try_begin),
        (check_quest_active, "qst_persuade_lords_to_make_peace"),
        (this_or_next|quest_slot_eq, "qst_persuade_lords_to_make_peace", "slot_quest_target_troop", ":troop_no"),
        (quest_slot_eq, "qst_persuade_lords_to_make_peace", "slot_quest_object_troop", ":troop_no"),
        (assign, ":quest_target", 1),
      (else_try),
        (ge, ":troop_no", "trp_sea_raider_leader"),
        (lt, ":troop_no", "trp_bandit_leaders_end"),
        (try_begin),
          (check_quest_active, "qst_learn_where_merchant_brother_is"),
          (assign, ":quest_target", 1), #always catched
        (else_try),  
          (assign, ":quest_target", -1), #always run.
        (try_end),
      (try_end),
      
      (assign, ":continue", 0),
      (try_begin),
        (eq, ":quest_target", 0), #if not quest target
        (store_random_in_range, ":rand", 0, 100),#gdw why not change this to straight value like 35?
        (lt, ":rand", hero_escape_after_defeat_chance),
        (assign, ":continue", 1),
      (else_try),  
        (eq, ":quest_target", -1), #if (always run) quest target
        (assign, ":continue", 1),
      (try_end),       
      (eq, ":continue", 1),
  ]),

  # script_cf_party_remove_random_regular_troop
  # Input: arg1 = party_no
  # Output: troop_id that has been removed (can fail)
  ("cf_party_remove_random_regular_troop",
    [(store_script_param_1, ":party_no"),
     (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
     (assign, ":num_troops", 0),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
       (neg|troop_is_hero, ":stack_troop"),
       (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
       (val_add, ":num_troops", ":stack_size"),
     (try_end),
     (assign, reg0, -1),
     (gt, ":num_troops", 0),
     (store_random_in_range, ":random_troop", 0, ":num_troops"),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
       (neg|troop_is_hero, ":stack_troop"),
       (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
       (val_sub, ":random_troop", ":stack_size"),
       (lt, ":random_troop", 0),
       (assign, ":num_stacks", 0), #break
       (party_remove_members, ":party_no", ":stack_troop", 1),
       (assign, reg0, ":stack_troop"),
     (try_end),
     ]),

  # script_place_player_banner_near_inventory
  # Input: none
  # Output: none
  ("place_player_banner_near_inventory",
    [
    	#normal_banner_begin
    	(troop_get_slot, ":troop_banner_object", "trp_player", "slot_troop_banner_scene_prop"),
    	#custom_banner_begin
#    	(troop_get_slot, ":flag_spr", "trp_player", "slot_troop_custom_banner_flag_type"),

     (try_begin),
    	#normal_banner_begin
       (gt, ":troop_banner_object", 0),
       (scene_prop_get_instance, ":flag_object", ":troop_banner_object", 0),
    	#custom_banner_begin
#       (ge, ":flag_spr", 0),
#       (val_add, ":flag_spr", custom_banner_flag_scene_props_begin),
#       (scene_prop_get_instance, ":flag_object", ":flag_spr", 0),
       (try_begin),
         (ge, ":flag_object", 0),
         (get_player_agent_no, ":player_agent"),
         (agent_get_look_position, pos1, ":player_agent"),
         (position_move_y, pos1, -500),
         (position_rotate_z, pos1, 180),
         (position_set_z_to_ground_level, pos1),
         (position_move_z, pos1, 300),
         (prop_instance_set_position, ":flag_object", pos1),
       (try_end),
       (scene_prop_get_instance, ":pole_object", "spr_banner_pole", 0),
       (try_begin),
         (ge, ":pole_object", 0),
         (position_move_z, pos1, -320),
         (prop_instance_set_position, ":pole_object", pos1),
       (try_end),
     (else_try),
       (init_position, pos1),
       (position_move_z, pos1, -1000000),
       (scene_prop_get_instance, ":flag_object", banner_scene_props_begin, 0),
       (try_begin),
         (ge, ":flag_object", 0),
         (prop_instance_set_position, ":flag_object", pos1),
       (try_end),
       (scene_prop_get_instance, ":pole_object", "spr_banner_pole", 0),
       (try_begin),
         (ge, ":pole_object", 0),
         (prop_instance_set_position, ":pole_object", pos1),
       (try_end),
     (try_end),
     ]),

  # script_place_player_banner_near_inventory_bms
  # Input: none
  # Output: none
  ("place_player_banner_near_inventory_bms",
    [
    	    	#normal_banner_begin
    	(troop_get_slot, ":troop_banner_object", "trp_player", "slot_troop_banner_scene_prop"),
    	    	#custom_banner_begin
#      (troop_get_slot, ":flag_spr", "trp_player", "slot_troop_custom_banner_flag_type"),
     (try_begin),
    	    	#normal_banner_begin
       (gt, ":troop_banner_object", 0),
       (replace_scene_props, banner_scene_props_begin, ":troop_banner_object"),
    	    	#custom_banner_begin
#       (ge, ":flag_spr", 0),
#       (val_add, ":flag_spr", custom_banner_flag_scene_props_begin),
#       (replace_scene_props, banner_scene_props_begin, ":flag_spr"),
     (try_end),
     ]),
  
  # script_stay_captive_for_hours
  # Input: arg1 = num_hours
  # Output: none
  ("stay_captive_for_hours",
    [
      (store_script_param, ":num_hours", 1),
      (store_current_hours, ":cur_hours"),
      (val_add, ":cur_hours", ":num_hours"),
      (val_max, "$g_check_autos_at_hour", ":cur_hours"),
      (val_add, ":num_hours", 1),
      (rest_for_hours, ":num_hours", 0, 0),
    ]),

  # script_set_parties_around_player_ignore_player
  # Input: arg1 = ignore_range, arg2 = num_hours_to_ignore
  # Output: none
  ("set_parties_around_player_ignore_player",
    [(store_script_param, ":ignore_range", 1),
     (store_script_param, ":num_hours", 2),
     (try_for_parties, ":party_no"),
       (party_is_active, ":party_no"),
       (store_distance_to_party_from_party, ":dist", "p_main_party", ":party_no"),
       (lt, ":dist", ":ignore_range"),
       (party_ignore_player, ":party_no", ":num_hours"),
     (try_end),
     ]),

  # script_randomly_make_prisoner_heroes_escape_from_party
  # Input: arg1 = party_no, arg2 = escape_chance_mul_1000
  # Output: none
  ("randomly_make_prisoner_heroes_escape_from_party",
    [(store_script_param, ":party_no", 1),
     (store_script_param, ":escape_chance", 2),
     (assign, ":quest_troop_1", -1),
     (assign, ":quest_troop_2", -1),
     (try_begin),
       (check_quest_active, "qst_rescue_lord_by_replace"),
       (quest_get_slot, ":quest_troop_1", "qst_rescue_lord_by_replace", "slot_quest_target_troop"),
     (try_end),
     (try_begin),
       (check_quest_active, "qst_deliver_message_to_prisoner_lord"),
       (quest_get_slot, ":quest_troop_2", "qst_deliver_message_to_prisoner_lord", "slot_quest_target_troop"),
     (try_end),
     (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
     (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
       (party_prisoner_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
       (troop_is_hero, ":stack_troop"),
       (neq, ":stack_troop", ":quest_troop_1"),
       (neq, ":stack_troop", ":quest_troop_2"),
       (troop_slot_eq, ":stack_troop", "slot_troop_occupation", slto_kingdom_hero),
       (store_random_in_range, ":random_no", 0, 1000),
       (lt, ":random_no", ":escape_chance"),
       (party_remove_prisoners, ":party_no", ":stack_troop", 1),
       (call_script, "script_remove_troop_from_prison", ":stack_troop"),
       (str_store_troop_name_link, s1, ":stack_troop"),
       (try_begin),
         (eq, ":party_no", "p_main_party"),
         (str_store_string, s2, "@your party"),
       (else_try),
         (str_store_party_name, s2, ":party_no"),
       (try_end),
       (assign, reg0, 0),
       (try_begin),
         (this_or_next|eq, ":party_no", "p_main_party"),
         (party_slot_eq, ":party_no", "slot_town_lord", "trp_player"),
         (assign, reg0, 1),
       (try_end),
       (store_troop_faction, ":troop_faction", ":stack_troop"),
       (str_store_faction_name_link, s3, ":troop_faction"),
       (display_message, "@{reg0?One of your prisoners, :}{s1} of {s3} has escaped from captivity!", color_terrible_news),
     (try_end),
     ]),

#xenoarg chief script para liberar a todos los prisioneros
		  ("free_all_prisoners",
		  [
			(store_script_param, ":party_no", 1),
			(party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
			(try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
				(party_prisoner_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
				(troop_is_hero, ":stack_troop"),
				(party_remove_prisoners, ":party_no", ":stack_troop", 1),
				(call_script, "script_remove_troop_from_prison", ":stack_troop"),
				(party_add_members,"p_main_party",":stack_troop",1),
			(try_end),
		  ]),

  # script_draw_banner_to_region
  # Input: arg1 = troop_no, arg2 = center_pos_x, arg3 = center_pos_y, arg4 = width, arg5 = height, arg6 = stretch_width, arg7 = stretch_height, arg8 = default_scale, arg9 = max_charge_scale, arg10 = drawn_item_type
  # drawn_item_type is 0 for banners, 1 for shields, 2 for heater shield, 3 for armor
  # arguments will be used as fixed point values
  # Output: none
  ("draw_banner_to_region",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":center_pos_x", 2),
      (store_script_param, ":center_pos_y", 3),
      (store_script_param, ":width", 4),
      (store_script_param, ":height", 5),
      (store_script_param, ":stretch_width", 6),
      (store_script_param, ":stretch_height", 7),
      (store_script_param, ":default_scale", 8),
      (store_script_param, ":max_charge_scale", 9),
      (store_script_param, ":drawn_item_type", 10),

      (troop_get_slot, ":bg_type", ":troop_no", "slot_troop_custom_banner_bg_type"),
      (val_add, ":bg_type", custom_banner_backgrounds_begin),
      (troop_get_slot, ":bg_color_1", ":troop_no", "slot_troop_custom_banner_bg_color_1"),
      (troop_get_slot, ":bg_color_2", ":troop_no", "slot_troop_custom_banner_bg_color_2"),
      (troop_get_slot, ":num_charges", ":troop_no", "slot_troop_custom_banner_num_charges"),
      (troop_get_slot, ":positioning", ":troop_no", "slot_troop_custom_banner_positioning"),
      (call_script, "script_get_troop_custom_banner_num_positionings", ":troop_no"),
      (assign, ":num_positionings", reg0),
      (val_mod, ":positioning", ":num_positionings"),

      (init_position, pos2),
      (position_set_x, pos2, ":width"),
      (position_set_y, pos2, ":height"),
      (assign, ":default_value", 1),
      (convert_to_fixed_point, ":default_value"),
      (position_set_z, pos2, ":default_value"),

      (init_position, pos1),
      (position_set_x, pos1, ":center_pos_x"),
      (position_set_y, pos1, ":center_pos_y"),
      (position_move_z, pos1, -20),

      (init_position, pos3),
      (position_set_x, pos3, ":default_scale"),
      (position_set_y, pos3, ":default_scale"),
      (position_set_z, pos3, ":default_value"),

      (try_begin),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_bg"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg01"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg02"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg03"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg08"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg09"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg10"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg11"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg12"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg13"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg16"),
        (eq, ":bg_type", "mesh_custom_banner_fg17"),
        (cur_tableau_add_mesh_with_scale_and_vertex_color, ":bg_type", pos1, pos2, 0, ":bg_color_1"),
      (else_try),
        (cur_tableau_add_mesh_with_scale_and_vertex_color, ":bg_type", pos1, pos3, 0, ":bg_color_1"),
      (try_end),
      (position_move_z, pos1, -20),
      (position_move_x, pos2, ":width"),
      (position_move_y, pos2, ":height"),
      (cur_tableau_add_mesh_with_scale_and_vertex_color, "mesh_custom_banner_bg", pos1, pos2, 0, ":bg_color_2"),
      
      (assign, ":charge_stretch", ":stretch_width"),
      (val_min, ":charge_stretch", ":stretch_height"),
      (val_min, ":charge_stretch", ":max_charge_scale"),
      (call_script, "script_get_custom_banner_charge_type_position_scale_color", "trp_player", ":positioning"),

      (try_begin),
        (this_or_next|eq, ":drawn_item_type", 2), #heater shield
        (eq, ":drawn_item_type", 3), #armor
        (assign, ":change_center_pos", 0),
        (try_begin),
          (eq, ":num_charges", 1),
          (assign, ":change_center_pos", 1),
        (else_try),
          (eq, ":num_charges", 2),
          (eq, ":positioning", 1),
          (assign, ":change_center_pos", 1),
        (else_try),
          (eq, ":num_charges", 3),
          (eq, ":positioning", 1),
          (assign, ":change_center_pos", 1),
        (try_end),
        (try_begin),
          (eq, ":change_center_pos", 1),
          (val_add, ":center_pos_y", 30),
        (try_end),
      (try_end),
      
      (try_begin),
        (ge, ":num_charges", 1),
        (val_mul, reg1, ":charge_stretch"),
        (val_div, reg1, 10000),
        (position_get_x, ":x", pos0),
        (position_get_y, ":y", pos0),
        (val_mul, ":x", ":stretch_width"),
        (val_mul, ":y", ":stretch_height"),
        (val_div, ":x", 10000),
        (val_div, ":y", 10000),
        (val_add, ":x", ":center_pos_x"),
        (val_add, ":y", ":center_pos_y"),
        (position_set_x, pos0, ":x"),
        (position_set_y, pos0, ":y"),
        (assign, ":scale_value", reg1),
        (convert_to_fixed_point, ":scale_value"),
        (store_mul, ":scale_value_inverse", ":scale_value", -1),
        (init_position, pos4),
        (position_set_x, pos4, ":scale_value"),
        (position_set_y, pos4, ":scale_value"),
        (position_set_z, pos4, ":scale_value"),
        (store_div, ":orientation", reg0, 256), #orientation flags
        (try_begin),
          (this_or_next|eq, ":orientation", 1),
          (eq, ":orientation", 3),
          (position_set_x, pos4, ":scale_value_inverse"),
        (try_end),
        (try_begin),
          (this_or_next|eq, ":orientation", 2),
          (eq, ":orientation", 3),
          (position_set_y, pos4, ":scale_value_inverse"),
        (try_end),
        (val_mod, reg0, 256), #remove orientation flags
        (cur_tableau_add_mesh_with_scale_and_vertex_color, reg0, pos0, pos4, 0, reg2),
      (try_end),
      (try_begin),
        (ge, ":num_charges", 2),
        (val_mul, reg4, ":charge_stretch"),
        (val_div, reg4, 10000),
        (position_get_x, ":x", pos1),
        (position_get_y, ":y", pos1),
        (val_mul, ":x", ":stretch_width"),
        (val_mul, ":y", ":stretch_height"),
        (val_div, ":x", 10000),
        (val_div, ":y", 10000),
        (val_add, ":x", ":center_pos_x"),
        (val_add, ":y", ":center_pos_y"),
        (position_set_x, pos1, ":x"),
        (position_set_y, pos1, ":y"),

        (assign, ":scale_value", reg4),
        (convert_to_fixed_point, ":scale_value"),
        (store_mul, ":scale_value_inverse", ":scale_value", -1),
        (init_position, pos4),
        (position_set_x, pos4, ":scale_value"),
        (position_set_y, pos4, ":scale_value"),
        (position_set_z, pos4, ":scale_value"),
        (store_div, ":orientation", reg3, 256), #orientation flags
        (try_begin),
          (this_or_next|eq, ":orientation", 1),
          (eq, ":orientation", 3),
          (position_set_x, pos4, ":scale_value_inverse"),
        (try_end),
        (try_begin),
          (this_or_next|eq, ":orientation", 2),
          (eq, ":orientation", 3),
          (position_set_y, pos4, ":scale_value_inverse"),
        (try_end),
        (val_mod, reg3, 256), #remove orientation flags

        (cur_tableau_add_mesh_with_scale_and_vertex_color, reg3, pos1, pos4, 0, reg5),
      (try_end),
      (try_begin),
        (ge, ":num_charges", 3),
        (val_mul, reg7, ":charge_stretch"),
        (val_div, reg7, 10000),
        (position_get_x, ":x", pos2),
        (position_get_y, ":y", pos2),
        (val_mul, ":x", ":stretch_width"),
        (val_mul, ":y", ":stretch_height"),
        (val_div, ":x", 10000),
        (val_div, ":y", 10000),
        (val_add, ":x", ":center_pos_x"),
        (val_add, ":y", ":center_pos_y"),
        (position_set_x, pos2, ":x"),
        (position_set_y, pos2, ":y"),

        (assign, ":scale_value", reg7),
        (convert_to_fixed_point, ":scale_value"),
        (store_mul, ":scale_value_inverse", ":scale_value", -1),
        (init_position, pos4),
        (position_set_x, pos4, ":scale_value"),
        (position_set_y, pos4, ":scale_value"),
        (position_set_z, pos4, ":scale_value"),
        (store_div, ":orientation", reg6, 256), #orientation flags
        (try_begin),
          (this_or_next|eq, ":orientation", 1),
          (eq, ":orientation", 3),
          (position_set_x, pos4, ":scale_value_inverse"),
        (try_end),
        (try_begin),
          (this_or_next|eq, ":orientation", 2),
          (eq, ":orientation", 3),
          (position_set_y, pos4, ":scale_value_inverse"),
        (try_end),
        (val_mod, reg6, 256), #remove orientation flags

        (cur_tableau_add_mesh_with_scale_and_vertex_color, reg6, pos2, pos4, 0, reg8),
      (try_end),
      (try_begin),
        (ge, ":num_charges", 4),
        (val_mul, reg10, ":charge_stretch"),
        (val_div, reg10, 10000),
        (position_get_x, ":x", pos3),
        (position_get_y, ":y", pos3),
        (val_mul, ":x", ":stretch_width"),
        (val_mul, ":y", ":stretch_height"),
        (val_div, ":x", 10000),
        (val_div, ":y", 10000),
        (val_add, ":x", ":center_pos_x"),
        (val_add, ":y", ":center_pos_y"),
        (position_set_x, pos3, ":x"),
        (position_set_y, pos3, ":y"),

        (assign, ":scale_value", reg10),
        (convert_to_fixed_point, ":scale_value"),
        (store_mul, ":scale_value_inverse", ":scale_value", -1),
        (init_position, pos4),
        (position_set_x, pos4, ":scale_value"),
        (position_set_y, pos4, ":scale_value"),
        (position_set_z, pos4, ":scale_value"),
        (store_div, ":orientation", reg9, 256), #orientation flags
        (try_begin),
          (this_or_next|eq, ":orientation", 1),
          (eq, ":orientation", 3),
          (position_set_x, pos4, ":scale_value_inverse"),
        (try_end),
        (try_begin),
          (this_or_next|eq, ":orientation", 2),
          (eq, ":orientation", 3),
          (position_set_y, pos4, ":scale_value_inverse"),
        (try_end),
        (val_mod, reg9, 256), #remove orientation flags

        (cur_tableau_add_mesh_with_scale_and_vertex_color, reg9, pos3, pos4, 0, reg11),
      (try_end),
     ]),

  # script_get_troop_custom_banner_num_positionings
  # Input: arg1 = troop_no
  # Output: reg0 = num_positionings
  ("get_troop_custom_banner_num_positionings",
    [
      (store_script_param, ":troop_no", 1),
      (troop_get_slot, ":num_charges", ":troop_no", "slot_troop_custom_banner_num_charges"),
      (try_begin),
        (eq, ":num_charges", 1),
        (assign, ":num_positionings", 2),
      (else_try),
        (eq, ":num_charges", 2),
        (assign, ":num_positionings", 4),
      (else_try),
        (eq, ":num_charges", 3),
        (assign, ":num_positionings", 6),
      (else_try),
        (assign, ":num_positionings", 2),
      (try_end),
      (assign, reg0, ":num_positionings"),
     ]),

  # script_get_custom_banner_charge_type_position_scale_color
  # Input: arg1 = troop_no, arg2 = positioning_index
  # Output: reg0 = type_1
  #         reg1 = scale_1
  #         reg2 = color_1
  #         reg3 = type_2
  #         reg4 = scale_2
  #         reg5 = color_2
  #         reg6 = type_3
  #         reg7 = scale_3
  #         reg8 = color_3
  #         reg9 = type_4
  #         reg10 = scale_4
  #         reg11 = color_4
  ("get_custom_banner_charge_type_position_scale_color",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":positioning", 2),
      (troop_get_slot, ":num_charges", ":troop_no", "slot_troop_custom_banner_num_charges"),
      (init_position, pos0),
      (init_position, pos1),
      (init_position, pos2),
      (init_position, pos3),

      (troop_get_slot, reg0, ":troop_no", "slot_troop_custom_banner_charge_type_1"),
      (val_add, reg0, custom_banner_charges_begin),
      (troop_get_slot, reg2, ":troop_no", "slot_troop_custom_banner_charge_color_1"),
      (troop_get_slot, reg3, ":troop_no", "slot_troop_custom_banner_charge_type_2"),
      (val_add, reg3, custom_banner_charges_begin),
      (troop_get_slot, reg5, ":troop_no", "slot_troop_custom_banner_charge_color_2"),
      (troop_get_slot, reg6, ":troop_no", "slot_troop_custom_banner_charge_type_3"),
      (val_add, reg6, custom_banner_charges_begin),
      (troop_get_slot, reg8, ":troop_no", "slot_troop_custom_banner_charge_color_3"),
      (troop_get_slot, reg9, ":troop_no", "slot_troop_custom_banner_charge_type_4"),
      (val_add, reg9, custom_banner_charges_begin),
      (troop_get_slot, reg11, ":troop_no", "slot_troop_custom_banner_charge_color_4"),

      (try_begin),
        (eq, ":num_charges", 1),
        (try_begin),
          (eq, ":positioning", 0),
          (assign, reg1, 100),
        (else_try),
          (assign, reg1, 50),
        (try_end),
      (else_try),
        (eq, ":num_charges", 2),
        (try_begin),
          (eq, ":positioning", 0),
          (position_set_y, pos0, 25),
          (position_set_y, pos1, -25),
          (assign, reg1, 40),
          (assign, reg4, 40),
        (else_try),
          (eq, ":positioning", 1),
          (position_set_x, pos0, -25),
          (position_set_x, pos1, 25),
          (assign, reg1, 40),
          (assign, reg4, 40),
        (else_try),
          (eq, ":positioning", 2),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, 25),
          (position_set_x, pos1, 25),
          (position_set_y, pos1, -25),
          (assign, reg1, 50),
          (assign, reg4, 50),
        (else_try),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, -25),
          (position_set_x, pos1, 25),
          (position_set_y, pos1, 25),
          (assign, reg1, 50),
          (assign, reg4, 50),
        (try_end),
      (else_try),
        (eq, ":num_charges", 3),
        (try_begin),
          (eq, ":positioning", 0),
          (position_set_y, pos0, 33),
          (position_set_y, pos2, -33),
          (assign, reg1, 30),
          (assign, reg4, 30),
          (assign, reg7, 30),
        (else_try),
          (eq, ":positioning", 1),
          (position_set_x, pos0, -33),
          (position_set_x, pos2, 33),
          (assign, reg1, 30),
          (assign, reg4, 30),
          (assign, reg7, 30),
        (else_try),
          (eq, ":positioning", 2),
          (position_set_x, pos0, -30),
          (position_set_y, pos0, 30),
          (position_set_x, pos2, 30),
          (position_set_y, pos2, -30),
          (assign, reg1, 35),
          (assign, reg4, 35),
          (assign, reg7, 35),
        (else_try),
          (eq, ":positioning", 3),
          (position_set_x, pos0, -30),
          (position_set_y, pos0, -30),
          (position_set_x, pos2, 30),
          (position_set_y, pos2, 30),
          (assign, reg1, 35),
          (assign, reg4, 35),
          (assign, reg7, 35),
        (else_try),
          (eq, ":positioning", 4),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, -25),
          (position_set_y, pos1, 25),
          (position_set_x, pos2, 25),
          (position_set_y, pos2, -25),
          (assign, reg1, 50),
          (assign, reg4, 50),
          (assign, reg7, 50),
        (else_try),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, 25),
          (position_set_y, pos1, -25),
          (position_set_x, pos2, 25),
          (position_set_y, pos2, 25),
          (assign, reg1, 50),
          (assign, reg4, 50),
          (assign, reg7, 50),
        (try_end),
      (else_try),
        (try_begin),
          (eq, ":positioning", 0),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, 25),
          (position_set_x, pos1, 25),
          (position_set_y, pos1, 25),
          (position_set_x, pos2, -25),
          (position_set_y, pos2, -25),
          (position_set_x, pos3, 25),
          (position_set_y, pos3, -25),
          (assign, reg1, 50),
          (assign, reg4, 50),
          (assign, reg7, 50),
          (assign, reg10, 50),
        (else_try),
          (position_set_y, pos0, 30),
          (position_set_x, pos1, -30),
          (position_set_x, pos2, 30),
          (position_set_y, pos3, -30),
          (assign, reg1, 35),
          (assign, reg4, 35),
          (assign, reg7, 35),
          (assign, reg10, 35),
        (try_end),
      (try_end),
     ]),

  # script_get_random_custom_banner
  # Input: arg1 = troop_no
  # Output: none
  ("get_random_custom_banner",
    [
      (store_script_param, ":troop_no", 1),
      (store_random_in_range, ":num_charges", 1, 5),
      (troop_set_slot, ":troop_no", "slot_troop_custom_banner_num_charges", ":num_charges"),
      (store_random_in_range, ":random_color_index", 0, 42),
      (call_script, "script_get_custom_banner_color_from_index", ":random_color_index"),
      (assign, ":color_1", reg0),
      (troop_set_slot, ":troop_no", "slot_troop_custom_banner_bg_color_1", ":color_1"),
      (assign, ":end_cond", 1),
      (try_for_range, ":unused", 0, ":end_cond"),
        (store_random_in_range, ":random_color_index", 0, 42),
        (call_script, "script_get_custom_banner_color_from_index", ":random_color_index"),
        (assign, ":color_2", reg0),
        (try_begin),
          (call_script, "script_cf_check_color_visibility", ":color_1", ":color_2"),
          (troop_set_slot, ":troop_no", "slot_troop_custom_banner_bg_color_2", ":color_2"),
        (else_try),
          (val_add, ":end_cond", 1),
        (try_end),
      (try_end),
      (assign, ":end_cond", 4),
      (assign, ":cur_charge", 0),
      (try_for_range, ":unused", 0, ":end_cond"),
        (store_random_in_range, ":random_color_index", 0, 42),
        (call_script, "script_get_custom_banner_color_from_index", ":random_color_index"),
        (assign, ":charge_color", reg0),
        (try_begin),
          (call_script, "script_cf_check_color_visibility", ":charge_color", ":color_1"),
          (call_script, "script_cf_check_color_visibility", ":charge_color", ":color_2"),
          (store_add, ":cur_slot", ":cur_charge", "slot_troop_custom_banner_charge_color_1"),
          (troop_set_slot, ":troop_no", ":cur_slot", ":charge_color"),
          (store_random_in_range, ":random_charge", custom_banner_charges_begin, custom_banner_charges_end),
          (val_sub, ":random_charge", custom_banner_charges_begin),
          (store_add, ":cur_slot", ":cur_charge", "slot_troop_custom_banner_charge_type_1"),
          (troop_set_slot, ":troop_no", ":cur_slot", ":random_charge"),
          (val_add, ":cur_charge", 1),
        (else_try),
          (val_add, ":end_cond", 1),
        (try_end),
      (try_end),
      (store_random_in_range, ":random_bg", custom_banner_backgrounds_begin, custom_banner_backgrounds_end),
      (val_sub, ":random_bg", custom_banner_backgrounds_begin),
      (troop_set_slot, ":troop_no", "slot_troop_custom_banner_bg_type", ":random_bg"),
      (store_random_in_range, ":random_flag", custom_banner_flag_types_begin, custom_banner_flag_types_end),
      (val_sub, ":random_flag", custom_banner_flag_types_begin),
      (troop_set_slot, ":troop_no", "slot_troop_custom_banner_flag_type", ":random_flag"),
      (store_random_in_range, ":random_positioning", 0, 4),
      (troop_set_slot, ":troop_no", "slot_troop_custom_banner_positioning", ":random_positioning"),
     ]),

  # script_get_custom_banner_color_from_index
  # Input: arg1 = color_index
  # Output: reg0 = color
  ("get_custom_banner_color_from_index",
    [
      (store_script_param, ":color_index", 1),

      (assign, ":cur_color", 0xFF000000),
      (assign, ":red", 0x00),
      (assign, ":green", 0x00),
      (assign, ":blue", 0x00),
      (store_mod, ":mod_i_color", ":color_index", 7),
      (try_begin),
        (eq, ":mod_i_color", 0),
        (assign, ":blue", 0xFF),
      (else_try),
        (eq, ":mod_i_color", 1),
        (assign, ":red", 0xEE),
      (else_try),
        (eq, ":mod_i_color", 2),
        (assign, ":red", 0xFB),
        (assign, ":green", 0xAC),
      (else_try),
        (eq, ":mod_i_color", 3),
        (assign, ":red", 0x5F),
        (assign, ":blue", 0xFF),
      (else_try),
        (eq, ":mod_i_color", 4),
        (assign, ":red", 0x05),
        (assign, ":green", 0x44),
      (else_try),
        (eq, ":mod_i_color", 5),
        (assign, ":red", 0xEE),
        (assign, ":green", 0xEE),
        (assign, ":blue", 0xEE),
      (else_try),
        (assign, ":red", 0x22),
        (assign, ":green", 0x22),
        (assign, ":blue", 0x22),
      (try_end),
      (store_div, ":cur_tone", ":color_index", 7),
      (store_sub, ":cur_tone", 8, ":cur_tone"),
      (val_mul, ":red", ":cur_tone"),
      (val_div, ":red", 8),
      (val_mul, ":green", ":cur_tone"),
      (val_div, ":green", 8),
      (val_mul, ":blue", ":cur_tone"),
      (val_div, ":blue", 8),
      (val_mul, ":green", 0x100),
      (val_mul, ":red", 0x10000),
      (val_add, ":cur_color", ":blue"),
      (val_add, ":cur_color", ":green"),
      (val_add, ":cur_color", ":red"),
      (assign, reg0, ":cur_color"),
     ]),

  # script_cf_check_color_visibility
  # Input: arg1 = color_1, arg2 = color_2
  # Output: none
  ("cf_check_color_visibility",
    [
      (store_script_param, ":color_1", 1),
      (store_script_param, ":color_2", 2),
      (store_mod, ":blue_1", ":color_1", 256),
      (store_div, ":green_1", ":color_1", 256),
      (val_mod, ":green_1", 256),
      (store_div, ":red_1", ":color_1", 256 * 256),
      (val_mod, ":red_1", 256),
      (store_mod, ":blue_2", ":color_2", 256),
      (store_div, ":green_2", ":color_2", 256),
      (val_mod, ":green_2", 256),
      (store_div, ":red_2", ":color_2", 256 * 256),
      (val_mod, ":red_2", 256),
      (store_sub, ":red_dif", ":red_1", ":red_2"),
      (val_abs, ":red_dif"),
      (store_sub, ":green_dif", ":green_1", ":green_2"),
      (val_abs, ":green_dif"),
      (store_sub, ":blue_dif", ":blue_1", ":blue_2"),
      (val_abs, ":blue_dif"),
      (assign, ":max_dif", 0),
      (val_max, ":max_dif", ":red_dif"),
      (val_max, ":max_dif", ":green_dif"),
      (val_max, ":max_dif", ":blue_dif"),
      (ge, ":max_dif", 64),
     ]),
  
  # script_get_next_active_kingdom
  # Input: arg1 = faction_no
  # Output: reg0 = faction_no (does not choose player faction)
  ("get_next_active_kingdom",
    [
      (store_script_param, ":faction_no", 1),
      (assign, ":end_cond", kingdoms_end),
      (try_for_range, ":unused", kingdoms_begin, ":end_cond"),
        (val_add, ":faction_no", 1),
        (try_begin),
          (ge, ":faction_no", kingdoms_end),
          (assign, ":faction_no", kingdoms_begin),
        (try_end),
        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (assign, ":end_cond", 0),
      (try_end),
      (assign, reg0, ":faction_no"),
     ]),

#  # script_store_average_center_value_per_faction
#  # Input: none
#  # Output: none (sets $g_average_center_value_per_faction)
#  ("store_average_center_value_per_faction",
#    [
#      (store_sub, ":num_towns", towns_end, towns_begin),
#      (store_sub, ":num_castles", castles_end, castles_begin),
#      (assign, ":num_factions", 0),
#      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
#        (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),
#        (val_add, ":num_factions", 1),
#      (try_end),
#      (val_max, ":num_factions", 1),
#      (store_mul, "$g_average_center_value_per_faction", ":num_towns", 2),
#      (val_add, "$g_average_center_value_per_faction", ":num_castles"),
#      (val_mul, "$g_average_center_value_per_faction", 10),
#      (val_div, "$g_average_center_value_per_faction", ":num_factions"),
#     ]),

  # script_remove_cattles_if_herd_is_close_to_party
  # Input: arg1 = party_no, arg2 = maximum_number_of_cattles_required
  # Output: reg0 = number_of_cattles_removed
  ("remove_cattles_if_herd_is_close_to_party",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":max_req", 2),
      (assign, ":cur_req", ":max_req"),
      (try_for_parties, ":cur_party"),
        (gt, ":cur_req", 0),
        (party_slot_eq, ":cur_party", "slot_party_type", spt_cattle_herd1),
        (store_distance_to_party_from_party, ":dist", ":cur_party", ":party_no"),
        (lt, ":dist", 3),
		
        #Do not use the quest herd for "move cattle herd"
        (assign, ":subcontinue", 1),
        (try_begin),
          (check_quest_active, "qst_move_cattle_herd1"),
          (quest_slot_eq, "qst_move_cattle_herd1", "slot_quest_target_party", ":cur_party"),
          (assign, ":subcontinue", 0),
        (try_end),
        (eq, ":subcontinue", 1),
        #Do not use the quest herd for "move cattle herd" ends
		
        (party_count_companions_of_type, ":num_cattle", ":cur_party", "trp_cattle"),
        (try_begin),
          (le, ":num_cattle", ":cur_req"),
          (assign, ":num_added", ":num_cattle"),
          (remove_party, ":cur_party"),
        (else_try),
          (assign, ":num_added", ":cur_req"),
          (party_remove_members, ":cur_party", "trp_cattle", ":cur_req"),
        (try_end),
        (val_sub, ":cur_req", ":num_added"),
		
		
        (try_begin),
          (party_slot_eq, ":party_no", "slot_party_type", spt_village),
          (party_get_slot, ":village_cattle_amount", ":party_no", "slot_village_number_of_cattle"),
          (val_add, ":village_cattle_amount", ":num_added"),
          (party_set_slot, ":party_no", "slot_village_number_of_cattle", ":village_cattle_amount"),
        (try_end),
		
        (assign, reg3, ":num_added"),
        (str_store_party_name_link, s1, ":party_no"),
        (display_message, "@You brought {reg3} heads of cattle to {s1}."),
		(try_begin),
			(gt, "$cheat_mode", 0),
			(assign, reg4, ":village_cattle_amount"),
			(display_message, "@{!}Village now has {reg4}"),
		(try_end),
      (try_end),
      (store_sub, reg0, ":max_req", ":cur_req"),
     ]),  

  # script_get_rumor_to_s61
  # Input: rumor_id
  # Output: reg0 = 1 if rumor found, 0 otherwise; s61 will contain rumor string if found
  ("get_rumor_to_s61",
    [
     (store_script_param, ":base_rumor_id", 1), # the script returns the same rumor for the same rumor id, so that one cannot hear all rumors by
                                                # speaking to a single person.

     (store_current_hours, ":cur_hours"),
     (store_div, ":cur_day", ":cur_hours", 24),
     (assign, ":rumor_found", 0),
     (assign, ":num_tries", 3),
     (try_for_range, ":try_no", 0, ":num_tries"),
       (store_mul, ":rumor_id", ":try_no", 6781),
       (val_add, ":rumor_id", ":base_rumor_id"),
       (store_mod, ":rumor_type", ":rumor_id", 16), #chief anade rumores
       (val_add, ":rumor_id", ":cur_hours"),
       (try_begin),
         (eq,  ":rumor_type", 0),
         (try_begin),
           # todo: this is tournament-related. Make it part of the respective pkg.
           # this can be achieved by making a list of rumors (instead of hard-code
           # their numbers to each case.
           (store_sub, ":range", towns_end, towns_begin),
           (store_mod, ":random_center", ":rumor_id", ":range"),
           (val_add, ":random_center", towns_begin),
           (party_slot_ge, ":random_center", "slot_town_has_tournament", 1),
           (neq, ":random_center", "$current_town"),
           (str_store_party_name, s62, ":random_center"),
           (str_store_string, s61, "@I heard that there will be a tournament in {s62} soon."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 1),
         (try_begin),
           (store_sub, ":range", active_npcs_end, original_kingdom_heroes_begin), #was reversed
           (store_mod, ":random_hero", ":rumor_id", ":range"),
           (val_add, ":random_hero", original_kingdom_heroes_begin),
		   (is_between, ":random_hero", active_npcs_begin, active_npcs_end),
           (troop_get_slot, ":personality", ":random_hero", "slot_lord_reputation_type"),
           (gt, ":personality", 0),
           (store_add, ":rumor_string", ":personality", "str_gossip_about_character_default"),
           (str_store_troop_name, s6, ":random_hero"),
           (str_store_string, s61, ":rumor_string"),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 2),
         (try_begin),
           (store_sub, ":range", trade_goods_end, trade_goods_begin),
           (store_add, ":random_trade_good", ":rumor_id", ":cur_day"),
           (store_mod, ":random_trade_good", ":random_trade_good", ":range"),
           (store_add, ":random_trade_good_slot", ":random_trade_good", "slot_town_trade_good_prices_begin"),
           (val_add, ":random_trade_good", trade_goods_begin),
           (store_mul, ":min_price", average_price_factor, 3),
           (val_div, ":min_price", 4),
           (assign, ":min_price_center", -1),
           (try_for_range, ":sub_try_no", 0, 10),
             (store_sub, ":range", towns_end, towns_begin),
             (store_add, ":center_rumor_id", ":rumor_id", ":sub_try_no"),
             (store_mod, ":random_center", ":center_rumor_id", ":range"),
             (val_add, ":random_center", towns_begin),
             (neq, ":random_center", "$g_encountered_party"),
             (party_get_slot, ":cur_price", ":random_center", ":random_trade_good_slot"),
             (lt, ":cur_price", ":min_price"),
             (assign, ":min_price", ":cur_price"),
             (assign, ":min_price_center", ":random_center"),
           (try_end),
           (ge, ":min_price_center", 0),
           (str_store_item_name, s62, ":random_trade_good"),
           (str_store_party_name, s63, ":min_price_center"),
           (str_store_string, s61, "@I heard that one can buy {s62} very cheap at {s63}."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 3),
         (try_begin),
           (store_sub, ":range", trade_goods_end, trade_goods_begin),
           (store_add, ":random_trade_good", ":rumor_id", ":cur_day"),
           (store_mod, ":random_trade_good", ":random_trade_good", ":range"),
           (store_add, ":random_trade_good_slot", ":random_trade_good", "slot_town_trade_good_prices_begin"),
           (val_add, ":random_trade_good", trade_goods_begin),
           (store_mul, ":max_price", average_price_factor, 5),
           (val_div, ":max_price", 4),
           (assign, ":max_price_center", -1),
           (try_for_range, ":sub_try_no", 0, 10),
             (store_sub, ":range", towns_end, towns_begin),
             (store_add, ":center_rumor_id", ":rumor_id", ":sub_try_no"),
             (store_mod, ":random_center", ":center_rumor_id", ":range"),
             (val_add, ":random_center", towns_begin),
             (neq, ":random_center", "$g_encountered_party"),
             (party_get_slot, ":cur_price", ":random_center", ":random_trade_good_slot"),
             (gt, ":cur_price", ":max_price"),
             (assign, ":max_price", ":cur_price"),
             (assign, ":max_price_center", ":random_center"),
           (try_end),
           (ge, ":max_price_center", 0),
           (str_store_item_name, s62, ":random_trade_good"),
           (str_store_party_name, s63, ":max_price_center"),
           (str_store_string, s61, "@I heard that they pay a very high price for {s62} at {s63}."),
           (assign, ":rumor_found", 1),
         (try_end),
       (try_end),
#chief rumores
            (else_try),
         (eq,  ":rumor_type", 4),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@I heard Brytenwalda Oswald, son of Aethelfrith of Bernacia, came to rule after spending a period in exile with Dal Riata."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 5),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@A few years ago, King Cadwallon of Gwynedd and King Penda of Mierce invaded Nordhymbralond and penetrated deep into the heart of the old kingdom of Deira. Here King Eadwine has amassed his warriors, and he rides south to meet them in battle. The two armies meet at Haedfeldland and engage one another in the bloodiest and most brutal battle of the century."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 6),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@I have heard the Pope of Rome sent missionaries to convert the Germanic Saxons!!."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 7),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@Penda, son of Pybba, is king of the Angles, and he is said to be a descendant of Icel, with a lineage purportedly extending back to Woden."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 8),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@Cadwallon ap Cadfan was the Great King of Gwynedd until his death in battle. The son and successor of Cadfan ap Iago, he is best remembered as the King of the Britons who invaded and conquered Bernacia and Deira, defeating and killing its king, Eadwine, prior to his own death in battle against Oswald of Bernacia, who is Brytenwalda actually."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 9),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@I hate bandits, somebody should kill them all."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 10),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@I would like to know about the Roman times."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 11),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@Many of the nobles of Britannia are very impressed by young princess Hild. She is so beautiful. Too bad she has religious leanings!"),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 12),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@A traveller told me the Franks are recruiting men for attacking the Visigoths."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 13),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@The Frisians have brought all kinds of strange people with them. It's like the whole world has come to Britannia."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 14),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@Conquest of Hwicce Kingdom has been the dream of many Gewissae kings ever since they lost it to the warriors of Mierce."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 15),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@I wish the world was less dangerous. Few men grow old."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 16),
         (try_begin),
           (store_random_in_range, ":rand", 0, 100),
           (lt, ":rand", rumor_found_chance),
           (str_store_string, s61, "@I've been told the Ui Neill army maintains strict discipline and training, for that reason they are the most powerful in Hibernia!"),
           (assign, ":rumor_found", 1),
         (try_end),
     ###chief rumores acaba

       (try_begin),
         (gt, ":rumor_found", 0),
         (assign, ":num_tries", 0),
       (try_end),
     (try_end),
     (assign, reg0, ":rumor_found"),
     ]),

  ("lord_comment_to_s43",
    [(store_script_param, ":lord", 1),
     (store_script_param, ":default_string", 2),

    (troop_get_slot,":reputation", ":lord", "slot_lord_reputation_type"),

	(try_begin),
		#some default strings will have added comments for the added commons reputation types
		(try_begin),
			(eq, ":reputation", lrep_roguish),
			(assign, ":reputation", lrep_goodnatured),
		(else_try),	
			(eq, ":reputation", lrep_custodian),
			(assign, ":reputation", lrep_cunning),
		(else_try),	
			(eq, ":reputation", lrep_benefactor),
			(assign, ":reputation", lrep_goodnatured),
		(try_end),	
	(try_end),

    (store_add, ":result", ":reputation", ":default_string"),

    (str_store_string, 43, ":result"),
	(assign, reg0, ":result"),
	
	
	]),
  
#Troop Commentaries begin
  
  # script_add_log_entry
  # Input: arg1 = entry_type, arg2 = event_actor, arg3 = center_object, arg4 = troop_object, arg5 = faction_object
  # Output: none
  ("add_log_entry",
    [(store_script_param, ":entry_type", 1),
     (store_script_param, ":actor", 2),
     (store_script_param, ":center_object", 3),
     (store_script_param, ":troop_object", 4),
     (store_script_param, ":faction_object", 5),
     (assign, ":center_object_lord", -1),
     (assign, ":center_object_faction", -1),
     (assign, ":troop_object_faction", -1),
     
     (try_begin),
       (party_is_active, ":center_object", 0),
       (party_get_slot, ":center_object_lord", ":center_object", "slot_town_lord"),
       (store_faction_of_party, ":center_object_faction", ":center_object"),
	 (else_try),
	   (assign, ":center_object_lord", 0),	 
       (assign, ":center_object_faction", 0),	 
     (try_end),
     
     (try_begin),
       (is_between, ":troop_object", 0, "trp_local_merchant"),
       (store_troop_faction, ":troop_object_faction", ":troop_object"),
	 (else_try),
	   (assign, ":troop_object_faction", 0),
     (try_end),

     (val_add, "$num_log_entries", 1),
     
     (store_current_hours, ":entry_time"),
     (troop_set_slot, "trp_log_array_entry_type",            "$num_log_entries", ":entry_type"),
     (troop_set_slot, "trp_log_array_entry_time",            "$num_log_entries", ":entry_time"),
     (troop_set_slot, "trp_log_array_actor",                 "$num_log_entries", ":actor"),
     (troop_set_slot, "trp_log_array_center_object",         "$num_log_entries", ":center_object"),
     (troop_set_slot, "trp_log_array_center_object_lord",    "$num_log_entries", ":center_object_lord"),
     (troop_set_slot, "trp_log_array_center_object_faction", "$num_log_entries", ":center_object_faction"),
     (troop_set_slot, "trp_log_array_troop_object",          "$num_log_entries", ":troop_object"),
     (troop_set_slot, "trp_log_array_troop_object_faction",  "$num_log_entries", ":troop_object_faction"),
     (troop_set_slot, "trp_log_array_faction_object",        "$num_log_entries", ":faction_object"),

     (try_begin),
       (eq, "$cheat_mode", 1),
       (assign, reg3, "$num_log_entries"), 
       (assign, reg4, ":entry_type"),
       (display_message, "@{!}Log entry {reg3}: type {reg4}"), 
       (try_begin),
          (gt, ":center_object", 0),
		  (neq, ":entry_type", logent_traveller_attacked),
		  (neq, ":entry_type", logent_party_traded),
		  (party_is_active, ":center_object"), #sometimes is a troop
		  
          (str_store_party_name, s4, ":center_object"),
          (display_message, "@{!}Center: {s4}"), 
       (try_end),      
       (try_begin),
          (gt, ":troop_object", 0),
		  (neq, ":entry_type", logent_traveller_attacked),
		  (neq, ":entry_type", logent_party_traded),
		  
		  (str_store_troop_name, s4, ":troop_object"),
		  (display_message, "@{!}Troop: {s4}"), 
       (try_end),      
       (try_begin),
          (gt, ":center_object_lord", 0),
		  (neq, ":entry_type", logent_traveller_attacked),
		  (neq, ":entry_type", logent_party_traded),
		  
		  (str_store_troop_name, s4, ":center_object_lord"),
          (display_message, "@{!}Lord: {s4}"), 
       (try_end),
     (try_end),


     (try_begin),
	   (this_or_next|eq, ":entry_type", logent_lord_defeated_by_player),
       (this_or_next|eq, ":entry_type", logent_player_participated_in_major_battle),
		(eq, ":entry_type", logent_player_participated_in_siege),
		
       (try_begin),
         (eq, "$cheat_mode", 1),
         (display_message, "@{!}Ally party is present"),
       (try_end),
       (try_for_range, ":hero", active_npcs_begin, active_npcs_end),
         (party_count_companions_of_type, ":hero_present", "p_collective_friends", ":hero"),
         (gt, ":hero_present", 0),
         (troop_set_slot, ":hero", "slot_troop_present_at_event", "$num_log_entries"),
#         (store_sub, ":skip_up_to_here", "$num_log_entries", 1),
#         (troop_set_slot, ":hero", "slot_troop_last_comment_slot", ":skip_up_to_here"),
         (try_begin),
           (eq, "$cheat_mode", 1),
           (str_store_troop_name, s4, ":hero"),
           (display_message, "@{!}{s4} is present at event"),
         (try_end),
       (try_end),
     (try_end),
     ]),

  
  # script_get_relevant_comment_for_log_entry
  # Input: arg1 = log_entry_no, 
  # Output: reg0 = comment_id; reg1 = relevance
  # Notes: 50 is the default relevance.
  # A comment with relevance less than 30 will always be skipped.
  # A comment with relevance 75 or more will never be skipped.
  # A comment with relevance 50 has about 50% chance to be skipped.
  # If there is more than one comment that is not skipped, the system will randomize their relevance values, and then choose the highest one.
  # Also note that the relevance of events decreases as time passes. After three months, relevance reduces to 50%, after 6 months, 25%, etc...
  ("get_relevant_comment_for_log_entry",
    [(store_script_param, ":log_entry_no", 1),
     
     (troop_get_slot, ":entry_type",            "trp_log_array_entry_type",            ":log_entry_no"),
     (troop_get_slot, ":entry_time",            "trp_log_array_entry_time",            ":log_entry_no"),
     (troop_get_slot, ":actor",                 "trp_log_array_actor",                 ":log_entry_no"),
     (troop_get_slot, ":center_object",         "trp_log_array_center_object",         ":log_entry_no"),
     (troop_get_slot, ":center_object_lord",    "trp_log_array_center_object_lord",    ":log_entry_no"),
     (troop_get_slot, ":center_object_faction", "trp_log_array_center_object_faction", ":log_entry_no"),
     (troop_get_slot, ":troop_object",          "trp_log_array_troop_object",          ":log_entry_no"),
     (troop_get_slot, ":troop_object_faction",  "trp_log_array_troop_object_faction",  ":log_entry_no"),
	 #MOTO chief faction -1 fix
	 #I can't figure out why this is happening, but it is
	 #The ONLY way this can happen is if troop_get_faction in script_add_log_entry is somehow handed a factionless troop
	 (val_max, ":troop_object_faction", 0),
	 #MOTO end faction -1 fix
     (troop_get_slot, ":faction_object",        "trp_log_array_faction_object",        ":log_entry_no"),

     (assign, ":relevance", 0),
     (assign, ":comment", -1), 
     (assign, ":rejoinder", -1), 
     (assign, ":suggested_relation_change", 0),

     (troop_get_slot, ":reputation", "$g_talk_troop", "slot_lord_reputation_type"),
     (store_current_hours, ":current_time"),
     (store_sub, ":entry_hours_elapsed", ":current_time", ":entry_time"),

#Post 0907 changes begin
     (assign, ":players_kingdom_relation", 0), ##the below is so that lords will not congratulate player on attacking neutrals
	 (try_begin),
        (gt, "$players_kingdom", 0),
		(store_relation, ":players_kingdom_relation", "$players_kingdom", ":troop_object_faction"),
	 (try_end),
	 
     (try_begin),
       (eq, "$cheat_mode", -1), #temporarily disabled
       (try_begin),
         (assign, reg5, ":log_entry_no"),
         (assign, reg6, ":entry_type"),
         (assign, reg8, ":entry_time"),

         (gt, "$players_kingdom", 0),
         (try_begin),
            (gt, ":troop_object_faction", 0),
            (assign, reg7, ":players_kingdom_relation"),
            (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}: player's kingdom relation to troop object = {reg7}"),
         (else_try),
            (gt, ":center_object_faction", 0),
            (assign, reg7, ":players_kingdom_relation"),
            (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}: player's kingdom relation to center object faction = {reg7}"),
         (else_try),
            (gt, ":faction_object", 0),
            (assign, reg7, ":players_kingdom_relation"),
            (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}: player's kingdom relation to faction object = {reg7}"),
         (else_try),
            (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}. No relevant kingdom relation"),
         (try_end),
       (else_try),
         (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}. Player unaffiliated"),
       (try_end),
     (try_end),

     (try_begin),
       (eq, ":entry_type", logent_game_start),
       (eq, "$g_talk_troop_met", 0),
       (is_between, "$g_talk_troop_faction_relation", -5, 5),
       (is_between, "$g_talk_troop_relation", -5, 5),

       (assign, ":relevance", 25),
       (troop_get_slot, ":plyr_renown", "trp_player", "slot_troop_renown"),
#normal_banner_begin
       (troop_get_slot, ":banner", "trp_player", "slot_troop_banner_scene_prop"),
#custom_banner_begin
#       (troop_get_slot, ":banner", "trp_player", "slot_troop_custom_banner_flag_type"),
       (store_random_in_range, ":renown_check", 100, 200),
       (try_begin),
          (eq, ":reputation", lrep_none),
          (gt, "$players_kingdom", 0),
          (assign, ":comment", "str_comment_intro_liege_affiliated"),
		  (try_begin),
			(faction_slot_eq, "$players_kingdom", "slot_faction_leader", "trp_player"),
			(assign, ":comment", "str_comment_intro_liege_affiliated_to_player"),
		  (try_end),
	   (else_try),
		  (eq, "$character_gender",tf_female),
		  
		  (call_script, "script_troop_get_romantic_chemistry_with_troop", "$g_talk_troop", "trp_player"),
		  (assign, ":attraction", reg0),
		  (store_random_in_range, ":random", 0, 2),
		  (this_or_next|eq, ":random", 0),
			  (gt, ":attraction", 10),
		  
		  (try_begin),
            (this_or_next|gt, ":plyr_renown", ":renown_check"), 
				(eq, "$g_disable_condescending_comments", 1),
            (assign, ":comment", "str_comment_intro_female_famous_liege"),
            (val_add, ":comment", ":reputation"),
		  (else_try),
		    (ge, ":attraction", 9),
			(assign, ":comment", "str_comment_intro_female_admiring_liege"),
			(val_add, ":comment", ":reputation"),
		  (else_try),	
            (gt, ":banner", 0), 
			(assign, ":comment", "str_comment_intro_female_noble_liege"),
			(val_add, ":comment", ":reputation"),
		  (else_try),
			(assign, ":comment", "str_comment_intro_female_common_liege"),
			(val_add, ":comment", ":reputation"),
		  (try_end),
		  
		  #Rejoinders for comments
		  (try_begin),
			(eq, ":comment", "str_comment_intro_female_common_badtempered"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_badtempered"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_noble_pitiless"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_noble_pitiless"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_common_pitiless"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_pitiless"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_noble_sadistic"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_noble_sadistic"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_common_sadistic"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_sadistic"),			
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_common_upstanding"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_upstanding"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_noble_upstanding"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_noble_upstanding"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_common_martial"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_martial"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_sadistic_admiring"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_sadistic_admiring"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_badtempered_admiring"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_badtempered_admiring"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_pitiless_admiring"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_pitiless_admiring"),
		  (try_end),
		  
	   (else_try),
		  #Male character or non-gendered comment
		  (try_begin),
			(gt, ":plyr_renown", ":renown_check"),
            (assign, ":comment", "str_comment_intro_famous_liege"),
            (val_add, ":comment", ":reputation"),
		  (else_try),	
            (gt, ":banner", 0), 
			(assign, ":comment", "str_comment_intro_noble_liege"),
			(val_add, ":comment", ":reputation"),
			
			(try_begin),
				(eq, ":comment", "str_comment_intro_noble_sadistic"),
				(assign, ":rejoinder", "str_rejoinder_intro_noble_sadistic"),
			(try_end),
			
          (else_try),
            (assign, ":comment", "str_comment_intro_common_liege"),
            (val_add, ":comment", ":reputation"),									
		  (try_end),
       (try_end),
#Post 0907 changes end

     (else_try),
       (eq, ":entry_type", logent_village_raided),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
         (assign, ":relevance", 200),
         (assign, ":suggested_relation_change", -1),
         (assign, ":comment", "str_comment_you_raided_my_village_default"),
         (try_begin),
            (lt, "$g_talk_troop_faction_relation", -5),
            (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_you_raided_my_village_enemy_benevolent"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -5),
            (this_or_next|eq, ":reputation", lrep_cunning),
                (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_you_raided_my_village_enemy_coldblooded"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_raided_my_village_enemy_spiteful"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -5),
            (assign, ":comment", "str_comment_you_raided_my_village_enemy"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_raided_my_village_unfriendly_spiteful"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (assign, ":comment", "str_comment_you_raided_my_village_friendly"),
         (try_end),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_village_extorted),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
         (assign, ":relevance", 30),
         (assign, ":suggested_relation_change", -1),
         (assign, ":comment", "str_comment_you_robbed_my_village_default"),
         (try_begin),
            (lt, "$g_talk_troop_faction_relation", -5),
            (this_or_next|eq, ":reputation", lrep_cunning),
                (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_you_robbed_my_village_enemy_coldblooded"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -5),
            (assign, ":comment", "str_comment_you_robbed_my_village_enemy"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_robbed_my_village_friendly_spiteful"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (assign, ":comment", "str_comment_you_robbed_my_village_friendly"),
         (try_end),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_caravan_accosted),
       (eq, ":actor", "trp_player"),
       (eq, ":faction_object", "$g_talk_troop_faction"),
	   (eq, ":center_object", -1),
	   (eq, ":troop_object", -1),
	   

	   
       (faction_slot_eq, "$g_talk_troop_faction", "slot_faction_leader", "$g_talk_troop"),
       (assign, ":relevance", 30),
       (assign, ":suggested_relation_change", -1),
       (assign, ":comment", "str_comment_you_accosted_my_caravan_default"),
       (try_begin),
            (lt, "$g_talk_troop_faction_relation", -5),
            (assign, ":comment", "str_comment_you_accosted_my_caravan_enemy"),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_helped_peasants),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
         (assign, ":relevance", 40),
         (assign, ":suggested_relation_change", 0),
         (try_begin),
            (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_you_helped_villagers_benevolent"),
            (assign, ":suggested_relation_change", 1),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_helped_villagers_friendly_cruel"),
            (assign, ":suggested_relation_change", -1),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_helped_villagers_unfriendly_spiteful"),
            (assign, ":suggested_relation_change", -1),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (assign, ":comment", "str_comment_you_helped_villagers_friendly"),
         (else_try),
            (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_helped_villagers_cruel"),
            (assign, ":suggested_relation_change", -1),
         (else_try),
             (assign, ":comment", "str_comment_you_helped_villagers_default"),
         (try_end),
       (try_end),

###Combat events
     (else_try),
       (eq, ":entry_type", logent_castle_captured_by_player),
       
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
		 (store_faction_of_party, ":current_center_faction", ":center_object"),
		 (eq, ":current_center_faction", "$players_kingdom"),
		 (neq, "$g_talk_troop_faction", "$players_kingdom"),
		 
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
			(eq, ":reputation", lrep_debauched),
		 
         (assign, ":comment", "str_comment_you_captured_my_castle_enemy_spiteful"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":center_object_lord", "$g_talk_troop"),
		 (store_faction_of_party, ":current_center_faction", ":center_object"),
		 (eq, ":current_center_faction", "$players_kingdom"),
		 (neq, "$g_talk_troop_faction", "$players_kingdom"),
		 
         (this_or_next|eq, ":reputation", lrep_martial),
			(eq, ":reputation", lrep_goodnatured),
			
         (assign, ":comment", "str_comment_you_captured_my_castle_enemy_chivalrous"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":center_object_lord", "$g_talk_troop"),
		 (store_faction_of_party, ":current_center_faction", ":center_object"),
		 (eq, ":current_center_faction", "$players_kingdom"),
		 (neq, "$g_talk_troop_faction", "$players_kingdom"),
		 
         (assign, ":comment", "str_comment_you_captured_my_castle_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
         (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied_spiteful"),
         (assign, ":relevance", 75),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (gt, "$g_talk_troop_relation", 5),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied_friendly"),
         (assign, ":relevance", 75),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
         (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied_unfriendly_spiteful"),
         (assign, ":relevance", 75),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied_unfriendly"),
         (assign, ":relevance", 75),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied"),
         (assign, ":relevance", 75),
       (try_end),
       
     (else_try),
       (eq, ":entry_type", logent_player_claims_throne_1),
       (eq, "$players_kingdom", "$g_talk_troop_faction"),
	   (faction_slot_eq, "$g_talk_troop_faction", "slot_faction_leader", "$g_talk_troop"),
       (assign, ":comment", "str_comment_you_claimed_the_throne_1_player_liege"),
       (assign, ":relevance", 500),
       (lt, "$g_talk_troop_relation", -10),
	   
     (else_try),
       (eq, ":entry_type", logent_player_claims_throne_2),
       (eq, "$players_kingdom", "$g_talk_troop_faction"),
	   (faction_slot_eq, "$g_talk_troop_faction", "slot_faction_leader", "$g_talk_troop"),
       (assign, ":comment", "str_comment_you_claimed_the_throne_2_player_liege"),
       (assign, ":relevance", 500),
       (lt, "$g_talk_troop_relation", -10),

     (else_try), #player appointed a commoner
       (eq, ":entry_type", logent_liege_grants_fief_to_vassal),
	   (eq, ":actor", "trp_player"),
	   (troop_slot_ge, ":troop_object", "slot_lord_reputation_type", lrep_roguish),
       (try_begin),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_you_enfiefed_a_commoner_nasty"),
           (assign, ":relevance", 100),
		   (assign, ":suggested_relation_change", -3),

       (else_try),
		   (eq, ":reputation", lrep_upstanding),
           (assign, ":comment", "str_comment_you_enfiefed_a_commoner_hesitant"),
           (assign, ":relevance", 100),
		   (assign, ":suggested_relation_change", -2),
		   
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
			   (eq, ":reputation", lrep_martial),
           (assign, ":comment", "str_comment_you_enfiefed_a_commoner_derisive"),
           (assign, ":relevance", 100),
		   (assign, ":suggested_relation_change", -4),
		   
       (try_end),
   	   	   
#Post 0907 changes begin
     (else_try),
       (this_or_next|eq, ":entry_type", logent_lord_defeated_by_player),
            (eq, ":entry_type", logent_lord_helped_by_player),
       (troop_slot_eq, "$g_talk_troop", "slot_troop_present_at_event", ":log_entry_no"),
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_we_defeated_a_lord_unfriendly_spiteful"),
           (assign, ":relevance", 150),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (assign, ":comment", "str_comment_we_defeated_a_lord_unfriendly"),
           (assign, ":relevance", 150),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_we_defeated_a_lord_cruel"),
           (assign, ":relevance", 150),
       (else_try),
           (eq, ":reputation", lrep_quarrelsome),        
           (assign, ":comment", "str_comment_we_defeated_a_lord_cruel"),
           (assign, ":relevance", 150),
       (else_try),
           (eq, ":reputation", lrep_upstanding),
           (assign, ":comment", "str_comment_we_defeated_a_lord_upstanding"),
           (assign, ":relevance", 150),
       (else_try),
           (assign, ":comment", "str_comment_we_defeated_a_lord_default"),
           (assign, ":relevance", 150),
       (try_end),

     (else_try),
       (this_or_next|eq, ":entry_type", logent_castle_captured_by_player),
       (eq, ":entry_type", logent_player_participated_in_siege),       
    
       (troop_slot_eq, "$g_talk_troop", "slot_troop_present_at_event", ":log_entry_no"),
       
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
           (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_we_fought_in_siege_unfriendly_spiteful"),
           (assign, ":relevance", 150),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (assign, ":comment", "str_comment_we_fought_in_siege_unfriendly"),
           (assign, ":relevance", 150),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
           (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_we_fought_in_siege_cruel"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),		   
       (else_try),
           (eq, ":reputation", lrep_quarrelsome),        
           (assign, ":comment", "str_comment_we_fought_in_siege_quarrelsome"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),		   
       (else_try),
           (eq, ":reputation", lrep_upstanding),
           (assign, ":comment", "str_comment_we_fought_in_siege_upstanding"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),		   
       (else_try),
           (eq, ":reputation", lrep_martial),
           (assign, ":comment", "str_comment_we_fought_in_siege_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 2),
       (else_try),
           (faction_slot_eq, "$players_kingdom", "slot_faction_leader", "$g_talk_troop"),
           (assign, ":comment", "str_comment_we_fought_in_siege_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
		(else_try),
           (assign, ":comment", "str_comment_we_fought_in_siege_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (try_end),
       
     (else_try),     
       (eq, ":entry_type", logent_castle_given_to_lord_by_player),
            
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),         
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
         (eq, ":reputation", lrep_debauched),         
         (assign, ":comment", "str_comment_you_give_castle_in_my_control"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),         
         (this_or_next|eq, ":reputation", lrep_martial),
         (eq, ":reputation", lrep_goodnatured),         
         (assign, ":comment", "str_comment_you_give_castle_in_my_control"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_give_castle_in_my_control"),
         (assign, ":relevance", 200),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_participated_in_major_battle),
       (troop_slot_eq, "$g_talk_troop", "slot_troop_present_at_event", ":log_entry_no"),
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_we_fought_in_major_battle_unfriendly_spiteful"),
           (assign, ":relevance", 150),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_unfriendly"),
           (assign, ":relevance", 150),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_we_fought_in_major_battle_cruel"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),		   
       (else_try),
           (eq, ":reputation", lrep_quarrelsome),        
           (assign, ":comment", "str_comment_we_fought_in_major_battle_cruel"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),		   
       (else_try),
           (eq, ":reputation", lrep_upstanding),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_upstanding"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),		   
       (else_try),
           (faction_slot_eq, "$players_kingdom", "slot_faction_leader", "$g_talk_troop"),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (else_try),
           (eq, ":reputation", lrep_martial),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 2),
	   (else_try),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),		   
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_suggestion_succeeded),
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_player_suggestion_succeeded"),
         (assign, ":relevance", 200),
		 (assign, ":suggested_relation_change", 3),

	   (try_end),
     (else_try),
       (eq, ":entry_type", logent_player_suggestion_failed),
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_player_suggestion_failed"),
         (assign, ":relevance", 200),
		 (assign, ":suggested_relation_change", -5),

	   (try_end),
	   
#Post 0907 changes end

     (else_try),
       (eq, ":entry_type", logent_lord_defeated_by_player),
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_defeated_me_enemy_chivalrous"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_debauched),
             (eq, ":reputation", lrep_quarrelsome),
         (assign, ":comment", "str_comment_you_defeated_me_enemy_spiteful"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_defeated_me_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_cunning),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_pragmatic"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_chivalrous"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_spiteful"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (faction_slot_eq, "$players_kingdom", "slot_faction_leader", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_liege"),
         (assign, ":relevance", 150),
		 (assign, ":suggested_relation_change", 1),
		 
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_unfriendly_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_unfriendly_chivalrous"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied"),
         (assign, ":relevance", 65),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_lord_defeated_by_player),
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_defeated_me_enemy_chivalrous"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_debauched),
             (eq, ":reputation", lrep_quarrelsome),
         (assign, ":comment", "str_comment_you_defeated_me_enemy_spiteful"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_defeated_me_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_cunning),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_pragmatic"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_chivalrous"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_spiteful"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (faction_slot_eq, "$players_kingdom", "slot_faction_leader", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_liege"),
         (assign, ":relevance", 70),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_unfriendly_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_unfriendly_chivalrous"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied"),
         (assign, ":relevance", 65),
       (try_end),

#Post 0907 changes begin
     (else_try),
       (eq, ":entry_type", logent_lord_helped_by_player),
       (neq, ":troop_object", "$g_talk_troop"),
       (eq, ":troop_object_faction", "$g_talk_troop_faction"),
       (try_begin),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_helped_my_ally_unfriendly_chivalrous"),
         (assign, ":relevance", 65),
         (assign, ":suggested_relation_change", 2),
       (else_try),
         (lt, "$g_talk_troop_relation", -5),
         (assign, ":comment", "str_comment_you_helped_my_ally_unfriendly"),
         (assign, ":relevance", 0),
       (else_try),
         (eq, ":reputation", lrep_none),
         (assign, ":comment", "str_comment_you_helped_my_ally_liege"),
         (assign, ":relevance", 65),
         (assign, ":suggested_relation_change", 3),
       (else_try),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_helped_my_ally_unfriendly_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_helped_my_ally_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_you_helped_my_ally_chivalrous"),
         (assign, ":relevance", 65),
         (assign, ":suggested_relation_change", 2),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_helped_my_ally_default"),
       (try_end),

#Post 0907 changes begin
     (else_try),
       (eq, ":entry_type", logent_player_defeated_by_lord),
       (troop_slot_eq, "$g_talk_troop", "slot_troop_present_at_event", ":log_entry_no"),
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_we_were_defeated_unfriendly_spiteful"),
           (assign, ":relevance", 150),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (assign, ":comment", "str_comment_we_were_defeated_unfriendly"),
           (assign, ":relevance", 150),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_we_were_defeated_cruel"),
           (assign, ":relevance", 150),
       (else_try),
           (assign, ":comment", "str_comment_we_were_defeated_default"),
           (assign, ":relevance", 150),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_defeated_by_lord),
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_I_defeated_you_enemy_spiteful"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_I_defeated_you_enemy_chivalrous"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_I_defeated_you_enemy_benevolent"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_selfrighteous),
             (eq, ":reputation", lrep_cunning),
         (assign, ":comment", "str_comment_I_defeated_you_enemy_coldblooded"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_I_defeated_you_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_I_defeated_you_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
         (gt, "$g_talk_troop_relation", 5),
         (assign, ":comment", "str_comment_you_were_defeated_allied_friendly_spiteful"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
         (lt, "$g_talk_troop_relation", -5),
         (assign, ":comment", "str_comment_you_were_defeated_allied_unfriendly_cruel"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
         (le, "$g_talk_troop_relation", 5),
         (assign, ":comment", "str_comment_you_were_defeated_allied_spiteful"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (eq, ":reputation", lrep_selfrighteous),
         (assign, ":comment", "str_comment_you_were_defeated_allied_pitiless"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (eq, ":reputation", lrep_upstanding),
         (lt, "$g_talk_troop_relation", -15),
         (assign, ":comment", "str_comment_you_were_defeated_allied_unfriendly_upstanding"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, "$g_talk_troop_relation", -10),
         (assign, ":comment", "str_comment_you_were_defeated_allied_unfriendly"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (assign, ":comment", "str_comment_you_were_defeated_allied"),
         (assign, ":relevance", 65),
       (try_end),
#Post 0907 changes end

#Post 0907 changes begin
     (else_try),
       (eq, ":entry_type", logent_player_retreated_from_lord),
       (troop_slot_eq, "$g_talk_troop", "slot_troop_present_at_event", ":log_entry_no"),
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_you_abandoned_us_unfriendly_spiteful"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -5),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (eq, ":reputation", lrep_selfrighteous),        
           (assign, ":comment", "str_comment_you_abandoned_us_unfriendly_pitiless"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -5),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),        
           (assign, ":comment", "str_comment_you_abandoned_us_spiteful"),
           (assign, ":suggested_relation_change", -5),
       (else_try),
           (eq, ":reputation", lrep_martial),
           (assign, ":comment", "str_comment_you_abandoned_us_chivalrous"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -2),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_upstanding),
               (eq, ":reputation", lrep_goodnatured),        
           (assign, ":comment", "str_comment_you_abandoned_us_benefitofdoubt"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -1),
       (else_try),
           (assign, ":comment", "str_comment_you_abandoned_us_default"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -2),
       (try_end),


#Post 0907 changes end

     (else_try),
       (this_or_next|eq, ":entry_type", logent_player_retreated_from_lord),
            (eq, ":entry_type", logent_player_retreated_from_lord_cowardly),
			
       (eq, ":troop_object", "$g_talk_troop"),
       (try_begin),
         (eq, "$cheat_mode", 1),
         (assign, reg7, ":entry_hours_elapsed"),
         (display_message, "@{!}Elapsed hours: {reg7}"),
       (try_end),
       (gt, ":entry_hours_elapsed", 2),
       (try_begin),
         (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy_spiteful"),
         (assign, ":relevance", 25),
       (else_try),
         (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy_chivalrous"),
         (assign, ":relevance", 25),
       (else_try),
         (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy_benevolent"),
         (assign, ":relevance", 25),
       (else_try),
         (eq, ":reputation", lrep_cunning),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy_coldblooded"),
         (assign, ":relevance", 25),
       (else_try),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy"),
         (assign, ":relevance", 25),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_retreated_from_lord_cowardly),
       (try_begin),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_relation", 5),
         (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_ran_from_foe_allied_chivalrous"),
         (assign, ":relevance", 80),
         (assign, ":suggested_relation_change", -3),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
         (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_you_ran_from_foe_allied_upstanding"),
         (assign, ":relevance", 80),
         (assign, ":suggested_relation_change", -1),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_relation", 5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_ran_from_foe_allied_spiteful"),
         (assign, ":relevance", 80),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_lord_defeated_but_let_go_by_player),
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_let_me_go_spiteful"),
         (assign, ":relevance", 300),
         (assign, ":suggested_relation_change", -15),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (ge, "$g_talk_troop_faction_relation", 0),
         (assign, ":comment", "str_comment_you_let_me_go_default"),
         (assign, ":relevance", 300),
         (assign, ":suggested_relation_change", 2),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_faction_relation", 0),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_upstanding),
         (assign, ":suggested_relation_change", 5),
         (assign, ":relevance", 300),
         (assign, ":comment", "str_comment_you_let_me_go_enemy_chivalrous"),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_faction_relation", 0),
         (this_or_next|eq, ":reputation", lrep_selfrighteous),
             (eq, ":reputation", lrep_cunning),
         (assign, ":relevance", 300),
         (assign, ":comment", "str_comment_you_let_me_go_enemy_coldblooded"),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_faction_relation", 0),
         (assign, ":relevance", 300),
         (assign, ":comment", "str_comment_you_let_me_go_enemy"),
         (assign, ":suggested_relation_change", 1),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied_chivalrous"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied_upstanding"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_cunning),
             (eq, ":reputation", lrep_selfrighteous),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied_coldblooded"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied_unfriendly_spiteful"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied"),
         (assign, ":relevance", 80),
       (try_end),

#Internal faction relations

     (else_try),
       (eq, ":entry_type", logent_pledged_allegiance),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":faction_object", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
		 (eq, ":faction_object", "$players_kingdom"), #Ie, no switch of kingdoms
         (assign, ":relevance", 200),
         (try_begin),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_martial),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_martial_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_martial),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_martial"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_quarrelsome),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_quarrelsome_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_quarrelsome),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_quarrelsome"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_selfrighteous_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_selfrighteous"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_cunning),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_cunning_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_cunning),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_cunning"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_debauched_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_debauched"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_goodnatured),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_goodnatured_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_goodnatured),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_goodnatured"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_upstanding_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_upstanding"),
         (try_end),
       (try_end),


     (else_try),
       (eq, ":entry_type", logent_liege_grants_fief_to_vassal),
       (eq, ":troop_object", "trp_player"),
       (try_begin),
         (eq, ":faction_object", "$g_talk_troop_faction"),
         (neq, ":actor", "$g_talk_troop"),
         (eq, ":faction_object", "$players_kingdom"),
         (assign, ":relevance", 110),
         (try_begin),
            (gt, "$g_talk_troop_relation", 5),
            (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_friendly_cruel"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_cunning),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_friendly_cynical"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_friendly"),
         (else_try),
            (is_between, "$g_talk_troop_relation", -5, 5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_spiteful"),
            (assign, ":suggested_relation_change", -2),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_unfriendly_upstanding"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_unfriendly_spiteful"),
         (else_try),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied"),
         (try_end),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_renounced_allegiance),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":faction_object", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
         (try_begin),
           (ge, "$g_talk_troop_faction_relation", 0),
           (neq, "$g_talk_troop_faction", "$players_kingdom"),
           (assign, ":relevance", 180),
           (try_begin),
             (gt, "$g_talk_troop_relation", 5),
             (assign, ":comment", "str_comment_you_renounced_your_alliegance_friendly"),
           (else_try),
             (ge, "$g_talk_troop_relation", 0),
             (eq, ":reputation", lrep_goodnatured),
             (assign, ":comment", "str_comment_you_renounced_your_alliegance_friendly"),
		   (else_try),
		     (assign, ":comment", "str_comment_you_renounced_your_alliegance_default"),
           (try_end),
         (else_try),
           (lt, "$g_talk_troop_faction_relation", 0),
           (assign, ":relevance", 300),
           (try_begin),
              (ge, "$g_talk_troop_relation", 0),
              (this_or_next|eq, ":reputation", lrep_selfrighteous),
                  (eq, ":reputation", lrep_debauched),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_unfriendly_moralizing"),
           (else_try),
              (gt, "$g_talk_troop_relation", 5),
              (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_enemy_friendly"),
           (else_try),
              (gt, "$g_talk_troop_relation", 5),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_enemy"),
           (else_try),
              (is_between, "$g_talk_troop_relation", -5, 5),
              (this_or_next|eq, ":reputation", lrep_quarrelsome),
                  (eq, ":reputation", lrep_debauched),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_unfriendly_spiteful"),
              (assign, ":suggested_relation_change", -2),
           (else_try),
              (lt, "$g_talk_troop_relation", -5),
              (this_or_next|eq, ":reputation", lrep_quarrelsome),
              (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_unfriendly_spiteful"),
           (else_try),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_default"),
           (try_end),
         (try_end),
       (try_end),

     (else_try), 
       (eq, ":entry_type", logent_lady_marries_lord),
	   (eq, ":troop_object", "trp_player"),
	   (try_begin),
		  (this_or_next|eq, ":reputation", lrep_quarrelsome),
			(eq, ":reputation", lrep_debauched),
		  (lt, "$g_talk_troop_relation", -5),	
          (assign, ":relevance", 200),
		  (assign, ":comment", "str_comment_marriage_normal_nasty"),
	   (else_try),
		  (call_script, "script_troop_get_family_relation_to_troop", ":actor", "$g_talk_troop"),
		  (ge, reg0, 5),
		  (assign, ":comment", "str_comment_marriage_normal_family"),
          (assign, ":relevance", 300),
		  (assign, ":suggested_relation_change", reg0),
		  (val_div, ":suggested_relation_change", 3),#gdwnochangeyet
	   (else_try),
		  (store_faction_of_troop, ":bride_faction", ":actor"),
		  (eq, ":bride_faction", "$g_talk_troop_faction"),
		  (assign, ":comment", "str_comment_marriage_normal"),
          (assign, ":relevance", 100),
	   (try_end),
     (else_try), 
       (eq, ":entry_type", logent_lady_elopes_with_lord),
	   (eq, ":troop_object", "trp_player"),
	   (try_begin),
		  (call_script, "script_troop_get_family_relation_to_troop", ":actor", "$g_talk_troop"),
		  (ge, reg0, 5),
		  (assign, ":comment", "str_comment_marriage_elopement_family"),
          (assign, ":relevance", 300),
		  (store_sub, ":suggested_relation_change", 0, reg0),
		  (val_div, ":suggested_relation_change", 3),
	   (else_try),
		  (store_faction_of_troop, ":bride_faction", ":actor"),
		  (eq, ":bride_faction", "$g_talk_troop_faction"),
		  (faction_slot_eq, ":bride_faction", "slot_faction_leader", "$g_talk_troop"),
		  (assign, ":comment", "str_comment_marriage_elopement_liege"),
          (assign, ":relevance", 300),
		  (assign, ":suggested_relation_change", -10),
	   (try_end),
     (else_try), #this is specific to quarrels with the player 
       (eq, ":entry_type", logent_lords_quarrel_over_woman),
 	   (eq, ":actor", "$g_talk_troop"),
 	   (eq, ":center_object", "trp_player"),

	   (neg|troop_slot_ge, ":troop_object", "slot_troop_spouse", "trp_player"),
	   
	   (str_store_troop_name, s54, ":troop_object"),

	   (try_begin),
	       (this_or_next|eq, ":reputation", lrep_selfrighteous),
	       (this_or_next|eq, ":reputation", lrep_quarrelsome),
				(eq, ":reputation", lrep_debauched),
		   
	       (assign, ":comment", "str_comment_i_quarreled_with_you_over_woman_derisive"),
		   (assign, ":relevance", 200),
	       (assign, ":suggested_relation_change", -20),
	   (else_try),
	       (assign, ":comment", "str_comment_i_quarreled_with_you_over_woman_default"),
		   (assign, ":relevance", 200),
	       (assign, ":suggested_relation_change", -20),
	   (try_end),
	 
     (else_try), 
       (eq, ":entry_type", logent_border_incident_troop_breaks_truce),
 	   (eq, ":actor", "trp_player"),
 	   (faction_slot_eq, ":faction_object", "slot_faction_leader", "$g_talk_troop"),
	   (eq, "$players_kingdom", ":faction_object"),
	   
	   (assign, ":suggested_relation_change", -10),
	   (assign, ":comment", "str_comment_you_broke_truce_as_my_vassal"),
	   (assign, ":relevance", 300),

     (else_try), 
       (eq, ":entry_type", logent_border_incident_troop_attacks_neutral),
 	   (eq, ":actor", "trp_player"),
 	   (faction_slot_eq, ":faction_object", "slot_faction_leader", "$g_talk_troop"),
	   (eq, "$players_kingdom", ":faction_object"),

	   (assign, ":suggested_relation_change", -3),
	   (assign, ":comment", "str_comment_you_attacked_neutral_as_my_vassal"),
	   (assign, ":relevance", 200),

	 #THE FOLLOWING ARE ALL COMPLAINTS SPOKEN BY LORDS WITHIN CONVERATIONS, RATHER THAN COMMENTS WHEN THE PLAYER FIRST SPEAKS TO A LORD
	 (else_try), #these need to have the actor and object strings added because they are used outside of "script_get_relevant_comment_to_s42"
       (eq, ":entry_type", logent_ruler_intervenes_in_quarrel),
 	   (eq, ":center_object", "$g_talk_troop"), #actor is liege lord, center object is loser lord, troop object is winner lord
	   (str_store_troop_name, s50, ":actor"), 
	   (str_store_troop_name, s51, ":center_object"), #s50 is actor, s51 is center object, s54 is troop object
	   (str_store_troop_name, s54, ":troop_object"), #s50 is actor, s51 is center object, s54 is troop object
       (assign, ":comment", "str_comment_lord_intervened_against_me"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_lord_protests_marshall_appointment),
 	   (eq, ":actor", "$g_talk_troop"),

	   (str_store_troop_name, s51, ":center_object"), #s51 is center object (marshall), s54 is troop object (liege lord), 
	   (str_store_troop_name, s54, ":troop_object"), 

       (assign, ":comment", "str_comment_i_protested_marshall_appointment"),
	   (assign, ":relevance", -1),
	   
	 (else_try),
       (eq, ":entry_type", logent_lord_blames_defeat),
 	   (eq, ":actor", "$g_talk_troop"),

	   (str_store_troop_name, s51, ":center_object"), #s51 is center object (marshall), s54 is troop object (liege lord), 
	   (str_store_troop_name, s54, ":troop_object"),  
	   (str_store_troop_name, s56, ":faction_object"), #faction object is unusual in this circumstance
	   
       (assign, ":comment", "str_comment_i_blamed_defeat"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_troop_feels_cheated_by_troop_over_land),
 	   (eq, ":actor", "$g_talk_troop"),

	   (str_store_party_name, s51, ":center_object"),  
	   (str_store_troop_name, s54, ":troop_object"),  
	   (str_store_troop_name, s56, ":faction_object"), #faction object is unusual in this circumstance
	   
       (assign, ":comment", "str_comment_i_was_entitled_to_fief"),
	   (assign, ":relevance", -1),
	   
	 (else_try),
       (eq, ":entry_type", logent_lords_quarrel_over_woman),
 	   (eq, ":actor", "$g_talk_troop"),

	   (str_store_troop_name, s51, ":center_object"), 
	   (str_store_troop_name, s54, ":troop_object"),  
	   
       (assign, ":comment", "str_comment_i_quarreled_with_troop_over_woman"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_lords_quarrel_over_woman),
 	   (eq, ":center_object", "$g_talk_troop"),

	   (str_store_troop_name, s51, ":actor"), 
	   (str_store_troop_name, s54, ":troop_object"),  
	   
       (assign, ":comment", "str_comment_i_quarreled_with_troop_over_woman"),
	   (assign, ":relevance", -1),
	   
	 (else_try),	 
       (eq, ":entry_type", logent_player_stole_cattles_from_village),
       
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
         (assign, ":relevance", 200),
         (assign, ":suggested_relation_change", -1),
         (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_default"),
         (try_begin),
            (lt, "$g_talk_troop_faction_relation", -3),
            (this_or_next|eq, ":reputation", lrep_goodnatured),
            (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_enemy_benevolent"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -3),
            (this_or_next|eq, ":reputation", lrep_cunning),
                (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_enemy_coldblooded"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -3),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_enemy_spiteful"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -3),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_enemy"),
         (else_try),
            (lt, "$g_talk_troop_relation", -3),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_unfriendly_spiteful"),
         (else_try),
            (gt, "$g_talk_troop_relation", 6),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_friendly"),
         (try_end),
       (try_end),
             	   
     (try_end),

     (assign, reg0, ":comment"),
	 (assign, reg1, ":relevance"),
     (assign, reg2, ":suggested_relation_change"),
     (assign, reg3, ":rejoinder"),
	]),

  # script_get_relevant_comment_to_s42
  # Input: none
  # Output: reg0 = 1 if comment found, 0 otherwise; s61 will contain comment string if found
  ("get_relevant_comment_to_s42",
    [

	 (troop_get_slot, ":reputation", "$g_talk_troop", "slot_lord_reputation_type"),
     (try_begin),
	   (eq, "$cheat_mode", 1),
       (store_add, ":rep_string", ":reputation", "str_personality_archetypes"),
       (str_store_string, s15, ":rep_string"),
       (display_message, "@{!}Reputation type: {s15}"),
     (try_end),

	 
     (assign, ":highest_score_so_far", 50),
     (assign, ":best_comment_so_far", -1),
     (assign, ":rejoinder_to_best_comment_so_far", -1),
     (assign, ":comment_found", 0),
     (assign, ":best_log_entry", -1),
     (assign, ":comment_relation_change", 0),
     (store_current_hours, ":current_time"),

#prevents multiple comments in conversations in same hour

#     (troop_get_slot, ":talk_troop_last_comment_time", "$g_talk_troop", "slot_troop_last_comment_time"),
#"$num_log_entries should also be set to one, not zero. This is included in the initialize npcs script, although could be moved to game_start
     (troop_get_slot, ":talk_troop_last_comment_slot", "$g_talk_troop", "slot_troop_last_comment_slot"),
     (troop_set_slot, "$g_talk_troop", "slot_troop_last_comment_slot", "$num_log_entries"),

     (store_add, ":log_entries_plus_one", "$num_log_entries", 1),
     (try_for_range, ":log_entry_no", 1, ":log_entries_plus_one"),
#      It should be log entries plus one, so that the try_ sequence does not stop short of the last log entry
#      $Num_log_entries is now the number of the last log entry, which begins at "1" rather than "0"
#      This is so that (le, ":log_entry_no", ":talk_troop_last_comment_slot") works properly
     
       (troop_get_slot, ":entry_time",           "trp_log_array_entry_time",           ":log_entry_no"),
#      (val_max, ":entry_time", 1), #This is needed for pre-game events to be commented upon, if hours are used rather than the order of events
       (store_sub, ":entry_hours_elapsed", ":current_time", ":entry_time"),
       (try_begin),
         (le, ":log_entry_no", ":talk_troop_last_comment_slot"),
#         (le, ":entry_time", ":talk_troop_last_comment_time"),
         (try_begin),
           (eq, ":log_entry_no", ":talk_troop_last_comment_slot"),
           (eq, "$cheat_mode", 1),
           (assign, reg5, ":log_entry_no"),
           (display_message, "@{!}Entries up to #{reg5} skipped"),
         (try_end),
#       I suggest using the log entry number as opposed to time so that events in the same hour can be commented upon
#       This feels more natural, for example, if there are other lords in the court when the player pledges allegiance     
       (else_try),
#         (le, ":entry_hours_elapsed", 3), #don't comment on really fresh events 
#       (else_try),
         (call_script, "script_get_relevant_comment_for_log_entry", ":log_entry_no"),
         (gt, reg1, 10),
         (assign, ":score", reg1),
         (assign, ":comment", reg0),
		 #reg2 is what
		 (assign, ":rejoinder", reg3),
		 
         (store_random_in_range, ":rand", 70, 140),
         (val_mul, ":score", ":rand"),
         (store_add, ":entry_time_score", ":entry_hours_elapsed", 500), #approx. one month 
         (val_mul, ":score", 1000),
         (val_div, ":score", ":entry_time_score"), ###Relevance decreases over time - halved after one month, one-third after two, etc
         (try_begin),
           (gt, ":score", ":highest_score_so_far"),
           (assign, ":highest_score_so_far", ":score"),
           (assign, ":best_comment_so_far",  ":comment"),
           (assign, ":rejoinder_to_best_comment_so_far",  ":rejoinder"),
           (assign, ":best_log_entry", ":log_entry_no"),
           (assign, ":comment_relation_change", reg2),
         (try_end),
       (try_end),
     (try_end),

     (try_begin),
       (gt, ":best_comment_so_far", 0),
       (assign, ":comment_found", 1), #comment found print it to s61 now. 
       (troop_get_slot, ":actor",                 "trp_log_array_actor",                 ":best_log_entry"),
       (troop_get_slot, ":center_object",         "trp_log_array_center_object",         ":best_log_entry"),
       (troop_get_slot, ":center_object_lord",    "trp_log_array_center_object_lord",    ":best_log_entry"),
       (troop_get_slot, ":center_object_faction", "trp_log_array_center_object_faction", ":best_log_entry"),
       (troop_get_slot, ":troop_object",          "trp_log_array_troop_object",          ":best_log_entry"),
       (troop_get_slot, ":troop_object_faction",  "trp_log_array_troop_object_faction",  ":best_log_entry"),
       (troop_get_slot, ":faction_object",        "trp_log_array_faction_object",        ":best_log_entry"),
       (try_begin),
         (ge, ":actor", 0),
         (str_store_troop_name,   s50, ":actor"),
       (try_end),
       (try_begin),
         (ge, ":center_object", 0),
         (str_store_party_name,   s51, ":center_object"),
       (try_end),
       (try_begin),
         (ge, ":center_object_lord", 0),
         (str_store_troop_name,   s52, ":center_object_lord"),
       (try_end),
       (try_begin),
         (ge, ":center_object_faction", 0),
         (str_store_faction_name, s53, ":center_object_faction"),
       (try_end),
       (try_begin),
         (ge, ":troop_object", 0),
         (str_store_troop_name,   s54, ":troop_object"),
       (try_end),
       (try_begin),
         (is_between, ":troop_object_faction", kingdoms_begin, kingdoms_end),
         (str_store_faction_name, s55, ":troop_object_faction"),
         (str_store_string, s55, "str_the_s55"),
	   (else_try), 
		 (is_between, ":troop_object", bandits_begin, bandits_end),
         (str_store_string, s55, "str_bandits"),
	   (else_try),
	     (eq, ":troop_object_faction", "fac_deserters"),
         (str_store_string, s55, "str_deserters"),
       (else_try),
         (str_store_string, s55, "str_travellers_on_the_road"),
	   (else_try),
	   
       (try_end),
	   
       (try_begin),
         (ge, ":faction_object", 0),
         (str_store_faction_name, s56, ":faction_object"),
       (try_end),
	   (assign, "$g_last_comment_copied_to_s42", ":best_comment_so_far"), #maybe deprecate
	   (assign, "$g_rejoinder_to_last_comment", ":rejoinder_to_best_comment_so_far"),
	   
       (str_store_string, s42, ":best_comment_so_far"),
     (try_end),
     
     (assign, reg0, ":comment_found"),
	 
     (assign, "$log_comment_relation_change", ":comment_relation_change"),
     ]),

#	 
  ("merchant_road_info_to_s42", #also does itemss to s32
    [
	(store_script_param, ":center", 1),
	
	(assign, ":last_bandit_party_found", -1),
	(assign, ":last_bandit_party_origin", -1),
	(assign, ":last_bandit_party_destination", -1),
	(assign, ":last_bandit_party_hours_ago", -1),
	
	(str_clear, s32),
	
	(str_clear, s42), 
	(str_clear, s47), #safe roads
	
	(try_for_range, ":center_to_reset", centers_begin, centers_end),
		(party_set_slot, ":center_to_reset", "slot_party_temp_slot_1", 0),
	(try_end),

	(assign, ":road_attacks", 0),
	(assign, ":trades", 0),
	
#first mention all attacks	
    (try_for_range, ":log_entry_iterator", 0, "$num_log_entries"),
		(store_sub, ":log_entry_no", "$num_log_entries", ":log_entry_iterator"),
#how long ago?
        (this_or_next|troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_traveller_attacked),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_party_traded),

#       reference - (call_script, "script_add_log_entry", logent_traveller_attacked, ":winner_party" (actor),  ":origin" (center object), ":destination" (troop_object), ":winner_faction"),
			
        (troop_get_slot, ":origin",         "trp_log_array_center_object",         ":log_entry_no"),
        (troop_get_slot, ":destination",    "trp_log_array_troop_object",          ":log_entry_no"),
		
		(this_or_next|eq, ":origin", ":center"),
			(eq, ":destination", ":center"),
		
	
        (troop_get_slot, ":event_time",            "trp_log_array_entry_time",              ":log_entry_no"),
		(store_current_hours, ":cur_hour"),
		(store_sub, ":hours_ago", ":cur_hour", ":event_time"),
		(assign, reg3, ":hours_ago"),

		(lt, ":hours_ago", 672), #four weeks
		
		(try_begin),
			(eq, "$cheat_mode", 1),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_traveller_attacked),
			(display_message, "str_attack_on_travellers_found_reg3_hours_ago"),
		(else_try),	
			(eq, "$cheat_mode", 1),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_party_traded),
			(display_message, "str_trade_event_found_reg3_hours_ago"),
		(try_end),

		(try_begin), #possibly make script -- get_colloquial_for_time
			(lt, ":hours_ago", 24),
			(str_store_string, s46, "str_a_short_while_ago"),
		(else_try),
			(lt, ":hours_ago", 48),
			(str_store_string, s46, "str_one_day_ago"),
		(else_try),	
			(lt, ":hours_ago", 72),
			(str_store_string, s46, "@two days ago"),
		(else_try),	
			(lt, ":hours_ago", 154),
			(str_store_string, s46, "str_earlier_this_week"),
		(else_try),
			(lt, ":hours_ago", 240),
			(str_store_string, s46, "str_about_a_week_ago"),
		(else_try),
			(lt, ":hours_ago", 480),
			(str_store_string, s46, "str_about_two_weeks_ago"),
		(else_try),
			(str_store_string, s46, "str_several_weeks_ago"),
		(try_end),


			
        (troop_get_slot, ":actor", "trp_log_array_actor", ":log_entry_no"),
        (troop_get_slot, ":faction_object", "trp_log_array_faction_object", ":log_entry_no"),
	 
		(str_store_string, s39, "str_unknown_assailants"),
		(assign, ":assailants_known", -1),
		(try_begin),
			(party_is_active, ":actor"),
			(store_faction_of_party, ":actor_faction", ":actor"),
			(eq, ":faction_object", ":actor_faction"),
			(assign, ":assailants_known", ":actor"),
			(str_store_party_name, s39, ":assailants_known"),
			(assign, "$g_bandit_party_for_bounty", -1),
			(try_begin), #possibly make script -- get_colloquial_for_faction chief cambia str facciones
				(eq, ":faction_object", "fac_kingdom_1"),
				(str_store_string, s39, "str_vaegirs"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_2"),
				(str_store_string, s39, "str_khergits"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_3"),
				(str_store_string, s39, "str_khergits"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_4"),
				(str_store_string, s39, "str_nords"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_5"),
				(str_store_string, s39, "str_khergits"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_6"),
				(str_store_string, s39, "str_swadians"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_7"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_8"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_9"),
				(str_store_string, s39, "str_nords"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_10"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_11"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_12"),
				(str_store_string, s39, "str_swadians"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_13"),
				(str_store_string, s39, "str_nords"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_14"),
				(str_store_string, s39, "str_nords"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_15"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_16"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_17"),
				(str_store_string, s39, "str_rhodoks"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_18"),
				(str_store_string, s39, "str_swadians"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_19"),
				(str_store_string, s39, "str_rhodoks"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_20"),
				(str_store_string, s39, "str_sarranids"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_21"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_22"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_23"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_24"),
				(str_store_string, s39, "str_swadians"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_25"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_26"),
				(str_store_string, s39, "str_swadians"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_27"),
				(str_store_string, s39, "str_rhodoks"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_28"),
				(str_store_string, s39, "str_rhodoks"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_29"),
				(str_store_string, s39, "str_rhodoks"),
			(else_try),	
				(eq, ":faction_object", "fac_kingdom_30"),
				(str_store_string, s39, "str_rhodoks"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_31"),
				(str_store_string, s39, "str_rhodoks"),
			(else_try), #chief acaba
				(eq, ":faction_object", "fac_player_supporters_faction"),
				(str_store_string, s39, "str_your_followers"),
			(else_try), #bandits	
				(assign, ":last_bandit_party_found", ":assailants_known"),
				(assign, ":last_bandit_party_origin", ":origin"),
				(assign, ":last_bandit_party_destination", ":destination"),
				(assign, ":last_bandit_party_hours_ago", ":hours_ago"),
			(try_end),
		(try_end),
	 
		(try_begin),
			(eq, ":origin", ":center"),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_traveller_attacked),
			(party_slot_eq, ":destination", "slot_party_temp_slot_1", 0),

			(party_set_slot, ":destination", "slot_party_temp_slot_1", 1),
			(str_store_party_name, s40, ":destination"),
			(str_store_string, s44, "str_we_have_heard_that_travellers_heading_to_s40_were_attacked_on_the_road_s46_by_s39"),
			(str_store_string, s43, "str_s42"),
			(str_store_string, s42, "str_s43_s44"),

			(val_add, ":road_attacks", 1),
			#travellers were attacked on the road to...			
		(else_try),
			(eq, ":destination", ":center"),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_traveller_attacked),
			(party_slot_eq, ":origin", "slot_party_temp_slot_1", 0),

			(party_set_slot, ":origin", "slot_party_temp_slot_1", 1),
			(str_store_party_name, s40, ":origin"),
			(str_store_string, s44, "str_we_have_heard_that_travellers_coming_from_s40_were_attacked_on_the_road_s46_by_s39"),

			(str_store_string, s43, "str_s42"),
			(str_store_string, s42, "str_s43_s44"),

			(val_add, ":road_attacks", 1),

		#travellers from here traded at...
#		(else_try),
#			(eq, ":origin", ":center"),
#			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_party_traded),
#			(party_slot_eq, ":destination", "slot_party_temp_slot_1", 0),

#			(party_set_slot, ":destination", "slot_party_temp_slot_1", 1),
#			(str_store_party_name, s40, ":destination"),
#			(str_store_string, s44, "@Travellers headed to {s40} traded there {s46}"),
#			(str_store_string, s43, "@{s42"),
#			(str_store_string, s42, "str_s43_s44"),

			#caravan from traded at...
		(else_try),
			(eq, ":destination", ":center"),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_party_traded),
			(party_slot_eq, ":origin", "slot_party_temp_slot_1", 0),

			(party_set_slot, ":origin", "slot_party_temp_slot_1", 1),
			(str_store_party_name, s40, ":origin"),
			(str_store_string, s44, "str_travellers_coming_from_s40_traded_here_s46"),
			(str_store_string, s43, "str_s42"),
			(str_store_string, s42, "str_s43_s44"),

			(val_add, ":trades", 1),

			#caravan from traded at...
		(try_end),
		
	(try_end),

	
	(try_begin),
		(le, ":trades", 2),
		(eq, ":road_attacks", 0),
		(store_current_hours, ":hours"),
		(lt, ":hours", 168),
		(str_store_string, s42, "str_it_is_still_early_in_the_caravan_season_so_we_have_seen_little_tradings42"),
	(else_try),
		(eq, ":trades", 0),
		(eq, ":road_attacks", 0),
		(str_store_string, s42, "str_there_has_been_very_little_trading_activity_here_recentlys42"),
	(else_try),
		(le, ":trades", 2),
		(eq, ":road_attacks", 0),
		(str_store_string, s42, "str_there_has_some_trading_activity_here_recently_but_not_enoughs42"),
	(else_try),	
		(le, ":trades", 2),
		(le, ":road_attacks", 2),
		(str_store_string, s42, "str_there_has_some_trading_activity_here_recently_but_the_roads_are_dangerouss42"),
	(else_try),	
		(ge, ":road_attacks", 3),
		(str_store_string, s42, "str_the_roads_around_here_are_very_dangerouss42"),
	(else_try),	
		(ge, ":road_attacks", 1),
		(str_store_string, s42, "str_we_have_received_many_traders_in_town_here_although_there_is_some_danger_on_the_roadss42"),
	(else_try),
		(str_store_string, s42, "str_we_have_received_many_traders_in_town_heres42"),
	(try_end),
	
#do safe roads
	(assign, ":unused_trade_route_found", 0),
	(try_for_range, ":trade_route_slot", "slot_town_trade_routes_begin", "slot_town_trade_routes_end"),
		(party_get_slot, ":trade_center", ":center", ":trade_route_slot"),
		(is_between, ":trade_center", centers_begin, centers_end),

		(party_slot_eq, ":trade_center", "slot_party_temp_slot_1", 0),

#		(party_get_slot, ":town_lord", ":trade_center", "slot_town_lord"),
				
		(str_store_party_name, s41, ":trade_center"),
		(try_begin),
			(eq, ":unused_trade_route_found", 1),
			(str_store_string, s44, "str_s44_s41"),
		(else_try),
			(str_store_string, s44, "str_s41"),
		(try_end),
		(assign, ":unused_trade_route_found", 1),
	(try_end),
	(try_begin),
		(eq, ":unused_trade_route_found", 1),
		(str_store_string, s47, "str_there_is_little_news_about_the_caravan_routes_to_the_towns_of_s44_and_nearby_parts_but_no_news_is_good_news_and_those_are_therefore_considered_safe"),
	(try_end),

	(assign, ":safe_village_road_found", 0),
	(try_for_range, ":village", villages_begin, villages_end),
		(party_slot_eq, ":village", "slot_village_market_town", ":center"),
		(party_slot_eq, ":village", "slot_party_temp_slot_1", 0),

#		(party_get_slot, ":town_lord", ":village", "slot_town_lord"),
		(str_store_party_name, s41, ":village"),
		(try_begin),
			(eq, ":safe_village_road_found", 1),
			(str_store_string, s44, "str_s44_s41"),
		(else_try),
			(str_store_string, s44, "str_s41"),
		(try_end),
		(assign, ":safe_village_road_found", 1),
	(try_end),

	(try_begin),
		(eq, ":safe_village_road_found", 1),
		(eq, ":unused_trade_route_found", 1),
		(str_store_string, s47, "str_s47_also_the_roads_to_the_villages_of_s44_and_other_outlying_hamlets_are_considered_safe"),
	(else_try),	
		(eq, ":safe_village_road_found", 1),
		(str_store_string, s47, "str_however_the_roads_to_the_villages_of_s44_and_other_outlying_hamlets_are_considered_safe"),
	(try_end),

	(str_store_string, s33, "str_we_have_shortages_of"),
	(assign, ":some_shortages_found", 0),
	(try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
        (store_sub, ":cur_good_price_slot", ":cur_good", trade_goods_begin),
        (val_add, ":cur_good_price_slot", "slot_town_trade_good_prices_begin"),
        (party_get_slot, ":price", ":center", ":cur_good_price_slot"),
		(gt, ":price", 1100),

        (str_store_item_name, s34, ":cur_good"),
        (assign, reg1, ":price"),
        (str_store_string, s33, "str_s33_s34_reg1"),

		(assign, ":some_shortages_found", 1),	
	(try_end),

	(try_begin),
		(eq, ":some_shortages_found", 0),
		(str_store_string, s32, "str_we_have_adequate_stores_of_all_commodities"),
	(else_try),
		(str_store_string, s32, "str_s33_and_some_other_commodities"),
	(try_end),

	(assign, reg0, ":last_bandit_party_found"),
	(assign, reg1, ":last_bandit_party_origin"),
	(assign, reg2, ":last_bandit_party_destination"),
	(assign, reg3, ":last_bandit_party_hours_ago"),
	
	
	] 
	),

  ("get_manhunt_information_to_s15", 
    [
     (store_script_param, ":quest", 1),

	(str_store_string, s15, "str_the_roads_are_full_of_brigands_friend_but_that_name_in_particular_does_not_sound_familiar_good_hunting_to_you_nonetheless"),
    (quest_get_slot, ":quarry", ":quest", "slot_quest_target_party"),
	(try_begin),
		(is_between, "$g_talk_troop", active_npcs_begin, active_npcs_end),
		(troop_get_slot, ":talk_party", "$g_talk_troop", "slot_troop_leaded_party"),
	(else_try),
		(gt, "$g_encountered_party", "p_spawn_points_end"),
		(assign, ":talk_party", "$g_encountered_party"),
	(else_try),	
		(assign, ":talk_party", -1),
	(try_end),
	
    (try_for_range, ":log_entry", 0, "$num_log_entries"),
		(gt, ":talk_party", -1),
		(troop_get_slot, ":party", "trp_log_array_actor", ":log_entry"),
		(eq, ":party", ":talk_party"),
		(troop_get_slot, ":bandit_party", "trp_log_array_troop_object", ":log_entry"),
		(eq, ":bandit_party", ":quarry"),
		(store_current_hours, ":hours_ago"),
		(troop_get_slot, ":sighting_time", "trp_log_array_entry_time",  ":log_entry"),
		(val_sub, ":hours_ago", ":sighting_time"), 
		(try_begin),
			(le, ":hours_ago", 1),
			(str_store_string, s16, "str_less_than_an_hour_ago"),
		(else_try),
			(le, ":hours_ago", 48),
			(assign, reg3, ":hours_ago"),
			(str_store_string, s16, "str_maybe_reg3_hours_ago"),
		(else_try),
			(val_div, ":hours_ago", 24),
			(assign, reg3, ":hours_ago"),
			(str_store_string, s16, "str_reg3_days_ago"),
		(try_end),
		
		(troop_get_slot, ":center", "trp_log_array_center_object", ":log_entry"),
		(str_store_party_name, s17, ":center"),
		(troop_get_slot, ":entry_type", "trp_log_array_entry_type", ":log_entry"),
		(eq, ":entry_type", logent_party_spots_wanted_bandits),
		(str_store_string, s15, "str_youre_in_luck_we_sighted_those_bastards_s16_near_s17_hurry_and_you_might_be_able_to_pick_up_their_trail_while_its_still_hot"),
		
#		(try_begin),
#			(eq, ":entry_type", logent_party_chases_wanted_bandits),
#			(str_store_string, s15, "@You're in luck. We gave chase to those bastards {s16} near {s17}. They have eluded us so far -- but perhaps you will do better..."),
#		(else_try),
#			(eq, ":entry_type", logent_party_runs_from_wanted_bandits),
#			(str_store_string, s15, "@As it happens, they tried to run us down near {s17} {s16}. By the heavens, I hope you teach them a lesson."),
#		(try_end),
	(try_end),
	]),

	
#Troop Commentaries end



  ("rebellion_arguments", #Right now, called only in one place. This is only used when for player overtures, and will need some changes if this script is called when NPCs try to suborn lords
    [
     (store_script_param, ":lord", 1),
     (store_script_param, ":argument", 2),
     (store_script_param, ":candidate", 3),

     (assign, ":argument_appeal", 0),
     (assign, ":argument_strength", 0),

     (troop_get_slot, ":reputation", ":lord", "slot_lord_reputation_type"),

	 (store_faction_of_troop, ":lord_faction", ":candidate"),
	 (store_faction_of_troop, ":candidate_faction", ":candidate"),
	 
	 (try_begin),
		(eq, ":candidate", "trp_player"),
		(assign, ":right_to_rule", "$player_right_to_rule"),
	 (else_try), #default right to rule of 75 for pretenders claiming throne
		(is_between, ":candidate", pretenders_begin, pretenders_end),
		(troop_slot_eq, ":candidate", "slot_troop_original_faction", ":lord_faction"),
		(assign, ":right_to_rule", 66),#gdw70
	 (else_try), #default right to rule of 60 for all other lords
		(assign, ":right_to_rule", 55),#gdw
	 (try_end),
	 
	 (try_begin),
		(eq, ":argument", argument_claim),	#rtr-30				
		(store_sub, ":argument_strength", ":right_to_rule", 29),#gdw30onlyforupstan				
	 (else_try),
		(eq, ":argument", argument_ruler),	#honor -20 fair ruler	gdw this was 25
		(store_sub, ":argument_strength", "$player_honor", 20),#gdw raise this?
	 (else_try),
		(eq, ":argument", argument_lords),		#honor - 20 for help nobility
		(store_sub, ":argument_strength", "$player_honor", 20),	#gdw raise this?
	 (else_try),
	    #argument_strength for unify is ((5 * number of centers player have) - 40) if argument type is argument_victory
		(eq, ":argument", argument_victory),		
		(assign, ":argument_strength", 0),
		(try_for_range, ":center", centers_begin, centers_end),
			(store_faction_of_party, ":center_faction", ":center"),
			(assign, ":argument_strength", -37),#gdw40centers include villages
			(try_begin),
				(eq, "$players_kingdom", ":candidate_faction"),#gdw it look like arg #= same as native
				(this_or_next|eq, ":center_faction", "fac_player_faction"),
				(eq, ":center_faction", "fac_player_supporters_faction"),
				(val_add, ":argument_strength", 5),
			(else_try),
				(eq, ":center_faction", ":candidate_faction"),
				(val_add, ":argument_strength", 5),
			(try_end),
		(try_end),		
	 (else_try),
	    #argument_strength is (20 - 20 * (number of lords in player's faction which not awareded fief by player although there is a fief awarding in future promise))
		(eq, ":argument", argument_benefit),
		(assign, ":argument_strength", 20),
		(try_for_range, ":lord_promised_fief", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":other_faction", ":lord_promised_fief"),
			(neq, ":lord", "$g_talk_troop"),
			(this_or_next|eq, ":other_faction", "fac_player_supporters_faction"),
			(eq, ":other_faction", "$players_kingdom"),
			(troop_slot_eq, ":lord_promised_fief", "slot_troop_promised_fief", 1),
			(val_sub, ":argument_strength", 15),#gdw20 seems rather severe, but only debauched lords go for it very easily you choose them you lose
		(try_end),
	 (try_end),
	 (val_clamp, ":argument_strength", -40, 41),
	 	 
     (try_begin),
         (eq, ":reputation", lrep_martial),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", 30),			 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_claims_to_the_throne_good_there_is_nothing_id_rather_do_than_fight_for_a_good_cause"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_claims_to_the_throne_well_there_is_nothing_id_rather_do_than_fight_for_a_good_cause_but_the_claim_you_make_seems_somewhat_weak"),
		     (try_end),
         (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", 15),	#gdw10		 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_i_am_pleased_that_you_speak_of_upholding_my_ancient_rights_which_are_sometimes_trod_upon_in_these_sorry_days"),
			 (else_try),
				(str_store_string, s15, "str_i_am_pleased_that_you_speak_of_upholding_my_ancient_rights_but_sometimes_men_make_pledges_before_they_are_king_which_they_cannot_keep_once_they_take_the_throne"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", 0),		
			 (try_begin),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_well_i_supposed_thats_good_but_sometimes_the_commons_overstep_their_boundaries_im_more_concerned_that_your_claim_be_legal_so_i_can_swing_my_sword_with_a_good_conscience"),
			 (try_end),			 
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", -10),			 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_good_i_ask_for_no_more_than_my_due"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_unfortunately_you_are_not_wellknown_for_rewarding_those_to_whom_you_have_made_such_offers"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", -30),			 
			 (str_store_string, s15, "str_you_speak_of_unifying_calradia_well_i_believe_that_well_always_be_fighting__its_important_that_we_fight_for_a_rightful_cause"),
         (try_end),
     (else_try),
        (eq, ":reputation", lrep_quarrelsome),
        (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", -20),
 			 (str_store_string, s15, "str_you_talk_of_claims_to_the_throne_but_i_leave_bickering_about_legalities_to_the_lawyers_and_clerks"),
		(else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", -30),
			 (str_store_string, s15, "str_you_speak_of_ruling_justly_hah_ill_believe_theres_such_a_thing_as_a_just_king_when_i_see_one"),
		(else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", 0),
			 (str_store_string, s15, "str_you_spoke_of_protecting_the_rights_of_the_nobles_if_you_did_youd_be_the_first_king_to_do_so_in_a_very_long_time"),
		(else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", 33),#gdw30
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_ay_well_lets_see_if_you_deliver"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_bah_youre_not_known_for_delivering_on_your_pledges"),
			 (try_end),
	    (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 14),	#gdw10		 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_well_youve_done_a_good_job_at_making_calradia_bend_its_knee_to_you_so_maybe_thats_not_just_talk"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_id_be_impressed_if_i_thought_you_could_do_it_but_unfortunately_you_dont"),
			 (try_end),
		(try_end),
     (else_try),
         (eq, ":reputation", lrep_selfrighteous),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", -20),
			 (str_store_string, s15, "str_you_speak_of_claims_to_the_throne_well_any_peasant_can_claim_to_be_a_kings_bastard"),
		 (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", -30),			 
			 (str_store_string, s15, "str_well_its_a_fine_thing_to_court_the_commons_with_promises_but_what_do_you_have_to_offer_me"),
		 (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", 10),#gdw	0		 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_that_would_make_a_fine_change_if_my_rights_as_lord_would_be_respected"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_that_would_make_a_fine_change_if_my_rights_as_lord_would_be_respected_however_it_is_easy_for_you_to_make_promises_while_you_are_weak_that_you_have_no_intention_of_keeping_when_you_are_strong"),
			 (try_end),			 
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", 22),#gdw20
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_well_my_family_is_of_ancient_and_noble_lineage_so_you_promise_me_no_more_than_my_due_still_your_gesture_is_appreciated"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_well_you_make_that_pledge_but_i_am_not_impressed"),
			 (try_end),
		 (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 22),#gdwrare anyways			 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_well_much_of_this_land_now_bends_its_knee_to_you_so_perhaps_that_is_not_just_talk"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_but_right_now_yours_is_just_one_squabbling_faction_among_many"),
			 (try_end),			 			 
         (try_end),
     (else_try),
         (eq, ":reputation", lrep_cunning),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", -30),
			 (str_store_string, s15, "str_you_speak_of_claims_well_no_offense_but_a_claim_unsupported_by_might_rarely_prospers"),			 			 
         (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", 14),	#gdw		 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_well_i_suppose_that_will_make_for_a_more_prosperous_realm_ive_always_tried_to_treat_my_peasants_decently_saves_going_to_bed_worrying_about_whether_youll_wake_up_with_the_roof_on_fire"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_very_well_but_remember_that_peasants_are_more_likely_to_cause_trouble_if_you_make_promises_then_dont_deliver_than_if_you_never_made_the_promise_in_the_first_place"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", 17),#gdw			 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_good_youd_be_well_advised_to_do_that__men_fight_better_for_a_king_wholl_respect_their_rights"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_very_well_but_remember__failing_to_keep_promises_which_you_made_while_scrambling_up_the_throne_is_the_quickest_way_to_topple_off_of_it_once_you_get_there"),
			 (try_end),			 			 			 			 
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", -20),			 
			 (str_store_string, s15, "str_you_speak_of_giving_me_land_very_good_but_often_i_find_that_when_a_man_makes_too_many_promises_trying_to_get_to_the_top_he_has_trouble_keeping_them_once_he_reaches_it"),
         (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 20),			 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_well_many_have_said_that_you_might_very_well_be_the_one_to_do_it"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_well_all_the_kings_say_that_im_not_sure_that_you_will_succeed_while_they_fail"),
			 (try_end),			 			 
         (try_end),
     (else_try),
         (eq, ":reputation", lrep_debauched),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", -20),			 
			 (str_store_string, s15, "str_you_speak_of_claims_do_you_think_i_care_for_the_nattering_of_lawyers"),			 
         (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", -20),			 
			 (str_store_string, s15, "str_you_speak_of_protecting_the_commons_how_kind_of_you_i_shall_tell_my_swineherd_all_about_your_sweet_promises_no_doubt_he_will_become_your_most_faithful_vassal"),
         (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", -10),			 
			 (str_store_string, s15, "str_you_speak_of_protecing_the_rights_of_lords_such_sweet_words_but_ill_tell_you_this__the_only_rights_that_are_respected_in_this_world_are_the_rights_to_dominate_whoever_is_weaker_and_to_submit_to_whoever_is_stronger"),			 
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", 35),	#gdw		 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_yes_very_good__but_you_had_best_deliver"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_hah_perhaps_all_those_others_to_whom_you_promised_lands_will_simply_step_aside"),
			 (try_end),			 			 
         (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 10),			 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_you_may_indeed_humble_the_other_kings_of_this_land_and_in_that_case_i_would_hope_that_you_would_remember_me_as_your_faithful_servant"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_but_you_are_weak_and_i_think_that_you_will_remain_weak"),
			 (try_end),			 
         (try_end),
	 (else_try),
         (eq, ":reputation", lrep_goodnatured),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", 15),#gdw
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_claims_its_good_for_a_king_to_have_a_strong_claim_although_admittedly_im_more_concerned_that_he_rules_just_ly_than_with_legalities_anyway_your_claim_seems_wellfounded_to_me"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_claims_but_your_claim_seems_a_bit_weak_to_me"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", 36),#gdw
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_i_like_that_my_tenants_are_a_happy_lot_i_think_but_i_hear_of_others_in_other_estates_that_arent_so_fortunate"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_im_glad_to_hear_you_say_that_but_do_me_a_favor__dont_promise_the_commons_anything_you_cant_deliver_thats_a_sure_way_to_get_them_to_rebel_and_it_breaks_my_heart_to_have_to_put_them_down"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_lords),
			 (assign, ":argument_appeal", 0),
			 (str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_well_very_good_i_suppose_but_you_know__we_lords_can_take_of_ourselves_its_the_common_folk_who_need_a_strong_king_to_look_out_for_them_to_my_mind"),			 
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", -15),
			 (str_store_string, s15, "str_you_speak_of_giving_me_land_its_kind_of_you_really_though_that_is_not_necessary"),			 			 
         (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", -25),
			 (str_store_string, s15, "str_you_speak_of_unifying_calradia_well_maybe_you_can_unite_this_land_by_the_sword_but_im_not_sure_that_this_will_make_you_a_good_ruler"),			 			 
         (try_end),
     (else_try),
         (eq, ":reputation", lrep_upstanding),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", 20),#gdw
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_claims_a_king_must_have_a_strong_legal_claim_for_there_not_to_be_chaos_in_the_realm_and_yours_is_wellestablished"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_claims_a_king_must_have_a_strong_legal_claim_for_there_not_to_be_chaos_in_the_realm_but_your_claim_is_not_so_strong"),
			 (try_end),
		 (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", -5),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_it_is_of_course_important_that_a_king_respect_the_rights_of_his_vassals_although_i_worry_that_a_king_who_took_a_throne_without_proper_cause_would_not_rule_with_justice"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_it_is_of_course_important_that_a_king_respect_the_rights_of_his_vassals_however_i_would_like_to_know_that_you_would_indeed_deliver_on_your_promises"),
			 (try_end),
		 (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", 20),#gdw			 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_i_would_be_pleased_to_serve_a_king_who_respected_the_rights_of_his_subjects_although_i_worry_that_a_king_who_took_a_throne_without_proper_cause_would_not_rule_with_justice"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_i_would_be_pleased_to_serve_a_king_who_respected_the_rights_of_his_subjects_however_i_would_like_to_know_that_you_would_indeed_deliver_on_your_promises"),
			 (try_end),			 
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", -40),
			 (str_store_string, s15, "str_i_am_not_swayed_by_promises_of_reward"),
		 (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 10),			 
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_it_would_be_good_to_bring_peace_to_the_realm_and_i_believe_that_you_are_strong_enough_to_do_so"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_it_would_be_good_to_bring_peace_the_realm_but_with_your_kingdom_in_its_current_state_i_worry_that_you_are_just_bringing_more_discord"),
			 (try_end),			 			 
         (try_end),
     (try_end),
	 
	 (str_store_string, s14, "str_s15"),
	 	 
     (assign, reg0, ":argument_appeal"),
     (assign, reg1, ":argument_strength"),     
]),



#Rebellion changes end

  # script_get_culture_with_party_faction_for_music
  # Input: arg1 = party_no
  # Output: reg0 = culture
  ("get_culture_with_party_faction_for_music",
    [
      (store_script_param, ":party_no", 1),
      (store_faction_of_party, ":faction_no", ":party_no"),
      (try_begin),
        (this_or_next|eq, ":faction_no", "fac_player_faction"),
        (eq, ":faction_no", "fac_player_supporters_faction"),
        (assign, ":faction_no", "$players_kingdom"),
      (try_end),
      (try_begin),
        (is_between, ":party_no", centers_begin, centers_end),
        (this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
        (neg|is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (party_get_slot, ":faction_no", ":party_no", "slot_center_original_faction"),
      (try_end),
      (call_script, "script_get_culture_with_faction_for_music", ":faction_no"),
     ]),

  # script_get_culture_with_faction_for_music #chief anade facciones
  # Input: arg1 = party_no
  # Output: reg0 = culture
  ("get_culture_with_faction_for_music",
    [
      (store_script_param, ":faction_no", 1),
      (try_begin),
        (eq, ":faction_no", "fac_kingdom_1"),
        (assign, ":result", mtf_culture_1),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_2"),
        (assign, ":result", mtf_culture_2),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_3"),
        (assign, ":result", mtf_culture_3),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_4"),
        (assign, ":result", mtf_culture_4),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_5"),
        (assign, ":result", mtf_culture_5),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_6"),
        (assign, ":result", mtf_culture_6),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_7"),
        (assign, ":result", mtf_culture_1),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_8"),
        (assign, ":result", mtf_culture_2),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_9"),
        (assign, ":result", mtf_culture_3),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_10"),
        (assign, ":result", mtf_culture_4),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_11"),
        (assign, ":result", mtf_culture_5),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_12"),
        (assign, ":result", mtf_culture_6),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_13"),
        (assign, ":result", mtf_culture_3),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_14"),
        (assign, ":result", mtf_culture_4),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_15"),
        (assign, ":result", mtf_culture_5),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_16"),
        (assign, ":result", mtf_culture_6),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_17"),
        (assign, ":result", mtf_culture_1),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_18"),
        (assign, ":result", mtf_culture_2),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_19"),
        (assign, ":result", mtf_culture_3),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_20"),
        (assign, ":result", mtf_culture_4),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_21"),
        (assign, ":result", mtf_culture_5),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_22"),
        (assign, ":result", mtf_culture_6),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_23"),
        (assign, ":result", mtf_culture_3),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_24"),
        (assign, ":result", mtf_culture_4),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_25"),
        (assign, ":result", mtf_culture_5),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_26"),
        (assign, ":result", mtf_culture_6),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_27"),
        (assign, ":result", mtf_culture_1),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_28"),
        (assign, ":result", mtf_culture_2),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_29"),
        (assign, ":result", mtf_culture_3),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_30"),
        (assign, ":result", mtf_culture_4),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_31"),
        (assign, ":result", mtf_culture_5),
      (else_try),
        (this_or_next|eq, ":faction_no", "fac_outlaws"),
        (this_or_next|eq, ":faction_no", "fac_peasant_rebels"),
        (this_or_next|eq, ":faction_no", "fac_deserters"),
        (this_or_next|eq, ":faction_no", "fac_mountain_bandits"),
        (eq, ":faction_no", "fac_forest_bandits"),
        (assign, ":result", mtf_culture_6),
      (else_try),
        (assign, ":result", 0), #no culture, including player with no bindings to another kingdom
      (try_end),
      (assign, reg0, ":result"),
     ]),

  # script_music_set_situation_with_culture
  # Input: arg1 = music_situation
  # Output: none
  ("music_set_situation_with_culture",
    [
      (store_script_param, ":situation", 1),
      (assign, ":culture", 0), #no culture
      (try_begin),
        (this_or_next|eq, ":situation", mtf_sit_town),
        (this_or_next|eq, ":situation", mtf_sit_day),
        (this_or_next|eq, ":situation", mtf_sit_night),
        (this_or_next|eq, ":situation", mtf_sit_town_infiltrate),
        (eq, ":situation", mtf_sit_encounter_hostile),
        (call_script, "script_get_culture_with_party_faction_for_music", "$g_encountered_party"),
        (val_or, ":culture", reg0),
      (else_try),
        (this_or_next|eq, ":situation", mtf_sit_ambushed),
        (eq, ":situation", mtf_sit_fight),
        (call_script, "script_get_culture_with_party_faction_for_music", "$g_encountered_party"),
        (val_or, ":culture", reg0),
        (call_script, "script_get_culture_with_party_faction_for_music", "p_main_party"),
        (val_or, ":culture", reg0),
        (call_script, "script_get_closest_center", "p_main_party"),
        (call_script, "script_get_culture_with_party_faction_for_music", reg0),
        (val_or, ":culture", reg0),
      (else_try),
        (eq, ":situation", mtf_sit_multiplayer_fight),
        (call_script, "script_get_culture_with_faction_for_music", "$g_multiplayer_team_1_faction"),
        (val_or, ":culture", reg0),
        (call_script, "script_get_culture_with_faction_for_music", "$g_multiplayer_team_2_faction"),
        (val_or, ":culture", reg0),
      (else_try),
        (eq, ":situation", mtf_sit_travel),
        (call_script, "script_get_culture_with_party_faction_for_music", "p_main_party"),
        (val_or, ":culture", reg0),
        (call_script, "script_get_closest_center", "p_main_party"),
        (call_script, "script_get_culture_with_party_faction_for_music", reg0),
        (val_or, ":culture", reg0),
      (else_try),
        (eq, ":situation", mtf_sit_victorious),
        (call_script, "script_get_culture_with_party_faction_for_music", "p_main_party"),
        (val_or, ":culture", reg0),
      (else_try),
        (eq, ":situation", mtf_sit_killed),
        (call_script, "script_get_culture_with_party_faction_for_music", "$g_encountered_party"),
        (val_or, ":culture", reg0),
      (try_end),
      (try_begin),
        (this_or_next|eq, ":situation", mtf_sit_town),
        (eq, ":situation", mtf_sit_day),
        (try_begin),
          (is_currently_night),
          (assign, ":situation", mtf_sit_night),
        (try_end),
      (try_end),
      (music_set_situation, ":situation"),
 	  # multiplayer chief para todas las facciones
	  (assign,":culture",mtf_culture_all),	 	  
	  
      (music_set_culture, ":culture"),
     ]),

  
  # script_combat_music_set_situation_with_culture
  # Input: none
  # Output: none
  ("combat_music_set_situation_with_culture",
    [
      (assign, ":situation", mtf_sit_fight),
      (assign, ":num_allies", 0),
      (assign, ":num_enemies", 0),
      (try_for_agents, ":agent_no"),
        (agent_is_alive, ":agent_no"),
        (agent_is_human, ":agent_no"),
        (agent_get_troop_id, ":agent_troop_id", ":agent_no"),
        (store_character_level, ":troop_level", ":agent_troop_id"),
        (val_add,  ":troop_level", 10),
        (val_mul, ":troop_level", ":troop_level"),
        (try_begin),
          (agent_is_ally, ":agent_no"),
          (val_add, ":num_allies", ":troop_level"),
        (else_try),
          (val_add, ":num_enemies", ":troop_level"),
        (try_end),
      (try_end),
      (val_mul, ":num_allies", 4), #play ambushed music if we are 2 times outnumbered.
      (val_div, ":num_allies", 3),
      (try_begin),
        (lt, ":num_allies", ":num_enemies"),
        (assign, ":situation", mtf_sit_ambushed),
      (try_end),
      (call_script, "script_music_set_situation_with_culture", ":situation"),
     ]),

  # script_play_victorious_sound
  # Input: none
  # Output: none
  ("play_victorious_sound",
   [
     (call_script, "script_music_set_situation_with_culture", mtf_sit_victorious),
#      (play_cue_track, "track_victorious_neutral_1"),
#      (play_track, "track_victorious_neutral_1", 1),
     ]),

  # script_custom_battle_end
  # Input: none
  # Output: none
  ("custom_battle_end",
    [
      (assign, "$g_custom_battle_team1_death_count", 0),
      (assign, "$g_custom_battle_team2_death_count", 0),
      (get_player_agent_no, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),
      (try_for_agents, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (neg|agent_is_alive, ":cur_agent"),
        (agent_get_team, ":cur_team", ":cur_agent"),
        (try_begin),
          (eq, ":cur_team", ":player_team"),
          (val_add, "$g_custom_battle_team1_death_count", 1),
        (else_try),
          (val_add, "$g_custom_battle_team2_death_count", 1),
        (try_end),
      (try_end),
      ]),  

  # script_remove_troop_from_prison
  # Input: troop_no
  # Output: none
  #Other search terms: release, peace
  
  ("remove_troop_from_prison",
    [
      (store_script_param, ":troop_no", 1),
      (troop_set_slot, ":troop_no", "slot_troop_prisoner_of_party", -1),
      (try_begin),
        (eq, "$do_not_cancel_quest", 0),      
        (check_quest_active, "qst_rescue_lord_by_replace"),
        (quest_slot_eq, "qst_rescue_lord_by_replace", "slot_quest_target_troop", ":troop_no"),
        (call_script, "script_cancel_quest", "qst_rescue_lord_by_replace"),
      (try_end),
      (try_begin),
        (eq, "$do_not_cancel_quest", 0),      
        (check_quest_active, "qst_rescue_prisoner"),
        (quest_slot_eq, "qst_rescue_prisoner", "slot_quest_target_troop", ":troop_no"),
        (call_script, "script_cancel_quest", "qst_rescue_prisoner"),
      (try_end),
      (try_begin),
        (check_quest_active, "qst_deliver_message_to_prisoner_lord"),
        (quest_slot_eq, "qst_deliver_message_to_prisoner_lord", "slot_quest_target_troop", ":troop_no"),
        (call_script, "script_cancel_quest", "qst_deliver_message_to_prisoner_lord"),
      (try_end),
      ]),

#lord recruitment scripts begin	  
  ("troop_describes_troop_to_s15",
  [
	(store_script_param, ":troop_1", 1),
	(store_script_param, ":troop_2", 2),

	
	(str_store_troop_name, s15, ":troop_2"),
	
	(try_begin),
		(eq, ":troop_2", "trp_player"),
		(str_store_string, s15, "str_you"),
	(else_try),	
		(eq, ":troop_2", ":troop_1"),
		(str_store_string, s15, "str_myself"),
	(else_try),
		(call_script, "script_troop_get_family_relation_to_troop", ":troop_2", ":troop_1"),
		(gt, reg0, 0),
		(str_store_string, s15, "str_my_s11_s15"),
	(else_try),	
		(call_script, "script_troop_get_relation_with_troop", ":troop_2", ":troop_1"),
		(ge, reg0, 20),
		(str_store_string, s15, "str_my_friend_s15"),
	(try_end),	
	
	]),
	
  ("troop_describes_quarrel_with_troop_to_s14",
  #perhaps replace this with get_relevant_comment at a later date
    [
	(store_script_param, ":troop", 1),
	(store_script_param, ":troop_2", 2),

	(str_store_troop_name, s15, ":troop"),
	(str_store_troop_name, s16, ":troop_2"),

	(str_store_string, s14, "str_stop_gap__s15_is_the_rival_of_s16"),
	
	(try_begin),
		(eq, ":troop", "$g_talk_troop"),
		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":troop", ":troop_2"),
		(str_store_string, s14, s17),
	(else_try),	
		(eq, ":troop_2", "$g_talk_troop"),
		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":troop_2", ":troop"),
		(str_store_string, s14, s17),
	(else_try),
		(str_store_string, s14, "str_general_quarrel"),
	(try_end),
	
]),

  ("cf_test_lord_incompatibility_to_s17", #writes rivalry chance to reg0
    [

	(store_script_param, ":source_lord", 1),
	(store_script_param, ":target_lord", 2),
	
	
	(assign, ":chance_of_rivalry", 0),
	
	(troop_get_slot, ":source_reputation", ":source_lord", "slot_lord_reputation_type"),
	(troop_get_slot, ":target_reputation", ":target_lord", "slot_lord_reputation_type"),
	
## Gender fix chief altura	                   
       (troop_get_type, reg15, ":target_lord"),
## Gender fix
(val_mod, reg15, 2),
###gender fix chief
	
	(str_store_troop_name, s18, ":target_lord"),
	
	(assign, ":divisor", 1),
	
	(call_script, "script_troop_get_family_relation_to_troop", ":target_lord", ":source_lord"),
	(assign, ":family_relationship", reg0),
	
	(try_begin),
		(gt, ":family_relationship", 0),
		(store_div, ":family_divisor", reg0, 5),
		(val_add, ":divisor", ":family_divisor"),
		(str_store_string, s18, "str_my_s11_s18"),
	(else_try),
		(gt, ":target_reputation", lrep_upstanding),
		(this_or_next|eq, ":source_reputation", lrep_debauched),
			(eq, ":source_reputation", lrep_selfrighteous),
		(str_store_string, s18, "str_the_socalled_s11_s18"),
	(try_end),	

	
	(try_begin), #test if reps are compatible
        (eq, ":source_reputation", lrep_martial),
		(is_between, ":family_relationship", 1, 5), #uncles and cousins
		
		(assign, ":chance_of_rivalry", 90),##gdw100
        (str_store_string, s17, "str_s18_would_cheat_me_of_my_inheritance_by_heaven_i_know_my_rights_and_im_not_going_to_back_down"), 
	(else_try),
        (eq, ":source_reputation", lrep_martial),
        (eq, ":target_reputation", lrep_quarrelsome),
        (str_store_string, s17, "str_s18_once_questioned_my_honour_and_my_bravery_i_long_for_the_day_when_i_can_meet_him_in_battle_and_make_him_retract_his_statement"),
		(assign, ":chance_of_rivalry", 45),##gdw50

	(else_try),
        (eq, ":source_reputation", lrep_martial),
        (eq, ":target_reputation", lrep_upstanding),
        (str_store_string, s17, "str_s18_once_questioned_my_judgment_in_battle_by_heaven_would_he_have_us_shirk_our_duty_to_smite_our_sovereigns_foes"),
		(assign, ":chance_of_rivalry", 45),##gdw50

	(else_try),
        (eq, ":target_reputation", lrep_martial),
		(is_between, ":family_relationship", 1, 5),
		
		(assign, ":chance_of_rivalry", 85),##gdw100
        (str_store_string, s17, "str_s18_seems_to_think_he_has_the_right_to_some_of_my_property_well_he_does_not"), 
		
	(else_try),
        (eq, ":source_reputation", lrep_quarrelsome),
        (eq, ":target_reputation", lrep_martial),
        (str_store_string, s17, "str_s18_once_took_something_i_said_amiss_stubborn_bastard_wont_give_it_up_and_keeps_trying_to_get_me_to_recant_my_words"), 
		(assign, ":chance_of_rivalry", 42),##gdw50

	(else_try),
        (eq, ":source_reputation", lrep_quarrelsome),
        (eq, ":target_reputation", lrep_cunning),
        (str_store_string, s17, "str_s18_is_a_crafty_weasel_and_i_dont_trust_him_one_bit"), 
		(assign, ":chance_of_rivalry", 90),##gdw50

		
    (else_try),
        (eq, ":source_reputation", lrep_debauched),
        (eq, ":target_reputation", lrep_upstanding),
		(str_store_string, s17, "str_s18_i_despite_him_he_puts_on_such_a_nauseating_display_of_virtue_and_thinks_nothing_of_insulting_his_betters"),
		(assign, ":chance_of_rivalry", 90),##gdw100

        #debauched insults upstanding

    (else_try),
        (eq, ":source_reputation", lrep_debauched),
        (eq, ":target_reputation", lrep_selfrighteous),
		(str_store_string, s17, "str_s18_entered_into_a_little_deal_with_me_and_is_now_trying_to_wriggle_out_of_it"),
		(assign, ":chance_of_rivalry", 90),##gdw100

        #debauched insults selfrighteous

		
		
    (else_try),
        (eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_debauched),
		(str_store_string, s17, "str_s18_once_ran_an_errand_for_me_and_now_thinks_i_owe_him_something_i_owe_his_ilk_nothing"),
		(assign, ":chance_of_rivalry", 90),##gdw100
        #selfrighteous dismisses debauched
		
    (else_try),
        (eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_goodnatured),
		(str_store_string, s17, "str_s18_is_soft_and_weak_and_not_fit_to_govern_a_fief_and_i_have_always_detested_him"),
		(assign, ":chance_of_rivalry", 90),##gdw100
             

			 
	(else_try),
        (eq, ":source_reputation", lrep_cunning),
        (eq, ":target_reputation", lrep_quarrelsome),
        (str_store_string, s17, "str_s18_is_a_quarrelsome_oaf_and_a_liability_in_my_opinion_and_ive_let_him_know_as_much"), 
		(assign, ":chance_of_rivalry", 90),##gdw100
        #cunning insults quarrelsome

	(else_try),
        (eq, ":source_reputation", lrep_cunning),
        (eq, ":target_reputation", lrep_goodnatured),
        (str_store_string, s17, "str_s18_i_am_sorry_to_say_is_far_too_softhearted_a_man_to_be_given_any_kind_of_responsibility_his_chivalry_will_allow_the_enemy_to_flee_to_fight_another_day_and_will_cost_the_lives_of_my_own_faithful_men"), 
		(assign, ":chance_of_rivalry", 90),##gdw100
		

	(else_try),
        (eq, ":source_reputation", lrep_goodnatured),
        (eq, ":target_reputation", lrep_cunning),
        (str_store_string, s17, "str_s18_seems_to_have_something_against_me_for_some_reason_i_dont_like_to_talk_ill_of_people_but_i_think_hes_can_be_a_bit_of_a_cad_sometimes"), 
		(assign, ":chance_of_rivalry", 90),##gdw100
		
	(else_try),
        (eq, ":source_reputation", lrep_goodnatured),
        (eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_s18_has_always_treated_me_contemptuously_although_i_have_done_him_no_wrong"), 
		(assign, ":chance_of_rivalry", 90),##gdw100
		
		

	(else_try),
        (eq, ":source_reputation", lrep_upstanding),
        (eq, ":target_reputation", lrep_debauched),
        (str_store_string, s17, "str_s18_is_thoroughly_dishonorable_and_a_compulsive_spinner_of_intrigues_which_i_fear_will_drag_us_into_wars_or_incite_rebellions"), 
		(assign, ":chance_of_rivalry", 50),

	(else_try),
        (eq, ":source_reputation", lrep_upstanding),
        (eq, ":target_reputation", lrep_martial),
        (str_store_string, s17, "str_s18_disappoints_me_i_once_scolded_for_his_rashness_in_battle_and_he_took_offense_i_do_not_care_to_apologize_for_my_efforts_to_save_his_life_and_the_lives_of_his_men"), 
		(assign, ":chance_of_rivalry", 50),

	#for commons	
	(else_try),
        (this_or_next|eq, ":source_reputation", lrep_upstanding),
		(this_or_next|eq, ":source_reputation", lrep_martial),
			(eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_roguish),
        (str_store_string, s17, "str_s18_squanders_money_and_carouses_in_a_way_most_unbefitting_a_noble_by_doing_so_he_disgraces_us_all"), 
		(assign, ":chance_of_rivalry", 100),

		
	(else_try),
        (eq, ":source_reputation", lrep_roguish),
        (this_or_next|eq, ":target_reputation", lrep_upstanding),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_s18_has_been_speaking_ill_of_me_behind_my_back_or_so_they_say"), 
		(assign, ":chance_of_rivalry", 100),


	(else_try),
        (this_or_next|eq, ":source_reputation", lrep_quarrelsome),
		(this_or_next|eq, ":source_reputation", lrep_martial),
			(eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_custodian),
        (str_store_string, s17, "str_s18_is_a_disgrace_reg3shehe_consorts_with_merchants_lends_money_at_interest_uses_coarse_language_and_shows_no_attempt_to_uphold_the_dignity_of_the_honor_bestowed_upon_reg3herhim"), 
		(assign, ":chance_of_rivalry", 100),

	(else_try),
        (eq, ":source_reputation", lrep_custodian),
		(this_or_next|eq, ":target_reputation", lrep_quarrelsome),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_s18_has_condemned_me_for_engaging_in_commerce_what_could_possibly_be_wrong_with_that"), 
		(assign, ":chance_of_rivalry", 100),

		
	(else_try),
        (this_or_next|eq, ":source_reputation", lrep_debauched),
		(this_or_next|eq, ":source_reputation", lrep_martial),
			(eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_benefactor),
        (str_store_string, s17, "str_s18_i_have_heard_has_been_encouraging_seditious_ideas_among_the_peasantry__a_foolish_move_which_endangers_us_all"), 
		(assign, ":chance_of_rivalry", 100),
		
		
	(else_try),
        (eq, ":source_reputation", lrep_benefactor),
		(this_or_next|eq, ":target_reputation", lrep_debauched),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_s18_has_called_me_out_for_the_way_i_deal_with_my_tenants_well_so_be_it_if_i_teach_them_that_they_are_the_equal_of_anyone_with_socalled_gentle_blood_what_is_it_to_reg3herhim"), 
		(assign, ":chance_of_rivalry", 100),


	#lady incompatibilities	
	(else_try),	
		(eq, ":source_reputation", lrep_conventional),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_a_most_gallant_gentleman_who_knows_how_to_treat_a_lady"), 
		(assign, ":chance_of_rivalry", -50),

	(else_try),	
		(eq, ":source_reputation", lrep_conventional),
		(eq, ":target_reputation", lrep_quarrelsome),
        (str_store_string, s17, "str_a_base_cad"), 
		(assign, ":chance_of_rivalry", 50),
	
		
	(else_try),	
		(eq, ":source_reputation", lrep_adventurous),
		(eq, ":target_reputation", lrep_cunning),
        (str_store_string, s17, "str_a_man_who_treats_me_as_his_equal_which_is_rare"), 
		(assign, ":chance_of_rivalry", -50),

	(else_try),	
		(eq, ":source_reputation", lrep_adventurous),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_debauched),
		(str_store_string, s17, "str_appears_to_value_me_with_his_estate_and_his_horse_as_prizes_worth_having"), 
		(assign, ":chance_of_rivalry", 50),

	(else_try),	
		(eq, ":source_reputation", lrep_adventurous),
		(neq, ":target_reputation", lrep_goodnatured),
		
        (str_store_string, s17, "str_a_bit_dull_but_what_can_you_expect"), 
		(assign, ":chance_of_rivalry", 10),

	(else_try),	
		(eq, ":source_reputation", lrep_otherworldly),
		(call_script, "script_troop_get_romantic_chemistry_with_troop", ":source_lord", ":target_lord"),
		(ge, reg0, 10),
        (str_store_string, s17, "str_the_man_whom_destiny_intends_for_me"), 
		(assign, ":chance_of_rivalry", -50),

	(else_try),	
		(eq, ":source_reputation", lrep_otherworldly),
		(lt, reg0, 0),
		
        (str_store_string, s17, "str_is_not_right_for_me__i_cannot_say_why_but_he_makes_my_skin_crawl"), 
		(assign, ":chance_of_rivalry", 50),

		
	(else_try),	
		(eq, ":source_reputation", lrep_ambitious),
		(this_or_next|eq, ":target_reputation", lrep_selfrighteous),
			(eq, ":target_reputation", lrep_cunning),
        (str_store_string, s17, "str_is_a_man_who_clearly_intends_to_make_his_mark_in_the_world"), 
		(assign, ":chance_of_rivalry", -20),

	(else_try),	
		(eq, ":source_reputation", lrep_ambitious),
		(eq, ":target_reputation", lrep_goodnatured),
		
        (str_store_string, s17, "str_is_a_layabout_a_naif_prey_for_others_who_are_cleverer_than_he"), 
		(assign, ":chance_of_rivalry", 30),

				
	(else_try),	
		(eq, ":source_reputation", lrep_moralist),
		(eq, ":target_reputation", lrep_upstanding),
		
        (str_store_string, s17, "str_is_a_man_of_stalwart_character"), 
		(assign, ":chance_of_rivalry", -50),

	(else_try),	
		(eq, ":source_reputation", lrep_moralist),
		(this_or_next|eq, ":target_reputation", lrep_debauched),
			(eq, ":target_reputation", lrep_cunning),
			
        (str_store_string, s17, "str_appears_to_be_a_man_of_low_morals"), 
		(assign, ":chance_of_rivalry", 50),

	(else_try),	
		(eq, ":source_reputation", lrep_moralist),
		(eq, ":target_reputation", lrep_quarrelsome),
		
        (str_store_string, s17, "str_appears_to_be_a_man_who_lacks_selfdiscipline"), 
		(assign, ":chance_of_rivalry", 50),
		
	(else_try),

       #Ambitious vs otherworldly chief diplomacy
       (eq, ":source_reputation", lrep_ambitious),
       (eq, ":target_reputation", lrep_otherworldly),
       (str_store_string, s17, "str_s18_is_soft_and_weak_and_not_fit_to_govern_a_fief_and_i_have_always_detested_him"),
       (str_store_string, s17, "str_s18_has_always_treated_me_contemptuously_although_i_have_done_him_no_wrong"),
		(assign, ":chance_of_rivalry", 100),
   (else_try),
       #Otherworldly vs ambitious
       (eq, ":source_reputation", lrep_otherworldly),
       (eq, ":target_reputation", lrep_ambitious),
       (str_store_string, s17, "str_s18_has_always_treated_me_contemptuously_although_i_have_done_him_no_wrong"),
		(assign, ":chance_of_rivalry", 100),
   (else_try),
       #Quarrelsome quarrels with conventional and moralist
       (eq, ":source_reputation", lrep_quarrelsome),
       (this_or_next|eq, ":target_reputation", lrep_moralist),
          (eq, ":target_reputation", lrep_conventional),
       (str_store_string, s17, "str_s18_once_took_something_i_said_amiss_stubborn_bastard_wont_give_it_up_and_keeps_trying_to_get_me_to_recant_my_words"),
		(assign, ":chance_of_rivalry", 50),
   (else_try),
        #Cunning conflicts with moralist
        (eq, ":source_reputation", lrep_cunning),
        (eq, ":target_reputation", lrep_moralist),
        (str_store_string, s17, "str_s18_i_am_sorry_to_say_is_far_too_softhearted_a_man_to_be_given_any_kind_of_responsibility_his_chivalry_will_allow_the_enemy_to_flee_to_fight_another_day_and_will_cost_the_lives_of_my_own_faithful_men"),
		(assign, ":chance_of_rivalry", 50),
    (else_try),
        #Debauched conflicts with moralist
        (eq, ":source_reputation", lrep_debauched),
        (eq, ":target_reputation", lrep_moralist),
		(str_store_string, s17, "str_s18_i_despite_him_he_puts_on_such_a_nauseating_display_of_virtue_and_thinks_nothing_of_insulting_his_betters"),
		(assign, ":chance_of_rivalry", 50),
    (else_try),
        #Martial or debauched conflicts with adventurous
	   (this_or_next|eq, ":source_reputation", lrep_martial),
	   (eq, ":source_reputation", lrep_debauched),
      (eq, ":target_reputation", lrep_adventurous),
      (str_store_string, s17, "str_s18_once_took_something_i_said_amiss_stubborn_bastard_wont_give_it_up_and_keeps_trying_to_get_me_to_recant_my_words"),
		(assign, ":chance_of_rivalry", 50),
	(else_try),
        (eq, ":source_reputation", lrep_goodnatured),
        (eq, ":target_reputation", lrep_ambitious),
        (str_store_string, s17, "str_s18_seems_to_have_something_against_me_for_some_reason_i_dont_like_to_talk_ill_of_people_but_i_think_hes_can_be_a_bit_of_a_cad_sometimes"),
		  (assign, ":chance_of_rivalry", 30),
##Add support for secondary morality types
	(else_try),
		(call_script, "script_dplmc_get_troop_morality_value", ":target_lord", tmt_honest),
		(ge, reg0, 1),#This would apply (if no previous condition was reached) to Marnid, Rolf, Firentis, Alayan, and Jeremus.
		(eq, ":source_reputation", lrep_moralist),
		(str_store_string, s17, "str_is_a_man_of_stalwart_character"),#<- (does not apply to Rolf, since he is Cunning)
		(assign, ":chance_of_rivalry", -50),
	(else_try),
		(call_script, "script_dplmc_get_troop_morality_value", ":target_lord", tmt_pious),
		(ge, reg0, 1),#This doesn't apply to anyone at the moment.
		(eq, ":source_reputation", lrep_moralist),
		(str_store_string, s17, "str_is_a_man_of_stalwart_character"),
		(assign, ":chance_of_rivalry", -50),
#diplomacy chief acaba	
	
    (try_end),

	(val_div, ":chance_of_rivalry", ":divisor"),
##diplomacy start+ for companions, use compatability information chief
    (try_begin),
	   (is_between, ":source_lord", companions_begin, companions_end),
	   (troop_slot_eq, ":source_lord", "slot_troop_personalitymatch_object", ":target_lord"),
	   (val_min, ":chance_of_rivalry", -100),
	(else_try),
	   (is_between, ":source_lord", companions_begin, companions_end),
	   (this_or_next|troop_slot_eq, ":source_lord", "slot_troop_personalityclash_object", ":target_lord"),
	   (troop_slot_eq, ":source_lord", "slot_troop_personalityclash2_object", ":target_lord"),
	   (try_begin),
	      (le, ":chance_of_rivalry", 0),
		  (str_store_string, s17, "str_general_quarrel"),
	   (try_end),
	   (val_max, ":chance_of_rivalry", 100),
	(try_end),
##diplomacy end+

	(assign, reg0, ":chance_of_rivalry"),

	(neq, ":chance_of_rivalry", 0),
#	(eq, ":incompatibility_found", 1), #cf can be removed with this
	
	]),

  ("troop_get_romantic_chemistry_with_troop", #source is lady, target is man
    [
      (store_script_param, ":source_lady", 1),
      (store_script_param, ":target_lord", 2),
      
      (store_add, ":chemistry_sum", ":source_lady", ":target_lord"),
      (val_add, ":chemistry_sum", "$romantic_attraction_seed"),      
      
      #This calculates (modula ^ 2) * 3 
      (store_mod, ":chemistry_remainder", ":chemistry_sum", 5),
      (val_mul, ":chemistry_remainder", ":chemistry_remainder"), #0, 1, 4, 9, 16
      (val_mul, ":chemistry_remainder", 3), #0, 3, 12, 27, 48
      
      (store_attribute_level, ":romantic_chemistry", ":target_lord", ca_charisma),
      (val_sub, ":romantic_chemistry", ":chemistry_remainder"),
      
      (val_mul, ":romantic_chemistry", 2),
      (assign, reg0, ":romantic_chemistry"), 
      
      #examples : 
      #For a charisma of 18, yields (18 - 0) * 2 = 36, (18 - 3) * 2 = 30, (18 - 12) * 2 = 12, (18 - 27) * 2 = -18, (18 - 48) * 2 = -60
      #For a charisma of 10, yields (10 - 0) * 2 = 20, (10 - 3) * 2 = 14, (10 - 12) * 2 = -4, (10 - 27) * 2 = -34, (10 - 48) * 2 = -76
      #For a charisma of 7, yields  (7 - 0) * 2 = 14,  (7 - 3) * 2 = 8,   (7 - 12) * 2 = -10, (7 - 27) * 2 = -40,  (7 - 48) * 2 = -82
      
      #15 is high attraction, 0 is moderate attraction, -76 is lowest attraction
	]),

  ("cf_random_political_event", #right now, just enmities
    [
	
	(store_random_in_range, ":lord_1", active_npcs_begin, active_npcs_end),
	(store_random_in_range, ":lord_2", active_npcs_begin, active_npcs_end),

	(troop_slot_eq, ":lord_1", "slot_troop_occupation", slto_kingdom_hero),
	(troop_slot_eq, ":lord_2", "slot_troop_occupation", slto_kingdom_hero),

	(neq, ":lord_1", ":lord_2"),
	
	(val_add, "$total_political_events", 1),
					
	(store_troop_faction, ":lord_1_faction", ":lord_1"),
	(store_troop_faction, ":lord_2_faction", ":lord_2"),
	
	(assign, reg8, "$total_political_events"),
	
	
	(faction_get_slot, ":faction_1_leader", ":lord_1_faction", "slot_faction_leader"),
	(faction_get_slot, ":faction_2_leader", ":lord_2_faction", "slot_faction_leader"),
	
	(this_or_next|eq, ":lord_1_faction", ":lord_2_faction"),
	(this_or_next|eq, ":lord_1", ":faction_1_leader"),
		(eq, ":lord_2", ":faction_2_leader"),
	
	
	(call_script, "script_troop_get_relation_with_troop", ":lord_1", ":lord_2"),
	(assign, ":relation", reg0),
	

	(store_random_in_range, ":random", 0, 100),
		
	(try_begin),
		#reconciliation
		#The chance of a liege reconciling two quarreling vassals is equal to (relationship with lord 1 x relationship with lord 2) / 4
		
		(eq, ":lord_1_faction", ":lord_2_faction"),
		(neq, ":faction_1_leader", "trp_player"),
		
		(le, ":relation", -10),
		
#		(ge, "$total_political_events", 5000),

		(call_script, "script_troop_get_relation_with_troop", ":lord_1", ":faction_1_leader"),
		(gt, reg0, 0),
		(assign, ":lord_1_leader_rel", reg0),
		
		(call_script, "script_troop_get_relation_with_troop", ":lord_2", ":faction_1_leader"),
		(gt, reg0, 0),
		(store_mul, ":reconciliation_chance", ":lord_1_leader_rel", reg0),		
		(val_div, ":reconciliation_chance", 3),	#was 2 before##gdw was 4	
				
		(le, ":random", ":reconciliation_chance"), 
		
		(str_store_troop_name, s4, ":faction_1_leader"),
		(str_store_troop_name, s5, ":lord_1"),
		(str_store_troop_name, s6, ":lord_2"),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(display_message, "str_check_reg8_s4_reconciles_s5_and_s6_"),
		(try_end),
		
		(call_script, "script_troop_change_relation_with_troop", ":lord_1", ":lord_2", 22),#gdw20
		(val_add, "$total_random_quarrel_changes", 22),#gdw20
	(else_try),	#palyer as lord intervenes in quarrel
		(eq, ":lord_1_faction", ":lord_2_faction"),

		(le, ":relation", -10),
#		(ge, ":random", 50),
		(try_begin),
			(eq, ":faction_1_leader", "trp_player"),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_diagnostic__player_should_receive_consultation_quest_here_if_not_already_active"),
			(try_end),
			(neg|check_quest_active, "qst_consult_with_minister"),
			(neg|check_quest_active, "qst_resolve_dispute"),
			(eq, "$g_minister_notification_quest", 0),
			(assign, "$g_minister_notification_quest", "qst_resolve_dispute"),
			(quest_set_slot, "qst_resolve_dispute", "slot_quest_target_troop", ":lord_1"),
			(quest_set_slot, "qst_resolve_dispute", "slot_quest_object_troop", ":lord_2"),
			
			(call_script, "script_add_notification_menu", "mnu_notification_player_should_consult", 0, 0),
			
			
		(else_try),
			(call_script, "script_troop_get_relation_with_troop", ":lord_1", ":faction_1_leader"),
			(assign, ":lord_1_rel_w_leader", reg0),
			
			(call_script, "script_troop_get_relation_with_troop", ":lord_2", ":faction_1_leader"),
			(assign, ":lord_2_rel_w_leader", reg0),
			
			(store_random_in_range, ":another_random", -5, 5),

			(val_add, ":lord_1_rel_w_leader", ":another_random"),
			
			(try_begin),
				(ge, ":lord_1_rel_w_leader", ":lord_2_rel_w_leader"),
				(assign, ":winner_lord", ":lord_1"),
				(assign, ":loser_lord", ":lord_2"),
			(else_try),
				(assign, ":loser_lord", ":lord_1"),
				(assign, ":winner_lord", ":lord_2"),
			(try_end),
			
			(str_store_troop_name, s4, ":faction_1_leader"),
			(str_store_troop_name, s5, ":winner_lord"),
			(str_store_troop_name, s6, ":loser_lord"),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_check_reg8_s4_rules_in_favor_of_s5_quarrel_with_s6_"),
			(try_end), 
			 
			(call_script, "script_add_log_entry", logent_ruler_intervenes_in_quarrel, ":faction_1_leader",  ":loser_lord", ":winner_lord", ":lord_1_faction"), #faction leader is actor, loser lord is center object, winner lord is troop_object
			
			(call_script, "script_troop_change_relation_with_troop", ":winner_lord", ":faction_1_leader", 10),
			(call_script, "script_troop_change_relation_with_troop", ":loser_lord", ":faction_1_leader", -17),##gdw-20
			(val_add, "$total_random_quarrel_changes", -7),

		(try_end),

		
	(else_try), #new quarrel - netween companions
		(is_between, ":lord_1", companions_begin, companions_end),
		(is_between, ":lord_2", companions_begin, companions_end),
		
		(ge, ":relation", -10), 		
		(this_or_next|troop_slot_eq, ":lord_1", "slot_troop_personalityclash_object", ":lord_2"),
			(troop_slot_eq, ":lord_1", "slot_troop_personalityclash2_object", ":lord_2"),
		
		(str_store_troop_name, s5, ":lord_1"),
		(str_store_troop_name, s6, ":lord_2"),
		
		(try_begin),
			(eq, "$cheat_mode", 1),
			(display_debug_message, "str_check_reg8_new_rivalry_generated_between_s5_and_s6"),
		(try_end),
		
		(call_script, "script_troop_change_relation_with_troop", ":lord_1", ":lord_2", -21),##gdw -30reducing conflicts
		(val_add, "$total_random_quarrel_changes", -21),
				
		
	(else_try), #new quarrel - others
		(eq, ":lord_1_faction", ":lord_2_faction"),
		# (neq, ":lord_1", ":faction_1_leader"),
		# (neq, ":lord_2", ":faction_2_leader"),
		(neq, ":lord_1", ":faction_2_leader"),
		(neq, ":lord_1", ":faction_1_leader"),
		(neq, ":lord_2", ":faction_2_leader"),
		(neq, ":lord_2", ":faction_1_leader"),
###########################################################gdw added above two to prevent lords having too many quarrels with vassals
		(ge, ":relation", -10), #can have two quarrels

		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":lord_1", ":lord_2"),
		(assign, ":chance_of_enmity", reg0),
		(gt, ":chance_of_enmity", 0),
	
	
		(lt, ":random", ":chance_of_enmity"), #50 or 100 percent, usually
	
	
		(str_store_troop_name, s5, ":lord_1"),
		(str_store_troop_name, s6, ":lord_2"),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(display_message, "str_check_reg8_new_rivalry_generated_between_s5_and_s6"),
		(try_end),
		
		(call_script, "script_troop_change_relation_with_troop", ":lord_1", ":lord_2", -24),##gdw -30reducing conflicts
		(val_add, "$total_random_quarrel_changes", -24),##gdw -30reducing conflicts

#		(call_script, "script_update_troop_notes", ":lord_1"),
#		(call_script, "script_update_troop_notes", ":lord_2"),
	(else_try), #a lord attempts to suborn a character
		(store_current_hours, ":hours"),
		(ge, ":hours", 24),
	
		(neq, ":lord_1_faction", ":lord_2_faction"),
#		(eq, ":lord_1", ":faction_1_leader"),##not gdw this was there
		(is_between, ":lord_1_faction", kingdoms_begin, kingdoms_end),
		
		(call_script, "script_cf_troop_can_intrigue", ":lord_2", 0),
		(neq, ":lord_2", ":faction_2_leader"),
		(neq, ":lord_2", ":faction_1_leader"),

		(str_store_troop_name, s5, ":faction_1_leader"),
		(str_store_troop_name, s6, ":lord_2"),		

		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "str_check_reg8_s5_attempts_to_win_over_s6"),
		(try_end),
			
		(call_script, "script_calculate_troop_political_factors_for_liege", ":lord_2", ":faction_1_leader"),
		(assign, ":lord_1_score", reg0),

		(call_script, "script_calculate_troop_political_factors_for_liege", ":lord_2", ":faction_2_leader"),
		(assign, ":faction_2_leader_score", reg0),

		(try_begin),
			(gt, ":lord_1_score", ":faction_2_leader_score"),
						
			(try_begin),
				(ge, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":lord_2"),
				(display_message, "@{!}DEBUG - {s4} faction changed in subornment (cf_random_political)"), 
			(try_end),
			
			(call_script, "script_change_troop_faction", ":lord_2", ":lord_1_faction"),		
		(try_end),
	(try_end),

]),


#this calculates the average number of rivalries per lord, giving a rough indication of how easily a faction may be divided
#fairly expensive in terms of CPU
  ("evaluate_realm_stability",
 
    [
	(store_script_param, ":realm", 1),

	(assign, ":total_lords", 0),
	(assign, ":total_restless_lords", 0),
	(assign, ":total_disgruntled_lords", 0),
	
	(faction_get_slot, ":liege", ":realm", "slot_faction_leader"),
	
	(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
		(troop_slot_eq, ":lord", "slot_troop_occupation", slto_kingdom_hero),
		(store_troop_faction, ":lord_faction", ":lord"),
		(eq, ":lord_faction", ":realm"),
		(val_add, ":total_lords", 1),

		(call_script, "script_calculate_troop_political_factors_for_liege", ":lord", ":liege"),
		(try_begin),
			(le, reg3, -10),
			(val_add, ":total_disgruntled_lords", 1),
		(else_try),
			(le, reg3, 10),
			(val_add, ":total_restless_lords", 1),
		(try_end),
	(try_end),
	
	(try_begin),
		(gt, ":total_lords", 0),
		(store_mul, ":instability_quotient", ":total_disgruntled_lords", 100),
		(val_div, ":instability_quotient", ":total_lords"),

		(store_mul, ":restless_quotient", ":total_restless_lords", 100),
		(val_div, ":restless_quotient", ":total_lords"),

		(store_mul, ":combined_quotient", ":instability_quotient", 2),
		(val_add, ":combined_quotient", ":restless_quotient"),
		(faction_set_slot, ":realm", "slot_faction_instability", ":combined_quotient"),
	
		(assign, reg0, ":instability_quotient"),
		(assign, reg1, ":restless_quotient"),
		(assign, reg1, ":restless_quotient"),
	(else_try),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_faction_name, s1, ":realm"),
			(display_message, "str_s1_has_no_lords"),
		(try_end),
		(assign, reg0, 0),
		(assign, reg1, 0),
	(try_end),
	
	]),
	
	
	
#lord recruitment scripts end	  
	  
#called from game_event_simulate_battle
#Includes a number of consequences that follow on battles, mostly affecting relations between different NPCs
#This only fires from complete victories
  ("battle_political_consequences",
    [
	(store_script_param, ":defeated_party", 1),
	(store_script_param, ":winner_party", 2),

	(try_begin),
		(eq, "$cheat_mode", 1),
		(str_store_party_name, s4, ":winner_party"),
		(str_store_party_name, s5, ":defeated_party"),
		(display_message, "str_do_political_consequences_for_s4_victory_over_s5"),
	(try_end),
	
	(store_faction_of_party, ":winner_faction", ":winner_party"),
	(try_begin),
		(eq, ":winner_party", "p_main_party"),
		(assign, ":winner_faction", "$players_kingdom"),
	(try_end),
		
	(party_get_template_id, ":defeated_party_template", ":defeated_party"),
		
	#did the battle involve travellers?	
	(try_begin),
		(this_or_next|eq, ":defeated_party_template", "pt_village_farmers"),
			(eq, ":defeated_party_template", "pt_kingdom_caravan_party"),

		(party_get_slot, ":destination", ":defeated_party", "slot_party_ai_object"),
		(party_get_slot, ":origin", ":defeated_party", "slot_party_last_traded_center"),
		
        (call_script, "script_add_log_entry", logent_traveller_attacked, ":winner_party",  ":origin", ":destination", ":winner_faction"),
		
		(try_begin),
			(eq, "$cheat_mode", 2),
			(neg|is_between, ":winner_faction", kingdoms_begin, kingdoms_end),
			(str_store_string, s65, "str_bandits_attacked_a_party_on_the_roads_so_a_bounty_is_probably_available"),
			(call_script, "script_add_notification_menu", "mnu_debug_alert_from_s65", 0, 0),

			(str_store_party_name, s15, ":origin"),
			(str_store_party_name, s16, ":destination"),
			(display_message, "str_travellers_attacked_on_road_from_s15_to_s16"),
		(try_end),
		
		
		#by logging the faction and the party, we can verify that the party number is unlikely to have been reassigned - or at any rate, that the factions have not changed 
	(try_end),
	
	#winner consequences:
	#1)   leader improves relations with other leaders
	#2)  Player given credit for victory if the victorious party is following the player's advice
	(try_begin),
		(party_get_template_id, ":winner_party_template", ":winner_party"),
		(eq, ":winner_party_template", "pt_kingdom_hero_party"),
		(neq, ":winner_party", "p_main_party"),
		#Do not do for player party, as is included in post-battle dialogs
		
		(party_stack_get_troop_id, ":winner_leader", ":winner_party", 0),
		(is_between, ":winner_leader", active_npcs_begin, active_npcs_end),
		
		(store_faction_of_party, ":winner_faction", ":winner_party"),

		(party_collect_attachments_to_party, ":winner_party", "p_temp_party_2"),
        (party_get_num_companion_stacks, ":num_stacks", "p_temp_party_2"),
		(try_for_range, ":troop_iterator", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":cur_troop_id", "p_temp_party_2", ":troop_iterator"),
            (is_between, ":cur_troop_id", active_npcs_begin, active_npcs_end),
			
			(try_begin),
				(troop_get_slot, ":winner_lord_party", ":cur_troop_id", "slot_troop_leaded_party"),
				(party_is_active, ":winner_lord_party"),				
				(call_script, "script_cf_party_under_player_suggestion", ":winner_lord_party"),
				(call_script, "script_add_log_entry", logent_player_suggestion_succeeded, "trp_player", -1, ":cur_troop_id", -1),
			(try_end),

			
			(store_faction_of_troop, ":troop_faction", ":cur_troop_id"),
			(eq, ":troop_faction", ":winner_faction"),
			(neq, ":cur_troop_id", ":winner_leader"),

			(try_begin),
				(eq, "$cheat_mode", 4),
				(str_store_troop_name, s15, ":cur_troop_id"),
				(str_store_troop_name, s16, ":winner_leader"),
				(display_message, "str_s15_shares_joy_of_victory_with_s16"),
			(try_end),
			
			(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", ":winner_leader", 3),
			(val_add, "$total_battle_ally_changes", 3),

		(try_end),
		(party_clear, "p_temp_party_2"),
	(try_end),
	
	#consequences of defeat,
	#1) -1 relation with lord per lord, plus -15 if there is an incompatible marshal
	#2)  losers under player suggestion blame the player
	#3) Some losers resent the victor lord
	#4) Possible quarrels over defeat
	(try_begin),
		(party_collect_attachments_to_party, ":defeated_party", "p_temp_party_2"),
        (party_get_num_companion_stacks, ":num_stacks", "p_temp_party_2"),

		(try_begin),
			(gt, "$marshall_defeated_in_battle", 0),
			(str_store_troop_name, s15, "$marshall_defeated_in_battle"),
			(store_faction_of_troop, ":defeated_marshall_faction", "$marshall_defeated_in_battle"),
            (try_begin),
                (eq, "$cheat_mode", 1),
			    (display_message, "str_faction_marshall_s15_involved_in_defeat"),
            (try_end),
		(else_try),
			(eq, "$marshall_defeated_in_battle", "trp_player"),
			(eq, ":defeated_party", "p_main_party"),
			(faction_slot_eq, "fac_player_supporters_faction", "slot_faction_state", sfs_active),
            (try_begin),
                (eq, "$cheat_mode", 1),
			    (display_message, "str_player_faction_marshall_involved_in_defeat"),
            (try_end),
		(else_try),	
			(assign, "$marshall_defeated_in_battle", -1),
		(try_end),
		
		(try_for_range, ":troop_iterator", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":cur_troop_id", "p_temp_party_2", ":troop_iterator"),
            (troop_slot_eq, ":cur_troop_id", "slot_troop_occupation", slto_kingdom_hero),
		
			(try_begin), #is party under suggestion?
				(troop_get_slot, ":defeated_lord_party", ":cur_troop_id", "slot_troop_leaded_party"),
				(party_is_active, ":defeated_lord_party"),

				#is party under suggestion?
				(call_script, "script_cf_party_under_player_suggestion", ":defeated_lord_party"),
				(call_script, "script_add_log_entry", logent_player_suggestion_failed, "trp_player", -1, ":cur_troop_id", -1),		
			(try_end),

			
			(store_faction_of_troop, ":troop_faction", ":cur_troop_id"),
			
			(faction_get_slot, ":faction_leader", ":troop_faction", "slot_faction_leader"),
			(neq, ":cur_troop_id", ":faction_leader"),
			
			#Lose one point relation with liege
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s14, ":cur_troop_id"),
				(str_store_faction_name, s15, ":troop_faction"),
				
				(display_message, "str_s14_of_s15_defeated_in_battle_loses_one_point_relation_with_liege"),
			(try_end),
			
			(try_begin),
				(this_or_next|neq, ":faction_leader", "trp_player"), #if leader is zero at beginning of game. I'm not entirely sure how this could happen...
					(eq, "$players_kingdom", ":troop_faction"),
				
				(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", ":faction_leader", -1),
				(val_add, "$total_battle_ally_changes", -1),
			(try_end),
			
	
			(call_script, "script_faction_inflict_war_damage_on_faction", ":winner_faction", ":troop_faction", 10),
		
			
			(try_begin),
				(this_or_next|is_between, ":winner_leader", active_npcs_begin, active_npcs_end),
					(eq, ":winner_leader", "trp_player"),
					
				(this_or_next|neq, ":winner_leader", "trp_player"), #prevents winner leader being zero, for whatever reason
					(eq, ":winner_party", "p_main_party"),
				
				(this_or_next|troop_slot_eq, ":cur_troop_id", "slot_lord_reputation_type", lrep_quarrelsome),
				(this_or_next|troop_slot_eq, ":cur_troop_id", "slot_lord_reputation_type", lrep_selfrighteous),
					(troop_slot_eq, ":cur_troop_id", "slot_lord_reputation_type", lrep_debauched),
			
				(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", ":winner_leader", -1),
				(val_add, "$total_battle_enemy_changes", -1),
				
				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_troop_name, s14, ":cur_troop_id"),
					(str_store_troop_name, s15, ":winner_leader"),
				
					(display_message, "str_s14_defeated_in_battle_by_s15_loses_one_point_relation"),
				(try_end),

				
			(try_end),
			
			(gt, "$marshall_defeated_in_battle", -1),
			(eq, ":troop_faction", ":defeated_marshall_faction"),
			(str_store_troop_name, s14, ":cur_troop_id"),
			
			(call_script, "script_cf_test_lord_incompatibility_to_s17", ":cur_troop_id", "$marshall_defeated_in_battle"),
            (try_begin),
                (eq, "$cheat_mode", 1),
			    (display_message, "str_s14_blames_s15_for_defeat"),
            (try_end),
			
			(call_script, "script_add_log_entry", logent_lord_blames_defeat, ":cur_troop_id", "$marshall_defeated_in_battle", ":faction_leader", ":winner_faction"),

			(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", ":faction_leader", -9),
			(val_add, "$total_battle_ally_changes", -9),##gdw was -15 but troops going negative too much
			
			(neq, "$marshall_defeated_in_battle", ":faction_leader"),##gdw was -15 but troops going negative too much
			(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", "$marshall_defeated_in_battle", -9),
			(val_add, "$total_battle_ally_changes", -9),
			
		(try_end),
		
		(party_clear, "p_temp_party_2"),
	(try_end),
	]),

    ("faction_inflict_war_damage_on_faction",
    [
	(store_script_param, ":actor_faction", 1),
	(store_script_param, ":target_faction", 2),
	(store_script_param, ":amount", 3),
	
	
	(store_add, ":slot_war_damage", ":target_faction", "slot_faction_war_damage_inflicted_on_factions_begin"),
	(val_sub, ":slot_war_damage", kingdoms_begin),
	(faction_get_slot, ":cur_war_damage", ":actor_faction", ":slot_war_damage"),
	
	(val_add, ":cur_war_damage", ":amount"),
	(faction_set_slot, ":actor_faction", ":slot_war_damage", ":cur_war_damage"),


	(try_begin),
	  (ge, "$cheat_mode", 1),
	  (str_store_faction_name, s4, ":actor_faction"),
	  (str_store_faction_name, s5, ":target_faction"),
	  (assign, reg3, ":cur_war_damage"),
	  (assign, reg4, ":amount"),
	  (display_message, "@{!}{s4} inflicts {reg4} damage on {s5}, raising total inflicted to {reg3}"),
	(try_end),

	
	(faction_get_slot, ":faction_marshal", ":target_faction", "slot_faction_marshall"),
	(try_begin),
		(ge, ":faction_marshal", 0),
		(gt, ":amount", 0),
		
		(troop_get_slot, ":controversy", ":faction_marshal", "slot_troop_controversy"),
		(val_add, ":controversy", ":amount"),
		(val_min, ":controversy", 100),
		(troop_set_slot, ":faction_marshal", "slot_troop_controversy", ":controversy"),
		
		(try_begin),
			(gt, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":faction_marshal"),
			(assign, reg4, ":amount"),
			(assign, reg5, ":controversy"),
			(display_message, "@{!}War damage raises {s4}'s controversy by {reg4} to {reg5}"),
		(try_end),
	(try_end),

	(faction_get_slot, ":faction_marshal", ":actor_faction", "slot_faction_marshall"),
	(try_begin),
		(ge, ":faction_marshal", 0),
		(val_div, ":amount", 3),
		(gt, ":amount", 0),
		
		
		(troop_get_slot, ":controversy", ":faction_marshal", "slot_troop_controversy"),
		(val_sub, ":controversy", ":amount"),
		(val_max, ":controversy", 0),
		(troop_set_slot, ":faction_marshal", "slot_troop_controversy", ":controversy"),
		
		(try_begin),
			(gt, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":faction_marshal"),
			(assign, reg4, ":amount"),
			(assign, reg5, ":controversy"),
			(display_message, "@{!}War damage lowers {s4}'s controversy by {reg4} to {reg5}"),
		(try_end),
	(try_end),


	
	]),
	
    ("calculate_troop_political_factors_for_liege",######HERE IT ISgdw
    [
	(store_script_param, ":troop", 1),
	(store_script_param, ":liege", 2),

	(troop_get_slot, ":lord_reputation", ":troop", "slot_lord_reputation_type"),
	
	(store_faction_of_troop, ":faction", ":liege"),

	
	(try_begin),
		(eq, ":faction", "fac_player_faction"),
		(assign, ":faction", "fac_player_supporters_faction"),
	(try_end),

	(assign, ":liege_is_undeclared_rebel", 0),
	(try_begin),
		(neg|faction_slot_eq, ":faction", "slot_faction_leader", ":liege"),
		#the liege is a rebel
		(assign, ":liege_is_undeclared_rebel", 1),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_troop_name, s32, ":liege"),
			(display_message, "str_s32_is_undeclared_rebel"),
		(try_end),
	(try_end),	
	
	(assign, ":result_for_material", 0),
	(assign, ":penalty_for_changing_sides", 0),

	

	#FACTOR 1 - MILITARY SECURITY
	(assign, ":result_for_security", 0),

	#find the lord's home
	(assign, ":base_center", -1),
	(try_begin),
		(is_between, ":troop", active_npcs_begin, active_npcs_end),
		(try_for_range, ":center", centers_begin, centers_end),
			(eq, ":base_center", -1),
			(party_slot_eq, ":center", "slot_town_lord", ":troop"),
			(assign, ":base_center", ":center"),
		(try_end),
	(try_end),
	
	(assign, ":faction_has_base", 0),
	
	#add up all other centers for the security value
	(try_for_range, ":center", centers_begin, centers_end),
		(neq, ":center", ":base_center"),
		(gt, ":base_center", 0),
	
		(try_begin),
			(is_between, ":center", towns_begin, towns_end),
			(assign, ":weight", 9000),#gdw
		(else_try),
			(is_between, ":center", castles_begin, castles_end),
			(assign, ":weight", 6000),#gdwtesting
		(else_try),
			(assign, ":weight", 1000),	
		(try_end),

		(store_distance_to_party_from_party, ":distance", ":base_center", ":center"),
		(val_add, ":distance", 10),
		(val_div, ":weight", ":distance"),
		(val_div, ":weight", ":distance"),
		##I guess we're weighting all the centers on the map here gdw
		(store_faction_of_party, ":center_faction", ":center"),

		(try_begin),
			(eq, ":center_faction", ":faction"),

			(assign, ":faction_has_base", 1),
			(val_add, ":result_for_security", ":weight"),
		(else_try),
			(neq, ":center_faction", ":faction"),
			(store_relation, ":center_relation", ":center_faction", ":faction"),
		
			(try_begin), #potentially hostile center
				(this_or_next|eq, ":liege_is_undeclared_rebel", 1),
					(lt, ":center_relation", 0),
				(val_div, ":weight", 2),
			(else_try), #neutral center
				(val_div, ":weight", 4),
			(try_end),
		
			(val_sub, ":result_for_security", ":weight"),		
		(try_end),
	(try_end),
	
	
	#if a faction controls no other centers, then there is a small bonus
	(try_begin),
		(eq, ":faction_has_base", 0),
		(val_add, ":result_for_security", 23),#gdw20 help out centerless factions more
		(try_begin),
			(eq, "$cheat_mode", 2),
			(display_debug_message, "str_small_bonus_for_no_base"),
		(try_end),
	(try_end),
	(val_clamp, ":result_for_security", -100, 100),

	
	(assign, ":result_for_security_weighted", ":result_for_security"),
	(try_begin),
		(eq, ":lord_reputation", lrep_cunning),
		(val_mul, ":result_for_security_weighted", 2),
	(else_try),
		(eq, ":lord_reputation", lrep_debauched),#gdw
		(val_mul, ":result_for_security_weighted", 2),
	(try_end),



	#FACTOR 2 - INTERNAL FACTION POLITICS
	#this is a calculation of how much influence the lord believes he will have in each faction
	(assign, ":result_for_political", 0),
	
    (try_for_range, ":loop_var", "trp_kingdom_heroes_including_player_begin", active_npcs_end),
        (assign, ":kingdom_hero", ":loop_var"),

		(this_or_next|troop_slot_eq, ":kingdom_hero", "slot_troop_occupation", slto_kingdom_hero),
		(this_or_next|eq, ":kingdom_hero", "trp_kingdom_heroes_including_player_begin"),
			(is_between, ":kingdom_hero", pretenders_begin, pretenders_end),

		(store_faction_of_troop, ":kingdom_hero_faction", ":kingdom_hero"),

        (try_begin),
            (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
            (assign, ":kingdom_hero", "trp_player"),
			(assign, ":kingdom_hero_faction", "$players_kingdom"),
			(try_begin), #do not count player relation if the player is trying to #suborn the character. this has the slight potential for a miscalculation, if the #script is called from outside dialogs and $g_talk_troop has #not been reset
				(eq, "$g_talk_troop", ":troop"),
				(store_faction_of_troop, ":cur_faction", ":troop"),
				(eq, ":cur_faction", ":faction"),
				(assign, ":kingdom_hero_faction", 0),
			(try_end),	
		(try_end),
		
		(eq, ":kingdom_hero_faction", ":faction"),
		(neg|faction_slot_eq, ":kingdom_hero_faction", "slot_faction_leader", ":kingdom_hero"),
		(neq, ":liege_is_undeclared_rebel", 1),
		(neg|is_between, ":kingdom_hero", pretenders_begin, pretenders_end),
		
						
		(call_script, "script_troop_get_relation_with_troop", ":troop", ":kingdom_hero"),
		(assign, ":troop_rel_w_hero", reg0),

		(call_script, "script_troop_get_relation_with_troop", ":kingdom_hero", ":liege"),
		(assign, ":hero_rel_w_liege", reg0),

		(store_mul, ":lord_political_weight", ":troop_rel_w_hero", ":hero_rel_w_liege"),
		(val_div, ":lord_political_weight", 100),

		(try_begin),
			(eq, "$cheat_mode", 2), #disabled
			(eq, "$g_talk_troop", ":troop"),
			(str_store_faction_name, s20, ":kingdom_hero_faction"),
			(str_store_troop_name, s15, ":kingdom_hero"),
			(assign, reg15, ":lord_political_weight"),
			(display_message, "str_s15_considered_member_of_faction_s20_weight_of_reg15"),
		(try_end),
		
		(val_add, ":result_for_political", ":lord_political_weight"),
	(try_end),			

	(val_clamp, ":result_for_political", -100, 101), #lords portion represents half
	
	(try_begin),
		(call_script, "script_troop_get_relation_with_troop", ":troop", ":liege"),
		(assign, ":liege_relation", reg0),
		(val_add, ":result_for_political", ":liege_relation"),
	(try_end),	

	(val_div, ":result_for_political", 2),
	
	(val_clamp, ":result_for_political", -100, 101), #liege portion represents half
	
	(assign, ":result_for_political_weighted", ":result_for_political"),
	
	(try_begin),
		(this_or_next|eq, ":lord_reputation", lrep_goodnatured),
			(eq, ":lord_reputation", lrep_quarrelsome),
		(val_mul, ":result_for_political_weighted", 2),
	(try_end),

	#FACTOR 3 - PROMISES AND OTHER ANTICIPATED GAINS
	#lord's calculation of anticipated gains
	(assign, ":result_for_material", 0),
	(assign, ":result_for_material_weighted", ":result_for_material"),

	
	#FACTOR 4 - IDEOLOGY
	#lord's calculation of ideological comfort
	(try_begin),
		#Originally, the argument section was not used for a non-player liege. Actually, it can be used
		(eq, 1, 0),
		(neq, ":liege", "trp_player"),
		(neq, ":liege", "$supported_pretender"), #player is advocate for pretender
		(assign, ":argument_strength", 0),
		(assign, ":argument_appeal", 0),
		(assign, ":result_for_argument", 0),
	(else_try),	#only if the recruitment candidate is either the player, or a supported pretender
		(troop_get_slot, ":recruitment_argument", ":troop", "slot_lord_recruitment_argument"),

		(call_script, "script_rebellion_arguments", ":troop", ":recruitment_argument", ":liege"),
		(assign, ":argument_appeal", reg0),
		(assign, ":argument_strength", reg1),
		
		(store_add, ":result_for_argument", ":argument_appeal", ":argument_strength"),

		(store_skill_level, ":player_persuasion_skill", "skl_persuasion", "trp_player"),
		(try_begin),
			(gt, ":result_for_argument", 0),
			#make sure player is the one making the overture
			
			#if player has 0 persuasion, ":result_for_argument" will be multiplied by 3/10.
			(store_add, ":player_persuasion_skill_plus_5_mul_066", ":player_persuasion_skill", 5),
			(val_mul, ":player_persuasion_skill_plus_5_mul_066", 5),#gdw2  augmenting persuasion effect
			(val_div, ":player_persuasion_skill_plus_5_mul_066", 3),
			
			(val_mul, ":result_for_argument", ":player_persuasion_skill_plus_5_mul_066"),
			(val_div, ":result_for_argument", 10),
		(else_try),#gdw don't see why this would be needed even with a negative #result for argument
			(lt, ":result_for_argument", 0),
			(store_sub, ":ten_minus_player_persuasion_skill", 10, ":player_persuasion_skill"),
			(val_mul, ":result_for_argument", ":ten_minus_player_persuasion_skill"),
			(val_div, ":result_for_argument", 10),
		(try_end),
##below for nonplayer faction defections (could be too player faction)		
		(try_begin),
			(neq, ":liege", "trp_player"),
			(neq, ":liege", "$supported_pretender"), #player is advocate for pretender
			(val_div, ":argument_strength", 2),
			(val_div, ":argument_appeal", 2),
			(val_div, ":result_for_argument", 2),		
		(try_end),
		
	(try_end),
	
	(assign, ":result_for_ideological_weighted", ":result_for_argument"),
	(try_begin),
#		(eq, ":lord_reputation", lrep_cunning),#gdw
#		(val_div, ":result_for_ideological_weighted", 2),
#	(else_try),
		(eq, ":lord_reputation", lrep_upstanding),
		(val_mul, ":result_for_ideological_weighted", 2),#gdwcouldbecancelled out by low rtr below
	(else_try),
		(eq, ":lord_reputation", lrep_goodnatured),
		(val_mul, ":result_for_ideological_weighted", 2),#gdwcanceled out by low rtr below
	(try_end),


	#FACTOR 5 - PENALTY FOR CHANGING SIDES
	(try_begin), #no penalty for the incumbent
		(store_faction_of_troop, ":cur_faction", ":troop"),
		(eq, ":cur_faction", ":faction"),
		(assign, ":penalty_for_changing_sides", 0),
	(else_try), #penalty for the player##was at 60##is this for leavingplayer faction
		(eq, ":liege", "trp_player"),
		(store_sub, ":penalty_for_changing_sides", 54, "$player_right_to_rule"),
		(val_max, ":penalty_for_changing_sides", 0),
	(else_try), #same culture, such as a pretender
		(troop_get_slot, ":orig_faction_of_lord", ":troop", "slot_troop_original_faction"),
		(troop_get_slot, ":orig_faction_of_liege", ":liege", "slot_troop_original_faction"),
		(eq, ":orig_faction_of_lord", ":orig_faction_of_liege"),
		(assign, ":penalty_for_changing_sides", 9),#gdw from 10##just following liege
	(else_try), #a liege from a different culture
		(assign, ":penalty_for_changing_sides", 47),#gdw from 50
	(try_end),
	(val_clamp, ":penalty_for_changing_sides", 0, 90),#gdw101??why would it go above 50?
	
	(assign, ":penalty_for_changing_sides_weighted", ":penalty_for_changing_sides"),
	(try_begin),#originally the was debauched getting unreal bonus for defection
		(eq, ":lord_reputation", lrep_goodnatured),#gdwGN too easy to persuade with 
		(val_mul, ":penalty_for_changing_sides_weighted", 2),#commoner argument
	(else_try),
		(eq, ":lord_reputation", lrep_upstanding),
		(val_mul, ":penalty_for_changing_sides_weighted", 2),
	(else_try),
		(eq, ":lord_reputation", lrep_upstanding),
		(val_mul, ":penalty_for_changing_sides_weighted", 2),
	(try_end),

	
	
	(assign, reg1, ":result_for_security"),
	(assign, reg2, ":result_for_security_weighted"),
	(assign, reg3, ":result_for_political"),
	(assign, reg4, ":result_for_political_weighted"),
	(assign, reg5, ":result_for_material"),
	(assign, reg6, ":result_for_material_weighted"),
	(assign, reg7, ":argument_strength"),
	(assign, reg17, ":argument_appeal"),

	(assign, reg8, ":result_for_argument"),
	(assign, reg9, ":penalty_for_changing_sides"),
	(assign, reg10, ":penalty_for_changing_sides_weighted"),

	
	(try_begin),
		(eq, "$cheat_mode", 1),
		(eq, "$g_talk_troop", ":troop"),
		(str_store_troop_name, s20, ":troop"),
		(str_store_faction_name, s21, ":faction"),
		(str_store_troop_name, s22, ":liege"),
		
		(display_message, "@{!}G_talk_troop {s20} evaluates being vassal to {s22} of {s21}"),

		(display_message, "str_base_result_for_security_reg1"),
		(display_message, "str_result_for_security_weighted_by_personality_reg2"),
		(display_message, "str_base_result_for_political_connections_reg3"),	
		(display_message, "str_result_for_political_connections_weighted_by_personality_reg4"),	
		(display_debug_message, "@{!}Result for anticipated_gains: {reg5}"),	
		(display_debug_message, "@{!}Result for anticipated_gains weighted by personality: {reg6}"),	

		(try_begin),
			(this_or_next|eq, ":liege", "trp_player"),
				(eq, ":liege", "$supported_pretender"), #player is advocate for pretender
			(display_debug_message, "str_result_for_argument_strength_reg7"),	
			(display_debug_message, "str_result_for_argument_appeal_reg17"),	
			(display_debug_message, "str_combined_result_for_argument_modified_by_persuasion_reg8"),
		(try_end),			
		(display_debug_message, "str_base_changing_sides_penalty_reg9"),	
		(display_debug_message, "str_changing_sides_penalty_weighted_by_personality_reg10"),	
	(try_end),
		
	(store_add, ":total", ":result_for_security_weighted", ":result_for_political_weighted"),
	(val_add, ":total", ":result_for_material_weighted"),
	(val_add, ":total", ":result_for_argument"),
	(val_sub, ":total", ":penalty_for_changing_sides_weighted"),


	(assign, reg0, ":total"),

	(try_begin),
		(eq, "$cheat_mode", 2),
		(display_debug_message, "@{!}DEBUG -- Analyzing lord allegiances, combined bonuses and penalties = {reg0}"),
		#(display_message, "str_combined_bonuses_and_penalties_=_reg0"),
	(try_end),
	]),
	  


    ("cf_troop_can_intrigue",
	#This script should be called from dialogs, and also prior to any event which might result in a lord changing sides
    [
      (store_script_param, ":troop", 1),
      (store_script_param, ":skip_player_party", 2),
##     #chief anade para quitar lords principales que cambien de bando Esto crea conflicto cuando lores pierden faccion, anulado
##     (neq, ":troop", "trp_knight_1_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_1_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_2_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_2_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_3_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_3_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_4_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_4_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_4_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_4_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_5_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_5_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_5_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_5_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_6_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_6_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_7_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_8_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_8_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_8_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_8_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_9_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_9_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_9_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_9_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_10_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_11_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_11_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_11_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_11_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_12_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_12_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_13_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_13_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_13_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_13_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_14_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_14_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_15_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_15_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_15_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_16_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_16_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_17_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_17_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_17_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_17_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_18_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_18_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_18_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_18_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_19_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_19_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_19_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_19_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_20_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_20_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_20_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_20_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_20_5"), ##ADD THIS
##     (neq, ":troop", "trp_knight_21_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_22_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_22_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_23_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_23_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_24_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_24_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_25_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_26_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_26_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_27_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_27_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_28_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_28_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_28_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_28_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_29_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_29_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_30_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_30_2"), ##ADD THIS
##     (neq, ":troop", "trp_knight_30_3"), ##ADD THIS
##     (neq, ":troop", "trp_knight_30_4"), ##ADD THIS
##     (neq, ":troop", "trp_knight_31_1"), ##ADD THIS
##     (neq, ":troop", "trp_knight_31_2"), ##ADD THIS
###lords que no pueden cambiar de bando acaba chief

      (troop_get_slot, ":led_party_1", ":troop", "slot_troop_leaded_party"),
      (party_is_active, ":led_party_1"),
      
      (try_begin),
        (eq, "$cheat_mode", 1),
        (eq, ":troop", "$g_talk_troop"),
        (display_debug_message, "str_intrigue_test_troop_party_is_active",0xFF0000),
      (try_end),
      
      (party_get_battle_opponent, ":battle_opponent", ":led_party_1"),
      (le, ":battle_opponent", 0), #battle opponent can be 0 for an attached party?
      
      (try_begin),
        (eq, "$cheat_mode", 1),
        (eq, ":troop", "$g_talk_troop"),
        (display_debug_message, "str_intrigue_test_troop_party_is_not_in_battle",0xFF0000),
      (try_end),
      
      (troop_slot_eq, ":troop", "slot_troop_prisoner_of_party", -1),
      
      (try_begin),
        (eq, "$cheat_mode", 1),
        (eq, ":troop", "$g_talk_troop"),
        (display_debug_message, "str_intrigue_test_troop_is_not_prisoner",0xFF0000),
      (try_end),
      
      (party_get_attached_to, ":led_party_1_attached", ":led_party_1"),
      
      (store_faction_of_party, ":led_party_1_faction", ":led_party_1"),
      
      (assign, ":other_lords_nearby", 0),
      (try_for_range, ":troop_2", active_npcs_begin, active_npcs_end),
        (neq, ":troop", ":troop_2"),
        (eq, ":other_lords_nearby", 0),
        
        (troop_slot_eq, ":troop_2", "slot_troop_occupation", slto_kingdom_hero),
        
        (troop_get_slot, ":led_party_2", ":troop_2", "slot_troop_leaded_party"),
        (party_is_active, ":led_party_2"),
        (neq, ":led_party_1", ":led_party_2"),
        
        (store_faction_of_party, ":led_party_2_faction", ":led_party_2"),
        (eq, ":led_party_1_faction", ":led_party_2_faction"),
        
        (try_begin),###same-lord faction nearby
          (eq, ":led_party_1_attached", -1),
          (store_distance_to_party_from_party, ":distance", ":led_party_1", ":led_party_2"),
          (lt, ":distance", 3),
          (assign, ":other_lords_nearby", 1),
        (else_try),###they're in the same town
          (is_between, ":led_party_1_attached", walled_centers_begin, walled_centers_end),
          (party_get_attached_to, ":led_party_2_attached", ":led_party_2"),
          (eq, ":led_party_1_attached", ":led_party_2_attached"),
          (assign, ":other_lords_nearby", 1),
        (try_end),
      (try_end),
      
      (try_begin),
        (eq, "$cheat_mode", 1),
        (eq, ":troop", "$g_talk_troop"),
        (display_debug_message, "str_intrigue_test_troop_is_nearby",0xFF0000),
      (try_end),
      
      (try_begin),
        (eq, ":skip_player_party", 0),
        #temporary spot
      (try_end),
      
      (eq, ":other_lords_nearby", 0),	
	]),


    ("troop_change_relation_with_troop",
    [
	(store_script_param, ":troop1", 1),
	(store_script_param, ":troop2", 2),
	(store_script_param, ":amount", 3),

	(try_begin),
		(eq, ":troop1", "trp_player"),
		(call_script, "script_change_player_relation_with_troop", ":troop2", ":amount"),
	(else_try),	
		(eq, ":troop2", "trp_player"),
		(call_script, "script_change_player_relation_with_troop", ":troop1", ":amount"),
	(else_try),	
		(eq, ":troop1", ":troop2"),
		
	(else_try),
		(call_script, "script_troop_get_relation_with_troop", ":troop1", ":troop2"),
		(store_add, ":new_relation", reg0, ":amount"),

		(val_clamp, ":new_relation", -100, 101),

		(try_begin),
			(eq, ":new_relation", 0),
			(assign, ":new_relation", 1), #this removes the need for a separate "met" slot - any non-zero relation will be a met
		(try_end),
		
		(store_add, ":troop1_slot_for_troop2", ":troop2", "slot_troop_relations_begin"),
		(troop_set_slot, ":troop1", ":troop1_slot_for_troop2", ":new_relation"),
	
		(store_add, ":troop2_slot_for_troop1", ":troop1", "slot_troop_relations_begin"),
		(troop_set_slot, ":troop2", ":troop2_slot_for_troop1", ":new_relation"),
	(try_end),
	
	
	(try_begin), #generate controversy if troops are in the same faciton
		(lt, ":amount", -5),
		(try_begin),
			(eq, ":troop1", "trp_player"),
			(assign, ":faction1", "$players_kingdom"),
		(else_try),	
			(store_faction_of_troop, ":faction1", ":troop1"),
		(try_end),
		(try_begin),
			(eq, ":troop2", "trp_player"),
			(assign, ":faction2", "$players_kingdom"),
		(else_try),	
			(store_faction_of_troop, ":faction2", ":troop2"),
		(try_end),
		(eq, ":faction1", ":faction2"),
		(is_between, ":faction1", kingdoms_begin, kingdoms_end),
		
		(store_mul, ":controversy_generated", ":amount", -1),
	
		(troop_get_slot, ":controversy1", ":troop1", "slot_troop_controversy"),
		(val_add, ":controversy1", ":controversy_generated"),
		(val_min, ":controversy1", 100),
		(troop_set_slot, ":troop1", "slot_troop_controversy", ":controversy1"),

		(troop_get_slot, ":controversy2", ":troop2", "slot_troop_controversy"),
		(val_add, ":controversy2", ":controversy_generated"),
		(val_min, ":controversy2", 100),
		(troop_set_slot, ":troop2", "slot_troop_controversy", ":controversy2"),
		
	(try_end),
	
	(try_begin),
		(is_between, ":troop1", active_npcs_begin, active_npcs_end),
		(is_between, ":troop2", active_npcs_begin, active_npcs_end),
		(neq, ":troop1", ":troop2"),
		
		(try_begin),
			(gt, ":amount", 0),
			(val_add, "$total_relation_adds", ":amount"),
		(else_try),
			(val_sub, "$total_relation_subs", ":amount"),
		(try_end),
	(try_end),
	
	(try_begin),
		(eq, "$cheat_mode", 1), #This was at 4 but never showed in cheat mode gdw81415
		
		(is_between, ":troop1", active_npcs_begin, active_npcs_end),
		(is_between, ":troop2", active_npcs_begin, active_npcs_end),
		(neq, ":troop1", ":troop2"),
		
		(str_store_troop_name, s20, ":troop1"),
		(str_store_troop_name, s15, ":troop2"),
		(assign, reg4, ":amount"),
		(assign, reg14, ":new_relation"),
		# (try_begin),
		# (eq, "$cheat_mode", 1), #This was at 4 but never showed in cheat mode gdw81415
		(display_message, "@{!} --new relation change!--"),
		(display_message, "str_s20_relation_with_s15_changed_by_reg4_to_reg14"),
		
		(assign, reg4, "$total_relation_adds"),
		(display_debug_message, "str_total_additions_reg4", 0xFF0000),
		(assign, reg4, "$total_relation_subs"),
		(display_message, "str_total_subtractions_reg4"),
		
		(assign, reg4, "$total_courtship_quarrel_changes"),
		(display_message, "@{!}DEBUG -- Total courtship quarrel changes: {reg4}"),

		(assign, reg4, "$total_random_quarrel_changes"),
		(display_log_message, "@{!}DEBUG -- Total random quarrel changes: {reg4}"),
		
		(assign, reg4, "$total_battle_ally_changes"),
		(display_message, "@{!}DEBUG -- Total battle changes for allies: {reg4}"),

		(assign, reg4, "$total_battle_enemy_changes"),
		(display_message, "@{!}DEBUG -- Total battle changes for enemies: {reg4}"),

		(assign, reg4, "$total_promotion_changes"),
		(display_message, "@{!}DEBUG -- Total promotion changes: {reg4}"),
		
		(assign, reg4, "$total_feast_changes"),
		(display_message, "@{!}DEBUG -- Total feast changes: {reg4}"),
		
		(assign, reg4, "$total_policy_dispute_changes"),
		(assign, reg5, "$number_of_controversial_policy_decisions"),		
		(display_message, "@{!}DEBUG -- Total policy dispute changes: {reg4} from {reg5} decisions"),

		(assign, reg4, "$total_indictment_changes"),
		(display_message, "@{!}DEBUG -- Total faction switch changes: {reg4}"),

		(assign, reg4, "$total_no_fief_changes"),
		(display_message, "@{!}DEBUG -- Total no fief changes: {reg4}"),

		(assign, reg4, "$total_relation_changes_through_convergence"),
		(display_message, "@{!}DEBUG -- Total changes through convergence: {reg4}"),
		
		(assign, reg4, "$total_vassal_days_responding_to_campaign"),
		(display_message, "@{!}DEBUG -- Total vassal responses to campaign: {reg4}"),
		
		(assign, reg4, "$total_vassal_days_on_campaign"),
		(display_message, "@{!}DEBUG -- Total vassal campaign days: {reg4}",0xFF0000),
		
		(val_max, "$total_vassal_days_on_campaign", 1),
		(store_mul, ":response_rate", "$total_vassal_days_responding_to_campaign", 100),
		(val_div, ":response_rate", "$total_vassal_days_on_campaign"),
		(assign, reg4, ":response_rate"),
		(display_message, "@{!}DEBUG -- Vassal response rate: {reg4}"),

		
		
		
		# (assign, reg4, "$total_joy_battle_changes"),
		# (display_message, "@{!}DEBUG -- Total joy of battle changes"),
		
	(try_end),

	]),


    ("troop_get_relation_with_troop",
    [
	(store_script_param, ":troop1", 1),
	(store_script_param, ":troop2", 2),

	(assign, ":relation", 0),
	(try_begin),
		(this_or_next|eq, ":troop1", -1),
			(eq, ":troop2", -1),

		#Possibly switch to relation with liege	
		(assign, ":relation", 0),
	(else_try),
		(eq, ":troop1", "trp_player"),
		(call_script, "script_troop_get_player_relation", ":troop2"),
		(assign, ":relation", reg0),
	(else_try),
		(eq, ":troop2", "trp_player"),
		(call_script, "script_troop_get_player_relation", ":troop1"),
		(assign, ":relation", reg0),
	(else_try),
		(store_add, ":troop1_slot_for_troop2", ":troop2", "slot_troop_relations_begin"),
		(troop_get_slot, ":relation", ":troop1", ":troop1_slot_for_troop2"),
	(try_end),
	
	
	(val_clamp, ":relation", -100, 101),
	(assign, reg0, ":relation"),
	
	]),

	
	
	("appoint_faction_marshall",
    [
	(store_script_param, ":faction_no", 1),
	(store_script_param, ":faction_marshall", 2),


    (faction_get_slot, ":faction_leader", ":faction_no", "slot_faction_leader"),
    (faction_get_slot, ":old_marshall", ":faction_no", "slot_faction_marshall"),

    (faction_set_slot, ":faction_no", "slot_faction_marshall", ":faction_marshall"),

    # (faction_get_slot, ":old_marshall", ":faction_no", "slot_faction_marshall"),	MOTO chief this just sets old_marshall to current_marshall, so old_marshall never processed!
    (try_begin),
		(ge, ":old_marshall", 0),
		(troop_get_slot, ":old_marshall_party", ":old_marshall", "slot_troop_leaded_party"),
        (party_is_active, ":old_marshall_party"),
        (party_set_marshall, ":old_marshall_party", 0),
    (try_end),  

    
    (try_begin),
      (ge, ":faction_marshall", 0),
	  (troop_get_slot, ":new_marshall_party", ":faction_marshall", "slot_troop_leaded_party"),
      (party_is_active, ":new_marshall_party"),
      (party_set_marshall,":new_marshall_party", 1),
    (try_end),  
	
	
	(try_begin),###get bonus relation with liege if chosen marshall
		(neq, ":faction_marshall", ":faction_leader"),
		(neq, ":faction_marshall", ":old_marshall"),
		(this_or_next|eq, ":faction_marshall", "trp_player"),
			(is_between, ":faction_marshall", active_npcs_begin, active_npcs_end),
			
		(this_or_next|neq, ":faction_no", "fac_player_supporters_faction"),
			(neg|check_quest_active, "qst_rebel_against_kingdom"),

		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_faction_name, s15, ":faction_no"),
			(display_message, "str_checking_lord_reactions_in_s15"),
		(try_end),

		
		(call_script, "script_troop_change_relation_with_troop", ":faction_marshall", ":faction_leader", 6),
		(val_add, "$total_promotion_changes", 6),
		
		(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
			(troop_slot_eq, ":lord", "slot_troop_occupation", slto_kingdom_hero),
			(store_faction_of_troop, ":lord_faction", ":lord"),
			(eq, ":lord_faction", ":faction_no"),

			(neq, ":lord", ":faction_marshall"),
			(neq, ":lord", ":faction_leader"),

			(call_script, "script_troop_get_relation_with_troop", ":faction_marshall", ":lord"),
			(store_sub, ":adjust_relations", reg0, 10),
			(val_div, ":adjust_relations", 15),
			(neq, ":adjust_relations", 0),
			(assign, reg5, ":adjust_relations"),
			(try_begin),  ###gdw this was commeneted out
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s14, ":lord"),
				(str_store_troop_name, s17, ":faction_marshall"),
				(display_message, "@{!}{s14}'s relation with {s17} was {reg0} but has dropped {reg5}"),##gdw
			(try_end),

			#Not negatively affected if they favored the lord
			(try_begin),
				(troop_slot_eq, ":lord", "slot_troop_stance_on_faction_issue", ":faction_marshall"),
				(val_add, ":adjust_relations", 1),
				(val_max, ":adjust_relations", 0),
			(try_end),

			(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":lord", ":adjust_relations"),
			(val_add, "$total_promotion_changes", ":adjust_relations"),
			
			(lt, ":adjust_relations", -2),
			(store_random_in_range, ":random", 1, 10),
			
			(val_add, ":adjust_relations", ":random"),
			
			(lt, ":adjust_relations", 0),
			
			(str_store_troop_name, s14, ":lord"),
			(str_store_troop_name, s15, ":faction_marshall"),

			(try_begin),
                (eq, "$cheat_mode", 1),
                (display_message, "str_s14_protests_the_appointment_of_s15_as_marshall"),
            (try_end),

			(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":lord", -10),
			(call_script, "script_troop_change_relation_with_troop", ":faction_marshall", ":lord", -5),
			(val_add, "$total_promotion_changes", -15),
			
			(call_script, "script_add_log_entry", logent_lord_protests_marshall_appointment, ":lord",  ":faction_marshall", ":faction_leader", "$g_encountered_party_faction"),

		(try_end),
	(try_end),
	
		]),

	("lord_get_home_center",
	[
      (store_script_param, ":troop_no", 1),
      (assign, ":result", -1),
      
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
        (assign, ":result", ":center_no"),
      (try_end),
      
      #NOTE : In old code if a lord has no walled center then home city of this lord is assigning to 
      #faction leader's home city. Now I changed this to assign home cities more logical and homogeneous.
      #In new code if a lord has no walled center then his home city becomes his village's border_city.
      #This means his home city becomes owner city of his village. If he has no village then as last change 
      #his home city become faction leader's home city.
      (try_begin),
        (eq, ":result", -1),
        (try_for_range, ":center_no", centers_begin, centers_end),
          (eq, ":result", -1),
          (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
          
          (try_begin),
            (neg|is_between, ":center_no", walled_centers_begin, walled_centers_end),
            (party_get_slot, ":bound_center", ":center_no", "slot_village_bound_center"),            
            (assign, ":result", ":bound_center"),
          (try_end),
        (try_end),      
      (try_end),
      
      #If lord has no walled center and is player faction, then assign player court
      (try_begin),
        (eq, ":result", -1),
        (store_faction_of_troop, ":faction_no", ":troop_no"),
        (eq, ":faction_no", "fac_player_supporters_faction"),
		(is_between, "$g_player_court", walled_centers_begin, walled_centers_end),
		(store_faction_of_party, ":player_court_faction", "$g_player_court"),
		(eq, ":player_court_faction", "fac_player_supporters_faction"),
		
        (assign, ":result", "$g_player_court"),
      (try_end),
      
      #If lord has no walled center and any not walled village then assign faction capital
      (try_begin),
        (eq, ":result", -1),
        (store_faction_of_troop, ":faction_no", ":troop_no"),
        (faction_get_slot, ":faction_leader", ":faction_no", "slot_faction_leader"),
        (neq, ":troop_no", ":faction_leader"),
						  (ge, ":faction_leader", 0), # Bugfix to filter invalid faction leader values.  Floris 2.6 chief - Windyplains
        (call_script, "script_lord_get_home_center", ":faction_leader"),
        (gt, reg0, -1),
        (assign, ":result", reg0),
      (try_end),
      
	  #Any center of the faction
      (try_begin),
        (eq, ":result", -1),
		(store_faction_of_troop, ":faction_no", ":troop_no"),
		
		(try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
		    (eq, ":result", -1),

			(store_faction_of_party, ":center_faction", ":walled_center"),
			(eq, ":faction_no", ":center_faction"),
			(assign, ":result", ":walled_center"),
		(try_end),
      (try_end),
	  
	  
	  
      (assign, reg0, ":result"),	
	]),
	
	
	
	
	("get_kingdom_lady_social_determinants", #Calradian society is rather patriarchal, at least among the upper classes
    [
	(store_script_param, ":kingdom_lady", 1),
	
	(store_faction_of_troop, ":faction_of_lady", ":kingdom_lady"),
	(assign, ":center", -1),
	(assign, ":closest_male_relative", -1),
	(assign, ":best_center_score", 0),
	
	(try_begin),
		(troop_slot_ge, ":kingdom_lady", "slot_troop_spouse", 0),
		(troop_get_slot, ":closest_male_relative", ":kingdom_lady", "slot_troop_spouse"),
	(else_try),
		(troop_slot_ge, ":kingdom_lady", "slot_troop_father", 0),
		(troop_get_slot, ":closest_male_relative", ":kingdom_lady", "slot_troop_father"),
	(else_try),
		(troop_slot_ge, ":kingdom_lady", "slot_troop_guardian", 0),
		(troop_get_slot, ":closest_male_relative", ":kingdom_lady", "slot_troop_guardian"),
	(try_end),
	
	
	(try_begin), #if ongoing social event (maybe add if not besieged)
		(faction_slot_eq, ":faction_of_lady", "slot_faction_ai_state", sfai_feast),
		(faction_get_slot, ":feast_center", ":faction_of_lady", "slot_faction_ai_object"),

		(gt, ":closest_male_relative", -1),
		(troop_get_slot, ":closest_male_party", ":closest_male_relative", "slot_troop_leaded_party"),
		(party_is_active, ":closest_male_party"),
		(party_get_attached_to, ":closest_male_cur_location", ":closest_male_party"),
		
		(eq, ":closest_male_cur_location", ":feast_center"),
		(is_between, ":feast_center", walled_centers_begin, walled_centers_end),
		
		(assign, ":center", ":feast_center"),
		
	(else_try),
		(troop_slot_eq, "trp_player", "slot_troop_spouse", ":kingdom_lady"),
		###diplomacy chief begin
    (try_begin),
    ##diplomacy chief end
		(is_between, "$g_player_court", walled_centers_begin, walled_centers_end),
		(assign, ":center", "$g_player_court"),
		##diplomacy chief begin
    (else_try),
      (troop_get_slot, ":cur_residence", ":kingdom_lady", "slot_troop_cur_center"),
      (is_between, ":cur_residence", walled_centers_begin, walled_centers_end),
      (party_slot_eq, ":cur_residence", "slot_town_lord", "trp_player"),
      (assign, ":center", ":cur_residence"),
    (try_end),
    (is_between, ":center",  walled_centers_begin, walled_centers_end),
    ##diplomacy chief end		
		
	(else_try),
		(try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
			(store_faction_of_party, ":walled_center_faction", ":walled_center"),
			(this_or_next|eq, ":faction_of_lady", ":walled_center_faction"),
				(neg|is_between, ":faction_of_lady", kingdoms_begin, kingdoms_end), #lady married to a player without a faction
				
			(party_get_slot, ":castle_lord", ":walled_center", "slot_town_lord"),
		
			(gt, ":castle_lord", -1),
			
			(call_script, "script_troop_get_family_relation_to_troop", ":kingdom_lady", ":castle_lord"),

			(try_begin),
				(this_or_next|is_between, ":faction_of_lady", kingdoms_begin, kingdoms_end),
					(troop_slot_eq, "trp_player", "slot_troop_spouse", ":kingdom_lady"),
					
				(faction_slot_eq, ":faction_of_lady", "slot_faction_leader", ":castle_lord"),
				(val_max, reg0, 1),
			(try_end),
			
			(try_begin),
				(eq, "$cheat_mode", 2),
				(str_store_troop_name, s3, ":kingdom_lady"),
				(str_store_troop_name, s4, ":castle_lord"),
				(str_store_party_name, s5, ":walled_center"),
				(display_message, "str_checking_s3_at_s5_with_s11_relationship_with_s4_score_reg0"),
				(str_clear, s11),
			(try_end),

			(gt, reg0, ":best_center_score"),
		
			(assign, ":best_center_score", reg0),
			(assign, ":center", ":walled_center"),
			
			
	    (try_end),
	(try_end),

	(assign, reg0, ":closest_male_relative"),
	(assign, reg1, ":center"),
	
	
	]),

	
	#This is probably unnecessarily complicated, but can support a multi-generational mod
	("age_troop_one_year",
    [
	(store_script_param, ":troop_no", 1),

	(troop_get_type, ":is_female", ":troop_no"),
	
	(troop_get_slot, ":age", ":troop_no", "slot_troop_age"),
	(troop_get_slot, ":appearance", ":troop_no", "slot_troop_age_appearance"),
	
	(val_add, ":age", 1),
	(store_random_in_range, ":addition", 1, 5),

	(try_begin),
###gender fix chief
       (this_or_next|eq, ":is_female", 1), #female
       (this_or_next|eq, ":is_female", 3), #female
       (this_or_next|eq, ":is_female", 5), #female
       (eq, ":is_female", 7), #female
#gender fix chief acaba
#		(val_add, ":addition", 2), #the women's age slider seems to produce less change than the male one - commented out: makes women look too old.
	(try_end),
	
	(val_add, ":appearance", ":addition"),
	(try_begin),
		(gt, ":age", 45),
		(store_attribute_level, ":strength", ":troop_no", ca_strength),
		(store_attribute_level, ":agility", ":troop_no", ca_agility),
		(store_random_in_range, ":random", 0, 50), #2% loss brings it down to about 36% by age 90, but of course can be counteracted by new level gain
		(try_begin),
			(lt, ":random", ":strength"),
			(troop_raise_attribute, ":troop_no", ca_strength, -1),
		(try_end),
		(try_begin),
			(lt, ":random", ":agility"),
			(troop_raise_attribute, ":troop_no", ca_agility, -1),
		(try_end),
	(try_end),

	(val_clamp, ":appearance", 1, 100),
	
	(troop_set_slot, ":troop_no", "slot_troop_age", ":age"),
	(troop_set_slot, ":troop_no", "slot_troop_age_appearance", ":appearance"),
	(troop_set_age, ":troop_no", ":appearance"),
	]),
	

	("add_lady_items",
	[
	(store_script_param, ":lady_no", 1),
	(troop_equip_items, ":lady_no"),
	
	(store_faction_of_troop, ":faction_no", ":lady_no"),
	
	(store_random_in_range, ":random", 0, 6),
	
	(try_begin), #assign clothes
		(this_or_next|troop_slot_eq, ":lady_no", "slot_lord_reputation_type", lrep_adventurous),
			(troop_slot_eq, ":lady_no", "slot_lord_reputation_type", lrep_ambitious),
	
		(this_or_next|troop_slot_eq, ":lady_no", "slot_lord_reputation_type", lrep_adventurous),
			(lt, ":random", 2),
		#cambio chief empieza	
		(neg|troop_slot_ge, ":lady_no", "slot_troop_age", 40),
		(try_begin),
			(eq, ":faction_no", "fac_kingdom_2"),
			(lt, ":random", 4),
			(troop_add_item, ":lady_no", "itm_briton_dress_blue", 0),
		(else_try),
			(eq, ":faction_no", "fac_kingdom_3"),
			(lt, ":random", 3),
			(troop_add_item, ":lady_no", "itm_briton_dress_blue", 0),
		(else_try),	
			(troop_add_item, ":lady_no", "itm_briton_dress_blue", 0),
		(try_end),
	(else_try),
		(eq, ":faction_no", "fac_kingdom_1"),
		(try_begin),
			(lt, ":random", 2),
			(troop_add_item, ":lady_no", "itm_peasant_dressblue", 0),
		(else_try),
			(lt, ":random", 4),
			(troop_add_item, ":lady_no", "itm_brown_dress", 0),
		(else_try),
			(troop_add_item, ":lady_no", "itm_briton_dress_blue", 0),
		(try_end),
	(else_try),
		(eq, ":faction_no", "fac_kingdom_2"),
		(try_begin),
			(eq, ":random", 0),
			(troop_add_item, ":lady_no", "itm_brown_dress", 0),
		(else_try),
			(eq, ":random", 1),
			(troop_add_item, ":lady_no", "itm_lady_dress_green", 0),
		(else_try),
			(eq, ":random", 2),
			(troop_add_item, ":lady_no", "itm_briton_dress_blue", 0),
		(else_try),
			(lt, ":random", 5),
			(neg|troop_slot_eq, ":lady_no", "slot_lord_reputation_type", lrep_conventional),
			(neg|troop_slot_eq, ":lady_no", "slot_lord_reputation_type", lrep_ambitious),
			(troop_add_item, ":lady_no", "itm_peasant_etunic", 0),
		(else_try),
			(lt, ":random", 5),
			(troop_add_item, ":lady_no", "itm_lady_dress_ruby", 0),
		(else_try),
			(troop_add_item, ":lady_no", "itm_peasant_etunic", 0),
		(try_end),
	
	(else_try),
		(eq, ":faction_no", "fac_kingdom_3"),
		(troop_add_item, ":lady_no", "itm_peasant_etunic", 0),
	#chief acaba
				
	(else_try),
		(eq, ":faction_no", "fac_kingdom_4"),

	(else_try),
		(eq, ":faction_no", "fac_kingdom_5"),

		
	(try_end),
	(troop_equip_items, ":lady_no"),

	#also available:
	#itm_bluepantsbody_woad04
	#itm_court_dress	
	
	#to add for khergits -- salwar/shalvar?
	#western tang costume (p105, china's golden age)
	#kipchak woman from russia book
	
	#chief empieza
	(try_begin), #assign headguear matched to item
		(this_or_next|troop_has_item_equipped, ":lady_no", "itm_woolen_dressplain"),
		(this_or_next|troop_has_item_equipped, ":lady_no", "itm_peasant_etunic"),
			(troop_has_item_equipped, ":lady_no", "itm_peasant_dressblue"),
		
		#assign no headgear
	(else_try),
		(this_or_next|troop_slot_eq, ":lady_no", "slot_lord_reputation_type", lrep_moralist),
		(this_or_next|troop_slot_eq, ":lady_no", "slot_lord_reputation_type", lrep_conventional),
			(lt, ":random", 2),
			
		
		(try_begin),
			(troop_has_item_equipped, ":lady_no", "itm_brown_dress"),
			(troop_add_item, ":lady_no", "itm_briton_dress_blue", 0),
		
		(else_try),
			(troop_has_item_equipped, ":lady_no", "itm_brown_dress"),
			(troop_add_item, ":lady_no", "itm_briton_dress_blue", 0),

			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving ruby turret hat to {s4}"),
		(else_try),
			(troop_has_item_equipped, ":lady_no", "itm_briton_dress_blue"),
			(troop_add_item, ":lady_no", "itm_wimplea", 0),
		
			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving blue turret hat to {s4}"),
		(else_try),
			(troop_has_item_equipped, ":lady_no", "itm_briton_dress_blue"),
			(troop_add_item, ":lady_no", "itm_wimple_with_veil", 0),
		
			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving green turret hat to {s4}"),
		(else_try),	
			(troop_has_item_equipped, ":lady_no", "itm_peasant_dressblue"),
			(troop_add_item, ":lady_no", "itm_wimple_with_veil", 0),

			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving green-lined wimple to {s4}"),
		(else_try),
			(neq, ":faction_no", "fac_kingdom_3"),
			(neq, ":faction_no", "fac_kingdom_6"),
			(troop_add_item, ":lady_no", "itm_wimplea", 0),

			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving red-lined wimple to {s4}"),
		(else_try),
			(eq, ":faction_no", "fac_kingdom_6"),
			(try_begin),
				(troop_has_item_equipped, ":lady_no", "itm_brown_dress"),
				(troop_add_item, ":lady_no", "itm_veila", 0),
			(else_try),
				(troop_add_item, ":lady_no", "itm_veila", 0),
			(try_end),
		(try_end),
	(try_end),
	(troop_equip_items, ":lady_no"),
	#chief acaba	
	]
	),

	("assign_troop_love_interests", #Called at the beginning, or whenever a lord is spurned
    [
	(store_script_param, ":cur_troop", 1),

	(store_faction_of_troop, ":troop_faction", ":cur_troop"),
	(try_for_range, ":unused", 0, 50),
		(store_random_in_range, ":cur_lady", kingdom_ladies_begin, kingdom_ladies_end),
		(troop_slot_eq, ":cur_lady", "slot_troop_spouse", -1),
		(store_faction_of_troop, ":lady_faction", ":cur_lady"),
		(eq, ":troop_faction", ":lady_faction"),
		(call_script, "script_troop_get_family_relation_to_troop", ":cur_troop", ":cur_lady"),
		(eq, reg0, 0),

		(call_script, "script_troop_get_relation_with_troop", ":cur_troop", ":cur_lady"),
		(eq, reg0, 0), #do not develop love interest if already spurned or courted
		
		(neg|troop_slot_eq, ":cur_troop", "slot_troop_love_interest_1", ":cur_lady"),
		(neg|troop_slot_eq, ":cur_troop", "slot_troop_love_interest_2", ":cur_lady"),
		(neg|troop_slot_eq, ":cur_troop", "slot_troop_love_interest_3", ":cur_lady"),
		(try_begin),
			(troop_slot_eq, ":cur_troop", "slot_troop_love_interest_1", 0),
			(troop_set_slot, ":cur_troop", "slot_troop_love_interest_1", ":cur_lady"),
		(else_try),
			(troop_slot_eq, ":cur_troop", "slot_troop_love_interest_2", 0),
			(troop_set_slot, ":cur_troop", "slot_troop_love_interest_2", ":cur_lady"),
		(else_try),
			(troop_slot_eq, ":cur_troop", "slot_troop_love_interest_3", 0),
			(troop_set_slot, ":cur_troop", "slot_troop_love_interest_3", ":cur_lady"),
		(try_end),
	(try_end),
	
	]),
	
	("faction_conclude_feast", 
	[
	(store_script_param, ":faction_no", 1),
	(store_script_param, ":venue", 2),
	
	(str_store_faction_name, s3, ":faction_no"),
	(str_store_party_name, s4, ":venue"),

    (try_begin),
        (eq, "$cheat_mode", 1),
	    (display_debug_message, "str_s3_feast_concludes_at_s4",0xFF0000),
    (try_end),

	(try_begin),
		(eq, ":faction_no", "fac_player_faction"),
		(assign, ":faction_no", "$players_kingdom"),
	(try_end),
	
	(call_script, "script_end_feast_tournament", ":venue"),

	#markspot
	
	(assign, ":nobility_in_faction", 0),
	(assign, ":nobility_in_attendance", 0),

	(try_for_range, ":troop_no", active_npcs_begin, kingdom_ladies_end),
		(store_faction_of_troop, ":troop_faction", ":troop_no"),
		(eq, ":faction_no", ":troop_faction"),
		
		(val_add, ":nobility_in_faction", 1),

		#CHECK -- is the troop there?
		(troop_slot_eq, ":troop_no", "slot_troop_cur_center", ":venue"),
		(val_add, ":nobility_in_attendance", 1),

		#check for marriages
		(troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_lady),
		(troop_get_slot, ":groom", ":troop_no", "slot_troop_betrothed"),
		(gt, ":groom", 0),

		(troop_get_slot, ":groom_party", ":groom", "slot_troop_leaded_party"),
		(party_is_active, ":groom_party"),
		(party_get_attached_to, ":groom_party_attached", ":groom_party"),
		(eq, ":groom_party_attached", ":venue"),
		
		(store_faction_of_troop, ":lady_faction", ":troop_no"),
		(store_faction_of_troop, ":groom_faction", ":groom"),

		(eq, ":groom_faction", ":lady_faction"),
		(eq, ":lady_faction", ":faction_no"),
		(store_current_hours, ":hours_since_betrothal"),
		(troop_get_slot, ":betrothal_time", ":troop_no", "slot_troop_betrothal_time"),
		(val_sub, ":hours_since_betrothal", ":betrothal_time"),
		(ge, ":hours_since_betrothal", 144), #6 days, should perhaps eventually be 29 days, or 696 yours
				
		(call_script, "script_get_kingdom_lady_social_determinants", ":troop_no"), 
		(assign, ":wedding_venue", reg1),
				
		(eq, ":venue", ":wedding_venue"),
		(neq, ":troop_no", "trp_player"),
		(neq, ":groom", "trp_player"),

		(call_script, "script_courtship_event_bride_marry_groom", ":troop_no", ":groom", 0), #parameters from dialog
	(try_end),


#ssss	(assign, ":placeholder_reminder_to_calculate_effect_for_player_feast", 1),
	
	
	
	(party_get_slot, ":feast_host", ":venue", "slot_town_lord"),
	(assign, ":quality_of_feast", 0),
	
	(try_begin),
		(check_quest_active, "qst_organize_feast"),
		(quest_slot_eq, "qst_organize_feast", "slot_quest_target_center", ":venue"),
		(assign, ":feast_host", "trp_player"),
		
		(assign, ":total_guests", 400),
		
		(call_script, "script_succeed_quest", "qst_organize_feast"),
		(call_script, "script_end_quest", "qst_organize_feast"),
		
		(call_script, "script_internal_politics_rate_feast_to_s9", "trp_household_possessions", ":total_guests", "$players_kingdom", 1),
		(assign, ":quality_of_feast", reg0),
	(else_try),
		(assign, ":quality_of_feast", 60),
	(try_end),
	
	
	(try_begin),
		(ge, "$cheat_mode", 1),
		(str_store_troop_name, s4, ":feast_host"),
		(assign, reg4, ":quality_of_feast"),
		(display_debug_message, "@{!}DEBUG - {s4}'s feast has rating of {reg4}",0xFF0000),
	(try_end),
	
	
	(try_begin),
	  (ge, ":feast_host", 0),
	  (store_div, ":renown_boost", ":quality_of_feast", 3),
	  (call_script, "script_change_troop_renown", ":feast_host", ":renown_boost"),

	  (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
		(troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
		(troop_get_slot, ":leaded_party", ":troop_no", "slot_troop_leaded_party"),
		(party_is_active, ":leaded_party"),
		(party_get_attached_to, ":leaded_party_attached", ":leaded_party"),
		(eq, ":leaded_party_attached", ":venue"),
		
		(assign, ":relation_booster", ":quality_of_feast"),
		(val_div, ":relation_booster", 15),#gdwwas20
		##		
		(try_begin),
			(eq, ":feast_host", "trp_player"),
			(val_sub, ":relation_booster", 1),
			(val_max, ":relation_booster", 0),
		(try_end),
		(call_script, "script_troop_change_relation_with_troop", ":feast_host", ":troop_no", ":relation_booster"),
		(val_add, "$total_feast_changes", ":relation_booster"),
		(assign, reg5, ":relation_booster"),
		
	  (try_end),
	(try_end),
	

	(assign, reg5, ":nobility_in_attendance"),
	(assign, reg6, ":nobility_in_faction"),
	(assign, reg7, ":relation_booster"),
	(display_debug_message, "@{!}DEBUG - {s4}'s feast for {s3} caused relationship gains of of {reg7}",0xFF0000), 
	(try_begin),
		(eq, "$cheat_mode", 1),##line92
		(display_debug_message, "str_attendance_reg5_nobles_out_of_reg6",0xFF0000),
	(try_end),	
	]),

	("lady_evaluate_troop_as_suitor", 
	[
	(store_script_param, ":lady", 1),
	(store_script_param, ":suitor", 2),
	
	(call_script, "script_troop_get_romantic_chemistry_with_troop", ":lady", ":suitor"),
	(assign, ":romantic_chemistry", reg0),
	
	(try_begin),
      (call_script, "script_cf_test_lord_incompatibility_to_s17", ":lady", ":suitor"),		
    (try_end),
	
	(store_sub, ":personality_modifier", 0, reg0),
	(assign, reg2, ":personality_modifier"),
		
	(try_begin),
		(troop_get_slot, ":renown_modifier", ":suitor", "slot_troop_renown"),
		(val_div, ":renown_modifier", 20),
		(try_begin),
			(this_or_next|troop_slot_eq, ":lady", "slot_lord_reputation_type", lrep_conventional),
				(troop_slot_eq, ":lady", "slot_lord_reputation_type", lrep_ambitious),
			(val_mul, ":renown_modifier", 2),
			(val_sub, ":renown_modifier", 15),
		(try_end),
	(try_end),
	
	(store_add, ":final_score", ":renown_modifier", ":personality_modifier"),
	(val_add, ":final_score", ":romantic_chemistry"),
	(assign, reg0, ":final_score"),	
	]),
	
	("courtship_event_troop_court_lady", 
	[
	(store_script_param, ":suitor", 1),
	(store_script_param, ":lady", 2),

	
	#(try_begin),
	  #(eq, "$cheat_mode", 1),
	  #(str_store_troop_name, s4, ":suitor"),
	  #(str_store_troop_name, s5, ":lady"),
	  #(troop_get_slot, ":lady_location", ":lady", "slot_troop_cur_center"),
	  #(str_store_party_name, s7, ":lady_location"),
	  #(display_message, "str_s4_pursues_suit_with_s5_in_s7"),
	#(try_end),
	
	(troop_get_slot, ":previous_suitor", ":lady", "slot_lady_last_suitor"),
	(troop_set_slot, ":lady", "slot_lady_last_suitor", ":suitor"), #can determine quarrels
	
	(try_begin),
		(eq, ":previous_suitor", "trp_player"),
		
		(troop_slot_ge, ":lady", "slot_troop_met", 2),
		(call_script, "script_troop_get_relation_with_troop", ":suitor", "trp_player"), #add this to list of quarrels
		(assign, ":suitor_relation_w_player", reg0),
		
		(try_begin),
			(this_or_next|troop_slot_eq, ":suitor", "slot_lord_reputation_type", lrep_selfrighteous),
			(this_or_next|troop_slot_eq, ":suitor", "slot_lord_reputation_type", lrep_quarrelsome),
				(troop_slot_eq, ":suitor", "slot_lord_reputation_type", lrep_debauched),
			(gt, ":suitor_relation_w_player", -20),
			(call_script, "script_add_log_entry", logent_lords_quarrel_over_woman, ":suitor", "trp_player", ":lady", 0),
		(else_try),
			(is_between, ":suitor_relation_w_player", -5, -25),
			(call_script, "script_add_log_entry", logent_lords_quarrel_over_woman, ":suitor", "trp_player", ":lady", 0),
		(try_end),
	(else_try),
		(neq, ":previous_suitor", "trp_player"), #not the player
	
		(neq, ":suitor", ":previous_suitor"),
		(ge, ":previous_suitor", active_npcs_begin),
		
		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":suitor", ":previous_suitor"),
		(call_script, "script_add_log_entry", logent_lords_quarrel_over_woman, ":suitor", ":previous_suitor", ":lady", 0),
		
		(call_script, "script_troop_get_relation_with_troop", ":suitor", ":previous_suitor"), #add this to list of quarrels
		(ge, reg0, 0),
		(call_script, "script_troop_change_relation_with_troop", ":suitor", ":previous_suitor", -20),
		(val_add, "$total_courtship_quarrel_changes", -20),
	(else_try),	 #quarrelsome lords quarrel anyway
		(troop_slot_eq, ":suitor", "slot_lord_reputation_type", lrep_quarrelsome),
		(neq, ":suitor", ":previous_suitor"),
		(ge, ":previous_suitor", active_npcs_begin),
		
#		(neq, ":previous_suitor", "trp_player"),
		
		(call_script, "script_troop_get_relation_with_troop", ":suitor", ":previous_suitor"), #add this to list of quarrels
		(lt, reg0, 10),
		(call_script, "script_add_log_entry", logent_lords_quarrel_over_woman, ":suitor", ":previous_suitor", ":lady", 0),
		(ge, reg0, 0),
		(call_script, "script_troop_change_relation_with_troop", ":suitor", ":previous_suitor", -20),
		(val_add, "$total_courtship_quarrel_changes", -20),
		
	(try_end),
	
	
#	(call_script, "script_troop_get_relation_with_troop", ":lady", ":suitor"),
#	(assign, ":orig_relation", reg0),

    (call_script, "script_lady_evaluate_troop_as_suitor", ":lady", ":suitor"),
	
	(store_random_in_range, ":random", 5, 16),
	(store_div, ":relationship_change", reg0, ":random"),
	
	(call_script, "script_troop_get_relation_with_troop", ":lady", ":suitor"),
	(assign, ":orig_relation", reg0),

	(call_script, "script_troop_change_relation_with_troop", ":lady", ":suitor", ":relationship_change"),
	
	(call_script, "script_troop_get_relation_with_troop", ":lady", ":suitor"),
	(assign, ":lady_suitor_relation", reg0),
		
	(try_begin),
		(ge, ":lady_suitor_relation", 10),
		(lt, ":orig_relation", 10),
		(call_script, "script_add_log_entry", logent_lady_favors_suitor, ":lady", 0, ":suitor", 0),
		
		(try_begin),
			(eq, "$cheat_mode", 1),
			(display_message, "str_note__favor_event_logged"),
		(try_end),
		
	(else_try),
		(this_or_next|lt, ":lady_suitor_relation", -20),
			(ge, ":lady_suitor_relation", 20),

		(call_script, "script_get_kingdom_lady_social_determinants", ":lady"),
		(assign, ":guardian", reg0),
		(call_script, "script_troop_get_relation_with_troop", ":suitor", ":guardian"),
		(assign, ":suitor_guardian_relation", reg0),
		#things come to a head, one way or another
		
		(assign, ":highest_competitor_lady_score", -1),
		(assign, ":competitor_preferred_by_lady", -1),
		
		(assign, ":highest_competitor_guardian_score", ":suitor_guardian_relation"),
		(assign, ":competitor_preferred_by_guardian", -1),
		
		#log potential competitors
		(try_for_range, ":possible_competitor", lords_begin, lords_end),
			(neq, ":possible_competitor", ":suitor"),
		
			(this_or_next|troop_slot_eq, ":possible_competitor", "slot_troop_love_interest_1", ":lady"),
			(this_or_next|troop_slot_eq, ":possible_competitor", "slot_troop_love_interest_2", ":lady"),
				(troop_slot_eq, ":possible_competitor", "slot_troop_love_interest_3", ":lady"),
			
			(try_begin),
				(call_script, "script_troop_get_relation_with_troop", ":possible_competitor", ":lady"),
				(gt, reg0, ":highest_competitor_lady_score"),
				(assign, ":competitor_preferred_by_lady", ":possible_competitor"),
				(assign, ":highest_competitor_lady_score", reg0),
			(try_end),	

			(try_begin),
				(call_script, "script_troop_get_relation_with_troop", ":possible_competitor", ":guardian"),
				(gt, reg0, ":highest_competitor_guardian_score"),
				(assign, ":competitor_preferred_by_guardian", ":possible_competitor"),
				(assign, ":highest_competitor_guardian_score", reg0),
			(try_end),	
		(try_end),

		#RESULTS
		#Guardian forces lady to be betrothed to suitor now		
		(try_begin), 
			(lt, ":lady_suitor_relation", -20),
			(this_or_next|troop_slot_eq, ":guardian", "slot_lord_reputation_type", lrep_selfrighteous),
			(this_or_next|troop_slot_eq, ":guardian", "slot_lord_reputation_type", lrep_debauched),
				(troop_slot_eq, ":guardian", "slot_lord_reputation_type", lrep_quarrelsome),
			(eq, ":competitor_preferred_by_guardian", -1),

			(this_or_next|troop_slot_eq, ":suitor", "slot_lord_reputation_type", lrep_selfrighteous),
			(this_or_next|troop_slot_eq, ":suitor", "slot_lord_reputation_type", lrep_debauched),
				(troop_slot_eq, ":suitor", "slot_lord_reputation_type", lrep_quarrelsome),

			(troop_slot_eq, ":suitor", "slot_troop_betrothed", -1),
			(troop_slot_eq, ":lady", "slot_troop_betrothed", -1),
				
			(call_script, "script_add_log_entry", logent_lady_betrothed_to_suitor_by_family, ":lady", 0, ":suitor", 0),
			(troop_set_slot, ":suitor", "slot_troop_betrothed", ":lady"),
			(troop_set_slot, ":lady", "slot_troop_betrothed", ":suitor"),
			(store_current_hours, ":hours"),
			(troop_set_slot, ":lady", "slot_troop_betrothal_time", ":hours"),
			(troop_set_slot, ":suitor", "slot_troop_betrothal_time", ":hours"),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_result_lady_forced_to_agree_to_engagement"),
			(try_end),

		#Lady rejects the suitor			
		(else_try),
			(lt, ":lady_suitor_relation", -20),
			
			(call_script, "script_add_log_entry", logent_lady_rejects_suitor, ":lady", 0, ":suitor", 0),
			(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":lady", ":suitor"),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_result_lady_rejects_suitor"),
			(try_end),

		#A happy engagement, with parental blessing
		(else_try),	
			(gt, ":lady_suitor_relation", 20),
			(gt, ":suitor_guardian_relation", 0),
			(eq, ":competitor_preferred_by_lady", -1),

			(troop_slot_eq, ":suitor", "slot_troop_betrothed", -1),
			(troop_slot_eq, ":lady", "slot_troop_betrothed", -1),
			
			(call_script, "script_add_log_entry", logent_lady_betrothed_to_suitor_by_choice, ":lady", 0, ":suitor", 0),
			(troop_set_slot, ":suitor", "slot_troop_betrothed", ":lady"),
			(troop_set_slot, ":lady", "slot_troop_betrothed", ":suitor"),
			(store_current_hours, ":hours"),
			(troop_set_slot, ":lady", "slot_troop_betrothal_time", ":hours"),
			(troop_set_slot, ":suitor", "slot_troop_betrothal_time", ":hours"),
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":lady"),
				(str_store_troop_name, s5, ":suitor"),
				(display_message, "str_result_happy_engagement_between_s4_and_s5"),
			(try_end),
			
		#Lady elopes
		(else_try), 
			(gt, ":lady_suitor_relation", 20),
			
			(eq, ":competitor_preferred_by_lady", -1),
			(this_or_next|troop_slot_eq, ":guardian", "slot_lord_reputation_type", lrep_adventurous),
				(troop_slot_eq, ":guardian", "slot_lord_reputation_type", lrep_ambitious),
				
			(troop_slot_eq, ":suitor", "slot_troop_betrothed", -1),
			(troop_slot_eq, ":lady", "slot_troop_betrothed", -1),
				
			#lady elopes
			(call_script, "script_courtship_event_bride_marry_groom", ":lady", ":suitor", 1),
			#add elopements to quarrel descriptions
					
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":lady"),
				(str_store_troop_name, s5, ":suitor"),
				(display_message, "str_result_s4_elopes_with_s5"),
			(try_end),
			
		#Lady reluctantly agrees to marry under pressure from family			
		(else_try),	
			(troop_slot_eq, ":lady", "slot_lord_reputation_type", lrep_conventional),
			(eq, ":competitor_preferred_by_guardian", -1),
			(gt, ":suitor_guardian_relation", 4),
			
			(store_random_in_range, ":random", 0, 5),
			(eq, ":random", 0),
			
			(troop_slot_eq, ":suitor", "slot_troop_betrothed", -1),
			(troop_slot_eq, ":lady", "slot_troop_betrothed", -1),

			(call_script, "script_add_log_entry", logent_lady_betrothed_to_suitor_by_pressure, ":lady", 0, ":suitor", 0),
			(troop_set_slot, ":suitor", "slot_troop_betrothed", ":lady"),
			(troop_set_slot, ":lady", "slot_troop_betrothed", ":suitor"),
			(store_current_hours, ":hours"),
			(troop_set_slot, ":lady", "slot_troop_betrothal_time", ":hours"),
			(troop_set_slot, ":suitor", "slot_troop_betrothal_time", ":hours"),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":lady"),
				(str_store_troop_name, s5, ":suitor"),				
				(display_message, "str_result_s4_reluctantly_agrees_to_engagement_with_s5"),
			(try_end),

		#Stalemate -- make patience roll
		(else_try), 
			(gt, ":lady_suitor_relation", 20),

			(store_random_in_range, reg3, 0, 3),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_result_stalemate_patience_roll_=_reg3"),
			(try_end),

			(eq, reg3, 0),
			(call_script, "script_add_log_entry", logent_lady_rejected_by_suitor, ":lady", 0, ":suitor", 0),
			(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":lady", ":suitor"),
		(try_end),
		
	(try_end),
	
	]),


		
	("courtship_event_lady_break_relation_with_suitor", #parameters from dialog
	[
	(store_script_param, ":lady", 1),
	(store_script_param, ":suitor", 2),
	
	(try_for_range, ":love_interest_slot", "slot_troop_love_interest_1", "slot_troop_love_interests_end"),
		(troop_slot_eq, ":suitor", ":love_interest_slot", ":lady"),
		(troop_set_slot, ":suitor", ":love_interest_slot", 0),
	(try_end),
	(call_script, "script_assign_troop_love_interests", ":suitor"),
	
	(try_begin),
		(troop_slot_eq, ":lady", "slot_troop_betrothed", ":suitor"),
				
		
		(troop_set_slot, ":lady", "slot_troop_betrothed", -1),
		(troop_set_slot, ":suitor", "slot_troop_betrothed", -1),
	(try_end),
	
	
	]),
	

	("courtship_event_bride_marry_groom", #parameters from dialog or scripts
	[
	(store_script_param, ":bride", 1),
	(store_script_param, ":groom", 2),
	(store_script_param, ":elopement", 3),

	(try_begin),
		(eq, ":bride", "trp_player"),
		(assign, ":venue", "$g_encountered_party"),
	(else_try),	
		(troop_get_slot, ":venue", ":bride", "slot_troop_cur_center"),
	(try_end),
	
	(store_faction_of_troop, ":groom_faction", ":groom"),
	
	
	(try_begin),
		(eq, ":elopement", 0),
		(call_script, "script_add_log_entry", logent_lady_marries_suitor, ":bride", ":venue", ":groom", 0),
	(else_try),
		(call_script, "script_add_log_entry", logent_lady_elopes_with_lord, ":bride", ":venue", ":groom", 0),
	(try_end),
	
	(str_store_troop_name, s3, ":bride"), 
	(str_store_troop_name, s4, ":groom"), 
	(str_store_party_name, s5, ":venue"), 

	(try_begin),
        (eq, "$cheat_mode", 1),
	    (display_message, "str_s3_marries_s4_at_s5"),
    (try_end),
	
	(troop_set_slot, ":bride", "slot_troop_spouse", ":groom"),
	(troop_set_slot, ":groom", "slot_troop_spouse", ":bride"),
	
	#Break groom's romantic relations
	(try_for_range, ":love_interest_slot", "slot_troop_love_interest_1", "slot_troop_love_interests_end"),
		(troop_set_slot, ":groom", ":love_interest_slot", 0),
	(try_end),

	#Break bride's romantic relations
	(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
		(try_for_range, ":love_interest_slot", "slot_troop_love_interest_1", "slot_troop_love_interests_end"),
			(troop_slot_eq, ":active_npc", ":love_interest_slot", ":bride"),
			(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":bride", ":active_npc"),
		(try_end),
	(try_end),
	
	
	
	(troop_set_slot, ":bride", "slot_troop_betrothed", -1),
	(troop_set_slot, ":groom", "slot_troop_betrothed", -1),
	
	
	
    #change relations with family
	(try_for_range, ":family_member", lords_begin, lords_end),
		(call_script, "script_troop_get_family_relation_to_troop", ":bride", ":family_member"),
		(gt, reg0, 0),
		(store_div, ":family_relation_boost", reg0, 3),
		(try_begin),
			(eq, ":elopement", 1),
			(val_mul, ":family_relation_boost", -2),
		(try_end),
		(call_script, "script_troop_change_relation_with_troop", ":groom", ":bride", ":family_relation_boost"),
		(val_add, "$total_courtship_quarrel_changes", ":family_relation_boost"),
	(try_end),
	
	(try_begin),
		(this_or_next|eq, ":groom", "trp_player"),
			(eq, ":bride", "trp_player"),
		(call_script, "script_change_player_right_to_rule", "trp_player", 17),#gdw15
	(try_end),
	
	
	(try_begin),
		(eq, ":groom", "trp_player"),
		(check_quest_active, "qst_wed_betrothed"),
		(call_script, "script_succeed_quest", "qst_wed_betrothed"),
		(call_script, "script_end_quest", "qst_wed_betrothed"),
	(try_end),

	
	(try_begin),
		(check_quest_active, "qst_visit_lady"),
		(quest_slot_eq, "qst_visit_lady", "slot_quest_giver_troop", ":bride"),
		(call_script, "script_abort_quest", "qst_visit_lady", 0),
	(try_end),

	
	(try_begin),
		(eq, ":groom", "trp_player"),
		(check_quest_active, "qst_visit_lady"),
		(call_script, "script_abort_quest", "qst_visit_lady", 0),
	(try_end),	
	(try_begin),
		(eq, ":groom", "trp_player"),
		(check_quest_active, "qst_duel_courtship_rival"),
		(call_script, "script_abort_quest", "qst_duel_courtship_rival", 0),
	(try_end),	
	
	
	(try_begin),
		(eq, ":bride", "trp_player"),
	    (call_script, "script_player_join_faction", ":groom_faction"),
		(assign, "$player_has_homage", 1),
	(else_try),
		(eq, ":groom", "trp_player"),		
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":bride"),
			(display_message, "@{!} DEBUG - {s4} faction change in marriage case 5"),
		(try_end),
		(troop_set_faction, ":bride", "$players_kingdom"),
	(else_try),
	
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":bride"),
			(display_message, "@{!}DEBUG - {s4} faction changed by marriage, case 6"), 
		(try_end),
	
		(troop_set_faction, ":bride", ":groom_faction"),
	(try_end),

    (try_begin),
        (this_or_next|eq, ":groom", "trp_player"),
           (eq, ":bride", "trp_player"),   
        (unlock_achievement, ACHIEVEMENT_HAPPILY_EVER_AFTER),
		(try_begin),
			(eq, ":elopement", 1),
			(unlock_achievement, ACHIEVEMENT_HEART_BREAKER),
		(try_end),
    (try_end),	
	
	
    (try_begin),
        (this_or_next|eq, ":groom", "trp_player"),
           (eq, ":bride", "trp_player"),
        #(eq, ":elopement", 0),    
        (call_script, "script_start_wedding_cutscene", ":groom", ":bride"),
    (try_end),
	]),


    #script_npc_decision_checklist_party_ai   
	# DECISION CHECKLISTS (OCT 14)
	# I was thinking of trying to convert as much AI decision-making as possible to the checklist format
	# While outcomes are not as nuanced and varied as a random decision using weighted chances for each outcoms, 
	# the checklist has the advantage of being much more transparent, both to developers and to players
	# The checklist can yield a string (standardized to s14) which explains the rationale for the decision
	# When the script yields a yes/no/maybe result, than that is standardized from -3 to +3
    # INPUT: troop_no
    # OUTPUT: none
	("npc_decision_checklist_party_ai", 
	[
	#this script can replace decide_kingdom_hero_ai and decide_kingdom_hero_ai_follow_or_not
	#However, it does not contain script_party_set_ai_state
	
	(store_script_param, ":troop_no", 1),
	
	(troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
    #(party_get_slot, ":our_strength", ":party_no", "slot_party_cached_strength"),
    #(store_div, ":min_strength_behind", ":our_strength", 2),
    #(party_get_slot, ":our_follower_strength", ":party_no", "slot_party_follower_strength"),

    (try_begin),
      (eq, "$cheat_mode", 1),
      (assign, "$g_talk_troop", ":troop_no"),
    (try_end),

    (store_troop_faction, ":faction_no", ":troop_no"),

	(try_begin),
      (eq, ":troop_no", "$g_talk_troop"),
      (str_store_string, s15, "str__i_must_attend_to_this_matter_before_i_worry_about_the_affairs_of_the_realm"),
	(try_end),
	
    #find current center
    (party_get_attached_to, ":cur_center_no", ":party_no"),
    (try_begin),
      (lt, ":cur_center_no", 0),
      (party_get_cur_town, ":cur_center_no", ":party_no"),
    (try_end),
    (assign, ":besieger_party", -1),
    (try_begin),
      (neg|is_between, ":cur_center_no", centers_begin, centers_end),
      (assign, ":cur_center_no", -1),
    (else_try),
      (party_get_slot, ":besieger_party", ":cur_center_no", "slot_center_is_besieged_by"),
      (try_begin),
        (neg|party_is_active, ":besieger_party"),
        (assign, ":besieger_party", -1),
      (try_end),
    (try_end),
    
	#party_count
    (call_script, "script_party_count_fit_for_battle", ":party_no"),
    (assign, ":party_fit_for_battle", reg0),
    (call_script, "script_party_get_ideal_size", ":party_no"),
    (assign, ":ideal_size", reg0),
    (store_mul, ":party_strength_as_percentage_of_ideal", ":party_fit_for_battle", 100),
    (val_div, ":party_strength_as_percentage_of_ideal", ":ideal_size"),
    (try_begin),
      (faction_slot_eq, ":faction_no", "slot_faction_num_towns", 0),
      (faction_slot_eq, ":faction_no", "slot_faction_num_castles", 0),
      (assign, ":party_ratio_of_prisoners", 0), #do not let prisoners have an effect on ai calculation
    (else_try),
      # (party_get_num_prisoners, ":num_prisoners", ":party_no"),	MOTO scrimping for local var slots
      (party_get_num_prisoners, ":party_ratio_of_prisoners", ":party_no"),
	  (val_mul, ":party_ratio_of_prisoners", 100),	#MOTO I believe they're going for 35% prisoners, not 35:1 prisoners (see below)
      (val_max, ":party_fit_for_battle", 1), #avoid division by zero error
      # (store_div, ":party_ratio_of_prisoners", ":num_prisoners", ":party_fit_for_battle"),	MOTO scrimping for local var slots
      (val_div, ":party_ratio_of_prisoners", ":party_fit_for_battle"),	#MOTO scrimping for local var slots
    (try_end),
				
	(assign, ":faction_is_at_war", 0),
	(try_for_range, reg0, kingdoms_begin, kingdoms_end),
	  (faction_slot_eq, reg0, "slot_faction_state", sfs_active),
	  (store_relation, ":relation", ":faction_no", reg0),
	  (lt, ":relation", 0),
	  (assign, ":faction_is_at_war", 1),
	(try_end),
	
	(assign, ":operation_in_progress", 0),
	(try_begin),
	  (this_or_next|party_slot_eq, ":party_no", "slot_party_ai_state", spai_raiding_around_center),
	  (party_slot_eq, ":party_no", "slot_party_ai_state", spai_besieging_center),
	  
	  (party_get_slot, ":target_center", ":party_no", "slot_party_ai_object"),
	  (is_between, ":target_center", centers_begin, centers_end),
	  
	  (store_faction_of_party, ":center_faction", ":target_center"),
	  (store_relation, ":relation", ":faction_no", ":center_faction"),
	  (lt, ":relation", 0),
	  
	  (store_distance_to_party_from_party, ":distance", ":party_no", ":target_center"),
	  (lt, ":distance", 10),
	  
	  #MOTO keep marshal from getting stranded during siege
	  (try_begin),
	    (party_slot_eq, ":target_center", "slot_village_state", svs_under_siege),
	    (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
        (neg|party_slot_ge, ":party_no", "slot_party_follower_strength", 1000),	#about 50 troops
		(assign, ":marshal_stranded", 1),
	  (else_try),
	    (assign, ":marshal_stranded", 0),
	  (try_end),
	  
	  (eq, ":marshal_stranded", 0),
	  #MOTO end keep marshal from getting stranded during siege

	  (this_or_next|party_slot_eq, ":target_center", "slot_village_state", svs_under_siege),
	  (this_or_next|party_slot_eq, ":target_center", "slot_village_state", svs_normal),
	  (party_slot_eq, ":target_center", "slot_village_state", svs_being_raided),
	  
	  (assign, ":operation_in_progress", 1),	
	  
	#MOTO include operations under commander
	(else_try),
	  (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
	  
	  (party_get_slot, ":commander_party", ":party_no", "slot_party_ai_object"),
	  (gt, ":commander_party", 0),
	  (party_is_active, ":commander_party"),
	  (party_get_slot, ":target_center", ":commander_party", "slot_party_ai_object"),
	  (is_between, ":target_center", centers_begin, centers_end),
	  
	  (store_faction_of_party, ":center_faction", ":target_center"),
	  (store_relation, ":relation", ":faction_no", ":center_faction"),
	  (lt, ":relation", 0),
	  
	  (store_distance_to_party_from_party, ":distance", ":party_no", ":target_center"),
	  (lt, ":distance", 10),
	  (this_or_next|party_slot_eq, ":target_center", "slot_village_state", svs_under_siege),
	  (this_or_next|party_slot_eq, ":target_center", "slot_village_state", svs_normal),
	  (party_slot_eq, ":target_center", "slot_village_state", svs_being_raided),
	  
	  (assign, ":operation_in_progress", 1),	
	#MOTO end include operations under commander	
	(try_end),
			
	(troop_get_slot, ":troop_reputation", ":troop_no", "slot_lord_reputation_type"),
			
    (party_get_slot, ":old_ai_state", ":party_no", "slot_party_ai_state"),
    (party_get_slot, ":old_ai_object", ":party_no", "slot_party_ai_object"),

	(party_get_slot, ":party_cached_strength", ":party_no", "slot_party_cached_strength"),
	
	#MOTO scrimping for local var slots
	(store_current_hours, ":hours_since_last_rest"),
	(party_get_slot, reg0, ":party_no", "slot_party_last_in_any_center"),
	(val_sub, ":hours_since_last_rest", reg0),

	(store_current_hours, ":hours_since_last_home"),
	(party_get_slot, reg0, ":party_no", "slot_party_last_in_home_center"),
	(val_sub, ":hours_since_last_home", reg0),
	
	(store_current_hours, ":hours_since_last_combat"),
	(party_get_slot, reg0, ":party_no", "slot_party_last_in_combat"),
	(val_sub, ":hours_since_last_combat", reg0),
	
	(store_current_hours, ":hours_since_last_courtship"),
	(party_get_slot, reg0, ":party_no", "slot_party_leader_last_courted"),
	(val_sub, ":hours_since_last_courtship", reg0),
	
    (troop_get_slot, reg0, ":troop_no", "slot_troop_temp_decision_seed"),
    (store_mod, ":aggressiveness", reg0, 73), #To derive the 
	#MOTO end scrimping for local var slots
    (try_begin),
      (eq, ":troop_reputation", lrep_martial),
      (val_add, ":aggressiveness", 27),
    (else_try),
      (neq, ":troop_reputation", lrep_debauched),
      (neq, ":troop_reputation", lrep_quarrelsome),
      (val_add, ":aggressiveness", 14),
    (try_end),
    
    (try_begin),
      (gt, ":aggressiveness", ":hours_since_last_combat"),
      (val_add, ":aggressiveness", ":hours_since_last_combat"),
      (val_div, ":aggressiveness", 2),
    (try_end),        
    
    (try_begin),
      (eq, "$cheat_mode", 1), #100
      (eq, ":troop_no", "$g_talk_troop"),
      (str_store_troop_name, s4, ":troop_no"), 
      (assign, reg3, ":hours_since_last_rest"),
      (assign, reg4, ":hours_since_last_courtship"),
      (assign, reg5, ":hours_since_last_combat"),
      (assign, reg6, ":hours_since_last_home"),
      (assign, reg7, ":aggressiveness"),
      #(display_message, "@{!}{s4}: hours since rest {reg3}, courtship {reg4}, combat {reg5}, home {reg6}, aggressiveness {reg7}"),
    (try_end),
		
	##I am inspecting an estate (use "slot_center_npc_volunteer_troop_amount")
		
	(str_store_string, s17, "str_the_other_matter_took_precedence"),
	
	# (assign, ":do_only_collecting_rents", 0),	MOTO deprecated
	
	#Wait in current city (dangerous to travel with less (<=10) men)
	(try_begin),	
      #NOTE : I added also this condition to very top of list. Because if this condition does not exists in top then a bug happens. 
      #Bug is about alone wounded lords without any troop near him travels between cities, sometimes it want to return his home city 
      #to collect reinforcements, sometimes it want to patrol ext, but his party is so weak even without anyone. So we sometimes see 
      #(0/1) parties in map with only one wounded lord inside. Because after wars completely defeated lords spawn again in a walled center 
      #in 48 hours periods (by codes in module_simple_trigers). He spawns with only wounded himself. Then he should wait in there for 
      #a time to collect new men to his (0/1) party. If a lord is the only one in his party and if he is at any walled center already then he 
      #should stay where he is. He should not travel to anywhere because of any reason. If he is the only one and he is wounded and 
      #he is not in any walled center this means this situation happens because of one another bug, because any lord cannot be out of 
      #walled centers with wounded himself only. So I am adding this condition below. 
      
      #SUMMARY : If lord has not got enought troops (<10 || <10%) with himself and he is currently at a walled center he should not leave 
      #his current center because of any reason.
      
      (ge, ":cur_center_no", 0),

      # (this_or_next|le, ":party_fit_for_battle", 10),
      # (le, ":party_strength_as_percentage_of_ideal", 30),
      (le, ":party_fit_for_battle", 10),	#MOTO percentage requirement too broad

      (assign, ":action", spai_holding_center),
      (assign, ":object", ":cur_center_no"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"), 
	    (str_store_string, s14, "str_i_need_to_raise_some_men_before_attempting_anything_else"),
	    (str_store_string, s16, "str_i_need_to_raise_some_men_before_attempting_anything_else"),
	  (try_end),
	  
	#Stand in a siege
	(else_try),
	  (gt, ":besieger_party", -1),
      (ge, ":cur_center_no", 0),	#MOTO bug fix
	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":cur_center_no"),
	  
	  (try_begin), 
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_cannot_leave_this_fortress_now_as_it_is_under_siege"),
	    (str_store_string, s16, "str_after_all_we_are_under_siege"),
	  (try_end),
		
	#Continue retreat to walled center
	(else_try),
	  (eq, ":old_ai_state", spai_retreating_to_center),
	  (neg|party_is_in_any_town, ":party_no"),
	  
	  (ge, ":old_ai_object", 0),
	  (party_is_active, ":old_ai_object"),
	  
	  (store_faction_of_party, ":center_faction", ":old_ai_object"),
	  (eq, ":faction_no", ":center_faction"),
	  
	  (assign, ":action", spai_retreating_to_center),
	  (assign, ":object", ":old_ai_object"),
	  	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_we_are_not_strong_enough_to_face_the_enemy_out_in_the_open"),
	    (str_store_string, s16, "str_i_should_probably_seek_shelter_behind_some_stout_walls"),
	  (try_end),

	#Stand by in current center against enemies		
	(else_try),
	  (is_between, ":cur_center_no", walled_centers_begin, walled_centers_end),
	  
	  (party_get_slot, ":enemy_strength_nearby", ":cur_center_no", "slot_center_sortie_enemy_strength"),
	  #MOTO stay if needed
	  # (ge, ":enemy_strength_in_area", 50),	MOTO this is 2-3 troops
	  (ge, ":enemy_strength_nearby", ":party_cached_strength"),
	  (party_get_slot, ":center_strength", ":cur_center_no", "slot_party_cached_strength"),
	  (ge, ":enemy_strength_nearby", ":center_strength"),
	  #MOTO end stay if needed
	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":cur_center_no"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_enemies_are_reported_to_be_nearby_and_we_should_stand_ready_to_either_man_the_walls_or_sortie_out_to_do_battle"),
	    (str_store_string, s16, "str_the_enemy_is_nearby"),
	  (try_end),
	  
	#MOTO move here to inform marshall decisions
	#Get reinforcements
	(else_try),
	  (assign, ":lowest_acceptable_strength_percentage", 30),
	  (assign, ":distance_addition", 0),	#MOTO for testing in marshal levy section
	  
	  (call_script, "script_lord_get_home_center", ":troop_no"),
	  (assign, ":center_to_visit", reg0),
	  (gt, ":center_to_visit", -1),
	  (party_slot_eq, ":center_to_visit", "slot_town_lord", ":troop_no"), #newly added
	  
	  #if troop is very close to its home center increase by 20%
	  (assign, ":distance_addition", 0),
	  (party_get_position, pos0, ":center_to_visit"),
	  (party_get_position, pos1, ":party_no"),
	  (get_distance_between_positions, ":distance", pos0, pos1),	  	  
	  (try_begin),	  
	    # (le, ":dist", 9000),	MOTO this is NOT very close
	    # (store_div, ":distance_addition", ":dist", 600),
		(le, ":distance", 1500),
	    (store_div, ":distance_addition", ":distance", 100),
	    (store_sub, ":distance_addition", 15, ":distance_addition"),
	  (else_try),
	    (assign, ":distance_addition", 0),
	  (try_end),
	  (val_add, ":lowest_acceptable_strength_percentage", ":distance_addition"),
	  
	  #if there is no campaign for faction increase by 35%
	  (assign, ":no_campaign_addition", 35),
	  (try_begin),
	    (this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemy_army),
	    (this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
	    (this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_raiding_village),
	    (this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_center),
	    (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
	    (assign, ":no_campaign_addition", 0),
	    
	    #If marshal is player itself and if there is a campaign then lower lowest_acceptable_strength_percentage by 10 instead of not changing it.
	    #Because players become confused when they see very less participation from AI lords to their campaigns.
	    (try_begin),	    
	      (faction_slot_eq, ":faction_no", "slot_faction_marshall", "trp_player"),
	      (options_get_campaign_ai, ":reduce_campaign_ai"),
	      (try_begin),
	        (eq, ":reduce_campaign_ai", 0), #hard
	        (assign, ":no_campaign_addition", 0),
	      (else_try),  
	        (eq, ":reduce_campaign_ai", 1), #medium
	        (assign, ":no_campaign_addition", -10),
	      (else_try),  
	        (eq, ":reduce_campaign_ai", 2), #easy
	        (assign, ":no_campaign_addition", -15),
	      (try_end),  
	    (try_end),
	  (try_end),
	  (val_add, ":lowest_acceptable_strength_percentage", ":no_campaign_addition"),
	  (val_max, ":lowest_acceptable_strength_percentage", 25),
	
	  #max : 30%+15%+35% = 80% (happens when there is no campaign and player is near to its home center.)
	  (lt, ":party_strength_as_percentage_of_ideal", ":lowest_acceptable_strength_percentage"),
	  
	  #MOTO don't interrupt marshal operation for this
	  (this_or_next|eq, ":operation_in_progress", 0),
	  (neg|faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
	  #MOTO end don't interrupt marshal operation for this
	
	  (troop_get_slot, ":troop_wealth", ":troop_no", "slot_troop_wealth"),
      (assign, ":hiring_budget", ":troop_wealth"),	#MOTO hiring budget/reinforcement cost comparison from script_hire_men_to_kingdom_hero_party
      (val_mul, ":hiring_budget", 3),
      (val_div, ":hiring_budget", 4),            
	  
	  (options_get_campaign_ai, ":reduce_campaign_ai"),
      (try_begin), 
        (eq, ":reduce_campaign_ai", 0), #hard
        (assign, ":reinforcement_cost", reinforcement_cost_hard),
      (else_try), 
        (eq, ":reduce_campaign_ai", 2), #easy
        (assign, ":reinforcement_cost", reinforcement_cost_easy),
      (else_try), 
        (assign, ":reinforcement_cost", reinforcement_cost_moderate),
      (try_end),
	  
	  (try_begin),
        (ge, ":hiring_budget", ":reinforcement_cost"),
	  	  	  	  	  	  
	    (assign, ":action", spai_holding_center),
	    (assign, ":object", ":center_to_visit"),
	  
	    (try_begin),
	      (eq, ":troop_no", "$g_talk_troop"),
	      (str_store_string, s14, "str_i_dont_have_enough_troops_and_i_need_to_get_some_more"),
	      (str_store_string, s16, "str_i_am_running_low_on_troops"),
	    (try_end),
		
	  (else_try),	#MOTO copy and modify visiting estates from below to avoid needlessly skipping other state choices
	    (assign, ":action", 0),	#MOTO set test for collection undertaken
	    (assign, ":center_to_visit", -1),

        #MOTO chief collect rents only when it actually helps recruit
        # (assign, ":score_to_beat", 300), #at least 300 gold to pick up MOTO equals reinforcement_cost_hard
		(options_get_campaign_ai, ":reduce_campaign_ai"),
		(try_begin), 
		  (eq, ":reduce_campaign_ai", 0), #hard
		  (assign, ":score_to_beat", reinforcement_cost_hard),
		(else_try), 
		  (eq, ":reduce_campaign_ai", 2), #easy
		  (assign, ":score_to_beat", reinforcement_cost_easy),
		(else_try), 
		  (assign, ":score_to_beat", reinforcement_cost_moderate),
		(try_end),
		(val_mul, ":score_to_beat", 4),    # 4/3 "hiring budget" from script_hire_men_to_kingdom_hero_party
		(val_div, ":score_to_beat", 3),
 		(val_div, ":score_to_beat", 2),    #parties that can't afford to recruit are willing to go get half of what they need
		#MOTO end collect rents only when it actually helps recruit

	    (try_begin),	    
	      (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
	      (ge, ":faction_marshal", 0),	#MOTO avoid bug
	    
	      (assign, reg17, 0),
	      (try_begin),
	        (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
	        # (party_slot_eq, ":party_no", "slot_party_ai_object", ":faction_marshal"),	MOTO wrong
	        (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
	        (party_is_active, ":marshal_party"),
	        (party_slot_eq, ":party_no", "slot_party_ai_object", ":marshal_party"),
		    #MOTO end wrong
	        (assign, reg17, 1),
	      (else_try),  	    
	        (party_slot_eq, ":party_no", "slot_party_following_player", 1),
	        (assign, reg17, 1),
	      (try_end),  
	      (eq, reg17, 1),
	    
	      (try_begin),
	        (neq, ":faction_marshal", "trp_player"),
	        (neg|party_slot_eq, ":party_no", "slot_party_following_player", 1),
	        (val_add, ":score_to_beat", 125),
	      (else_try),
	        (val_add, ":score_to_beat", 250),
	      (try_end),
	    (try_end),  
	  
	    (try_for_range, ":center_no", centers_begin, centers_end),
	      (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
	    
	      (assign, reg17, 0),
	      (try_begin),
	        (is_between, ":center_no", villages_begin, villages_end),
	        (party_slot_eq, ":center_no", "slot_village_state", svs_normal),
	        (assign, reg17, 1),
	      (else_try),  	    
	        (party_slot_eq, ":center_no", "slot_center_is_besieged_by", -1),
	        (assign, reg17, 1),
	      (try_end),	    
	      (eq, reg17, 1),
	    
	      (party_get_slot, ":tariffs_available", ":center_no", "slot_center_accumulated_tariffs"),
	      (party_get_slot, ":rents_available", ":center_no", "slot_center_accumulated_rents"),
	      (store_add, ":money_available", ":rents_available", ":tariffs_available"),
	    	    
	      (gt, ":money_available", ":score_to_beat"),
	      (assign, ":center_to_visit", ":center_no"),
	      (assign, ":score_to_beat", ":money_available"),			
	    (try_end),
	  
	    (is_between, ":center_to_visit", centers_begin, centers_end),
	  	  
	    (try_begin),
	      (is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),
	      (assign, ":action", spai_holding_center),
	      (assign, ":object", ":center_to_visit"),
	    (else_try),  
          (assign, ":action", spai_visiting_village),
  	      (assign, ":object", ":center_to_visit"),
	    (try_end),
	  
	    (try_begin),
	      (eq, ":troop_no", "$g_talk_troop"),
	      (str_store_string, s14, "str_i_need_to_inspect_my_properties_and_collect_my_dues"),
	      (str_store_string, s16, "str_it_has_been_too_long_since_i_have_inspected_my_estates"),
	    (try_end),
	  (try_end),
	  
	  (neq, ":action", 0),	#catch failure of is_between above
	  
	(else_try),	#MOTO special state - marshall levies troops
	  (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
	  (store_sub, reg0, ":lowest_acceptable_strength_percentage", ":distance_addition"),	#MOTO ignore distance addition for this purpose
	  (lt, ":party_strength_as_percentage_of_ideal", reg0),
	  (eq, ":operation_in_progress", 0),
	  
	  (assign, ":center_to_visit", -1),
	  (assign, ":troops_to_transfer", 25),	#don't go back until center recuits 25 more
	  
	  (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
		(store_faction_of_party, ":center_faction", ":center_no"),
		(eq, ":center_faction", ":faction_no"),
		
	    (party_get_slot, ":center_max_garrison", ":center_no", "slot_town_prosperity"),
		(val_mul, ":center_max_garrison", 8),
		(val_add, ":center_max_garrison", 100),	#100..900, average 500
		
	    (store_party_size_wo_prisoners, ":center_strength", ":center_no"),
	    (store_sub, ":surplus_troops", ":center_strength", ":center_max_garrison"),
		(lt, ":troops_to_transfer", ":surplus_troops"),
	    (assign, ":center_to_visit", ":center_no"),
		(assign, ":troops_to_transfer", ":surplus_troops"),
	  (try_end),
	  
	  (ge, ":center_to_visit", 0),
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_dont_have_enough_troops_and_i_need_to_get_some_more"),
	    (str_store_string, s16, "str_i_am_running_low_on_troops"),
	  (try_end),
	  
	  (try_begin),
		(party_is_in_town, ":party_no", ":center_to_visit"),
		
		(try_begin),
	      (party_get_slot, ":town_lord", ":center_to_visit", "slot_town_lord"),
	      (neq, ":town_lord", ":troop_no"),
		  (try_begin),
			(eq, ":town_lord", "trp_player"),
			(assign, reg0, ":troops_to_transfer"),
			(str_store_party_name, s10, ":center_to_visit"),
			(display_message, "@The marshal is levying {reg0} troops from your center {s10}."),
			
		  (else_try),
		    (store_mul, ":attitude_adjustment", ":troops_to_transfer", 20),
	        (store_party_size_wo_prisoners, ":center_strength", ":center_to_visit"),
		    (val_div, ":attitude_adjustment", ":center_strength"),
		    (val_add, ":attitude_adjustment", 1),
		    (val_mul, ":attitude_adjustment", -1),
	        (call_script, "script_troop_change_relation_with_troop", ":troop_no", ":town_lord", ":attitude_adjustment"),
		  (try_end),
		(try_end),
		
		(assign, ":num_stacks", 0),
		(assign, ":cur_stack", 1),

		(try_for_range, reg0, 0, ":troops_to_transfer"),
		  (try_begin),
		    (ge, ":cur_stack", ":num_stacks"),
            (party_get_num_companion_stacks, ":num_stacks", ":center_to_visit"),
		    (assign, ":cur_stack", 1),
		  (try_end),
		  
          (party_stack_get_troop_id, ":levy_troop", ":center_to_visit", ":cur_stack"),
          (party_stack_get_size, ":stack_size", ":center_to_visit", ":cur_stack"),
		  
		  (try_begin),
		    (this_or_next|le, ":stack_size", 0),
		    (is_between, ":levy_troop", active_npcs_begin, active_npcs_end),
			(val_add, ":troops_to_transfer", 1),	#not levying this guy!
		  (else_try),
			(party_remove_members, ":center_to_visit", ":levy_troop", 1),
			(party_add_members, ":party_no", ":levy_troop", 1),
		  (try_end),
		  
		  (val_add, ":cur_stack", 1),
		(try_end),
	  (try_end),
	#MOTO end move here to inform marshall decisions
	  
	#As the marshall, lead faction campaign
	(else_try),
	  (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
	  
	  #MOTO chief attempt to replace marshal if can't raise an army
	  (try_begin),
		(eq, ":operation_in_progress", 0),
	    (store_sub, reg0, ":lowest_acceptable_strength_percentage", ":distance_addition"),	#MOTO ignore distance addition for this purpose
	    (lt, ":party_strength_as_percentage_of_ideal", reg0),
		(faction_slot_eq, ":faction_no", "slot_faction_political_issue", 0),	#not already done?
        (call_script, "script_change_troop_renown", ":troop_no", -1),
		(faction_set_slot, ":faction_no", "slot_faction_political_issue", 1), #Appointment of marshal
		(store_current_hours, ":hours"),
		(val_max, ":hours", 0),
		(faction_set_slot, ":faction_no", "slot_faction_political_issue_time", ":hours"),
	  (try_end),
	  #MOTO end attempt to replace marshal if can't raise an army
	  
	  #Appoint screening party MOTO move here so marshall group always has a screening party
	  (try_begin),
	    (assign, ":best_screening_party", -1),
	    (assign, ":score_to_beat", 200),	#+- this amount

	    (try_for_range, ":screen_leader", active_npcs_begin, active_npcs_end),
		  # (store_faction_of_troop, ":screen_leader_faction", ":screen_leader"),
		  # (eq, ":screen_leader_faction", ":faction_no"),	MOTO neglects allies
		 
		  (troop_get_slot, ":screening_party", ":screen_leader", "slot_troop_leaded_party"),
		  (party_is_active, ":screening_party"),			
		  (party_slot_eq, ":screening_party", "slot_party_ai_object", ":party_no"),
		  (party_slot_eq, ":screening_party", "slot_party_ai_state", spai_accompanying_army),

		  (try_begin),
            (party_slot_eq, ":screening_party", "slot_party_ai_substate", 1),	#MOTO use substate to represent screening properly
			(call_script, "script_party_set_ai_state", ":screening_party", spai_accompanying_army, ":party_no"),	#turn off screening in case not chosen again
		  (try_end),
		  
          (store_distance_to_party_from_party, ":distance", ":screening_party", ":party_no"),
          (lt, ":distance", 15),
		  
		  (try_begin),
		    (ge, "$cheat_mode", 1),
		    (str_store_party_name, s4, ":screening_party"),
		    (display_message, "@{!}DEBUG -- {s4} screening for marshall"),
		  (try_end),

		  (store_party_size_wo_prisoners, ":screening_party_score", ":screening_party"),
		  (val_sub, ":screening_party_score", 250),	#closest in size to this
		  (val_abs, ":screening_party_score"),
		 
		  (lt, ":screening_party_score", ":score_to_beat"),

		  #set party and score
		  (assign, ":best_screening_party", ":screening_party"),
		  (assign, ":score_to_beat", ":screening_party_score"),
	    (try_end),			

	    (party_is_active, ":best_screening_party"),
	    (call_script, "script_party_set_ai_state", ":best_screening_party", spai_screening_army, ":party_no"),
	    (try_begin),
		  (ge, "$cheat_mode", 1),
		  (str_store_party_name, s4, ":best_screening_party"),
		  (display_message, "@{!}DEBUG -- {s4} chosen as screen"),
	    (try_end),
	  (try_end),
	  #end Appoint screening party MOTO move here so marshall group always has a screening party
	  
	  (str_clear, s15), #Does not say that overrides faction orders
	  (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
	  
	  # (party_set_ai_initiative, ":party_no", 10),	MOTO chief this is just overriden by script_party_set_ai_state called next
	  	  
	  #new ozan added - active gathering
	  #this code will allow marshal to travel around cities while gathering army if currently collected are less than 60%. 
	  #By ratio increases travel distances become less. Travels will be only points around walled centers.
	  (party_get_slot, ":old_ai_object", ":party_no", "slot_party_ai_object"),
	  #MOTO chief prevent marshall from gathering at enemy centers!
      (try_begin),
        (is_between, ":old_ai_object", centers_begin, centers_end),
        (store_faction_of_party, ":center_faction", ":old_ai_object"),
        (eq, ":center_faction", ":faction_no"),
        (assign, ":travel_target", ":old_ai_object"),
      (else_try),
        (assign, ":travel_target", -1),
      (try_end),
      #MOTO end prevent marshall from gathering at enemy centers!
      
      (call_script, "script_find_center_to_defend", ":troop_no"),
	  (assign, ":most_threatened_center", reg0),	  
	  (assign, ":travel_target_new_assigned", 0),
	  
      (try_begin),
        (lt, ":old_ai_object", 0),
        
        (store_random_in_range, ":random_value", 0, 8), #to eanble marshal to wait sometime during active gathering
        (this_or_next|eq, "$g_gathering_new_started", 1),
        (eq, ":random_value", 0),
        
        (assign, ":vassals_already_assembled", 0),
        (assign, ":total_vassals", 0),
        (try_for_range, ":lord", active_npcs_begin, active_npcs_end),
          (store_faction_of_troop, ":lord_faction", ":lord"),
          (eq, ":lord_faction", ":faction_no"),
          (troop_get_slot, ":led_party", ":lord", "slot_troop_leaded_party"),
          (party_is_active, ":led_party"),
          (val_add, ":total_vassals", 1),
          
          (party_slot_eq, ":led_party", "slot_party_ai_state", spai_accompanying_army),
          (party_slot_eq, ":led_party", "slot_party_ai_object", ":party_no"),
          
          (party_is_active, ":party_no"),
          (store_distance_to_party_from_party, ":distance", ":led_party", ":party_no"),
          (lt, ":distance", 15),
          (val_add, ":vassals_already_assembled", 1),
        (try_end),
     
        (assign, ":ratio_of_vassals_assembled", -1),
        (try_begin),
          (gt, ":total_vassals", 0),
          (store_mul, ":ratio_of_vassals_assembled", ":vassals_already_assembled", 100),
          (val_div, ":ratio_of_vassals_assembled", ":total_vassals"),
        (try_end),
          
        (try_begin),
          #if more than 35% of vassals already collected do not make any more active gathering, just hold and wait last vassals to participate.
          (le, ":ratio_of_vassals_assembled", 35), 
                      
          (assign, ":best_center_to_travel", ":most_threatened_center"),          

          (try_begin),
            (eq, "$g_gathering_new_started", 1),
            
            (assign, ":minimum_distance", 100000),
            (try_for_range, ":center_no", centers_begin, centers_end),
              (store_faction_of_party, ":center_faction", ":center_no"),
              (eq, ":center_faction", ":faction_no"), #200
              (try_begin),
                (neq, ":center_no", ":most_threatened_center"), 
                (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),                
                (lt, ":distance", ":minimum_distance"),
                (assign, ":minimum_distance", ":distance"),
                (assign, ":best_center_to_travel", ":center_no"),
              (try_end), 
            (try_end),
          (else_try), 
            #active gathering            
            (assign, ":max_travel_distance", 150),
            (try_begin),
              (ge, ":ratio_of_vassals_assembled",15),
              (store_sub, ":max_travel_distance", 35, ":ratio_of_vassals_assembled"),
              (val_add, ":max_travel_distance", 5), #5..25
              (val_mul, ":max_travel_distance", 6), #30..150
            (try_end),
            
            (try_begin),
              (ge, ":most_threatened_center", 0),
              (store_distance_to_party_from_party, reg12, ":party_no", ":most_threatened_center"),
            (else_try),  
              (assign, reg12, 0),
            (try_end),
              
            (assign, ":num_centers", 0),
            (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
              (store_faction_of_party, ":center_faction", ":center_no"),
              (eq, ":center_faction", ":faction_no"),
              (try_begin),
                #(ge, ":max_travel_distance", 0),
                (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),
                
                (try_begin),
                  (ge, ":most_threatened_center", 0),
                  (store_distance_to_party_from_party, reg13, ":center_no", ":most_threatened_center"),
                (else_try),  
                  (assign, reg13, 0),
                (try_end),

                (store_sub, reg11, reg13, reg12),
                
                (this_or_next|ge, reg11, 40),                
                (this_or_next|ge, ":distance", ":max_travel_distance"),
                (eq, ":center_no", ":most_threatened_center"),
              (else_try),
                #this center is a candidate so increase num_centers by one.
                (val_add, ":num_centers", 1),
              (try_end), 
            (try_end),
            
            (try_begin),
              (ge, ":num_centers", 0),
              (store_random_in_range, ":random_center_no", 0, ":num_centers"),
              (val_add, ":random_center_no", 1),
              (assign, ":num_centers", 0),
              (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
                (store_faction_of_party, ":center_faction", ":center_no"),
                (eq, ":center_faction", ":faction_no"),
                (try_begin),
                  (neq, ":center_no", ":most_threatened_center"),
                  (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),
                  (lt, ":distance", ":max_travel_distance"),
                  
                  (try_begin),
                    (ge, ":most_threatened_center", 0),
                    (store_distance_to_party_from_party, reg13, ":center_no", ":most_threatened_center"),
                  (else_try),  
                    (assign, reg13, 0),
                  (try_end),

                  (store_sub, reg11, reg13, reg12),                
                  (lt, reg11, 40),                
                  
                  (val_sub, ":random_center_no", 1),
                  (eq, ":random_center_no", 0),
                  (assign, ":best_center_to_travel", ":center_no"),
                (try_end),
              (try_end),                            
            (try_end),
          (try_end),  
          
          (assign, ":travel_target", ":best_center_to_travel"),          
          (assign, ":travel_target_new_assigned", 1),
        (try_end),
      (else_try),
        #if party has an ai object and they are close to that object while gathering army, 
        #forget that ai object so they will select a new ai object next.
        (is_between, ":old_ai_object", centers_begin, centers_end),
        # (party_get_position, pos1, ":party_no"),	MOTO chief this is a very small distance
        # (party_get_position, pos2, ":old_ai_object"),
        # (get_distance_between_positions, ":dist", pos1, pos2),
        (store_distance_to_party_from_party, ":distance", ":party_no", ":old_ai_object"),
        (le, ":distance", 3),
        (assign, ":travel_target", -1),
      (try_end),
      #end ozan
     
      (try_begin),
        (eq, ":travel_target", -1),
        (assign, ":action", spai_undefined),
      (else_try),
        (assign, ":action", spai_visiting_village),
      (try_end),
     
      (assign, ":object", ":travel_target"),
     
      (try_begin),
        (eq, ":troop_no", "$g_talk_troop"),
        (try_begin),
          (eq, ":travel_target", -1),
          (str_store_string, s14, "str_as_the_marshall_i_am_assembling_the_army_of_the_realm"),
        (else_try),
          (try_begin),
            (eq, ":faction_no", "$players_kingdom"),
            (eq, ":travel_target_new_assigned", 1),
            (le, "$number_of_report_to_army_quest_notes", 13),
            (check_quest_active, "qst_report_to_army"),            
            (str_store_party_name_link, s10, ":travel_target"),                        
            
            (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"), #300
            
            (str_store_troop_name_link, s11, ":faction_marshal"),
            (store_current_hours, ":hours"),
            (call_script, "script_game_get_date_text", 0, ":hours"),

            (str_store_string, s14, "str_as_the_marshall_i_am_assembling_the_army_of_the_realm_and_travel_to_lands_near_s10_to_inform_more_vassals"),
            (str_store_string, s14, "@({s1}) {s11}: {s14}"),         
            (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
            (val_add, "$number_of_report_to_army_quest_notes", 1),
          (try_end),  

          (assign, reg0, ":travel_target"),
          (str_store_party_name, s10, ":travel_target"),
          (str_store_string, s14, "str_as_the_marshall_i_am_assembling_the_army_of_the_realm_and_travel_to_lands_near_s10_to_inform_more_vassals"),
        (try_end),
        (str_store_string, s16, "str_i_intend_to_assemble_the_army_of_the_realm"),
      (try_end),      		 
	(else_try),
	  (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
	  (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_center),
	  (faction_get_slot, ":faction_object", ":faction_no", "slot_faction_ai_object"),
	  
	  (assign, ":action", spai_besieging_center),
	  (assign, ":object", ":faction_object"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_as_the_marshall_i_am_leading_the_siege"),
	    (str_store_string, s16, "str_i_intend_to_begin_the_siege"),
	  (try_end),
	
	(else_try),
	  (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
	  (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_raiding_village),
	  (faction_get_slot, ":faction_object", ":faction_no", "slot_faction_ai_object"),
	    
	  (assign, ":action", spai_raiding_around_center),
	  (assign, ":object", ":faction_object"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_as_the_marshall_i_am_leading_our_raid"),
	    (str_store_string, s16, "str_i_intend_to_start_our_raid"),
	  (try_end),
	
	(else_try),
	  (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
	  (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
	  (faction_get_slot, ":faction_object", ":faction_no", "slot_faction_ai_object"),
	  (party_is_active, ":faction_object"),
	  
	  #moved (party_set_ai_initiative, ":party_no", 10), #new to avoid losing time of marshal with attacking unimportant targets while there is a threat in our centers.
	  
	  # MOTO move functionality to party_set_ai_state to generalize
	  # (party_get_battle_opponent, ":besieger_party", ":faction_object"),
	  
	  # (try_begin),
	    # (gt, ":besieger_party", 0),
        # (party_is_active, ":besieger_party"),
	    
	    # (assign, ":action", spai_engaging_army),
	    # (assign, ":object", ":besieger_party"),
	    # (try_begin),
          # (eq, ":troop_no", "$g_talk_troop"),
          # (str_store_string, s14, "str_as_the_marshall_i_am_leading_our_forces_to_engage_the_enemy_in_battle"),
          # (str_store_string, s16, "str_i_intend_to_lead_our_forces_out_to_engage_the_enemy"),
        # (try_end),
      # (else_try),      
	  # MOTO end move functionality to party_set_ai_state to generalize
        (assign, ":action", spai_patrolling_around_center),                
        (assign, ":object", ":faction_object"),
        (try_begin),
          (eq, ":troop_no", "$g_talk_troop"),
          (str_store_string, s14, "str_as_the_marshall_i_am_leading_our_forces_in_search_of_the_enemy"),
          (str_store_string, s16, "str_i_intend_to_lead_our_forces_out_to_find_the_enemy"),
        (try_end),
      # (try_end), MOTO move functionality to party_set_ai_state to generalize
      
    (else_try),
      (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
      (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemy_army),
      (faction_get_slot, ":faction_object", ":faction_no", "slot_faction_ai_object"),
      (party_is_active, ":faction_object"),
      
      (assign, ":action", spai_engaging_army),
      (assign, ":object", ":faction_object"),
      (try_begin),
        (eq, ":troop_no", "$g_talk_troop"),
        (str_store_string, s14, "str_as_the_marshall_i_am_leading_our_forces_to_engage_the_enemy_in_battle"),
        (str_store_string, s16, "str_i_intend_to_lead_our_forces_out_to_engage_the_enemy"),
      (try_end),
		

	#MOTO chief move up to inform marshall decisions
	#Get reinforcements		
	# (else_try),
	  # (assign, ":lowest_acceptable_strength_percentage", 30),
	  
	  # #if troop has enought gold then increase by 10%
	  # #(troop_get_slot, ":cur_wealth", ":troop_no", "slot_troop_wealth"),
	  # #(try_begin),
	  # #  (ge, ":cur_wealth", 2000),
	  # #  (assign, ":wealth_addition", 10),
	  # #(else_try),  
	  # #  (store_div, ":wealth_addition", ":cur_wealth", 200),
	  # #(try_end),
	  # #(val_add, ":lowest_acceptable_strength_percentage", ":wealth_addition"),
	  
	  # (call_script, "script_lord_get_home_center", ":troop_no"),
	  # (assign, ":home_center", reg0),
	  # (gt, ":home_center", -1),
	  # (party_slot_eq, ":home_center", "slot_town_lord", ":troop_no"), #newly added
	  
	  # #if troop is very close to its home center increase by 20%
	  # (assign, ":distance_addition", 0),
	  # (party_get_position, pos0, ":home_center"),
	  # (party_get_position, pos1, ":party_no"),
	  # (get_distance_between_positions, ":dist", pos0, pos1),	  	  
	  	  
	  # (try_begin),	  
	    # (le, ":dist", 9000),
	    # (store_div, ":distance_addition", ":dist", 600),
	    # (store_sub, ":distance_addition", 15, ":distance_addition"),
	  # (else_try),
	    # (assign, ":distance_addition", 0),
	  # (try_end),
	  # (val_add, ":lowest_acceptable_strength_percentage", ":distance_addition"),
	  
	  # #if there is no campaign for faction increase by 35%
	  # (assign, ":no_campaign_addition", 35),
	  # (try_begin),
	    # (this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemy_army),
	    # (this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
	    # (this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_raiding_village),
	    # (this_or_next|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_center),
	    # (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
	    # (assign, ":no_campaign_addition", 0),
	    
	    # #If marshal is player itself and if there is a campaign then lower lowest_acceptable_strength_percentage by 10 instead of not changing it.
	    # #Because players become confused when they see very less participation from AI lords to their campaigns.
	    # (try_begin),	    
	      # (faction_slot_eq, ":faction_no", "slot_faction_marshall", "trp_player"),
	      # (options_get_campaign_ai, ":reduce_campaign_ai"),
	      # (try_begin),
	        # (eq, ":reduce_campaign_ai", 0), #hard
	        # (assign, ":no_campaign_addition", 0),
	      # (else_try),  
	        # (eq, ":reduce_campaign_ai", 1), #medium
	        # (assign, ":no_campaign_addition", -10),
	      # (else_try),  
	        # (eq, ":reduce_campaign_ai", 2), #easy
	        # (assign, ":no_campaign_addition", -15),
	      # (try_end),  
	    # (try_end),
	  # (try_end),
	  # (val_add, ":lowest_acceptable_strength_percentage", ":no_campaign_addition"),
	  # (val_max, ":lowest_acceptable_strength_percentage", 25),
	
	  # #max : 30%+15%+35% = 80% (happens when there is no campaign and player is near to its home center.)
	  # (lt, ":party_strength_as_percentage_of_ideal", ":lowest_acceptable_strength_percentage"),
	  
	  # #MOTO chief don't stick around if can't buy reinforcements
	  # (troop_get_slot, ":troop_wealth", ":troop_no", "slot_troop_wealth"),
      # (assign, ":hiring_budget", ":troop_wealth"),	#MOTO hiring budget/reinforcement cost comparison from script_hire_men_to_kingdom_hero_party
      # (val_mul, ":hiring_budget", 3),
      # (val_div, ":hiring_budget", 4),            
	  
	  # (options_get_campaign_ai, ":reduce_campaign_ai"),
      # (try_begin), 
        # (eq, ":reduce_campaign_ai", 0), #hard
        # (assign, ":reinforcement_cost", reinforcement_cost_hard),
      # (else_try), 
        # (eq, ":reduce_campaign_ai", 2), #easy
        # (assign, ":reinforcement_cost", reinforcement_cost_easy),
      # (else_try), 
        # (assign, ":reinforcement_cost", reinforcement_cost_moderate),
      # (try_end),
	  
	  # (try_begin),
        # (lt, ":hiring_budget", ":reinforcement_cost"),
	    # (assign, ":do_only_collecting_rents", 1),
      # (try_end),
	  
      # (ge, ":hiring_budget", ":reinforcement_cost"),

      # # (try_begin),
	    # # (store_div, ":lowest_acceptable_strength_percentage_div_3", ":lowest_acceptable_strength_percentage", 3),
	    # # (ge, ":party_strength_as_percentage_of_ideal", ":lowest_acceptable_strength_percentage_div_3"),
	    # # (troop_get_slot, ":troop_wealth", ":troop_no", "slot_troop_wealth"),
	    # # (le, ":troop_wealth", 1800),
	    # # (assign, ":do_only_collecting_rents", 1),
	  # # (try_end),
	  # #MOTO end don't stick around if can't buy reinforcements
	  	  	  	  	  	  
	  # (assign, ":action", spai_holding_center),
	  # (assign, ":object", ":home_center"),
	  
	  # (try_begin),
	    # (eq, ":troop_no", "$g_talk_troop"),
	    # (str_store_string, s14, "str_i_dont_have_enough_troops_and_i_need_to_get_some_more"),
	    	    
	    # (str_store_string, s16, "str_i_am_running_low_on_troops"),
	  # (try_end),
	  
	  # (eq, ":do_only_collecting_rents", 0),
	#MOTO chief end move up to inform marshall decisions
		
	#follow player orders
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (party_slot_ge, ":party_no", "slot_party_following_orders_of_troop", "trp_kingdom_heroes_including_player_begin"),
	  
	  (party_get_slot, ":orders_type", ":party_no", "slot_party_orders_type"),
	  (party_get_slot, ":orders_object", ":party_no", "slot_party_orders_object"),
	  (party_get_slot, ":orders_time", ":party_no", "slot_party_orders_time"),
	  
	  (ge, ":orders_object", 0),
	  
	  (store_current_hours, ":hours_since_orders_given"),
	  (val_sub, ":hours_since_orders_given", ":orders_time"),
	  
	  (party_is_active, ":orders_object"),
	  (party_get_slot, ":object_state", ":orders_object", "slot_village_state"),
	  (store_faction_of_party, ":object_faction", ":orders_object"),	  
	  (store_relation, ":relation_with_object", ":faction_no", ":object_faction"),
	  
	  (assign, ":orders_are_appropriate", 1),
	  (try_begin),
	    (gt, ":hours_since_orders_given", 48),
	    (assign, ":orders_are_appropriate", 0),
	  (else_try),
	    (eq, ":orders_type", spai_raiding_around_center),
	    (this_or_next|ge, ":relation_with_object", 0),
	    (ge, ":object_state", 2),
	    (assign, ":orders_are_appropriate", 0),
	  (else_try),
	    (eq, ":orders_type", spai_besieging_center),
	    (ge, ":relation_with_object", 0),
	    (assign, ":orders_are_appropriate", 0),
	  (else_try),
	    (this_or_next|eq, ":orders_type", spai_holding_center),
	    (this_or_next|eq, ":orders_type", spai_retreating_to_center),
	    (this_or_next|eq, ":orders_type", spai_accompanying_army),
	    (eq, ":orders_type", spai_visiting_village),
	    (le, ":relation_with_object", 0),
	    (assign, ":orders_are_appropriate", 0),
	  (try_end),
	  
	  (eq, ":orders_are_appropriate", 1),
	  
	  (assign, ":action", ":orders_type"),
	  (assign, ":object", ":orders_object"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_we_are_following_your_direction"),
	  (try_end),
		
	#Host of player wedding
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (eq, ":operation_in_progress", 0),
	  (check_quest_active, "qst_wed_betrothed"),
	  (quest_slot_eq, "qst_wed_betrothed", "slot_quest_giver_troop", ":troop_no"),
	  (quest_get_slot, ":bride", "qst_wed_betrothed", "slot_quest_target_troop"),
	  (call_script, "script_get_kingdom_lady_social_determinants", ":bride"),
	  (assign, ":center_to_visit", reg1),
	  (is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),	#MOTO avoid bug
	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_need_to_make_preparations_for_your_wedding"),
	    (str_store_string, s16, "str_after_all_i_need_to_make_preparations_for_your_wedding"),
	  (try_end),
	
	#Bridegroom at player wedding
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (eq, ":operation_in_progress", 0),
	  (check_quest_active, "qst_wed_betrothed_female"),
	  (quest_slot_eq, "qst_wed_betrothed_female", "slot_quest_giver_troop", ":troop_no"),
	  
	  (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_feast),
	  (faction_get_slot, ":center_to_visit", ":faction_no", "slot_faction_ai_object"),
	  (is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),	#MOTO avoid bug
	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_am_heading_to_the_site_of_our_wedding"), #500
	    (str_store_string, s16, "str_after_all_we_are_soon_to_be_wed"),
	  (try_end),
 	
	#Host of other feast
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (eq, ":operation_in_progress", 0),
	  (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_feast),
	  (faction_get_slot, ":center_to_visit", ":faction_no", "slot_faction_ai_object"),
	  (is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),	#MOTO avoid bug
	  (party_slot_eq, ":center_to_visit", "slot_town_lord", ":troop_no"),
	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_am_hosting_a_feast_there"),
	    (str_store_string, s16, "str_i_have_a_feast_to_host"),
	  (try_end),
		
	#I am the bridegroom at a feast
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (eq, ":operation_in_progress", 0),
	  (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_feast),
	  (troop_get_slot, reg0, ":troop_no", "slot_troop_betrothed"),
	  (is_between, reg0, kingdom_ladies_begin, kingdom_ladies_end),
	  
	  (faction_get_slot, ":center_to_visit", ":faction_no", "slot_faction_ai_object"),
	  (is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),	#MOTO avoid bug
	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_am_to_be_the_bridegroom_there"),
	    (str_store_string, s16, "str_my_wedding_day_draws_near"),
	  (try_end),
	  
	#Drop off prisoners
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (gt,  ":party_ratio_of_prisoners", 35),
	  (eq, ":operation_in_progress", 0),
	  
	  (call_script, "script_lord_get_home_center", ":troop_no"),
	  (assign, ":center_to_visit", reg0),
	  
	  (gt, ":center_to_visit", -1),
	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_have_too_much_loot_and_too_many_prisoners_and_need_to_secure_them"),
	    (str_store_string, s16, "str_i_should_think_of_dropping_off_some_of_my_prisoners"),
	  (try_end),
	
	#Reinforce a weak center		
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (assign, ":center_to_visit", -1),
	  (assign, ":score_to_beat", 100),
	  (eq, ":operation_in_progress", 0),
	  
	  (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
	    (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
	    # (party_get_slot, ":center_strength", ":walled_center", "slot_party_cached_strength"),	MOTO base on number of troops
	    (store_party_size_wo_prisoners, ":center_strength", ":center_no"),	#MOTO base on number of troops

        #MOTO add condition to limit size of prospective garrison
        #players complaining about huge armies sitting in a      center
        #garrison limit from levy above
        (party_get_slot, ":center_max_garrison",      ":center_no", "slot_town_prosperity"),
              (val_mul, ":center_max_garrison", 8),
              (val_add, ":center_max_garrison", 100),    #100..900,      average 500
        (store_add, reg0, ":center_strength", ":party_fit_for_battle"),
        (lt, reg0, ":center_max_garrison"),
        #MOTO end add condition to limit size of prospective      garrison
        
	    (lt, ":center_strength", ":score_to_beat"),
	    (assign, ":center_to_visit", ":center_no"),
	    (assign, ":score_to_beat", ":center_strength"),
	  (try_end),
	  
	  (gt, ":center_to_visit", -1),
	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_need_to_reinforce_it_as_it_is_poorly_garrisoned"),
	    (str_store_string, s16, "str_there_is_a_hole_in_our_defenses"),
	  (try_end),

	#Continue screening, if already doing so
	(else_try),	
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  #MOTO use substate to represent screening properly
	  # (eq, ":old_ai_state", spai_screening_army),
	  (eq, ":old_ai_state", spai_accompanying_army),
      (party_slot_eq, ":party_no", "slot_party_ai_substate", 1),
	  #MOTO end use substate to represent screening properly
	  
	  (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
	  (ge, ":faction_marshal", 0),	#MOTO avoid bug
	  (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
	  (party_is_active, ":marshal_party"),
	  
	  (call_script, "script_npc_decision_checklist_troop_follow_or_not", ":troop_no"),
	  (eq, reg0, 1),
	  
	  (assign, ":action", spai_screening_army),
	  (assign, ":object", ":marshal_party"),
	  (try_begin),
	    (eq, "$g_talk_troop", ":troop_no"),
	    (str_store_string, s14, "str_i_am_following_the_marshals_orders"),
	    (str_store_string, s16, "str_the_marshal_has_given_me_this_command"),
	  (try_end),
		
    (else_try), #special case for sfai_attacking_enemies_around_center for village raids
      (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
      (is_between, ":faction_object", villages_begin, villages_end),
      
      (call_script, "script_npc_decision_checklist_troop_follow_or_not", ":troop_no"),
      (this_or_next|faction_slot_eq, ":faction_no",  "slot_faction_marshall", -1),	#MOTO act if no marshall
      (eq, reg0, 1),
      
      (faction_get_slot, ":faction_object", ":faction_no", "slot_faction_ai_object"),
      (party_get_slot, ":raider_party", ":faction_object", "slot_village_raided_by"),
      (party_is_active, ":raider_party"),
      
      #think about adding one more condition here, what if raider army is so powerfull, again lords will go and engage enemy one by one?
      (party_get_slot, ":enemy_strength_nearby", ":faction_object", "slot_center_sortie_enemy_strength"),
      # (lt, ":enemy_strength_nearby", 4000),	MOTO compare to party's own strength
	  (lt, ":enemy_strength_nearby", ":party_cached_strength"),	#MOTO compare to party's own strength
      #end think
      
      (assign, ":action", spai_engaging_army),
      (assign, ":object", ":raider_party"),
      (try_begin),
        (eq, ":troop_no", "$g_talk_troop"),
        (str_store_string, s14, "str_our_realm_needs_my_support_there_is_enemy_raiding_one_of_our_villages_which_is_not_to_far_from_here_i_am_going_there"),
        (str_store_string, s16, "str_the_marshal_has_issued_a_summons"),
      (try_end),
      						
	#Follow the marshall's orders - if on the offensive, and the campaign has not lasted too long. Readiness is currently randomly set
	(else_try),	
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  # (call_script, "script_npc_decision_checklist_troop_follow_or_not", ":troop_no"),	MOTO check if marshal exists first
	  # (eq, reg0, 1),
	  
	  (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
	  (ge, ":faction_marshal", 0),	#MOTO avoid bug
	  (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
	  	  
	  #MOTO check if marshal first
	  (call_script, "script_npc_decision_checklist_troop_follow_or_not", ":troop_no"),
	  (eq, reg0, 1),
	  #MOTO end check if marshal first
	  
	  (assign, ":action", spai_accompanying_army),
	  (assign, ":object", ":marshal_party"),
	  	  	  
	  (try_begin),
	    (eq, "$g_talk_troop", ":troop_no"),
	    (str_store_string, s14, "str_i_am_answering_the_marshals_summons"),
	    (str_store_string, s16, "str_the_marshal_has_issued_a_summons"),
	  (try_end),
	  
	#Support a nearby ally who is on the offensive		
	(else_try),	
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (eq, ":faction_is_at_war", 1),
	  
	  (assign, ":party_to_support", -1),
	  (try_for_range, ":allied_hero", active_npcs_begin, active_npcs_end),
	    (troop_slot_eq, ":allied_hero", "slot_troop_occupation", slto_kingdom_hero),
	    (store_faction_of_troop, ":allied_hero_faction", ":allied_hero"),
	    (eq, ":allied_hero_faction", ":faction_no"),
	  
	    (neq, ":allied_hero", ":troop_no"),
	  
	    (troop_get_slot, ":allied_hero_party", ":allied_hero", "slot_troop_leaded_party"),
	    (gt, ":allied_hero_party", 1),
	    (party_is_active, ":allied_hero_party"),
		
	  
	    (this_or_next|party_slot_eq, ":allied_hero_party", "slot_party_ai_state", spai_raiding_around_center),
			(party_slot_eq, ":allied_hero_party", "slot_party_ai_state", spai_besieging_center),
	  
	    (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":allied_hero"),
	    # (gt, reg0, 4),	MOTO make variable
		(store_div, ":relation", reg0, 4),	#MOTO make variable
		(gt, ":relation", 1),	#MOTO make variable
	  
	    (troop_get_slot, ":troop_renown", ":troop_no", "slot_troop_renown"),
	    (troop_get_slot, ":ally_renown", ":allied_hero", "slot_troop_renown"),
	    (le, ":troop_renown", ":ally_renown"), #Ally to support must have higher renown
	  
	    (store_distance_to_party_from_party, ":distance", ":party_no", ":allied_hero_party"),
	  
	    # (lt, ":distance", 5),	MOTO make variable
		(lt, ":distance", ":relation"),	#MOTO make variable
	  
 	    (assign, ":party_to_support", ":allied_hero_party"),
	  (try_end),
	  (gt, ":party_to_support", 0),
	  	  
	  (assign, ":action", spai_accompanying_army),
	  (assign, ":object", ":party_to_support"),
	  (try_begin),
		  (eq, ":troop_no", "$g_talk_troop"),
		  (party_stack_get_troop_id, ":leader", ":object", 0),
		  (str_store_troop_name, s10, ":leader"),
		  
		  (call_script, "script_troop_get_family_relation_to_troop", ":leader", "$g_talk_troop"),
		  (try_begin),
		    (eq, reg0, 0),
		    (str_store_string, s11, "str_comradeinarms"),
		  (try_end),
		  (str_store_string, s14, "str_i_am_supporting_my_s11_s10"),
		  (str_store_string, s16, "str_i_believe_that_one_of_my_comrades_is_in_need"),
	  (try_end),
    #I have decided to attack a vulnerable fortress
	(else_try),	
	  # (eq, ":do_only_collecting_rents", 0),	MOTO deprecated
	  (eq, ":faction_is_at_war", 1),
	  (eq, ":operation_in_progress", 0),
	  
	  (assign, ":target_center", -1),
	  (assign, ":score_to_beat", 50),
	  
	  (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
	    (store_faction_of_party, ":center_faction", ":center_no"),
	    (store_relation, ":relation", ":faction_no", ":center_faction"),
	    (lt, ":relation", 0),
	    
	    (party_get_slot, ":center_strength", ":center_no", "slot_party_cached_strength"),
	    (val_mul, ":center_strength", 3),
	    (val_mul, ":center_strength", 2),
	    
	    (lt, ":center_strength", ":party_cached_strength"), 
	    # (lt, ":center_strength", 750),
	    (lt, ":center_strength", 3000),	#MOTO this is about 100 troops (with defense bonus)
	    
	    (party_slot_eq, ":center_no", "slot_village_state", svs_normal),
	    (store_distance_to_party_from_party, ":distance", ":center_no", ":party_no"),
	    (lt, ":distance", ":score_to_beat"),
	    
	    (assign, ":target_center", ":center_no"),
	    (assign, ":score_to_beat", ":distance"),
	  (try_end),
	  
	  (is_between, ":target_center", centers_begin, centers_end),
	  
	  (assign, ":action", spai_besieging_center),
	  (assign, ":object", ":target_center"),
	  (try_begin),
	    (eq, "$cheat_mode", 1),
	    (str_store_faction_name, s20, ":faction_no"),
	    (str_store_party_name, s21, ":object"),
	    (display_message, "str_s20_decided_to_attack_s21"),
	  (try_end),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_a_fortress_is_vulnerable"),
	    (str_store_string, s16, "str_i_believe_that_the_enemy_may_be_vulnerable"),
	  (try_end),
	  
	#I am visiting an estate
	(else_try),
	  (eq, ":operation_in_progress", 0),	  	  
	  	  
      #MOTO collect rents only when it actually helps recruit
	  # (assign, ":score_to_beat", 300),	#at least 300 gold to pick up MOTO equals reinforcement_cost_hard
	  (options_get_campaign_ai, ":reduce_campaign_ai"),
	  (try_begin), 
		(eq, ":reduce_campaign_ai", 0),	#hard
		(assign, ":score_to_beat", reinforcement_cost_hard),
	  (else_try), 
		(eq, ":reduce_campaign_ai", 2),	#easy
		(assign, ":score_to_beat", reinforcement_cost_easy),
	  (else_try), 
		(assign, ":score_to_beat", reinforcement_cost_moderate),
	  (try_end),
	  (val_mul, ":score_to_beat", 4),	# 4/3 "hiring budget" from script_hire_men_to_kingdom_hero_party
	  (val_div, ":score_to_beat", 3),
	  (troop_get_slot, ":troop_wealth", ":troop_no", "slot_troop_wealth"),	#average troop wealth is 2000
	  (try_begin),
		(lt, ":troop_wealth", ":score_to_beat"),	#parties that lack wealth...
		(val_div, ":score_to_beat", 2),	#...are willing to go get half of what they need
	  (else_try),	#parties with wealth are not so eager to collect more
		(val_sub, ":troop_wealth", ":score_to_beat"),	#MOTO add 10% of amount OVER what is needed
		(val_div, ":troop_wealth", 10),	#average troop wealth 10% is is 200 MOTO 160 with hard campaign AI
		(val_add, ":score_to_beat", ":troop_wealth"),	#average score to beat is 500 MOTO 560 with hard campaign AI
	  (try_end),
	  #MOTO end collect rents only when it actually helps recruit

	  (try_begin),	    
	    (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
	    (ge, ":faction_marshal", 0),	#MOTO avoid bug
	    
	    (assign, reg17, 0),
	    (try_begin),
	      (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
	      # (party_slot_eq, ":party_no", "slot_party_ai_object", ":faction_marshal"),	MOTO wrong
	      (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
	      (party_is_active, ":marshal_party"),
	      (party_slot_eq, ":party_no", "slot_party_ai_object", ":marshal_party"),
		  #MOTO end wrong
	      (assign, reg17, 1),
	    (else_try),  	    
	      (party_slot_eq, ":party_no", "slot_party_following_player", 1),
	      (assign, reg17, 1),
	    (try_end),  
	    (eq, reg17, 1),
	    
	    (try_begin),
	      (neq, ":faction_marshal", "trp_player"),
	      (neg|party_slot_eq, ":party_no", "slot_party_following_player", 1),
	      (val_add, ":score_to_beat", 125),
	    (else_try),
	      (val_add, ":score_to_beat", 250),
	    (try_end),
	  (try_end),  
	  
	  (assign, ":center_to_visit", -1),

	  (try_for_range, ":center_no", centers_begin, centers_end),
	    (party_slot_eq, ":center_no", "slot_town_lord", ":troop_no"),
	    
	    (assign, reg17, 0),
	    (try_begin),
	      (is_between, ":center_no", villages_begin, villages_end),
	      (party_slot_eq, ":center_no", "slot_village_state", svs_normal),
	      (assign, reg17, 1),
	    (else_try),  	    
	      (party_slot_eq, ":center_no", "slot_center_is_besieged_by", -1),
	      (assign, reg17, 1),
	    (try_end),	    
	    (eq, reg17, 1),
	    
	    (party_get_slot, ":tariffs_available", ":center_no", "slot_center_accumulated_tariffs"),
	    (party_get_slot, ":rents_available", ":center_no", "slot_center_accumulated_rents"),
	    (store_add, ":money_available", ":rents_available", ":tariffs_available"),
	    	    
	    (gt, ":money_available", ":score_to_beat"),
	    (assign, ":center_to_visit", ":center_no"),
	    (assign, ":score_to_beat", ":money_available"),			
	  (try_end),
	  
	  (is_between, ":center_to_visit", centers_begin, centers_end),
	  	  
	  (try_begin),
	    (is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),
	    (assign, ":action", spai_holding_center),
	    (assign, ":object", ":center_to_visit"),
	  (else_try),  
        (assign, ":action", spai_visiting_village),
  	    (assign, ":object", ":center_to_visit"),
	  (try_end),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_need_to_inspect_my_properties_and_collect_my_dues"),
	    (str_store_string, s16, "str_it_has_been_too_long_since_i_have_inspected_my_estates"),
	  (try_end),
	  
	#My men are weary, and I wish to return home
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
	  (this_or_next|gt, ":hours_since_last_rest", 504), #Three weeks
	  (lt, ":aggressiveness", 25),	  
	  (gt, ":hours_since_last_rest", 168), #one week if aggressiveness < 25	
	  (eq, ":operation_in_progress", 0),
	  
	  (call_script, "script_lord_get_home_center", ":troop_no"),
	  (assign, ":center_to_visit", reg0),
	  
	  (gt, ":center_to_visit", -1),
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_my_men_are_weary_so_we_are_returning_home"),
	    (str_store_string, s16, "str_my_men_are_becoming_weary"),
	  (try_end),
	
	#I have a score to settle with the enemy
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
	  (this_or_next|gt, ":hours_since_last_combat", 12),
	  (lt, ":hours_since_last_rest", 96),
	  (eq, ":operation_in_progress", 0),
      (gt, ":party_fit_for_battle", 30),	#MOTO chief size requirement
	  
	  (eq, ":faction_is_at_war", 1),
	  (this_or_next|eq, ":troop_reputation", lrep_debauched),
	  (eq, ":troop_reputation", lrep_quarrelsome),
	  
	  (assign, ":target_center", -1),
	  (assign, ":score_to_beat", 0), #based on relation
	  
	  (try_for_range, ":center_no", villages_begin, villages_end),
	    (store_faction_of_party, ":center_faction", ":center_no"),
	    (store_relation, ":relation", ":center_faction", ":faction_no"),
	    (lt, ":relation", 0),
	    
	    (neg|party_slot_ge, ":center_no", "slot_village_state", svs_looted),
	    (party_get_slot, ":town_lord", ":center_no", "slot_town_lord"),
	    (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":town_lord"),
	    (assign, ":village_score", reg0),
	    
	    (lt, ":village_score", ":score_to_beat"),
	    (assign, ":score_to_beat", ":village_score"),
	    (assign, ":target_center", ":center_no"),
	  (try_end),
	  
	  (is_between, ":target_center", centers_begin, centers_end),
	  (assign, ":action", spai_raiding_around_center),
	  (assign, ":object", ":target_center"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_have_a_score_to_settle_with_the_lord_there"),
	    (str_store_string, s16, "str_i_am_thinking_of_settling_an_old_score"),
	  (try_end),
	
	#I need money, so I am raiding where the money is
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
	  (eq, ":faction_is_at_war", 1),
	  (eq, ":operation_in_progress", 0),
      (gt, ":party_fit_for_battle", 30),	#MOTO chief size requirement
	  
	  (this_or_next|gt, ":hours_since_last_combat", 12),
	  (lt, ":hours_since_last_rest", 96),
	  (gt, ":aggressiveness", 40),
	  
	  (this_or_next|eq, ":troop_reputation", lrep_debauched),
	  (this_or_next|eq, ":troop_reputation", lrep_selfrighteous),
	  (this_or_next|eq, ":troop_reputation", lrep_cunning),
	  (eq, ":troop_reputation", lrep_quarrelsome),
	  
	  (troop_get_slot, ":troop_wealth", ":troop_no", "slot_troop_wealth"),
	  (lt, ":troop_wealth", 500),
	  
	  (assign, ":score_to_beat", 0),
	  (assign, ":target_center", -1),
	  
	  #MOTO count lord's fiefs
	  (assign, ":num_centers", 0),
	  # (try_for_range, ":possible_target", villages_begin, villages_end),
	  (try_for_range, ":center_no", centers_begin, centers_end),
	    (party_get_slot, ":town_lord", ":center_no", "slot_town_lord"),
		(try_begin),
		  (eq, ":town_lord", ":troop_no"),
		  (val_add, ":num_centers", 1),
		(try_end),
	    (is_between, ":center_no", villages_begin, villages_end),
		#MOTO end count lord's fiefs
	    (store_faction_of_party, ":center_faction", ":center_no"),
	    (store_relation, ":relation", ":center_faction", ":faction_no"),
	    (lt, ":relation", 0),
	    
	    (this_or_next|party_slot_eq, ":center_no", "slot_village_state", svs_normal),
	    (party_slot_eq, ":center_no", "slot_village_state", svs_being_raided),
	    
	    (party_get_slot, reg17, ":center_no", "slot_town_prosperity"),
	    (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),
	    (val_sub, reg17, ":distance"),
	    
	    (gt, reg17, ":score_to_beat"),
	    (assign, ":score_to_beat", reg17),
	    (assign, ":target_center", ":center_no"),
	  (try_end),
	  
	  (gt, ":num_centers", 0),	#a fief yields at least 1200 per week, so such a lord would not need to raid
	  (gt, ":target_center", -1),
	  
	  (assign, ":action", spai_raiding_around_center),
	  (assign, ":object", ":target_center"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_am_short_of_money_and_i_hear_that_there_is_much_wealth_there"),
	    (str_store_string, s16, "str_i_need_to_refill_my_purse_preferably_with_the_enemys_money"),
	  (try_end),
	
	#Attacking wealthiest lands
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(eq, ":faction_is_at_war", 1),
		(eq, ":operation_in_progress", 0),
		(gt, ":aggressiveness", 65),
        (gt, ":party_fit_for_battle", 30),	#MOTO chief size requirement
	
		(assign, ":score_to_beat", 0),
		(assign, ":target_center", -1),
		
		(try_for_range, ":center_no", villages_begin, villages_end),
			(store_faction_of_party, ":center_faction", ":center_no"),
			(store_relation, ":relation", ":center_faction", ":faction_no"),
			(lt, ":relation", 0),			
			(neg|party_slot_eq, ":center_no", "slot_village_state", svs_looted),			
			(party_get_slot, ":village_prosperity", ":center_no", "slot_town_prosperity"),
			# (val_mul, ":village_prosperity", 2),	MOTO too far

			(store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),
			(val_sub, ":village_prosperity", ":distance"),			
			(gt, ":village_prosperity", ":score_to_beat"),
			
			(assign, ":score_to_beat", ":village_prosperity"),
			(assign, ":target_center", ":center_no"),
		(try_end),

		(gt, ":target_center", -1),

		(assign, ":action", spai_raiding_around_center),
		(assign, ":object", ":target_center"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_by_striking_at_the_enemys_richest_lands_perhaps_i_can_draw_them_out_to_battle"),
			(str_store_string, s16, "str_i_am_thinking_of_going_on_the_attack"),
		(try_end),

	#End the war
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(eq, ":troop_reputation", lrep_upstanding),
		(eq, ":faction_is_at_war", 1),
		(eq, ":operation_in_progress", 0),
        (gt, ":party_fit_for_battle", 30),	#MOTO chief size requirement
		
		(assign, ":faction_to_attack", -1),
		(try_for_range, ":possible_faction_to_attack", kingdoms_begin, kingdoms_end),
			(store_relation, ":relation", ":faction_no", ":possible_faction_to_attack"),
			(lt, ":relation", 0),
			(faction_slot_eq, ":possible_faction_to_attack", "slot_faction_state", sfs_active),
			
			(store_add, ":slot", ":possible_faction_to_attack", "slot_faction_war_damage_inflicted_on_factions_begin"),
			(val_sub, ":slot", kingdoms_begin),
			(faction_get_slot, ":war_damage_inflicted", ":faction_no", ":slot"),

			(store_add, ":slot", ":faction_no", "slot_faction_war_damage_inflicted_on_factions_begin"),
			(val_sub, ":slot", kingdoms_begin),
			(faction_get_slot, ":war_damage_suffered", ":possible_faction_to_attack", ":slot"),
			
			(gt, ":war_damage_inflicted", 80),
			(lt, ":war_damage_inflicted", ":war_damage_suffered"),
			(assign, ":faction_to_attack", ":possible_faction_to_attack"),
		(try_end),
		
		(gt, ":faction_to_attack", -1),

		(assign, ":target_center", -1),
		(assign, ":score_to_beat", 50),
		
		(try_for_range, ":center_no", villages_begin, villages_end),
			(store_faction_of_party, ":center_faction", ":center_no"),		
			(eq, ":center_faction", ":faction_to_attack"),			
			(neg|party_slot_eq, ":center_no", "slot_village_state", svs_looted),			
			(store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),			
			(lt, ":distance", ":score_to_beat"),
			
			(assign, ":score_to_beat", ":distance"),
			(assign, ":target_center", ":center_no"),
		(try_end),
		
		(gt, ":target_center", -1),

		(assign, ":action", spai_raiding_around_center),
		(assign, ":object", ":target_center"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_perhaps_if_i_strike_one_more_blow_we_may_end_this_war_on_our_terms_"),
			(str_store_string, s16, "str_we_may_be_able_to_bring_this_war_to_a_close_with_a_few_more_blows"),
		(try_end),
	
	#I have a feast to attend
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_feast),
		(faction_get_slot, ":center_to_visit", ":faction_no", "slot_faction_ai_object"),
		(party_get_slot, ":town_lord", ":center_to_visit", "slot_town_lord"), 
	    (is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),	#MOTO avoid bug
		(eq, ":operation_in_progress", 0),
			
		(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":town_lord"),
		# (assign, ":relation_with_host", reg0),
			
        (ge, reg0, 0),
		
		(assign, ":action", spai_holding_center),
		(assign, ":object", ":center_to_visit"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_wish_to_attend_the_feast_there"),
			(str_store_string, s16, "str_there_is_a_feast_which_i_wish_to_attend"),
		(try_end),		
	#A lady to court
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(neg|troop_slot_eq, "trp_player", "slot_troop_betrothed", ":troop_no"),
		(troop_slot_eq, ":troop_no", "slot_troop_spouse", -1),
		(neg|is_between, ":troop_no", kings_begin, kings_end),
		(neg|is_between, ":troop_no", pretenders_begin, pretenders_end),

		
		(gt, ":hours_since_last_courtship", 72),
		(eq, ":operation_in_progress", 0),
		
		(assign, ":center_to_visit", -1),
		(assign, ":score_to_beat", 150),
		
		(try_for_range, ":slot", "slot_troop_love_interest_1", "slot_troop_love_interests_end"),
			(troop_get_slot, ":love_interest", ":troop_no", ":slot"),
			(is_between, ":love_interest", kingdom_ladies_begin, kingdom_ladies_end),	
			(troop_get_slot, ":center_no", ":love_interest", "slot_troop_cur_center"),
			(is_between, ":center_no", centers_begin, centers_end),
			(store_faction_of_party, ":center_faction", ":center_no"),
			(eq, ":faction_no", ":center_faction"),
            #(store_relation, ":relation", ":faction_no", ":love_interest_faction_no"),
            #(ge, ":relation", 0),
			
			(store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),
			
			(lt, ":distance", ":score_to_beat"),
			(assign, ":center_to_visit", ":center_no"),
			(assign, ":score_to_beat", ":distance"),			
        (try_end),
 
		(gt, ":center_to_visit", -1),
			
		(assign, ":action", spai_holding_center),
		(assign, ":object", ":center_to_visit"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_there_is_a_fair_lady_there_whom_i_wish_to_court"),
			(str_store_string, s16, "str_i_have_the_inclination_to_pay_court_to_a_fair_lady"),
		(try_end),
				
	#Patrolling an alarmed center
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(assign, ":target_center", -1),
		(assign, ":score_to_beat", 60),
		(eq, ":operation_in_progress", 0),
		(gt, ":aggressiveness", 40),

		(try_for_range, ":center_no", centers_begin, centers_end), #find closest center that has spotted enemies.
            (store_faction_of_party, ":center_faction", ":center_no"),
            (eq, ":center_faction", ":faction_no"),
			(party_slot_ge, ":center_no", "slot_center_last_spotted_enemy", 0),
			
			#new - begin
			# (party_get_slot, ":sortie_strength", ":center_to_patrol", "slot_center_sortie_strength"),	MOTO use party_slot_ge below
			(party_get_slot, ":enemy_strength_mul_14_div_10", ":center_no", "slot_center_sortie_enemy_strength"),
			(val_mul, ":enemy_strength_mul_14_div_10", 14),
			(val_div, ":enemy_strength_mul_14_div_10", 10),
			# (party_get_slot, ":party_strength", ":party_no", "slot_party_cached_strength"),	MOTO use party_slot_ge below
			
			(this_or_next|neg|party_is_in_town, ":party_no", ":center_no"),			
			# (gt, ":sortie_strength", ":enemy_strength_mul_14_div_10"),
			(party_slot_ge, ":center_no", "slot_center_sortie_strength", ":enemy_strength_mul_14_div_10"),
			
			# (ge, ":party_strength", 100),	MOTO this is 5 troops
			(party_slot_ge, ":party_no", "slot_party_cached_strength", 2000),	#MOTO this is around 100 troops
			#new - end
									
			(party_get_slot, ":town_lord", ":center_no", "slot_town_lord"),						
			(call_script, "script_troop_get_relation_with_troop", ":town_lord", ":troop_no"),
			
			(this_or_next|eq, ":troop_reputation", lrep_upstanding),
				(gt, reg0, -5),
			
            (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),
			(lt, ":distance", ":score_to_beat"),
			
			(assign, ":target_center", ":center_no"),
			(assign, ":score_to_beat", ":distance"),
		(try_end),

		(is_between, ":target_center", centers_begin, centers_end),
		
		(assign, ":action", spai_patrolling_around_center),
		(assign, ":object", ":target_center"),
				
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_we_have_heard_reports_that_the_enemy_is_in_the_area"),
			(str_store_string, s16, "str_i_have_heard_reports_of_enemy_incursions_into_our_territory"),
		(try_end),
	
	#Get reinforcements	MOTO copy here as low priority recruit without restriction
	(else_try),
	  (gt, ":center_to_visit", -1),
	  (party_slot_eq, ":center_to_visit", "slot_town_lord", ":troop_no"), #newly added
	  
	  # (lt, ":party_strength_as_percentage_of_ideal", 100),	#MOTO recruit whenever can
	  
	  #MOTO don't interrupt marshal operation for this
	  (this_or_next|eq, ":operation_in_progress", 0),
	  (neg|faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
	  #MOTO end don't interrupt marshal operation for this
	
	  (troop_get_slot, ":troop_wealth", ":troop_no", "slot_troop_wealth"),
      (assign, ":hiring_budget", ":troop_wealth"),	#MOTO hiring budget/reinforcement cost comparison from script_hire_men_to_kingdom_hero_party
      (val_mul, ":hiring_budget", 3),
      (val_div, ":hiring_budget", 4),            
	  
	  (options_get_campaign_ai, ":reduce_campaign_ai"),
      (try_begin), 
        (eq, ":reduce_campaign_ai", 0), #hard
        (assign, ":reinforcement_cost", reinforcement_cost_hard),
      (else_try), 
        (eq, ":reduce_campaign_ai", 2), #easy
        (assign, ":reinforcement_cost", reinforcement_cost_easy),
      (else_try), 
        (assign, ":reinforcement_cost", reinforcement_cost_moderate),
      (try_end),
	  
      (ge, ":hiring_budget", ":reinforcement_cost"),
	  	  	  	  	  	  
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_visit"),
	  
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_dont_have_enough_troops_and_i_need_to_get_some_more"),
	    (str_store_string, s16, "str_i_am_running_low_on_troops"),
	  (try_end),
		
	#Time in household
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(gt, ":hours_since_last_home", 168),
		(eq, ":operation_in_progress", 0),

		(call_script, "script_lord_get_home_center", ":troop_no"),
		(assign, ":center_to_visit", reg0),
		(gt, ":center_to_visit", -1),
		
		(assign, ":action", spai_holding_center),
		(assign, ":object", ":center_to_visit"),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_need_to_spend_some_time_with_my_household"),
			(str_store_string, s16, "str_it_has_been_a_long_time_since_i_have_been_able_to_spend_time_with_my_household"),
		(try_end),

	#Patrolling the borders
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(eq, ":faction_is_at_war", 1),
		(gt, ":aggressiveness", 65),
		(eq, ":operation_in_progress", 0),
		
		(assign, ":target_center", -1),
		(assign, ":score_to_beat", 75),
		
		(try_for_range, ":center_no", villages_begin, villages_end),
			(store_faction_of_party, ":center_faction", ":center_no"),
			(store_relation, ":relation", ":center_faction", ":faction_no"),
			(lt, ":relation", 0),
			
			(store_distance_to_party_from_party, ":distance", ":center_no", ":party_no"),
			(lt, ":distance", ":score_to_beat"),
			
			(assign, ":score_to_beat", ":distance"),
			(assign, ":target_center", ":center_no"),
		(try_end),
		
		(is_between, ":target_center", villages_begin, villages_end),
				
		(assign, ":action", spai_patrolling_around_center),
		(assign, ":object", ":target_center"),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_am_watching_the_borders"),
			(str_store_string, s16, "str_i_may_be_needed_to_watch_the_borders"),
		(try_end),

	#Visiting a friend - temporarily disabled
	(else_try),
		(eq, 1, 0),
		
	#Patrolling home
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(call_script, "script_lord_get_home_center", ":troop_no"),
		(assign, ":center_to_visit", reg0),
		
		(is_between, ":center_to_visit", centers_begin, centers_end),
		(eq, ":operation_in_progress", 0),
		
		(assign, ":action", spai_patrolling_around_center),
		(assign, ":object", ":center_to_visit"),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_will_guard_the_areas_near_my_home"),
			(str_store_string, s16, "str_i_am_perhaps_needed_most_at_home"),
		(try_end),
	
	#Default end
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(eq, ":operation_in_progress", 0),

		(call_script, "script_lord_get_home_center", ":troop_no"),
		(assign, ":center_to_visit", reg0),
		(is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),
		
		(assign, ":action", spai_holding_center),
		(assign, ":object", ":center_to_visit"),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_cant_think_of_anything_better_to_do"),
		(try_end),
	(else_try),	
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(eq, ":operation_in_progress", 1),

		(party_get_slot, ":action", ":party_no", "slot_party_ai_state"),
		(party_get_slot, ":object", ":party_no", "slot_party_ai_object"),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_am_completing_what_i_have_already_begun"),
		(try_end),
	(else_try),
	  # (eq, ":do_only_collecting_rents", 0),	MOTO chief since we are past "visit estates" section, there's no rent to collect
		(assign, ":action", spai_undefined),
		(assign, ":object", -1),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_dont_even_have_a_home_to_which_to_return"),
		(try_end),
	(try_end),
		
	(try_begin),
		(eq, "$cheat_mode", 2),
		(str_store_troop_name, s10, ":troop_no"),
		(display_message, "str_debug__s10_decides_s14_faction_ai_s15"),
	(try_end),
			
    (assign, reg0, ":action"),
	(assign, reg1, ":object"),  	
	]),
	
	#script_npc_decision_checklist_troop_follow_or_not
    # INPUT: troop_no
    # OUTPUT: reg0
	(
	"npc_decision_checklist_troop_follow_or_not", [

	(store_script_param, ":troop_no", 1),
	(store_faction_of_troop, ":faction_no", ":troop_no"),
	(faction_get_slot, ":faction_ai_state", ":faction_no", "slot_faction_ai_state"),

	(troop_get_slot, ":troop_reputation", ":troop_no", "slot_lord_reputation_type"),
	(faction_get_slot, ":faction_marshall", ":faction_no", "slot_faction_marshall"),
	
	(assign, ":result", 0),
	(try_begin),
		(eq, ":faction_marshall", -1),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__i_am_acting_independently_because_no_marshal_is_appointed"),
		(try_end),
	(else_try),			
		(troop_get_slot, ":faction_marshall_party", ":faction_marshall", "slot_troop_leaded_party"),
		(neg|party_is_active, ":faction_marshall_party"),

		#Not doing an offensive
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__i_am_acting_independently_because_our_marshal_is_currently_indisposed"),
		(try_end),
	(else_try),
		(neq, ":faction_ai_state", sfai_attacking_center),
        (neq, ":faction_ai_state", sfai_raiding_village),
        (neq, ":faction_ai_state", sfai_attacking_enemies_around_center),
        (neq, ":faction_ai_state", sfai_attacking_enemy_army),
        (neq, ":faction_ai_state", sfai_gathering_army),
	
		#Not doing an offensive
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__i_am_acting_independently_because_our_realm_is_currently_not_on_campaign"),
		(try_end),
	(else_try),
		(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_marshall"),
		(assign, ":relation_with_marshall", reg0),
		
		(try_begin),
		  (le, ":relation_with_marshall", -10),
		  (assign, ":acceptance_level", 10000),
		(else_try),  
		  (store_mul, ":acceptance_level", ":relation_with_marshall", -1000),
		(try_end), 
		
		(val_add, ":acceptance_level", 1500),
		(options_get_campaign_ai, ":reduce_campaign_ai"),
		(try_begin),
		  (neq, ":faction_no", "$players_kingdom"),          
          (try_begin),
            (eq, ":reduce_campaign_ai", 0), #hard
            (val_add, ":acceptance_level", -1350),#gdw-1250
          (else_try),
            (eq, ":reduce_campaign_ai", 1), #moderate
			(val_add, ":acceptance_level", 0),#gdw0
          (else_try),                        
            (eq, ":reduce_campaign_ai", 2), #easy
            (val_add, ":acceptance_level", 2300),#gdw1250 use this if itsoverhwhelmg
          (try_end),           
        (else_try), #you are marshall
          (faction_slot_eq, ":faction_no", "slot_faction_marshall", "trp_player"),
          (try_begin),
            (eq, ":reduce_campaign_ai", 0), #hard/player's faction
            (val_add, ":acceptance_level", -1000),#gdw
          (else_try),
            (eq, ":reduce_campaign_ai", 1), #moderate/player's faction
            (val_add, ":acceptance_level", -1800),#gdw
          (else_try),                        
            (eq, ":reduce_campaign_ai", 2), #easy/player's faction
            (val_add, ":acceptance_level", -2800),#gdw
          (try_end),           
		(try_end),
										
		(troop_get_slot, ":temp_ai_seed", ":troop_no", "slot_troop_temp_decision_seed"),
		
		(le, ":temp_ai_seed", ":acceptance_level"),				
	
		#Very low opinion of marshall
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__i_am_not_accompanying_the_marshal_because_i_fear_that_he_may_lead_us_into_disaster"),
		(try_end),
		#Make nuanced, depending on personality type
	(else_try),	
		# (troop_get_slot, ":marshal_controversy", ":faction_marshall", "slot_faction_marshall"),
		(troop_get_slot, ":marshal_controversy", ":faction_marshall", "slot_troop_controversy"),	#MOTO correction!
	
		(lt, ":relation_with_marshall", 0),
		(ge, ":marshal_controversy", 50),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str_i_am_not_accompanying_the_marshal_because_i_question_his_judgment"),
		(try_end),
	(else_try),	
		# (troop_get_slot, ":marshal_controversy", ":faction_marshall", "slot_faction_marshall"),	MOTO wrong!
		(neg|faction_slot_eq, ":faction_no", "slot_faction_leader", ":faction_marshall"),
		
		(lt, ":relation_with_marshall", 5),
		(ge, ":marshal_controversy", 80),
		
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str_i_am_not_accompanying_the_marshal_because_will_be_reappointment"),
		(try_end),
	(else_try),
		#(lt, ":relation_with_marshall", 45),	
		#(eq, ":faction_marshall", "trp_player"), #moved below as only effector. Search "think about this".
		
		(store_sub, ":relation_with_marshal_difference", 50, ":relation_with_marshall"),
		
		#for 50 relation with marshal ":acceptance_level" will be 0
		#for 20 relation with marshal ":acceptance_level" will be 2100 #gdw it #appears acceptance is inverse to friendliness
		#for 10 relation with marshal ":acceptance_level" will be 2800
		#for 0 relation with marshal ":acceptance_level" will be 3500
		#for -10 relation with marshal ":acceptance_level" will be 4200
		#average is about 2500
		(store_mul, ":acceptance_level", ":relation_with_marshal_difference", 70), 
		# -
        (options_get_campaign_ai, ":reduce_campaign_ai"),		
		(try_begin),
		  (neq, ":faction_no", "$players_kingdom"),
          
          (try_begin),
            (eq, ":reduce_campaign_ai", 0), #hard
            (val_add, ":acceptance_level", -1400),#gdw -1250
          (else_try),#gdw for when ai uncoordinated in making attacks
            (eq, ":reduce_campaign_ai", 1), #moderate
            (val_add, ":acceptance_level", 0),#gdw
		  (else_try),                        
            (eq, ":reduce_campaign_ai", 2), #easy
            (val_add, ":acceptance_level", 2300),#gdw
          (try_end),           
		(else_try),        
          (eq, ":faction_marshall", "trp_player"), #when you are the marshall
          
          (try_begin),
            (eq, ":reduce_campaign_ai", 0), #hard
            (val_add, ":acceptance_level", -1000),#gdw1000
          (else_try),
            (eq, ":reduce_campaign_ai", 1), #moderate
            (val_add, ":acceptance_level", -1600),#gdw1500
          (else_try),                        
            (eq, ":reduce_campaign_ai", 2), #easy
            (val_add, ":acceptance_level", -2800),#gdw -2000
          (try_end),           		  
		(try_end),
		
		(try_begin),
		  (eq, ":troop_reputation", lrep_selfrighteous),
		  (val_add, ":acceptance_level", 1200),#gdw1500
		(else_try),  
		  (this_or_next|eq, ":troop_reputation", lrep_martial),		
		  (this_or_next|eq, ":troop_reputation", lrep_roguish),		
		  (eq, ":troop_reputation", lrep_quarrelsome),
		  (val_add, ":acceptance_level", 850),#gdw1000 balances out big move above
		(else_try),  
		  (eq, ":troop_reputation", lrep_cunning), 
		  (val_add, ":acceptance_level", 400),#gdw450
		(else_try),  
		  (eq, ":troop_reputation", lrep_upstanding), #neutral
		(else_try),  
		  (this_or_next|eq, ":troop_reputation", lrep_benefactor), #helper	
		  (eq, ":troop_reputation", lrep_goodnatured),		
		  (val_add, ":acceptance_level", -600),#gdw
		(else_try),  
		  (eq, ":troop_reputation", lrep_custodian), #very helper
		  (val_add, ":acceptance_level", -1100),#gdw this must be for companions
		(try_end),  
		
		(try_begin),
		  (troop_slot_eq, ":faction_marshall", "slot_lord_reputation_type", lrep_quarrelsome),
		  (val_add, ":acceptance_level", -750),#gdw guess he likes war no change
		(else_try),  
		  (this_or_next|troop_slot_eq, ":faction_marshall", "slot_lord_reputation_type", lrep_martial),
		  (troop_slot_eq, ":faction_marshall", "slot_lord_reputation_type", lrep_upstanding),
		  (val_add, ":acceptance_level", -250),
		(try_end),  
				
		(val_add, ":acceptance_level", 2000),
		#average become 2500 + 2000 = 4500, (45% of lords will not join campaign because of this reason. (33% for hard, 57% for easy, 30% for marshal player))
										
		(troop_get_slot, ":temp_ai_seed", ":troop_no", "slot_troop_temp_decision_seed"),
				
		(le, ":temp_ai_seed", ":acceptance_level"),		
		
		(try_begin),		  
		  (eq, ":troop_no", "$g_talk_troop"),		  		  		  
		  (str_store_string, s15, "str_i_am_not_accompanying_the_marshal_because_i_can_do_greater_deeds"),
		(try_end),	
		
		#(try_begin),
		#  (ge, "$cheat_mode", 1),
		#  (assign, reg7, ":acceptance_level"),
		#  (assign, reg8, ":relation_with_marshall"),
		#  (display_message, "@{!}DEBUGS : acceptance level : {reg7}, relation with marshal : {reg8}"),
		#(try_end),
	(else_try),
		(store_current_hours, ":hours_since_last_faction_rest"),
		(faction_get_slot, ":last_rest_time", ":faction_no", "slot_faction_ai_last_rest_time"),
		(val_sub, ":hours_since_last_faction_rest", ":last_rest_time"),				
		
		#nine days on average, marshal will usually end after 10 days
		#ozan changed, 360 hours (15 days) in average, marshal cannot end it during a siege attack/defence anymore.
		(assign, ":troop_campaign_limit", 360), 
		(store_mul, ":marshal_relation_modifier", ":relation_with_marshall", 6), #ozan changed 4 to 6.
		(val_add, ":troop_campaign_limit", ":marshal_relation_modifier"),
		
		(try_begin),
			(eq, ":troop_reputation", lrep_upstanding),
			(val_mul, ":troop_campaign_limit", 4),
			(val_div, ":troop_campaign_limit", 3),
		(try_end),
		
		(str_store_troop_name, s16, ":faction_marshall"),
	
		(gt, ":hours_since_last_faction_rest", ":troop_campaign_limit"),
		
		#Too long a campaign
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__s16_has_kept_us_on_campaign_on_far_too_long_and_there_are_other_pressing_matters_to_which_i_must_attend"),
		(try_end),
		#Also make nuanced, depending on personality type
	(else_try),	
		(troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
		(neg|party_is_active, ":party_no"),
		#This string should not occur, as it will only happen if a lord is contemplating following the player		
	(else_try),	
		(troop_get_slot, ":marshal_party", ":faction_marshall", "slot_troop_leaded_party"),
		
		(assign, ":information_radius", 40), 
		(try_begin),
		  (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
		  (assign, ":information_radius", 50), 
		(try_end),
		
        (options_get_campaign_ai, ":reduce_campaign_ai"),
		(try_begin),
		  (neq, ":faction_no", "fac_player_supporters_faction"),
		  (neq, ":faction_no", "$players_kingdom"),		  
		  (try_begin),
		    (eq, ":reduce_campaign_ai", 2), #easy
		    (try_begin),
		      (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
		      (val_add, ":information_radius", -10),
		    (else_try),  
		      (val_add, ":information_radius", -8),
		    (try_end),
		  (else_try),
		    (eq, ":reduce_campaign_ai", 1), #moderate
		    (try_begin),
		      (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
		      (val_add, ":information_radius", -5),
		    (else_try),  
		      (val_add, ":information_radius", -4),
		    (try_end),
		  (try_end),
		(else_try),  
		  (try_begin),
		    (eq, ":reduce_campaign_ai", 2), #easy
		    (try_begin),
		      (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
		      (val_add, ":information_radius", 25),
		    (else_try),  
		      (val_add, ":information_radius", 20),
		    (try_end),
		  (else_try),
		    (eq, ":reduce_campaign_ai", 1), #moderate
		    (try_begin),
		      (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
		      (val_add, ":information_radius", 15),
		    (else_try),  
		      (val_add, ":information_radius", 12),
		    (try_end),
		  (else_try),
		    (eq, ":reduce_campaign_ai", 0), #hard
		    (try_begin),
		      (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_gathering_army),
		      (val_add, ":information_radius", 5),
		    (else_try),  
		      (val_add, ":information_radius", 4),
		    (try_end),
		  (try_end),		
		(try_end),  
		
		(faction_get_slot, ":faction_object", ":faction_no", "slot_faction_ai_object"),
		(assign, reg17, 0),
		(try_begin),		  		  
		  (try_begin),
		    (neg|is_between, ":faction_object", villages_begin, villages_end),
		    (assign, reg17, 1),
		  (try_end),
		  (try_begin),
		    (neg|faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_attacking_enemies_around_center),
		    (assign, reg17, 1),
		  (try_end),		  
		  (eq, reg17, 1),
		  
		  (store_distance_to_party_from_party, ":distance", ":marshal_party", ":party_no"),

		  (gt, ":distance", ":information_radius"),
		
          (try_begin),
            (eq, ":troop_no", "$g_talk_troop"),
            (str_store_string, s15, "str__i_am_not_participating_in_the_marshals_campaign_because_i_do_not_know_where_to_find_our_main_army"),
  		  (try_end),  		  
		(else_try),	
		  (eq, reg17, 0),	
		  
          (assign, reg17, 1),
          (try_begin),
            #if we are already accompanying marshal forget below.
            (this_or_next|party_slot_eq, ":party_no", "slot_party_ai_state", spai_screening_army),	#MOTO don't forget screeners
            (party_slot_eq, ":party_no", "slot_party_ai_state", spai_accompanying_army),
            (party_slot_eq, ":party_no", "slot_party_ai_object", ":marshal_party"),
            (assign, reg17, 0),
          (try_end),                                
          (eq, reg17, 1),
                              
		  #if faction ai is "attacking enemies around a center" is then do not find and compare distance to marshal, find and compare distance to "attacked village"
		  (party_get_slot, ":enemy_strength_nearby", ":faction_object", "slot_center_sortie_enemy_strength"),
		  
		  (try_begin), #changes between 70..x (as ":enemy_strength_nearby" increases, ":information_radius" increases too.),
		    (ge, ":enemy_strength_nearby", 4000),
		    (val_sub, ":enemy_strength_nearby", 4000),
		    (store_div, ":information_radius", ":enemy_strength_nearby", 200),
		    (val_add, ":information_radius", 70),
		  (else_try), #changes between 30..70
		    (store_div, ":information_radius", ":enemy_strength_nearby", 100),
		    (val_add, ":information_radius", 30),
		  (try_end),
		  
		  (store_distance_to_party_from_party, ":distance", ":faction_object", ":party_no"),

		  (gt, ":distance", ":information_radius"),
		
          (try_begin),
            (eq, ":troop_no", "$g_talk_troop"),
            (str_store_string, s15, "str__i_am_acting_independently_although_some_enemies_have_been_spotted_within_our_borders_they_havent_come_in_force_and_the_local_troops_should_be_able_to_dispatch_them"),
  		  (try_end),  		  
		(try_end),
		
		(gt, ":distance", ":information_radius"),
	(else_try),
		(try_begin),
		  (eq, ":troop_no", "$g_talk_troop"),
		  (str_store_string, s15, "str__the_needs_of_the_realm_must_come_first"),
		(try_end),
		(assign, ":result", 1),
	(try_end),
			
	(assign, reg0, ":result"),	
	]),
	
	#script_find_total_prosperity_score
    # INPUT: center_no
    # OUTPUT: reg0 = total_prosperity_score
	(
	"find_total_prosperity_score",
	[
	  (store_script_param, ":center_no", 1),
	  
      (try_begin), #":total_prosperity_score" changes between 10..100
        (is_between, ":center_no", walled_centers_begin, walled_centers_end),
            
        (party_get_slot, ":center_prosperity", ":center_no", "slot_town_prosperity"),
        (store_add, ":center_prosperity_add_200_div_10", ":center_prosperity", 200),
        (val_div, ":center_prosperity_add_200_div_10", 10),
        (try_begin),
          (is_between, ":center_no", towns_begin, towns_end),            
          (store_mul, ":this_center_score", ":center_prosperity_add_200_div_10", 15),
        (else_try),
          (store_mul, ":this_center_score", ":center_prosperity_add_200_div_10", 5),
        (try_end),
        (assign, ":total_prosperity_score", ":this_center_score"), 
                        
        (try_for_range_backwards, ":village_no", villages_begin, villages_end),
          (party_slot_eq, ":village_no", "slot_village_bound_center", ":center_no"),

          (party_get_slot, ":village_prosperity", ":village_no", "slot_town_prosperity"),
          (store_add, ":village_prosperity_add_200_div_10", ":village_prosperity", 200),
          (val_div, ":village_prosperity_add_200_div_10", 10),
          (store_mul, ":this_village_score", ":village_prosperity_add_200_div_10", 5),
                    
          (val_add, ":total_prosperity_score", ":this_village_score"), 
        (try_end),
      (else_try),
        (party_get_slot, ":center_prosperity", ":center_no", "slot_town_prosperity"),
        (store_add, ":center_prosperity_add_200_div_10", ":center_prosperity", 200),
        (val_div, ":center_prosperity_add_200_div_10", 10),
        (store_mul, ":this_center_score", ":center_prosperity_add_200_div_10", 5),
        (assign, ":total_prosperity_score", ":this_center_score"), 
      (try_end),
      (val_div, ":total_prosperity_score", 10),
      
      (assign, reg0, ":total_prosperity_score"),
	]),
		
    #script_calculate_center_assailability_score
    # INPUT: faction_no
    # param1: faction_no 
    # param2: all_vassals_included, (becomes 1 if we want to find attackable center if we collected 20% of vassals during gathering army phase)
    # OUTPUT: 
    # reg0 = center_to_attack (-1 if none is logical)
    # reg1 = maximum_attack_score
    (
    "calculate_center_assailability_score", 
    [		
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":potential_target", 2),
      (store_script_param, ":all_vassals_included", 3),
      
      (assign, ":target_score", -1),
      
      (store_faction_of_troop, ":faction_no", ":troop_no"),
  
      (store_current_hours, ":hours_since_last_offensive"),
      (faction_get_slot, ":last_offensive_time", ":faction_no", "slot_faction_last_offensive_concluded"),
      (val_sub, ":hours_since_last_offensive", ":last_offensive_time"),
      
      (store_div, ":last_offensive_time_score", ":hours_since_last_offensive", 12), #30..50 MOTO 30..100
      (val_add, ":last_offensive_time_score", 30),
      (val_min, ":last_offensive_time_score", 100),

      (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
    
      (assign, ":marshal_party", -1),
      (assign, ":marshal_strength", 0),
      #(assign, ":strength_of_nearby_friend", 0),
      
      (try_begin),
        (gt, ":faction_marshal", 0),
        (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
        (party_is_active, ":marshal_party"),
        (party_get_slot, ":marshal_strength", ":marshal_party", "slot_party_cached_strength"),
        #(eq, ":all_vassals_included", 0),
        (party_get_slot, ":strength_of_current_followers", ":marshal_party", "slot_party_follower_strength"),
        #(party_get_slot, ":strength_of_nearby_friend", ":marshal_party", "slot_party_nearby_friend_strength"),
      (try_end),
  
      #(try_begin),
      #  (eq, ":all_vassals_included", 0),
      #    
      #  (try_begin),
      #    (gt, ":faction_marshal", 0),
      #    (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
      #    (party_is_active, ":marshal_party"),
      #    (party_get_slot, ":strength_of_potential_followers", ":marshal_party", "slot_party_follower_strength"),
      #  (try_end),                
      #(else_try),
      #  (eq, ":all_vassals_included", 1),
      #      
      #  (assign, ":strength_of_potential_followers", 0),
      #          
      #  (try_for_parties, ":party_no"),
      #    (store_faction_of_party, ":party_faction", ":party_no"),
      #    (eq, ":party_faction", ":faction_no"),
      #    (neq, ":party_no", ":marshal_party"),          
      #    (party_slot_eq, ":party_no", "slot_party_type", spt_kingdom_hero_party),
      #    (call_script, "script_party_calculate_strength", ":party_no", 0),
      #    (val_add, ":strength_of_potential_followers", reg0),
      #  (try_end),    
      #  
      #  (val_div, ":strength_of_potential_followers", 2), #Ozan - Think about this, will you divide strength_of_potential_followers to 3 or 2.5 or 2
      #(else_try),
      #  (assign, ":strength_of_potential_followers", 0),      
      #(try_end),
      
      (faction_get_slot, ":last_attacked_center", ":faction_no", "slot_faction_last_attacked_center"),
      (faction_get_slot, ":last_attacked_hours", ":faction_no", "slot_faction_last_attacked_hours"),
            
      (try_begin),
        (store_current_hours, ":hours"),
        (store_add, ":last_attacked_hours_plus_24", ":last_attacked_hours", 24),
        (gt, ":hours", ":last_attacked_hours_plus_24"),
        (faction_set_slot, ":faction_no", "slot_faction_last_attacked_center", 0),
        (assign, ":last_attacked_center", 0),
      (try_end),
                
      (try_begin),        
        (this_or_next|eq, ":last_attacked_center", 0),
        (this_or_next|eq, ":last_attacked_center", ":potential_target"),
        (this_or_next|eq, "$g_do_not_skip_other_than_current_ai_object", 1),
        (neg|faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
        
        (party_is_active, ":potential_target"),
        (store_faction_of_party, ":potential_target_faction", ":potential_target"),
          
        (store_relation, ":relation", ":potential_target_faction", ":faction_no"),	      
        (lt, ":relation", 0),
        
        #attack if and only if we are already besieging that center or anybody do not making besiege.
        (assign, ":faction_of_besieger_party", -1),
        (try_begin),        
          (is_between, ":potential_target", walled_centers_begin, walled_centers_end),      
          (neg|party_slot_eq, ":potential_target", "slot_center_is_besieged_by", -1), 
          (party_get_slot, ":besieger_party", ":potential_target", "slot_center_is_besieged_by"),
          (party_is_active, ":besieger_party"),
          (store_faction_of_party, ":faction_of_besieger_party", ":besieger_party"),
        (try_end),	
        			     
        (this_or_next|eq, ":faction_of_besieger_party", -1), 
        (eq, ":faction_of_besieger_party", ":faction_no"),
        
        #attack if and only if this center is not a village or if it is village it should not be raided or looted
        (assign, ":village_is_looted_or_raided_already", 0),
        (try_begin),
          (is_between, ":potential_target", villages_begin, villages_end),
          (try_begin),
            (party_slot_eq, ":potential_target", "slot_village_state", svs_being_raided),
            (party_get_slot, ":raider_party", ":potential_target", "slot_village_raided_by"),
			(party_is_active, ":raider_party"),
			
            (store_faction_of_party, ":raider_faction", ":raider_party"),
            (neq, ":raider_faction", ":faction_no"),
            (assign, ":raiding_by_one_other_faction", 1),
          (else_try),
            (assign, ":raiding_by_one_other_faction", 0),
          (try_end),  
          (this_or_next|party_slot_eq, ":potential_target", "slot_village_state", svs_looted),
          (eq, ":raiding_by_one_other_faction", 1),
          (assign, ":village_is_looted_or_raided_already", 1),
        (try_end),        
        (eq, ":village_is_looted_or_raided_already", 0),

        #if ":potential_target" is faction object of some other faction which is enemy to owner of 
        #":potential_target" then this target cannot be new target we are looking for.
        (assign, ":this_potantial_target_is_target_of_some_other_faction", 0),
        (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
          (is_between, ":cur_faction", "fac_kingdom_1", kingdoms_end), #Excluding player kingdom
          (neq, ":cur_faction", ":faction_no"),
          (faction_get_slot, ":faction_object", ":cur_faction", "slot_faction_ai_object"),
          (eq, ":faction_object", ":potential_target"),
          (store_relation, ":rel", ":potential_target_faction", ":cur_faction"),
          (lt, ":rel", 0),
          (assign, ":this_potantial_target_is_target_of_some_other_faction", 1),          
        (try_end),      
        (eq, ":this_potantial_target_is_target_of_some_other_faction", 0),                                            
    		  				
        (try_begin),
          (is_between, ":potential_target", walled_centers_begin, walled_centers_end),      
          (party_get_slot, ":potential_target_inside_strength", ":potential_target", "slot_party_cached_strength"),
          (party_get_slot, ":potential_target_nearby_enemy_strength", ":potential_target", "slot_party_nearby_friend_strength"),    
          (val_div, ":potential_target_nearby_enemy_strength", 2),        
          (store_add, ":potential_target_strength", ":potential_target_inside_strength", ":potential_target_nearby_enemy_strength"),

          #(try_begin),
            #(eq, ":faction_no", "fac_kingdom_4"),
            #(assign, reg0, ":potential_target_inside_strength"),
            #(assign, reg1, ":potential_target_nearby_enemy_strength"),
            #(assign, reg2, ":marshal_strength"),
            #(assign, reg3, ":strength_of_potential_followers"),
            #(assign, reg4, ":strength_of_nearby_friend"),
            #(assign, reg6, ":marshal_party"),
            #(str_store_party_name, s8, ":potential_target"),
            #(eq, ":all_vassals_included", 0),
            #(display_message, "@DEBUG : {s8}:{reg0}, neare {reg1}, our {reg2}, follow {reg3}, nearf {reg4}"),
          #(try_end),
                    
          (val_mul, ":potential_target_strength", 4), #in walled centers defenders have advantage.
          (val_div, ":potential_target_strength", 3),
                              
          #(store_add, ":army_strength", ":marshal_strength", ":strength_of_potential_followers"),
          (assign, ":army_strength", ":marshal_strength"),
          (val_add, ":army_strength", ":strength_of_current_followers"),
          (store_mul, ":power_ratio", ":army_strength", 100),
          
          #this ratio ":power_ratio" shows (our total army power) / (their total army power)
          (try_begin),
            (gt, ":potential_target_strength", 0),
            (val_div, ":power_ratio", ":potential_target_strength"),
          (else_try),
            (assign, ":power_ratio", 1000),
          (try_end),  
        (else_try),        
          # (party_get_slot, ":potential_target_nearby_enemy_strength", ":potential_target", "slot_party_nearby_friend_strength"),                      
          (assign, ":potential_target_strength", 1000),
                    
          #(store_add, ":army_strength", ":marshal_strength", ":strength_of_potential_followers"),
          (assign, ":army_strength", ":marshal_strength"),
          (val_add, ":army_strength", ":strength_of_current_followers"),
          (store_mul, ":power_ratio", ":army_strength", 100),
                                                            
          (try_begin),
            (gt, ":potential_target_strength", 0),
            (val_div, ":power_ratio", ":potential_target_strength"),
          (else_try),
            (assign, ":power_ratio", 1000),
          (try_end),            
        (try_end),
                            
        (ge, ":power_ratio", 120), #attack if and only if our army is at least 1.2 times powerfull				
        (store_sub, ":power_ratio_sub_120", ":power_ratio", 120),
        
        (try_begin),
          (lt, ":power_ratio_sub_120", 100), #changes between 20..120
          (store_add, ":power_ratio_score", ":power_ratio_sub_120", 20),
        (else_try),
          (lt, ":power_ratio_sub_120", 200), #changes between 120..170
          (store_sub, ":power_ratio_score", ":power_ratio_sub_120", 100),
          (val_div, ":power_ratio_score", 2),
          (val_add, ":power_ratio_score", 120),
        (else_try),
          (lt, ":power_ratio_sub_120", 400), #changes between 170..210
          (store_sub, ":power_ratio_score", ":power_ratio_sub_120", 200),
          (val_div, ":power_ratio_score", 5),
          (val_add, ":power_ratio_score", 170),
        (else_try),
          (lt, ":power_ratio_sub_120", 800), #changes between 210..250
          (store_sub, ":power_ratio_score", ":power_ratio_sub_120", 400),
          (val_div, ":power_ratio_score", 10),
          (val_add, ":power_ratio_score", 210),
        (else_try),
          (assign, ":power_ratio_score", 250),
        (try_end),
          
        (assign, ":number_of_walled_centers", 0),
        (assign, ":total_distance", 0),
        (try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
          (store_faction_of_party, ":walled_center_faction", ":walled_center"),
          (eq, ":walled_center_faction", ":faction_no"),
                
          (store_distance_to_party_from_party, ":dist", ":walled_center", ":potential_target"),            
          (val_add, ":total_distance", ":dist"),
                
          (val_add, ":number_of_walled_centers", 1),
        (try_end),
                
        (try_begin),
          (gt, ":number_of_walled_centers", 0),
          (store_div, ":average_distance", ":total_distance", ":number_of_walled_centers"),
          #(assign, reg0, ":average_distance"),                    
          #(str_store_faction_name, s7, ":faction_no"),
          #(str_store_party_name, s8, ":potential_target"),
          #(display_message, "@average distance for {s7} for {s8} is {reg0}"),
          
          (try_begin),
            (ge, ":marshal_party", 0),
            (party_is_active, ":marshal_party"),
            (store_distance_to_party_from_party, ":marshal_dist_to_potential_target", ":marshal_party", ":potential_target"),
          (else_try),
            (assign, ":marshal_dist_to_potential_target", 100),
          (try_end),
                      
          (try_begin),  
            #if currently main aim of our faction is attacking to an enemy center and that center is already besieged/raided by one of 
            #our parties then divide marshal_dist_to_potential_target_div_x score for current center to "3/2" instead of "3" and this
            #result in decrease at distance_score, and also decrease some scores from power_ratio_score in order to avoid frequently 
            #changes at main aimed target city of our faction during sieges.
              
            (faction_get_slot, ":current_ai_state", ":faction_no", "slot_faction_ai_state"),
            (eq, ":current_ai_state", sfai_attacking_center),
            (faction_get_slot, ":current_ai_object", ":faction_no", "slot_faction_ai_object"),
            
            (ge, ":current_ai_object", 0),
            (neq, ":current_ai_object", ":potential_target"),
              
            (try_begin),
              (ge, ":power_ratio_score", 300), #200 max
              (assign, ":power_ratio_score", 200),
            (else_try),
              (ge, ":power_ratio_score", 100), #100..200
              (val_sub, ":power_ratio_score", 100),
              (val_div, ":power_ratio_score", 2),
              (val_add, ":power_ratio_score", 100),
            (try_end),  
            
            (try_begin),
              (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
              (eq, "$g_do_not_skip_other_than_current_ai_object", 0),
              (assign, ":power_ratio_score", 0), #lets completely forget all other choices if we are already besieging one center.
            (try_end),  
            
            (faction_set_slot, ":faction_no", "slot_faction_last_attacked_center", ":current_ai_object"),
            (store_current_hours, ":hours"),
            (faction_set_slot, ":faction_no", "slot_faction_last_attacked_hours", ":hours"),

            (eq, ":all_vassals_included", 0),

            (store_mul, ":marshal_dist_to_potential_target_div_x", ":marshal_dist_to_potential_target", 2),
            (val_div, ":marshal_dist_to_potential_target_div_x", 3),
          (else_try),
            (store_div, ":marshal_dist_to_potential_target_div_x", ":marshal_dist_to_potential_target", 3),
          (try_end),
            
          (store_add, ":total_distance", ":average_distance", ":marshal_dist_to_potential_target_div_x"), #in average ":total_distance" is about 150, min : 0, max : 1000
        (else_try),
          (assign, ":total_distance", 100),
        (try_end),                

        (try_begin),
          #according to cautious troop distance is more important

          ##diplomacy start+ Take into account lady & companion personality types chief
		  ##OLD:
	      #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
	      #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
	      #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_goodnatured),
	      #(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_cunning),
		  #
		  ##NEW:
		  (call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		  (assign, ":troop_caution", reg0),
		  # (gt, ":troop_caution", 0),	MOTO make this the normative case
		  (ge, ":troop_caution", 0),	#MOTO make this the normative case
		  ##diplomacy end+
		  
		  #MOTO chief use hyperbolic and fit to kingdom size
		  #Hyperbolic function drops off more sharply (emphasizes closeness more)
		  #Fit to kingdom size means small kingdoms won't attack too far from their centers
          # (try_begin),
            # (lt, ":total_distance", 30), #very close (100p)
            # (assign, ":distance_score", 100),
          # (else_try),
            # (lt, ":total_distance", 80), #close (50p-100p)
            # (store_sub, ":distance_score", ":total_distance", 30),
            # (val_div, ":distance_score", 1),
            # (store_sub, ":distance_score", 100, ":distance_score"),
          # (else_try),  
            # (lt, ":total_distance", 160), #far (10p-50p)
            # (store_sub, ":distance_score", ":total_distance", 80),
            # (val_div, ":distance_score", 2),
            # (store_sub, ":distance_score", 50, ":distance_score"),
          # (else_try),
            # (assign, ":distance_score", 10), #very far
          # (try_end),
        # (else_try),  
          # #according to agressive troop distance is less important
          
          # (try_begin),
            # (lt, ":total_distance", 40), #very close (100p)
            # (assign, ":distance_score", 100),
          # (else_try),
            # (lt, ":total_distance", 140), #close (50p-100p)
            # (store_sub, ":distance_score", ":total_distance", 40),
            # (val_div, ":distance_score", 2),
            # (store_sub, ":distance_score", 100, ":distance_score"),
          # (else_try),  
            # (lt, ":total_distance", 300), #far (10p-50p)
            # (store_sub, ":distance_score", ":total_distance", 140),
            # (val_div, ":distance_score", 4),
            # (store_sub, ":distance_score", 50, ":distance_score"),
          # (else_try),
            # (assign, ":distance_score", 10), #very far
          # (try_end),
        # (try_end),
		  (assign, ":depth_of_incursion", 50),	#25 is distance that determines neighboring factions
        (else_try),
          #according to agressive troop distance is less important
		  (assign, ":depth_of_incursion", 100),
        (try_end),
		
		#estimate kingdom "radius"
		(assign, reg0, ":number_of_walled_centers"),
		(convert_to_fixed_point, reg0),
		(store_sqrt, ":hyper_denominator", reg0),
		(convert_from_fixed_point, ":hyper_denominator"),
		(val_sub, ":hyper_denominator", 1),
		(val_mul, ":hyper_denominator", -18),	# 25 * SQRT(2) / 2 (25 is the distance that determines neighboring factions)
		
		#build rest of function
		(store_div, reg0, ":total_distance", 2),	#average marshall and average-walled-center distances
		(val_add, ":hyper_denominator", reg0),
		(val_div, ":hyper_denominator", ":depth_of_incursion"),
		(val_add, ":hyper_denominator", 1),
		
		(store_div, ":distance_score", 180, ":hyper_denominator"),
		(val_sub, ":distance_score", 80),
		(val_max, ":distance_score", 1),
		#MOTO chief use hyperbolic and fit to kingdom size end
                                                                                           
        (store_mul, ":target_score", ":distance_score", ":power_ratio_score"),
        (val_mul, ":target_score", ":last_offensive_time_score"),
        (val_div, ":target_score", 100), #target score is between 0..10000 generally here MOTO 6..25000

        (call_script, "script_find_total_prosperity_score", ":potential_target"),                
        (assign, ":total_prosperity_score", reg0),	#MOTO 10..75
            
        #(try_begin), #new for increase attackability of villages by ai
          #(is_between, ":potential_target", villages_begin, villages_end), 
           (val_mul, ":total_prosperity_score", 3),	#MOTO this does nothing but inflate the scores
           (val_div, ":total_prosperity_score", 2),
        #(try_end),

        (val_mul, ":target_score", ":total_prosperity_score"),	#MOTO 60..1875000
          
        #MOTO make discreet so can amplify importance of homelands
		# (try_begin), #if both that center was our (original center) and (ex center) than bonus is 1.2x
          # (party_slot_eq, ":potential_target", "slot_center_ex_faction", ":faction_no"),
          # (party_slot_eq, ":potential_target", "slot_center_original_faction", ":faction_no"),
          # (val_mul, ":target_score", 12),
          # (val_div, ":target_score", 10),
        # (else_try), #if either that center was our (original center) or (ex center) than bonus is 1.1x
          # (this_or_next|party_slot_eq, ":potential_target", "slot_center_ex_faction", ":faction_no"),
          # (party_slot_eq, ":potential_target", "slot_center_original_faction", ":faction_no"),
          # (val_mul, ":target_score", 11),
          # (val_div, ":target_score", 10),
        # (try_end),
		(try_begin),
          (is_between, ":potential_target", walled_centers_begin, walled_centers_end),      
		  (try_begin),
            (party_slot_eq, ":potential_target", "slot_center_original_faction", ":faction_no"),
            (val_mul, ":target_score", 14),
            (val_div, ":target_score", 10),
		  (try_end),
		  (try_begin),
            (party_slot_eq, ":potential_target", "slot_center_ex_faction", ":faction_no"),
            (val_mul, ":target_score", 11),
            (val_div, ":target_score", 10),
		  (try_end),
        (try_end),
        #MOTO end make discreet so can amplify importance of homelands
            
        (val_div, ":target_score", 1000), #target score is between 0..1000 generally here MOTO 0..2887
        
        (try_begin),
          (eq, ":potential_target_faction", "fac_player_supporters_faction"),
          (options_get_campaign_ai, ":reduce_campaign_ai"),
          
          (assign, ":number_of_walled_centers_player_have", 0),
          (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
            (store_faction_of_party, ":center_faction", ":center_no"),
            (eq, ":center_faction", "fac_player_supporters_faction"),
            (val_add, ":number_of_walled_centers_player_have", 1),
          (try_end),
          
          (try_begin),
            (eq, ":reduce_campaign_ai", 2), #easy
            
            (try_begin),
              (le, ":number_of_walled_centers_player_have", 2),
              (assign, ":hardness_score", 0),              
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 3),
              (assign, ":hardness_score", 20),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 4),
              (assign, ":hardness_score", 40),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 5),
              (eq, ":number_of_walled_centers_player_have", 6),
              (assign, ":hardness_score", 55),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 7),
              (eq, ":number_of_walled_centers_player_have", 8),
              (eq, ":number_of_walled_centers_player_have", 9),
              (assign, ":hardness_score", 70),
            (else_try),
              (assign, ":hardness_score", 85),
            (try_end),
          (else_try),  
            (eq, ":reduce_campaign_ai", 1), #medium

            (try_begin),
              (le, ":number_of_walled_centers_player_have", 1),
              (assign, ":hardness_score", 25),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 2),
              (assign, ":hardness_score", 45),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 3),
              (assign, ":hardness_score", 60),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 4),
              (eq, ":number_of_walled_centers_player_have", 5),
              (assign, ":hardness_score", 75),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 6),
              (eq, ":number_of_walled_centers_player_have", 7),
              (eq, ":number_of_walled_centers_player_have", 8),
              (assign, ":hardness_score", 85),
            (else_try),
              (assign, ":hardness_score", 92),
            (try_end),
          (else_try), #hard
            (assign, ":hardness_score", 100), 
          (try_end),
          
          (val_mul, ":target_score", ":hardness_score"),
          (val_div, ":target_score", 100),
        (try_end),

        (try_begin),
          (ge, "$cheat_mode", 1),
          (eq, ":faction_no", "fac_kingdom_4"),
          (ge, ":target_score", -1),
          (assign, reg0, ":target_score"),
          (assign, reg7, ":total_prosperity_score"),
          (assign, reg8, ":power_ratio_score"),
          (assign, reg9, ":distance_score"),
          (assign, reg10, ":last_offensive_time_score"),
          (str_store_party_name, s8, ":potential_target"),
          #(eq, ":all_vassals_included", 0),
          (assign, reg11, ":all_vassals_included"),          
          #(display_message, "@DEBUG : attack of {s8} is {reg0}({reg11}), prs:{reg7}, pow:{reg8}, dis:{reg9}, lst:{reg10}"),
        (try_end),  
      (try_end),
                                                     
      (assign, reg0, ":target_score"),
      (assign, reg1, ":power_ratio"),
      (assign, reg2, ":distance_score"),
      (assign, reg3, ":total_prosperity_score"),
    ]),
		
    #script_find_center_to_defend
    # INPUT: 
    # param1: faction_no 
    # OUTPUT: 
    # reg0 = center_to_defend (-1 if none is logical)
    # reg1 = maximum_defend_score
    # reg3 = enemy_strength_near_most_threatened_center
    (
    "find_center_to_defend",
    [
      (store_script_param, ":troop_no", 1),
	  
	  (store_faction_of_troop, ":faction_no", ":troop_no"),
	  
      (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
      (faction_get_slot, ":current_ai_state", ":faction_no", "slot_faction_ai_state"),
      (assign, ":marshal_party", -1),  
      (try_begin),
        (gt, ":faction_marshal", 0),
        (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
      (try_end),

      (assign, ":most_threatened_center", -1),
      (assign, ":maximum_threat_score", 0),
	  (assign, ":num_walled_centers", 0),	#MOTO count
	  (assign, ":num_villages", 0),	#MOTO count
	  (assign, ":num_idle_villages", 0),	#MOTO count
      (try_for_range, ":cur_center", centers_begin, centers_end),
        (store_faction_of_party, ":center_faction", ":cur_center"),
        (eq, ":center_faction", ":faction_no"),
	 	    
        (party_get_slot, ":exact_enemy_strength", ":cur_center", "slot_center_sortie_enemy_strength"),
		#Distort this to account for questionable intelligence
		#(call_script, "script_reduce_exact_number_to_estimate", ":exact_enemy_strength"),
		#(assign, ":enemy_strength_nearby", reg0),
		(assign, ":enemy_strength_nearby", ":exact_enemy_strength"),		
		
        (assign, ":threat_importance", 0),
        (try_begin),          
          (is_between, ":cur_center", walled_centers_begin, walled_centers_end),
	      (val_add, ":num_walled_centers", 1),	#MOTO count
          (party_slot_ge, ":cur_center", "slot_center_is_besieged_by", 0),
          
          (call_script, "script_find_total_prosperity_score", ":cur_center"),
          (assign, ":total_prosperity_score", reg0),          
                              
          (party_get_slot, ":cur_center_strength", ":cur_center", "slot_party_cached_strength"),
          (val_mul, ":cur_center_strength", 4),
          (val_div, ":cur_center_strength", 3), #give 33% bonus to insiders because they are inside a castle
          
          #I removed below line and assigned ":cur_center_nearby_strength" to 0, because if not when defender army comes to help
          #threat become less because of high defence power but not yet enemy cleared.
          #(party_get_slot, ":cur_center_nearby_strength", ":cur_center", "slot_party_nearby_friend_strength"),
          (assign, ":cur_center_nearby_strength", 0),
          
          (val_add, ":cur_center_strength", ":cur_center_nearby_strength"), #add nearby friends and find ":cur_center_strength"
          
          (store_mul, ":power_ratio", ":enemy_strength_nearby", 100),
          (val_add, ":cur_center_strength", 1),
		  (val_max, ":cur_center_strength", 1),
          (val_div, ":power_ratio", ":cur_center_strength"),
         
          (assign, ":player_is_attacking", 0),
          (party_get_slot, ":besieger_party", ":cur_center", "slot_center_is_besieged_by"),
          (try_begin),
            (party_is_active, ":besieger_party"),
            (try_begin),
              (eq, ":besieger_party", "p_main_party"),
              (assign, ":player_is_attacking", 1),
              #(display_message, "@{!}DEBUG : player is attacking a center (1)"),
            (else_try),
              (store_faction_of_party, ":besieger_faction", ":besieger_party"),
              (eq, ":besieger_faction", "fac_player_faction"),
              (assign, ":player_is_attacking", 1),
              #(display_message, "@{!}DEBUG : player is attacking a center (2)"),
            (else_try), 
              (party_get_attached_to, ":player_is_attached_to", "p_main_party"),
              (ge, ":player_is_attached_to", 0),
              (eq, ":player_is_attached_to", ":besieger_party"),
              (assign, ":player_is_attacking", 1),
              #(display_message, "@{!}DEBUG : player is attacking a center (3)"),
            (try_end),
          (try_end),
          
          (try_begin),
            (eq, ":player_is_attacking", 0),                       
            
            (try_begin),
              (lt, ":power_ratio", 40), #changes between 1..1
              (assign, ":threat_importance", 1),
            (else_try),  
              (lt, ":power_ratio", 80), #changes between 1..7
              (store_sub, ":threat_importance", ":power_ratio", 40),
              (val_div, ":threat_importance", 5),
              (val_add, ":threat_importance", 1), #1
            (else_try),  
              (lt, ":power_ratio", 120), #changes between 7..17
              (store_sub, ":threat_importance", ":power_ratio", 80),
              (val_div, ":threat_importance", 4),
              (val_add, ":threat_importance", 7), #1 + 6
            (else_try),  
              (lt, ":power_ratio", 200),
              (store_sub, ":threat_importance", ":power_ratio", 120),
              (val_div, ":threat_importance", 10),
              (val_add, ":threat_importance", 17), #1 + 6 + 10
            (else_try),  
              (assign, ":threat_importance", 25),
            (try_end),  
          (else_try),
            (try_begin),
              (lt, ":power_ratio", 200), #changes between 5..25
              (store_div, ":threat_importance", ":power_ratio", 10),	#MOTO correction
              (val_add, ":threat_importance", 6 ),	#MOTO effect is to ignore small player
            (else_try),  
              (assign, ":threat_importance", 25),
            (try_end),             
          (try_end),          
        (else_try),        
          (is_between, ":cur_center", villages_begin, villages_end),
		  #MOTO village defense rewrite
          # (party_slot_eq, ":cur_center", "slot_village_state", svs_being_raided),
          (neg|party_slot_eq, ":cur_center", "slot_village_state", svs_looted),
		  
	      (val_add, ":num_villages", 1),
		  (try_begin),
            (neg|party_slot_eq, ":cur_center", "slot_village_state", svs_normal),
	        (val_add, ":num_idle_villages", 1),
		  (try_end),
		  
          (gt, ":enemy_strength_nearby", 0),
          
          (call_script, "script_find_total_prosperity_score", ":cur_center"),
          # (assign, ":power_ratio", 100), #useless
          (assign, ":total_prosperity_score", reg0),
          (assign, ":threat_importance", 10), #if faction village is looted they lose money for shorter time period. So importance is something low (6-8).
        (try_end),
        
        (gt, ":threat_importance", 0),
        
        # (try_begin),
          # (is_between, ":cur_center", walled_centers_begin, walled_centers_end),
          # (assign, ":enemy_strength_nearby_score", 120), 
          (store_add, ":enemy_strength_nearby_score", ":enemy_strength_nearby", 20000), 
          (val_div, ":enemy_strength_nearby_score", 200),
          
          (try_begin),          
            (ge, ":marshal_party", 0),
            (party_is_active, ":marshal_party"),
            (store_distance_to_party_from_party, ":marshal_dist_to_cur_center", ":marshal_party", ":cur_center"),
          (else_try),
            (assign, ":marshal_dist_to_cur_center", 100),
          (try_end),
                              
          (try_begin),  
            #if currently our target is ride to break a siege then
            #divide marshal_distance for other center's to "2" instead of "4" and add some small more distance to avoid easily 
            #changing mind during siege because of small score differences.
            
	        #(faction_get_slot, ":current_ai_state", ":faction_no", "slot_faction_ai_state"),
            (eq, ":current_ai_state", sfai_attacking_enemies_around_center),                                   
            (faction_get_slot, ":current_ai_object", ":faction_no", "slot_faction_ai_object"),
            (is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),            
            (neq, ":current_ai_object", ":cur_center"),
            (val_mul, ":marshal_dist_to_cur_center", 2),
            (val_add, ":marshal_dist_to_cur_center", 20),
          (try_end),
          
          (val_mul, ":marshal_dist_to_cur_center", 2), #standard multipication (1.5x) to adjust distance scoring same with formula at find_center_to_attack
          #(val_div, ":marshal_dist_to_cur_center", 2),
                    
          (try_begin),
            (lt, ":marshal_dist_to_cur_center", 10), #very close (100p)
            (assign, ":distance_score", 100),
          (else_try),
            (lt, ":marshal_dist_to_cur_center", 110), #close (50p-100p)	MOTO change 160 to 110
            (store_sub, ":distance_score", ":marshal_dist_to_cur_center", 10),
            (val_div, ":distance_score", 2),	#MOTO change 3 to 2
            (store_sub, ":distance_score", 100, ":distance_score"),
          (else_try),  
            (lt, ":marshal_dist_to_cur_center", 270), #far (10p-50p) MOTO change 360 to 270
            (store_sub, ":distance_score", ":marshal_dist_to_cur_center", 110),	#MOTO change 250 to 110
            (val_div, ":distance_score", 4),	#MOTO change 5 to 4
            (store_sub, ":distance_score", 50, ":distance_score"),
          (else_try),
            (assign, ":distance_score", 10), #very far
          (try_end),
        # (else_try),
          # (store_add, ":enemy_strength_nearby_score", ":enemy_strength_nearby", 20000), 
          # (val_div, ":enemy_strength_nearby_score", 200),
          # (assign, ":distance_score", 70), #not related to marshal's position, because everybody is going same place (no gathering in most village raids)
        # (try_end),          
		  #MOTO end village defense rewrite
      		##diplomacy start+ chief
		(try_begin),
			#AI changes LOW: Give priority to defending centers with lords
			(party_slot_ge, ":cur_center", "slot_town_lord", 0),
			(val_mul, ":threat_importance", 120),
			(val_div, ":threat_importance", 100),
		(try_end),
		##diplomacy end+
   
        (store_mul, ":threat_score", ":enemy_strength_nearby_score", ":total_prosperity_score"), 
        (val_mul, ":threat_score", ":threat_importance"), 
        (val_mul, ":threat_score", ":distance_score"),
        (val_div, ":threat_score", 10000),	#MOTO 1..2808
        
        (try_begin),
		  (ge, "$cheat_mode", 1),
          (gt, ":threat_score", 0),
          (eq, ":faction_no", "fac_kingdom_6"),
          (assign, reg0, ":threat_score"),
          (str_store_party_name, s32, ":cur_center"),
          (assign, reg1,  ":total_prosperity_score"),
          (assign, reg2, ":enemy_strength_nearby_score"),
          (assign, reg3, ":threat_importance"),
          (assign, reg4, ":distance_score"),
          #(display_message, "@{!}DEBUG : defend of {s32} is {reg0}, prosperity:{reg1}, enemy nearby:{reg2}, threat importance:{reg3}, distance: {reg4}"),
        (try_end),

        (gt, ":threat_score", ":maximum_threat_score"),
        		
        (assign, ":most_threatened_center", ":cur_center"),
        (assign, ":maximum_threat_score", ":threat_score"),
        (assign, ":enemy_strength_near_most_threatened_center", ":enemy_strength_nearby"),
      (try_end),
      
      (val_mul, ":maximum_threat_score", 3),
      (val_div, ":maximum_threat_score", 2),

	  #MOTO importance decreases with more centers
      (val_mul, ":maximum_threat_score", 2),
      (try_begin),	#last walled center is all-important
        (is_between, ":most_threatened_center", walled_centers_begin, walled_centers_end),
		(val_div, ":maximum_threat_score", ":num_walled_centers"),
      (else_try),	#villages start becoming important after half of them have been trash
	    (gt, ":num_villages", 0),
		(val_mul, ":maximum_threat_score", ":num_idle_villages"),
		(val_div, ":maximum_threat_score", ":num_villages"),
	  (try_end),
	  #MOTO end importance decreases with more centers

      (assign, reg0, ":most_threatened_center"),
      (assign, reg1, ":maximum_threat_score"),
      (assign, reg2, ":enemy_strength_near_most_threatened_center"),
    ]),
    	
				
	#script_npc_decision_checklist_peace_or_war
	(
	"npc_decision_checklist_peace_or_war", 
	#this script is used to add a bit more color to diplomacy, particularly with regards to the player
	
	[
	(store_script_param, ":actor_faction", 1),
	(store_script_param, ":target_faction", 2),
	(store_script_param, ":envoy", 3),

	(assign, ":actor_strength", 1),	#MOTO avoid div by 0
	(assign, ":target_strength", 1),	#MOTO avoid div by 0
	(assign, ":actor_centers_held_by_target", 0),

	(assign, ":two_factions_share_border", 0),
	(assign, ":third_party_war", 0), 
	(assign, ":num_third_party_wars", 0),
	(assign, ":num_target_third_party_wars", 0),	#MOTO chief assess weakness

	(assign, ":active_mutual_enemy", 0), #an active enemy with which the target is at war
	(assign, "$g_concession_demanded", 0),
	
	(store_relation, ":current_faction_relation", ":actor_faction", ":target_faction"),
	
	(try_begin),
		(eq, ":target_faction", "fac_player_supporters_faction"),
		(assign, ":modified_honor_and_relation", "$player_honor"), #this can be affected by the emissary's skill
		
		(val_add, ":target_strength", 2), #for player party
	(else_try),
		(assign, ":modified_honor_and_relation", 0), #this can be affected by the emissary's skill
	(try_end),
	
	(faction_get_slot, ":actor_leader", ":actor_faction", "slot_faction_leader"),
	(faction_get_slot, ":target_leader", ":target_faction", "slot_faction_leader"),

	(call_script, "script_troop_get_relation_with_troop", ":actor_leader", ":target_leader"),

	(assign, ":relation_bonus", reg0),
	(val_min, ":relation_bonus", 10),
	(val_add, ":modified_honor_and_relation", ":relation_bonus"),

	# MOTO clarify actors chief
	# (str_store_troop_name, s15, ":actor_leader"),
	# (str_store_troop_name, s16, ":target_leader"),
	(str_store_faction_name, s1, ":actor_faction"),
	(str_store_troop_name, s12, ":actor_leader"),
	(str_store_string, s15, "@{s12} of {s1}"),
	
	(str_store_faction_name, s2, ":target_faction"),
	(str_store_troop_name, s12, ":target_leader"),
	(str_store_string, s16, "@{s12} of {s2}"),
	# MOTO clarify actors end	

	(assign, ":war_damage_suffered", 0),
	(assign, ":war_damage_inflicted", 0),

	(call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":actor_faction", ":target_faction"),
	(assign, ":war_peace_truce_status", reg0),
	(str_clear, s12),
	(try_begin),
		(eq, ":war_peace_truce_status", -2),
		(str_store_string, s12, "str_s15_is_at_war_with_s16_"),
		
		(store_add, ":war_damage_inflicted_slot", ":target_faction", "slot_faction_war_damage_inflicted_on_factions_begin"),
		(val_sub, ":war_damage_inflicted_slot", kingdoms_begin),
		(faction_get_slot, ":war_damage_inflicted", ":actor_faction", ":war_damage_inflicted_slot"),

		(store_add, ":war_damage_suffered_slot", ":actor_faction", "slot_faction_war_damage_inflicted_on_factions_begin"),
		(val_sub, ":war_damage_suffered_slot", kingdoms_begin),
		(faction_get_slot, ":war_damage_suffered", ":target_faction", ":war_damage_suffered_slot"),

		
	(else_try),
		#truce in effect
		(eq, ":war_peace_truce_status", 1),
		(str_store_string, s12, "str_in_the_short_term_s15_has_a_truce_with_s16_as_a_matter_of_general_policy_"),
	(else_try),
		#provocation noted
		(eq, ":war_peace_truce_status", -1),
		(str_store_string, s12, "str_in_the_short_term_s15_was_recently_provoked_by_s16_and_is_under_pressure_to_declare_war_as_a_matter_of_general_policy_"),
	(try_end),

	#MOTO chief cultural antipathy
	(faction_get_slot, ":kingdom_culture", ":actor_faction", "slot_faction_culture"),
	(faction_get_slot, ":recruit_type", ":kingdom_culture", "slot_faction_tier_1_troop"),
	(faction_get_slot, ":kingdom_culture", ":target_faction", "slot_faction_culture"),
	(faction_get_slot, ":recruit_type_2", ":kingdom_culture", "slot_faction_tier_1_troop"),
	(try_begin),
		(eq, ":recruit_type", ":recruit_type_2"),
		(assign, ":cultural_antipathy", 0),
	(else_try),
		(assign, ":cultural_antipathy", 1),
	(try_end),

	(store_relation, reg0, ":actor_faction", "fac_pagans"),
	(try_begin),
		(lt, reg0, 0),
		(store_relation, reg0, ":target_faction", "fac_christians"),
		(try_begin),
			(lt, reg0, 0),
			(val_max, ":cultural_antipathy", 1),
		(try_end),
	(try_end),

	(store_relation, reg0, ":actor_faction", "fac_christians"),
	(try_begin),
		(lt, reg0, 0),
		(store_relation, reg0, ":target_faction", "fac_pagans"),
		(try_begin),
			(lt, reg0, 0),
			(val_max, ":cultural_antipathy", 1),
		(try_end),
	(try_end),
	
	(assign, ":shift", ":cultural_antipathy"),
	
	(try_begin),
		(eq, ":war_peace_truce_status", -1),
		(val_max, ":shift", 1),	#attitude shaped by cultural antipathy or provocation shifts many results below
	(try_end),
	#MOTO chief cultural antipathy end

	#clear for dialog with lords
	(try_begin),
		(is_between, "$g_talk_troop", active_npcs_begin, active_npcs_end),
		(str_clear, s12),
	(try_end),
	
	(try_begin),
		(gt, ":envoy", -1),
		(store_skill_level, ":persuasion_x_2", "skl_persuasion", ":envoy"),
		(val_mul, ":persuasion_x_2", 2),
		(val_add, ":modified_honor_and_relation", ":persuasion_x_2"),
		
		(try_begin),
			(eq, "$cheat_mode", 1),
			(assign, reg4, ":modified_honor_and_relation"),
			(display_message, "str_envoymodified_diplomacy_score_honor_plus_relation_plus_envoy_persuasion_=_reg4"),
		(try_end),

	(try_end),
		
	
	(try_for_range, ":kingdom_to_reset", kingdoms_begin, kingdoms_end),
		(faction_set_slot, ":kingdom_to_reset", "slot_faction_temp_slot", 0),
	(try_end),
	
	(try_for_parties, ":party_no"),
		(assign, ":party_value", 0),
		(try_begin),
			(is_between, ":party_no", towns_begin, towns_end),
			(assign, ":party_value", 3),
		(else_try),	
			(is_between, ":party_no", castles_begin, castles_end),
			(assign, ":party_value", 2),
		(else_try),
			(is_between, ":party_no", villages_begin, villages_end),
			(assign, ":party_value", 1),
		(else_try),	
			(party_get_template_id, ":template", ":party_no"),
			(eq, ":template", "pt_kingdom_hero_party"),
			(assign, ":party_value", 2),
		(try_end),
		

		(store_faction_of_party, ":party_current_faction", ":party_no"),
		(party_get_slot, ":party_original_faction", ":party_no", "slot_center_original_faction"),
		(party_get_slot, ":party_ex_faction", ":party_no", "slot_center_ex_faction"),
		
		
		#total strengths
		(try_begin),
			(is_between, ":party_current_faction", kingdoms_begin, kingdoms_end),
			(faction_get_slot, ":faction_strength", ":party_current_faction", "slot_faction_temp_slot"),
			(val_add, ":faction_strength", ":party_value"),
			(faction_set_slot, ":party_current_faction", "slot_faction_temp_slot", ":faction_strength"),
		(try_end),
		
		
		(try_begin),
			(eq, ":party_current_faction", ":target_faction"),
			(val_add, ":target_strength", ":party_value"),

			(try_begin),
				(this_or_next|eq, ":party_original_faction", ":actor_faction"),
					(eq, ":party_ex_faction", ":actor_faction"),
				(val_add, ":actor_centers_held_by_target", 1),
				(try_begin),
					(is_between, ":party_no", walled_centers_begin, walled_centers_end),
					(assign, "$g_concession_demanded", ":party_no"),
					(str_store_party_name, s18, "$g_concession_demanded"),
				(try_end),
			(try_end),

# Could include two factions share border, but war is unlikely to break out in the first place unless there is a common border
			
#			(try_begin),
#				(is_between, ":party_no", walled_centers_begin, walled_centers_end),
#				(try_for_range, ":other_center", walled_centers_begin, walled_centers_end),
#					(assign, ":two_factions_share_border", 0),
#					(store_faction_of_party, ":other_faction", ":other_center"),
#					(eq, ":other_faction", ":actor_faction"),
#					(store_distance_to_party_from_party, ":distance", ":party_no", ":other_center"),
#					(le, ":distance", 15),
#					(assign, ":two_factions_share_border", 1),
#				(try_end),
#			(try_end),

			#MOTO chief used anyway, so may as well include, but use slot previously set
			(store_add, ":slot", "slot_faction_neighbors_begin", ":target_faction"),
			(val_sub, ":slot", kingdoms_begin),
			(faction_get_slot, ":two_factions_share_border", ":actor_faction", ":slot"),
			#MOTO chief used anyway, so may as well include, but use slot previously set end
			
		(else_try),
			(eq, ":party_current_faction", ":actor_faction"),
			(val_add, ":actor_strength", ":party_value"),
		(try_end),
	(try_end),

	#Total Calradia strength = 110 x 1 (villages,), 48? x 2 castles, 22 x 3 towns, 88 x 2 lord parties = 272 + 176 = 448
	(assign, ":strongest_kingdom", -1),
	(assign, ":score_to_beat", 60), #Maybe raise once it works
	(try_for_range, ":strongest_kingdom_candidate", kingdoms_begin, kingdoms_end),
		(faction_get_slot, ":candidate_strength", ":strongest_kingdom_candidate", "slot_faction_temp_slot"),
		(gt, ":candidate_strength", ":score_to_beat"),
		(assign, ":strongest_kingdom", ":strongest_kingdom_candidate"),
		(assign, ":score_to_beat", ":candidate_strength"),
	(try_end),
	
	
	(try_begin),
		(eq, "$cheat_mode", 2),
		(gt, ":strongest_kingdom", 1),
		(str_store_faction_name, s4, ":strongest_kingdom"),
		(assign, reg3, ":score_to_beat"),
		(display_message, "@{!}DEBUG - {s4} strongest kingdom with {reg3} strength"),
	(try_end),
	
	#MOTO avoid div-by-0 through init (above)
	# (assign, ":strength_ratio", 1),
	# (try_begin),
		# (gt, ":actor_strength", 0),
		(store_mul, ":strength_ratio", ":target_strength", 100),
		(val_div, ":strength_ratio", ":actor_strength"),
	# (try_end),
	#MOTO avoid div-by-0 through init (above) end
	
	(try_for_range, ":possible_mutual_enemy", kingdoms_begin, kingdoms_end),
		(neq, ":possible_mutual_enemy", ":target_faction"),
		(neq, ":possible_mutual_enemy", ":actor_faction"),
		(faction_slot_eq, ":possible_mutual_enemy", "slot_faction_state", sfs_active),
		
		(store_relation, ":relation", ":possible_mutual_enemy", ":actor_faction"),
		#MOTO assess weakness chief
		(try_begin),
			(lt, ":relation", 0),
			(assign, ":third_party_war", ":possible_mutual_enemy"),
			(val_add, ":num_third_party_wars", 1),
		(try_end),
		
		(store_relation, ":relation", ":possible_mutual_enemy", ":target_faction"),
		(lt, ":relation", 0),
		(val_add, ":num_target_third_party_wars", 1),
		(eq, ":third_party_war", ":possible_mutual_enemy"),
		(assign, ":active_mutual_enemy", ":possible_mutual_enemy"),
		#MOTO assess weakness end
	(try_end),
	
	(store_current_hours, ":cur_hours"),
    (faction_get_slot, ":faction_ai_last_decisive_event", ":actor_faction", "slot_faction_ai_last_decisive_event"),
    (store_sub, ":hours_since_last_decisive_event", ":cur_hours", ":faction_ai_last_decisive_event"),	
	
	(try_begin),
		(gt, "$supported_pretender", 0),
		(this_or_next|eq, "$supported_pretender", ":actor_leader"),
			(eq, "$supported_pretender", ":target_leader"),
		(this_or_next|eq, ":actor_faction", "$supported_pretender_old_faction"),
            (eq, ":target_faction", "$supported_pretender_old_faction"),

		(assign, ":result", -3),			
## Gender fix chief altura	                   
       (troop_get_type, reg4, ":actor_leader"),
## Gender fix
(val_mod, reg4, 2),
###gender fix chief
        (assign, ":explainer_string", "str_s12s15_cannot_negotiate_with_s16_as_to_do_so_would_undermine_reg4herhis_own_claim_to_the_throne_this_civil_war_must_almost_certainly_end_with_the_defeat_of_one_side_or_another"),
	(else_try),
		(lt, ":modified_honor_and_relation", -20),
		(lt, ":strength_ratio", 125),
		(lt, ":war_damage_suffered", 400),
		(this_or_next|neq, ":war_peace_truce_status", -2),
			(lt, ":hours_since_last_decisive_event", 694),
		(eq, ":num_third_party_wars", 0),

		(assign, ":result", -3),		
## Gender fix chief altura	                   
      (troop_get_type, reg4, ":actor_leader"),
## Gender fix
(val_mod, reg4, 2),
###gender fix chief
        (assign, ":explainer_string", "str_s12s15_considers_s16_to_be_dangerous_and_untrustworthy_and_shehe_wants_to_bring_s16_down"),
	(else_try),	
		(gt, ":actor_centers_held_by_target", 0),
		(try_begin),
		  (eq, "$cheat_mode", 1),
		  (display_message, "@{!}Actor centers held by target noted"),
		(try_end),
		
		
		(lt, ":war_damage_suffered", 200),
		(try_begin),
		  (eq, "$cheat_mode", 1),
          (display_message, "@{!}War damage under minimum"),
		(try_end),
		
		(lt, ":strength_ratio", 125),
		(try_begin),
		  (eq, "$cheat_mode", 1),
          (display_message, "@{!}Strength ratio correct"),
		(try_end),
			
		(eq, ":num_third_party_wars", 0),
		(try_begin),
		  (eq, "$cheat_mode", 1),
          (display_message, "@{!}Third party wars"),
		(try_end),
		
		(assign, ":result", -2),
		(val_sub, ":result", ":shift"),	#MOTO add cultural antipathy, provocation factors
		(assign, ":explainer_string", "str_s12s15_is_anxious_to_reclaim_old_lands_such_as_s18_now_held_by_s16"),
	(else_try),
		(eq, ":war_peace_truce_status", -2),
		(lt, ":strength_ratio", 125),
		(le, ":num_third_party_wars", 1),
		(ge, ":war_damage_inflicted", 5),
		(this_or_next|neq, ":war_peace_truce_status", -2),
			(lt, ":hours_since_last_decisive_event", 694),
		
		(store_mul, ":war_damage_suffered_x_2", ":war_damage_suffered", 2),
		(gt, ":war_damage_inflicted", ":war_damage_suffered_x_2"),

		(assign, ":result", -2),
## Gender fix chief altura	                   
       (troop_get_type, reg4, ":actor_leader"),
## Gender fix
(val_mod, reg4, 2),
###gender fix chief
        (assign, ":explainer_string", "str_s12s15_feels_that_reg4shehe_is_winning_the_war_against_s16_and_sees_no_reason_not_to_continue"),
	(else_try),
		(le, ":war_peace_truce_status", -1),
		
		(this_or_next|eq, ":war_peace_truce_status", -1), #either a war is just beginning, or there is a provocation 
			(le, ":war_damage_inflicted", 1),
			
		(lt, ":strength_ratio", 150),
		(eq, ":num_third_party_wars", 0),
		
		(faction_slot_ge, ":actor_faction", "slot_faction_instability", 60),

		(assign, ":result", -1),
		(val_sub, ":result", ":cultural_antipathy"),	#MOTO add cultural antipathy factor
		(assign, ":explainer_string", "str_s12s15_faces_too_much_internal_discontent_to_feel_comfortable_ignoring_recent_provocations_by_s16s_subjects"),
	(else_try),	
		(eq, ":war_peace_truce_status", -2),
		(lt, ":war_damage_inflicted", 100),
		(eq, ":num_third_party_wars", 1),

		(assign, ":result", -1),
## Gender fix chief altura	                   
       (troop_get_type, reg4, ":actor_leader"),
## Gender fix
(val_mod, reg4, 2),
###gender fix chief
        (assign, ":explainer_string", "str_s12even_though_reg4shehe_is_fighting_on_two_fronts_s15_is_inclined_to_continue_the_war_against_s16_for_a_little_while_longer_for_the_sake_of_honor"),

	(else_try),	
		(eq, ":war_peace_truce_status", -2),
		(lt, ":war_damage_inflicted", 100),
		(eq, ":num_third_party_wars", 0),

		(assign, ":result", -1),
## Gender fix chief altura	                   
       (troop_get_type, reg4, ":actor_leader"),
## Gender fix
(val_mod, reg4, 2),
###gender fix chief
        (assign, ":explainer_string", "str_s12s15_feels_that_reg4shehe_must_pursue_the_war_against_s16_for_a_little_while_longer_for_the_sake_of_honor"),
	(else_try),
		(this_or_next|faction_slot_eq, ":actor_faction", "slot_faction_ai_state", sfai_attacking_center),
		(this_or_next|faction_slot_eq, ":actor_faction", "slot_faction_ai_state", sfai_raiding_village),
			(faction_slot_eq, ":actor_faction", "slot_faction_ai_state", sfai_attacking_enemy_army),
		(faction_get_slot, ":offensive_object", ":actor_faction", "slot_faction_ai_object"),
		(party_is_active, ":offensive_object"),
		(store_faction_of_party, ":offensive_object_faction", ":offensive_object"),
		(eq, ":offensive_object_faction", ":target_faction"),
		(str_store_party_name, s17, ":offensive_object"),
		
		(assign, ":result", -1),
		(assign, ":explainer_string", "str_s12s15_is_currently_on_the_offensive_against_s17_now_held_by_s16_and_reluctant_to_negotiate"),

		
	(else_try),
		#Attack strongest kingdom, if it is also at war
		(eq, ":strongest_kingdom", ":target_faction"),
		(eq, ":num_third_party_wars", 0),
		
		#Either not at war, or at war for two months
		(this_or_next|ge, ":war_peace_truce_status", -1),
			(lt, ":hours_since_last_decisive_event", 1240),##gdw1440
		
#		(eq, ":two_factions_share_border", 0),

		(assign, ":at_least_one_other_faction_at_war_with_strongest", 0),
		(try_for_range, ":kingdom_to_check", kingdoms_begin, kingdoms_end),
			(neq, ":kingdom_to_check", ":actor_faction"),
			(neq, ":kingdom_to_check", ":target_faction"),
			(faction_slot_eq, ":kingdom_to_check", "slot_faction_state", sfs_active),
			(store_relation, ":relation_of_factions", ":kingdom_to_check", ":target_faction"),
			(lt, ":relation_of_factions", 0),
			(assign, ":at_least_one_other_faction_at_war_with_strongest", 1),
		(try_end),
		(eq, ":at_least_one_other_faction_at_war_with_strongest", 1),
		
		
		(assign, ":result", -1),
		(val_sub, ":result", ":shift"),	#MOTO add cultural antipathy, provocation factors
		(assign, ":explainer_string", "str_s12s15_is_alarmed_by_the_growing_power_of_s16"),
		
	#bid to conquer all Calradia
	(else_try),
		(eq, ":num_third_party_wars", 0),
		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- No third party wars for {s15}"),
		(try_end),
		(eq, ":actor_faction", ":strongest_kingdom"),
		#peace with no truce or provocation

		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- {s15} is strongest kingdom"),
		(try_end),

		
		(faction_get_slot, ":actor_strength", ":actor_faction", "slot_faction_temp_slot"),
		(faction_get_slot, ":target_strength", ":target_faction", "slot_faction_temp_slot"),
		(store_sub, ":strength_difference", ":actor_strength", ":target_strength"),
		(ge, ":strength_difference", 30),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- {s15} has 30 point advantage over {s16}"),
		(try_end),

		
		# (assign, ":nearby_center_found", 0),	MOTO simply use two_factions_share_border
		# (try_for_range, ":actor_faction_walled_center", walled_centers_begin, walled_centers_end),
			# (store_faction_of_party, ":walled_center_faction_1", ":actor_faction_walled_center"),
			# (eq, ":walled_center_faction_1", ":actor_faction"), 
			# (try_for_range, ":target_faction_walled_center", walled_centers_begin, walled_centers_end),
				# (store_faction_of_party, ":walled_center_faction_2", ":target_faction_walled_center"),
				# (eq, ":walled_center_faction_2", ":target_faction"),
				# (store_distance_to_party_from_party, ":distance", ":target_faction_walled_center", ":actor_faction_walled_center"),
				# (lt, ":distance", 25),
				# (assign, ":nearby_center_found", 1),
				# (assign, ":last_center", ":actor_faction_center"),
			# (try_end),
		# (try_end),
		# (eq, ":nearby_center_found", 1),
		(eq, ":two_factions_share_border", 1),	#MOTO add border requirement		
		
		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- {s15} has proximity to {s16}"),
		(try_end),
		
		(assign, ":result", -1),
		(val_sub, ":result", ":shift"),	#MOTO add cultural antipathy, provocation factors
		(assign, ":explainer_string", "str_s12s15_declared_war_to_control_calradia"),
		
	(else_try),
		(lt, ":modified_honor_and_relation", -20),
		
		(assign, ":result", 0),
		(assign, ":explainer_string", "str_s12s15_distrusts_s16_and_fears_that_any_deals_struck_between_the_two_realms_will_not_be_kept"),
		

	#wishes to deal
	(else_try),
		(lt, ":current_faction_relation", 0),
		(ge, ":num_third_party_wars", 2),
		(assign, ":result", 3),
		(val_sub, ":result", ":shift"),	#MOTO add cultural antipathy, provocation factors
		
		(assign, ":explainer_string", "str_s12s15_is_at_war_on_too_many_fronts_and_eager_to_make_peace_with_s16"),
	(else_try),
		(gt, ":active_mutual_enemy", 0),
		(eq, ":actor_centers_held_by_target", 0),
		(this_or_next|ge, ":current_faction_relation", 0),
			(eq, ":two_factions_share_border", 0),
			# (eq, 1, 1),
			
		(assign, ":result", 3),
		(val_sub, ":result", ":shift"),	#MOTO add cultural antipathy, provocation factors
		(str_store_faction_name, s17, ":active_mutual_enemy"),
## Gender fix chief altura	                   
       (troop_get_type, reg4, ":actor_leader"),
## Gender fix
 (val_mod, reg4, 2),
###gender fix chief
        (assign, ":explainer_string", "str_s12s15_seems_to_think_that_s16_and_reg4shehe_have_a_common_enemy_in_the_s17"),
		
	(else_try),
		(eq, ":war_peace_truce_status", -2),
		(ge, ":hours_since_last_decisive_event", 694),
	
## Gender fix chief altura	                   
       (troop_get_type, reg4, ":actor_leader"),
## Gender fix
(val_mod, reg4, 2),
###gender fix chief
        
		(assign, ":result", 2),
		(val_sub, ":result", ":shift"),	#MOTO add cultural antipathy, provocation factors
		(assign, ":explainer_string", "str_s12s15_feels_frustrated_by_reg4herhis_inability_to_strike_a_decisive_blow_against_s16"),
	
		
	(else_try),
		(lt, ":current_faction_relation", 0),
		(gt, ":war_damage_suffered", 100),
		
		(val_mul, ":war_damage_suffered_x_2", 2),
		(lt, ":war_damage_inflicted", ":war_damage_suffered_x_2"),

		(assign, ":result", 2),
		(val_sub, ":result", ":shift"),	#MOTO add cultural antipathy, provocation factors
		(assign, ":explainer_string", "str_s12s15_has_suffered_enough_in_the_war_with_s16_for_too_little_gain_and_is_ready_to_pursue_a_peace"),
		
	(else_try),	
		(gt, ":third_party_war", 0),
		(ge, ":modified_honor_and_relation", 0),
		(lt, ":current_faction_relation", 0),
		(lt, ":shift", 1),	#MOTO no cultural antipathy, provocation

		(assign, ":result", 1),
		(str_store_faction_name, s17, ":third_party_war"),
		(assign, ":explainer_string", "str_s12s15_would_like_to_firm_up_a_truce_with_s16_to_respond_to_the_threat_from_the_s17"),
	(else_try),
		(gt, ":third_party_war", 0),
		(ge, ":modified_honor_and_relation", 0),
		(lt, ":shift", 1),	#MOTO no cultural antipathy, provocation

		(assign, ":result", 1),
		(str_store_faction_name, s17, ":third_party_war"),
		(assign, ":explainer_string", "str_s12s15_wishes_to_be_at_peace_with_s16_so_as_to_pursue_the_war_against_the_s17"),
	(else_try),
		(gt, ":strength_ratio", 175),
		(eq, ":two_factions_share_border", 1),
		
		(assign, ":result", 1),
		(assign, ":explainer_string", "str_s12s15_seems_to_be_intimidated_by_s16_and_would_like_to_avoid_hostilities"),

	#MOTO chief take advantage of a weak neighbor
	(else_try),
		(eq, ":two_factions_share_border", 1),	
		(le, ":strength_ratio", 50),
		(eq, ":num_third_party_wars", 0),

		(try_begin),
			(le, ":strength_ratio", 25),
			(assign, ":result", -2),
		(else_try),
			(le, ":strength_ratio", 33),
			(assign, ":result", -1),
		(else_try),
			(assign, ":result", 0),
		(try_end),

		(val_sub, ":result", ":shift"),	#MOTO add cultural antipathy, provocation factors
		(assign, ":explainer_string", "str_s12s15_dominates_its_weaker_neighbor_s16"),
	#MOTO chief take advantage of a weak neighbor end

	#MOTO chief genocide
	(else_try),
		(eq, ":num_third_party_wars", 0),
		(eq, ":two_factions_share_border", 1),	
		(lt, ":strength_ratio", 125),
		(eq, ":cultural_antipathy", 1),
		
		(try_begin),
			(eq, ":war_peace_truce_status", -1),	#provocation?
			(assign, ":result", -2),
		(else_try),
			(assign, ":result", -1),
		(try_end),
		(assign, ":explainer_string", "str_s12s15_acts_to_drive_the_people_of_s16_and_their_like_out_of_the_Isles"),
	#MOTO chief genocide end

	(else_try),
		(lt, ":current_faction_relation", 0),
		(lt, ":shift", 1),	#MOTO no cultural antipathy, provocation
		
		(assign, ":result", 1),
		(assign, ":explainer_string", "str_s12s15_has_no_particular_reason_to_continue_the_war_with_s16_and_would_probably_make_peace_if_given_the_opportunity"),
	(else_try),
		(lt, ":shift", 1),	#MOTO no cultural antipathy, provocation
		
		(assign, ":result", 1),
		(assign, ":explainer_string", "str_s12s15_seems_to_be_willing_to_improve_relations_with_s16"),
		
	#MOTO chief new default
	(else_try),
		(assign, ":result", 0),
		(assign, ":explainer_string", "str_s12s15_distrusts_s16_and_fears_that_any_deals_struck_between_the_two_realms_will_not_be_kept"),
	(try_end),
	#MOTO chief new default end

	(str_store_string, s14, ":explainer_string"),
	(assign, reg0, ":result"),
	(assign, reg1, ":explainer_string"),
	]),
	
	("npc_decision_checklist_male_guardian_assess_suitor", #parameters from dialog
	[
	(store_script_param, ":lord", 1),
	(store_script_param, ":suitor", 2),
	
	(troop_get_slot, ":lord_reputation", ":lord", "slot_lord_reputation_type"),
	(store_faction_of_troop, ":lord_faction", ":lord"),
	
	(try_begin),
		(eq, ":suitor", "trp_player"),
		(assign, ":suitor_faction", "$players_kingdom"),
	(else_try),
		(store_faction_of_troop, ":suitor_faction", ":suitor"),
	(try_end),
	(store_relation, ":faction_relation_with_suitor", ":lord_faction", ":suitor_faction"),
	
	(call_script, "script_troop_get_relation_with_troop", ":lord", ":suitor"),
	(assign, ":lord_suitor_relation", reg0),



	(troop_get_slot, ":suitor_renown", ":suitor", "slot_troop_renown"),


	(assign, ":competitor_found", -1),
	
	(try_begin),
		(eq, ":suitor", "trp_player"),	
		(gt, "$marriage_candidate", 0),		
			
		(try_for_range, ":competitor", lords_begin, lords_end),
			(store_faction_of_troop, ":competitor_faction", ":competitor"),
			(eq, ":competitor_faction", ":lord_faction"),
			(this_or_next|troop_slot_eq, ":competitor", "slot_troop_love_interest_1", "$marriage_candidate"),
			(this_or_next|troop_slot_eq, ":competitor", "slot_troop_love_interest_2", "$marriage_candidate"),
				(troop_slot_eq, ":competitor", "slot_troop_love_interest_3", "$marriage_candidate"),
			
			(call_script, "script_troop_get_relation_with_troop", ":competitor", ":lord"),
			(gt, reg0, 5),

			(troop_slot_ge, ":competitor", "slot_troop_renown", ":suitor_renown"),  #higher renown than player
			
			(assign, ":competitor_found", ":competitor"),
			(str_store_troop_name, s14, ":competitor"),
			(str_store_troop_name, s16, "$marriage_candidate"),
		(try_end),
	(try_end),
	
	#renown	
	(try_begin),
		(lt, ":suitor_renown", 50),
		(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_quarrelsome),
		(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_debauched),
			(troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_selfrighteous),
		(assign, ":explainer_string", "str_excuse_me_how_can_you_possibly_imagine_yourself_worthy_to_marry_into_our_family"),
		(assign, ":result", -3),
	(else_try),	
		(lt, ":suitor_renown", 50),
		(troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_goodnatured),
		
		(assign, ":explainer_string", "str_em_with_regard_to_her_ladyship_we_were_looking_specifically_for_a_groom_of_some_distinction_fight_hard_count_your_dinars_and_perhaps_some_day_in_the_future_we_may_speak_of_such_things_my_good_man"),
		(assign, ":result", -1),
	(else_try),
		(lt, ":suitor_renown", 50),
	
		(assign, ":explainer_string", "str_em_with_regard_to_her_ladyship_we_were_looking_specifically_for_a_groom_of_some_distinction"),
		(assign, ":result", -2),
		
	(else_try),
		(lt, ":suitor_renown", 200),
		(neg|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_goodnatured),
		(assign, ":explainer_string", "str_it_is_too_early_for_you_to_be_speaking_of_such_things_you_are_still_making_your_mark_in_the_world"),

		(assign, ":result", -1),
		
	(else_try), #wrong faction
		(eq, ":suitor", "trp_player"),
		(neq, ":suitor_faction", "$players_kingdom"),
		(str_store_faction_name, s4, ":lord_faction"),
		(this_or_next|eq, ":lord_reputation", lrep_quarrelsome),
			(eq, ":lord_reputation", lrep_debauched),
		(assign, ":explainer_string", "str_you_dont_serve_the_s4_so_id_say_no_one_day_we_may_be_at_war_and_i_prefer_not_to_have_to_kill_my_inlaws_if_at_all_possible"),

		(assign, ":result", -1),
		
	(else_try),	
		(eq, ":suitor", "trp_player"),
		(neq, ":suitor_faction", "$players_kingdom"),
		(neq, ":lord_reputation", lrep_goodnatured),
		(neq, ":lord_reputation", lrep_cunning),
	
		(assign, ":explainer_string", "str_as_you_are_not_a_vassal_of_the_s4_i_must_decline_your_request_the_twists_of_fate_may_mean_that_we_will_one_day_cross_swords_and_i_would_hope_not_to_make_a_widow_of_a_lady_whom_i_am_obligated_to_protect"),
		
		(assign, ":result", -1),
	(else_try),	
		(eq, ":suitor", "trp_player"),
		(lt, ":faction_relation_with_suitor", 0),

		(assign, ":explainer_string", "str_as_you_are_not_a_vassal_of_the_s4_i_must_decline_your_request_the_twists_of_fate_may_mean_that_we_will_one_day_cross_swords_and_i_would_hope_not_to_make_a_widow_of_a_lady_whom_i_am_obligated_to_protect"),
		
		(assign, ":result", -1),
		
	(else_try),	
		(eq, ":suitor", "trp_player"),
		(neq, "$player_has_homage", 1),
		(neg|faction_slot_eq, "fac_player_supporters_faction", "slot_faction_state", sfs_active),
		
		(assign, ":explainer_string", "str_as_you_are_not_a_pledged_vassal_of_our_liege_with_the_right_to_hold_land_i_must_refuse_your_request_to_marry_into_our_family"),
		
		(assign, ":result", -1),
	(else_try),	
		(gt, ":competitor_found", -1),

		(this_or_next|eq, ":lord_reputation", lrep_selfrighteous),
		(this_or_next|eq, ":lord_reputation", lrep_debauched),
		(this_or_next|eq, ":lord_reputation", lrep_martial),
			(eq, ":lord_reputation", lrep_quarrelsome),
		
		(assign, ":explainer_string",	"str_look_here_lad__the_young_s14_has_been_paying_court_to_s16_and_youll_have_to_admit__hes_a_finer_catch_for_her_than_you_so_lets_have_no_more_of_this_talk_shall_we"),
		(assign, ":result", -1),
		
	(else_try),
		(lt, ":lord_suitor_relation", -4),
		


		(assign, ":explainer_string", "str_i_do_not_care_for_you_sir_and_i_consider_it_my_duty_to_protect_the_ladies_of_my_household_from_undesirable_suitors"),
		(assign, ":result", -3),
	(else_try),	
		(lt, ":lord_suitor_relation", 5),

		(assign, ":explainer_string",	"str_hmm_young_girls_may_easily_be_led_astray_so_out_of_a_sense_of_duty_to_the_ladies_of_my_household_i_think_i_would_like_to_get_to_know_you_a_bit_better_we_may_speak_of_this_at_a_later_date"),
		(assign, ":result", -1),
	(else_try),	

		(assign, ":explainer_string",	"str_you_may_indeed_make_a_fine_match_for_the_young_mistress"),
		(assign, ":result", 1),
	(try_end),
	
	(assign, reg0, ":result"),
	(assign, reg1, ":explainer_string"),
	
	]),	
	
	("npc_decision_checklist_marry_female_pc", #
	[
	(store_script_param, ":npc", 1),


	(troop_get_slot, ":npc_reputation_type", ":npc", "slot_lord_reputation_type"),
	
	(call_script, "script_troop_get_romantic_chemistry_with_troop", ":npc", "trp_player"),
	(assign, ":romantic_chemistry", reg0),
	
	(call_script, "script_troop_get_relation_with_troop", ":npc", "trp_player"),
	(assign, ":relation_with_player", reg0),
	
	(assign, ":competitor", -1),
	(try_for_range, ":competitor_candidate", kingdom_ladies_begin, kingdom_ladies_end),
		(this_or_next|troop_slot_eq, ":npc", "slot_troop_love_interest_1", ":competitor_candidate"),
		(this_or_next|troop_slot_eq, ":npc", "slot_troop_love_interest_2", ":competitor_candidate"),
			(troop_slot_eq, ":npc", "slot_troop_love_interest_3", ":competitor_candidate"),
		(call_script, "script_troop_get_relation_with_troop", ":npc", ":competitor"),	
		(assign, ":competitor_relation", reg0),
		
		(gt, ":competitor_relation", ":relation_with_player"),
		(assign, ":competitor", ":competitor_candidate"),
	(try_end),

	(assign, ":player_possessions", 0),
	(try_for_range, ":center", centers_begin, centers_end),
		(troop_slot_eq, ":center", "slot_town_lord", "trp_player"),
		(val_add, ":player_possessions", 1),
	(try_end),
	
	(assign, ":lord_agrees", 0),
	#reasons for refusal	
	(try_begin), 
		(troop_slot_ge, "trp_player", "slot_troop_betrothed", active_npcs_begin),
		(neg|troop_slot_eq, "trp_player", "slot_troop_betrothed", ":npc"),
		
		(str_store_string, s14, "str_my_lady_engaged_to_another"),		
	(else_try),
		#bad relationship - minor
		(lt, ":relation_with_player", -3),
		(this_or_next|eq, ":npc_reputation_type", lrep_upstanding),
		(this_or_next|eq, ":npc_reputation_type", lrep_cunning),
				##diplomacy start+ also test commoner types chief
		(this_or_next|eq, ":npc_reputation_type", lrep_roguish),
		(this_or_next|eq, ":npc_reputation_type", lrep_custodian),
		(this_or_next|eq, ":npc_reputation_type", lrep_benefactor),
	(eq, ":npc_reputation_type", lrep_goodnatured),
		
		(str_store_string, s14, "str_madame__given_our_relations_in_the_past_this_proposal_is_most_surprising_i_do_not_think_that_you_are_the_kind_of_woman_who_can_be_bent_to_a_hushands_will_and_i_would_prefer_not_to_have_our_married_life_be_a_source_of_constant_acrimony"),
	
	(else_try), #really bad relationship
		(lt, ":relation_with_player", -10),
	
		(this_or_next|eq, ":npc_reputation_type", lrep_quarrelsome),
		(this_or_next|eq, ":npc_reputation_type", lrep_debauched),
			(eq, ":npc_reputation_type", lrep_selfrighteous),

		(str_store_string, s14, "str_i_would_prefer_to_marry_a_proper_maiden_who_will_obey_her_husband_and_is_not_likely_to_split_his_head_with_a_sword"),
	(else_try),
		(lt, ":romantic_chemistry", 5),

		(str_store_string, s14, "str_my_lady_not_sufficient_chemistry"),
		
	(else_try), #would prefer someone more ladylike
		(this_or_next|eq, ":npc_reputation_type", lrep_upstanding),
			(eq, ":npc_reputation_type", lrep_martial),
		
		(str_store_string, s14, "str_my_lady_while_i_admire_your_valor_you_will_forgive_me_if_i_tell_you_that_a_woman_like_you_does_not_uphold_to_my_ideal_of_the_feminine_of_the_delicate_and_of_the_pure"),
	(else_try),
		(eq, ":npc_reputation_type", lrep_quarrelsome),
		(lt, ":romantic_chemistry", 15),		
		
		(str_store_string, s14, "str_nah_i_want_a_woman_wholl_keep_quiet_and_do_what_shes_told_i_dont_think_thats_you"),
	(else_try), #no properties
		(this_or_next|eq, ":npc_reputation_type", lrep_selfrighteous),
			(eq, ":npc_reputation_type", lrep_debauched),
	
		(ge, ":romantic_chemistry", 10),		
		(eq, ":player_possessions", 0),
		
		(str_store_string, s14, "str_my_lady_you_are_possessed_of_great_charms_but_no_properties_until_you_obtain_some_to_marry_you_would_be_an_act_of_ingratitude_towards_my_ancestors_and_my_lineage"),
		
	(else_try), #you're a nobody - I can do better
		(this_or_next|eq, ":npc_reputation_type", lrep_selfrighteous),
			(eq, ":npc_reputation_type", lrep_debauched),
	
		(eq, ":player_possessions", 0),
		
		(str_store_string, s14, "str_my_lady_you_are_a_woman_of_no_known_family_of_no_possessions__in_short_a_nobody_do_you_think_that_you_are_fit_to_marry_into_may_family"),
	(else_try), #just not that into you
		(lt, ":romantic_chemistry", 5),
		(lt, ":relation_with_player", 20),
		
		(neq, ":npc_reputation_type", lrep_debauched),
		(neq, ":npc_reputation_type", lrep_selfrighteous),
		
		(str_store_string, s14, "str_my_lady__forgive_me__the_quality_of_our_bond_is_not_of_the_sort_which_the_poets_tell_us_is_necessary_to_sustain_a_happy_marriage"),
		
	(else_try), #you're a liability, given your relation with the liege
		(eq, ":npc_reputation_type", lrep_cunning),
		(faction_get_slot, ":leader", "slot_faction_leader", "$g_talk_troop_faction"),
		(str_store_troop_name, s4, ":leader"),
		(call_script, "script_troop_get_relation_with_troop", ":leader", "trp_player"),
		(lt, reg0, -10),
		
		(str_store_string, s14, "str_um_i_think_that_if_i_want_to_stay_on_s4s_good_side_id_best_not_marry_you"),
	(else_try),	#part of another faction
		(gt, "$players_kingdom", 0),
		(neq, "$players_kingdom", "$g_talk_troop_faction"),
		(faction_get_slot, ":leader", "slot_faction_leader", "$g_talk_troop_faction"),
## Gender fix chief altura	                   
       (troop_get_type, reg4, ":leader"),
## Gender fix
(val_mod, reg4, 2),
###gender fix chief		
		(str_store_string, s14, "str_you_serve_another_realm_i_dont_see_s4_granting_reg4herhis_blessing_to_our_union"),
	(else_try), #there's a competitor
		(gt, ":competitor", -1),
		(str_store_troop_name, s4, ":competitor"),
		
		(str_store_string, s14, "str_madame_my_heart_currently_belongs_to_s4"),

	(else_try),
		(lt, ":relation_with_player", 10),
		(assign, ":lord_agrees", 2),
	
		(str_store_string, s14, "str_my_lady_you_are_a_woman_of_great_spirit_and_bravery_possessed_of_beauty_grace_and_wit_i_shall_give_your_proposal_consideration"),
	(else_try),
		(assign, ":lord_agrees", 1),
	
		(str_store_string, s14, "str_my_lady_you_are_a_woman_of_great_spirit_and_bravery_possessed_of_beauty_grace_and_wit_i_would_be_most_honored_were_you_to_become_my_wife"),		
	(try_end),

	
	(assign, reg0, ":lord_agrees"),
	
	]
	),

	
#	(
#	"npc_decision_checklist_king_chooses_lord_for_center", 
#	[
#	(store_script_param, ":center", 1),
	
#	(store_faction_of_party, ":faction", ":center"),
#	(faction_get_slot, ":king", ":faction", "slot_faction_leader"),
	
#	(assign, ":total_renown_in_faction"),
#	(try_for_range, ":lord_iterator", active_npcs_including_player_begin, active_npcs_end), 
#		(assign, ":lord", ":lord_iterator"),
#		(store_faction_of_troop, ":lord_faction", ":lord"),
#		(try_begin),	
#			(eq, ":lord_iterator", "trp_kingdom_heroes_including_player_begin"),
#			(assign, ":lord", "trp_player"),
#			(assign, ":lord_faction", "$players_kingdom"),
#		(try_end),
#		(troop_get_slot, ":renown", ":lord", "slot_troop_renown"),
#		(val_add, ":total_renown_in_faction", ":renown"),
		
#		(troop_set_slot, ":lord", "slot_troop_temp_slot", 0),
#	(try_end),
	
#	(assign, ":total_property_points_in_faction"),
#	(try_for_range, ":village", villages_begin, villages_end),
	
#	(try_end),
	
	
	
#	(try_begin),
	
	#I needed it for myself
	
	#The one who captured it was suitably deserving 
		
	#I had not sufficiently recognized Lord X for his service
	
#	(try_end),
	
	
#	]),
	
	
	
	("courtship_poem_reactions", #parameters from dialog
	[
	(store_script_param, ":lady", 1),
	(store_script_param, ":poem", 2),	
	
	(troop_get_slot, ":lady_reputation", ":lady", "slot_lord_reputation_type"),

	(try_begin),
		(eq, "$cheat_mode", 1),
		(assign, reg4, ":poem"),
		(assign, reg5, ":lady_reputation"),
		(display_message, "str_poem_choice_reg4_lady_rep_reg5"),
	(try_end),
	
	(try_begin), #conventional ++, ambitious -, adventurous -
		(eq, ":poem", courtship_poem_tragic),
		(eq, ":lady_reputation", lrep_conventional),
		(str_store_string, s11, "str_ah__kais_and_layali__such_a_sad_tale_many_a_time_has_it_been_recounted_for_my_family_by_the_wandering_poets_who_come_to_our_home_and_it_has_never_failed_to_bring_tears_to_our_eyes"),
		(assign, ":result", 5),
	(else_try),
		(eq, ":poem", courtship_poem_tragic),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_kais_and_layali_three_hundred_stanzas_of_pathetic_sniveling_if_you_ask_me_if_kais_wanted_to_escape_heartbreak_he_should_have_learned_to_live_within_his_station_and_not_yearn_for_what_he_cannot_have"),
		(assign, ":result", 0),
	(else_try),
		(eq, ":poem", courtship_poem_tragic),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_kais_and_layali_no_one_should_ever_have_written_such_a_sad_poem_if_it_was_the_destiny_of_kais_and_layali_to_be_together_than_their_love_should_have_conquered_all_obstacles"),
		(assign, ":result", 2),#gdw
	(else_try),
		(eq, ":poem", courtship_poem_tragic),
#		moralizing and adventurous
		(str_store_string, s11, "str_ah_kais_and_layali_a_very_old_standby_but_moving_in_its_way"),
		(assign, ":result", 4),#gdw
	#Heroic	
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_adventurous),
		(str_store_string, s11, "str_the_saga_of_helgered_and_kara_such_happy_times_in_which_our_ancestors_lived_women_like_kara_could_venture_out_into_the_world_like_men_win_a_name_for_themselves_and_not_linger_in_their_husbands_shadow"),
		(assign, ":result", 5),#gdw
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_ah_the_saga_of_helgered_and_kara_now_there_was_a_lady_who_knew_what_she_wanted_and_was_not_afraid_to_obtain_it"),
		(assign, ":result", 3),#gdw
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_the_saga_of_helgered_and_kara_a_terrible_tale__but_it_speaks_of_a_very_great_love_if_she_were_willing_to_make_war_on_her_own_family"),
		(assign, ":result", 3),#gdw
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_moralist),
		(str_store_string, s11, "str_the_saga_of_helgered_and_kara_as_i_recall_kara_valued_her_own_base_passions_over_duty_to_her_family_that_she_made_war_on_her_own_father_i_have_no_time_for_a_poem_which_praises_such_a_woman"),
		(assign, ":result", 0),
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_conventional),
		(str_store_string, s11, "str_the_saga_of_helgered_and_kara_how_could_a_woman_don_armor_and_carry_a_sword_how_could_a_man_love_so_ungentle_a_creature"),
		(assign, ":result", 0),
	#Comic
	(else_try), #ambitious ++, romantic -, moralizing 0
		(eq, ":poem", courtship_poem_comic),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_a_conversation_in_the_garden_i_cannot_understand_the_lady_in_that_poem_if_she_loves_the_man_why_does_she_tease_him_so"),
		(assign, ":result", 0),
	(else_try), #ambitious ++, romantic -, moralizing 0
		(eq, ":poem", courtship_poem_comic),
		(eq, ":lady_reputation", lrep_moralist),
		(str_store_string, s11, "str_a_conversation_in_the_garden_let_us_see__it_is_morally_unedifying_it_exalts_deception_it_ends_with_a_maiden_surrendering_to_her_base_passions_and_yet_i_cannot_help_but_find_it_charming_perhaps_because_it_tells_us_that_love_need_not_be_tragic_to_be_memorable"),
		(assign, ":result", 2),#gdw
	(else_try), #ambitious ++, romantic -, moralizing 0
		(eq, ":poem", courtship_poem_comic),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_a_conversation_in_the_garden_now_that_is_a_tale_every_lady_should_know_by_heart_to_learn_the_subtleties_of_the_politics_she_must_practice"),
		(assign, ":result", 5),#gdw
	(else_try), #ambitious ++, romantic -, moralizing 0
		(eq, ":poem", courtship_poem_comic),
		#adventurous, conventional 
		(str_store_string, s11, "str_a_conversation_in_the_garden_it_is_droll_i_suppose__although_there_is_nothing_there_that_truly_stirs_my_soul"),
		(assign, ":result", 4),#gdw

	#Allegoric	
	(else_try), #moralizing ++, adventurous -, romantic -
		(eq, ":poem", courtship_poem_allegoric),
		(eq, ":lady_reputation", lrep_adventurous),
		(str_store_string, s11, "str_storming_the_fortress_of_love_ah_yes_the_lady_sits_within_doing_nothing_while_the_man_is_the_one_who_strives_and_achieves_i_have_enough_of_that_in_my_daily_life_why_listen_to_poems_about_it"),
		(assign, ":result", 0),
	(else_try), #moralizing ++, adventurous -, romantic -
		(eq, ":poem", courtship_poem_allegoric),
		(this_or_next|eq, ":lady_reputation", lrep_conventional),
			(eq, ":lady_reputation", lrep_moralist),
		(str_store_string, s11, "str_storming_the_fortress_of_love_ah_yes_an_uplifting_tribute_to_the_separate_virtues_of_man_and_woman"),
		(assign, ":result", 4),#gdw
	(else_try), #moralizing ++, adventurous -, romantic -
		(eq, ":poem", courtship_poem_allegoric),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_storming_the_fortress_of_love_ah_yes_but_although_it_is_a_fine_tale_of_virtues_it_speaks_nothing_of_passion"),
		(assign, ":result", 2),#gdw
	(else_try), #moralizing ++, adventurous -, romantic -
		(eq, ":poem", courtship_poem_allegoric),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_storming_the_fortress_of_love_ah_a_sermon_dressed_up_as_a_love_poem_if_you_ask_me"),
		(assign, ":result", 2),#gdw

	(else_try), #romantic ++, moralizing 0, ambitious -
		(eq, ":poem", courtship_poem_mystic),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_a_hearts_desire_ah_such_a_beautiful_account_of_the_perfect_perfect_love_to_love_like_that_must_be_to_truly_know_rapture"),
		(assign, ":result", 5),	#gdw	

	(else_try), #romantic ++, moralizing 0, ambitious -
		(eq, ":poem", courtship_poem_mystic),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_a_hearts_desire_silly_if_you_ask_me_if_the_poet_desires_a_lady_then_he_should_endeavor_to_win_her__and_not_dress_up_his_desire_with_a_pretense_of_piety"),
		(assign, ":result", 0),		

	(else_try), #romantic ++, moralizing 0, ambitious -
		(eq, ":poem", courtship_poem_mystic),
		(eq, ":lady_reputation", lrep_moralist),
		(str_store_string, s11, "str_a_hearts_desire_hmm__it_is_an_interesting_exploration_of_earthly_and_divine_love_it_does_speak_of_the_spiritual_quest_which_brings_out_the_best_in_man_but_i_wonder_if_the_poet_has_not_confused_his_yearning_for_higher_things_with_his_baser_passions"),
		(assign, ":result", 3),	#gdw	

	(else_try), #romantic ++, moralizing 0, ambitious -
		(eq, ":poem", courtship_poem_mystic),
		(str_store_string, s11, "str_a_hearts_desire_oh_yes__it_is_very_worthy_and_philosophical_but_if_i_am_to_listen_to_a_bard_strum_a_lute_for_three_hours_i_personally_prefer_there_to_be_a_bit_of_a_story"),
		(assign, ":result", 2),	#gdw	
	(try_end),

	
	(try_begin),
		(eq, "$cheat_mode", 2),#gdw
		(assign, reg4, ":result"),
		(display_message, "str_result_reg4_string_s11"),
	(try_end),	
	
	
	(assign, reg0, ":result"),
	
	]),

	(
	"diplomacy_faction_get_diplomatic_status_with_faction", 
	#result: -1 faction_1 has a casus belli against faction_2. 1, faction_1 has a truce with faction_2, -2, the two factions are at war
	[
	(store_script_param, ":actor_faction", 1),
	(store_script_param, ":target_faction", 2),

	(store_add, ":truce_slot", ":target_faction", "slot_faction_truce_days_with_factions_begin"),
	(store_add, ":provocation_slot", ":target_faction", "slot_faction_provocation_days_with_factions_begin"),
	(val_sub, ":truce_slot", kingdoms_begin),
	(val_sub, ":provocation_slot", kingdoms_begin),
	
	(assign, ":result", 0),
	(assign, ":duration", 0),
	
	(try_begin),
		(store_relation, ":relation", ":actor_faction", ":target_faction"),
		(lt, ":relation", 0),
		(assign, ":result", -2),
	(else_try),
		(faction_slot_ge, ":actor_faction", ":truce_slot", 1),
		(assign, ":result", 1),

		(faction_get_slot, ":duration", ":actor_faction", ":truce_slot"),
	(else_try),
		(faction_slot_ge, ":actor_faction", ":provocation_slot", 1),
		(assign, ":result", -1),
		
		(faction_get_slot, ":duration", ":actor_faction", ":provocation_slot"),
	(try_end),
	
	(assign, reg0, ":result"),
	(assign, reg1, ":duration"),
	]),
	
	("faction_follows_controversial_policy",
	[
	(store_script_param, ":faction_no", 1),
	(store_script_param, ":policy_type", 2),
	
	(faction_get_slot, ":faction_leader", ":faction_no", "slot_faction_leader"),

	(try_begin),
		(ge, "$cheat_mode", 1),
		(str_store_faction_name, s3, ":faction_no"),
		(display_message, "str_calculating_effect_for_policy_for_s3"),
		
		(val_add, "$number_of_controversial_policy_decisions", 1),
	(try_end),
	
	(try_begin),
		(eq, ":policy_type", logent_policy_ruler_attacks_without_provocation),
		(assign, ":hawk_relation_effect", 0),
		(assign, ":honorable_relation_effect", -2),
		(assign, ":honor_change", -1),
		
	(else_try),
		(eq, ":policy_type", logent_policy_ruler_ignores_provocation),
		(assign, ":hawk_relation_effect", -1),##gdw3 causing defections in week 1
		(assign, ":honorable_relation_effect", 0),
		(assign, ":honor_change", 0),
	
	(else_try),
		(eq, ":policy_type", logent_policy_ruler_declares_war_with_justification),
		(assign, ":hawk_relation_effect", 3),
		(assign, ":honorable_relation_effect", 1),
		(assign, ":honor_change", 0),

	(else_try),
		(eq, ":policy_type", logent_policy_ruler_breaks_truce),
		(assign, ":hawk_relation_effect", 0),
		(assign, ":honorable_relation_effect", -3),
		(assign, ":honor_change", -5),

	(else_try),
		(eq, ":policy_type", logent_policy_ruler_makes_peace_too_soon),
		(assign, ":hawk_relation_effect", -3),##gdw-5
		(assign, ":honorable_relation_effect", 0),
		(assign, ":honor_change", 0),
		
	(try_end),
	
	(try_begin),
		(eq, ":faction_leader", "trp_player"),
		(call_script, "script_change_player_honor", ":honor_change"),
	(try_end),	
	
	(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
		(troop_slot_eq, ":lord", "slot_troop_occupation", slto_kingdom_hero),
		(store_faction_of_troop, ":lord_faction", ":lord"),
		(eq, ":lord_faction", ":faction_no"),
		(neq, ":lord", ":faction_leader"),
		
		(try_begin),
			(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_martial),
			(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_quarrelsome),
			(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_selfrighteous),
				(troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_debauched),
			(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":lord", ":hawk_relation_effect"),
			(val_add, "$total_policy_dispute_changes", ":hawk_relation_effect"),
		(try_end),
		
		(try_begin),
			(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_martial),
			(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_goodnatured),
			(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_selfrighteous),
			(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_benefactor), #new for enfiefed commoners
			(this_or_next|troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_custodian), #new for enfiefed commoners
				(troop_slot_eq, ":lord", "slot_lord_reputation_type", lrep_upstanding),
			(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":lord", ":honorable_relation_effect"),
			(val_add, "$total_policy_dispute_changes", ":honorable_relation_effect"),
			
		(try_end),

	(try_end),
	
	]),

	
	
	("internal_politics_rate_feast_to_s9",
	[
	(store_script_param, ":householder", 1),
	(store_script_param, ":num_servings", 2),	
#	(store_script_param, ":faction", 3),	
	(store_script_param, ":consume_items", 4),	

	(val_max, ":num_servings", 1),
	
	(try_for_range, ":item", trade_goods_begin, trade_goods_end), 
		(item_set_slot, ":item", "slot_item_amount_available", 0), #had no "item"
	(try_end),
	
	(troop_get_inventory_capacity, ":capacity", ":householder"),
	(try_for_range, ":inventory_slot", 0, ":capacity"),
		(troop_get_inventory_slot, ":item", ":householder", ":inventory_slot"),
		(is_between, ":item", trade_goods_begin, trade_goods_end),
	    (troop_inventory_slot_get_item_amount, ":slot_amount", ":householder", ":inventory_slot"),
		(item_get_slot, ":item_amount", ":item", "slot_item_amount_available"),
		(val_add, ":item_amount", ":slot_amount"),
		(item_set_slot, ":item", "slot_item_amount_available", ":item_amount"),
	(try_end),
	#food
	(assign, ":food_amount", 0),
	(assign, ":food_variety", 0),
	
	(store_div, ":servings_div_by_12", ":num_servings", 12),
	(try_for_range, ":food_item", food_begin, food_end),
		(item_get_slot, ":food_in_slot", ":food_item", "slot_item_amount_available"),
		(val_add, ":food_amount", ":food_in_slot"),


##		(str_store_item_name, s4, ":food_item"),
##		(assign, reg3, ":food_in_slot"),
##		(assign, reg5, ":servings_div_by_12"),
##		(display_message, "str_reg3_units_of_s4_for_reg5_guests_and_retinue"),

		
		(ge, ":food_in_slot", ":servings_div_by_12"),
		(val_add, ":food_variety", 1),
	(try_end),
	
	(val_mul, ":food_amount", 100),
	(val_div, ":food_amount", ":num_servings"), #1 to 100 for each
	(val_min, ":food_amount", 100),
	
	(val_mul, ":food_variety", 85), #1 to 100 for each
	(val_div, ":food_variety", 10), 
	(val_min, ":food_variety", 100),
	
	#drink
	(assign, ":drink_amount", 0),
	(assign, ":drink_variety", 0),
	(store_div, ":servings_div_by_4", ":num_servings", 4),
	(try_for_range, ":drink_iterator", "itm_wine", "itm_smoked_fish"),
		(assign, ":drink_item", ":drink_iterator"),
		(item_get_slot, ":drink_in_slot", ":drink_item", "slot_item_amount_available"),
		
		(val_add, ":drink_amount", ":drink_in_slot"),
	
		(ge, ":drink_in_slot", ":servings_div_by_4"),
		(val_add, ":drink_variety", 1),
	(try_end),
	
	(val_mul, ":drink_amount", 200), #amount needed is 50% of the number of guests
	(val_max, ":num_servings", 1),
	
	(val_div, ":drink_amount", ":num_servings"), #1 to 100 for each
	(val_min, ":drink_amount", 100),
	(val_mul, ":drink_variety", 50), #1 to 100 for each

	#in the future, it might be worthwhile to add different varieties of spices
	(item_get_slot, ":spice_amount", "itm_spice", "slot_item_amount_available"),
	(store_mul, ":spice_percentage", ":spice_amount", 100),
	(val_max, ":servings_div_by_12", 1),
	(val_div, ":spice_amount", ":servings_div_by_12"),
	(val_min, ":spice_percentage", 100),
##	(assign, reg3, ":spice_amount"),
##	(assign, reg5, ":servings_div_by_12"),
##	(assign, reg6, ":spice_percentage"),
##	(display_message, "str_reg3_units_of_spice_of_reg5_to_be_consumed"),
	
	#oil availability. In the future, this may become an "atmospherics" category, including incenses
	(item_get_slot, ":oil_amount", "itm_oil", "slot_item_amount_available"),
	(store_mul, ":oil_percentage", ":oil_amount", 100),
	(val_max, ":servings_div_by_12", 1),
	(val_div, ":oil_amount", ":servings_div_by_12"),
	(val_min, ":oil_percentage", 100),
##	(assign, reg3, ":oil_amount"),
##	(assign, reg5, ":servings_div_by_12"),
##	(assign, reg6, ":oil_percentage"),
##	(display_message, "str_reg3_units_of_oil_of_reg5_to_be_consumed"),

	(store_div, ":food_amount_string", ":food_amount", 20),
	(val_add, ":food_amount_string", "str_feast_description"),
	(str_store_string, s8, ":food_amount_string"),
	(str_store_string, s9, "str_of_food_which_must_come_before_everything_else_the_amount_is_s8"),
	
	(store_div, ":food_variety_string", ":food_variety", 20),
	(val_add, ":food_variety_string", "str_feast_description"),
	(str_store_string, s8, ":food_variety_string"),
	(str_store_string, s9, "str_s9_and_the_variety_is_s8_"),

	(store_div, ":drink_amount_string", ":drink_amount", 20),
	(val_add, ":drink_amount_string", "str_feast_description"),
	(str_store_string, s8, ":drink_amount_string"),
	(str_store_string, s9, "str_s9_of_drink_which_guests_will_expect_in_great_abundance_the_amount_is_s8"),
	
	(store_div, ":drink_variety_string", ":drink_variety", 20),
	(val_add, ":drink_variety_string", "str_feast_description"),
	(str_store_string, s8, ":drink_variety_string"),
	(str_store_string, s9, "str_s9_and_the_variety_is_s8_"),
	
	(store_div, ":spice_string", ":spice_percentage", 20),
	(val_add, ":spice_string", "str_feast_description"),
	(str_store_string, s8, ":spice_string"),
	(str_store_string, s9, "str_s9_of_spice_which_is_essential_to_demonstrate_that_we_spare_no_expense_as_hosts_the_amount_is_s8_"),
	
	(store_div, ":oil_string", ":oil_percentage", 20),
	(val_add, ":oil_string", "str_feast_description"),
	(str_store_string, s8, ":oil_string"),
	(str_store_string, s9, "str_s9_of_oil_which_we_shall_require_to_light_the_lamps_the_amount_is_s8"),
	
	(store_mul, ":food_amount_cap", ":food_amount", 8),
	(store_add, ":total", ":food_amount", ":food_variety"),
	(val_mul, ":total", 2), #x4
	(val_add, ":total", ":drink_variety"),
	(val_add, ":total", ":drink_amount"), #x6
	(val_add, ":total", ":spice_amount"), #x7
	(val_add, ":total", ":oil_amount"), #x8
	(val_min, ":total", ":food_amount_cap"),
	(val_div, ":total", 8),
	(val_clamp, ":total", 1, 101),
	(store_div, ":total_string", ":total", 20),
	(val_add, ":total_string", "str_feast_description"),
	(str_store_string, s8, ":total_string"),
	(str_store_string, s9, "str_s9_overall_our_table_will_be_considered_s8"),
	
	(assign, reg0, ":total"), #zero to 100
	
	
	
	(try_begin),
		(eq, ":consume_items", 1),
		
		(assign, ":num_of_servings_to_serve", ":num_servings"),
		(try_for_range, ":unused", 0, 1999),
			(gt, ":num_of_servings_to_serve", 0),
			
			(try_for_range, ":item", trade_goods_begin, trade_goods_end),
				(item_set_slot, ":item", "slot_item_is_checked", 0),
			(try_end),
			
			(troop_get_inventory_capacity, ":inv_size", ":householder"),
			(try_for_range, ":i_slot", 0, ":inv_size"),
				(troop_get_inventory_slot, ":item", ":householder", ":i_slot"),
				(this_or_next|eq, ":item", "itm_spice"),
				(this_or_next|eq, ":item", "itm_oil"),
				(this_or_next|eq, ":item", "itm_wine"),
				(this_or_next|eq, ":item", "itm_ale"),
				(this_or_next|eq, ":item", "itm_mead"), #chief
					(is_between, ":item",  food_begin, food_end),
				(item_slot_eq, ":item", "slot_item_is_checked", 0),
				(troop_inventory_slot_get_item_amount, ":cur_amount", ":householder", ":i_slot"),
				(gt, ":cur_amount", 0),
				
				(val_sub, ":cur_amount", 1),
				(troop_inventory_slot_set_item_amount, ":householder", ":i_slot", ":cur_amount"),
				(val_sub, ":num_of_servings_to_serve", 1),
				(item_set_slot, ":item", "slot_item_is_checked", 1),
			(try_end),
		(try_end),
	(try_end),
	]),

	
	("faction_get_adjective_to_s10", 
	[
	(store_script_param, ":faction_no", 1),

	(try_begin),
		(eq, ":faction_no", "fac_player_faction"),
		(assign, ":faction_no", "$players_kingdom"),
	(try_end),
	
	
	(try_begin),
		(eq, ":faction_no", "fac_player_supporters_faction"),
		(str_store_string, s10, "str_rebel"),
	(else_try),	
		(this_or_next|eq, ":faction_no", "fac_outlaws"),
		(this_or_next|eq, ":faction_no", "fac_mountain_bandits"),
		(this_or_next|eq, ":faction_no", "fac_forest_bandits"),
			(eq, ":faction_no", "fac_deserters"),
		(str_store_string, s10, "str_bandit"),	
	(else_try),
		(faction_get_slot, ":adjective_string", ":faction_no", "slot_faction_adjective"),
		(str_store_string, s10, ":adjective_string"),
	(try_end),			
	]),
	
	("setup_tavern_attacker", 
	[
	  (store_script_param, ":cur_entry", 1),
	  	  
	  (try_begin),
	    (neg|troop_slot_eq, "trp_hired_assassin", "slot_troop_cur_center", "$g_encountered_party"),
	    (troop_slot_eq, "trp_belligerent_drunk", "slot_troop_cur_center", "$g_encountered_party"),
	    (set_visitor, ":cur_entry", "trp_belligerent_drunk"),
	  (try_end),
	  
	  (try_begin),
	    (troop_slot_eq, "trp_hired_assassin", "slot_troop_cur_center", "$g_encountered_party"),
	    (set_visitor, ":cur_entry", "trp_hired_assassin"),
	  (try_end),
	]),
		
	("activate_tavern_attackers", 
	[
	  (set_party_battle_mode),
	  (try_for_agents, ":cur_agent"),
	    (agent_get_troop_id, ":cur_agent_troop", ":cur_agent"),
	    (this_or_next|eq, ":cur_agent_troop", "trp_fugitive"),
	    (this_or_next|eq, ":cur_agent_troop", "trp_belligerent_drunk"),
	    (eq, ":cur_agent_troop", "trp_hired_assassin"),
	    (agent_set_team, ":cur_agent", 1),
	    (assign, "$g_main_attacker_agent", ":cur_agent"),
	    (agent_ai_set_aggressiveness, ":cur_agent", 199),
	  (try_end),
	]),
	
	("deactivate_tavern_attackers", 
	[
	  (finish_party_battle_mode),
	  (try_for_agents, ":cur_agent"),
	    (agent_get_troop_id, ":cur_agent_troop", ":cur_agent"),
	    (this_or_next|eq, ":cur_agent_troop", "trp_fugitive"),
	    (this_or_next|eq, ":cur_agent_troop", "trp_belligerent_drunk"),
	    (eq, ":cur_agent_troop", "trp_hired_assassin"),
	    (agent_set_team, ":cur_agent", 0),
	    (agent_ai_set_aggressiveness, ":cur_agent", 0),
	  (try_end),
	]),
	
	("activate_town_guard", 
	[
	  (set_party_battle_mode),
	  #(get_player_agent_no, ":player_agent"),
	  #(agent_get_team, ":player_team", ":player_agent"),
	  
	  (try_for_agents, ":cur_agent"), 
	    (agent_get_troop_id, ":troop_type", ":cur_agent"),
	    (is_between, ":troop_type", "trp_jute_recruit", "trp_looter"), #chief cambia para que entren todos
        (agent_set_team, ":cur_agent", 1),
        #(team_give_order, 1, grc_everyone, mordr_charge), - for some reason, this freezes everyone if the player is not yet spawned
		#(try_begin),
		#	(eq, "$g_main_attacker_agent", 0),
		#	(assign, "$g_main_attacker_agent", ":cur_agent"),
		#(try_end),
	(else_try),	
		(this_or_next|is_between, ":cur_agent", walkers_begin, walkers_end),
		(is_between, ":cur_agent", armor_merchants_begin, mayors_end),
		
		(agent_clear_scripted_mode, ":cur_agent"),
		(agent_set_team, ":cur_agent", 2),
	(try_end),
	]),


	#this determines whether or not a lord is thrown into a dungeon by his captor, or is kept out on parole
	#Not currently used (ie, it always fails)
	("cf_prisoner_offered_parole", 
	[
	  (store_script_param, ":prisoner", 1),
	  
	  (eq, 1, 0), #disabled, this will always return false
	  
	  (troop_get_slot, ":captor_party", ":prisoner", "slot_troop_prisoner_of_party"),
	  (party_is_active, ":captor_party"),
	  (is_between, ":captor_party", walled_centers_begin, walled_centers_end),
	  (party_get_slot, ":captor", ":captor_party", "slot_town_lord"),
	  
	  (troop_get_slot, ":prisoner_rep", ":prisoner", "slot_lord_reputation_type"),
	  (troop_get_slot, ":captor_rep", ":captor", "slot_lord_reputation_type"),
	  
	  (neq, ":prisoner_rep", lrep_debauched),
	  (neq, ":captor_rep", lrep_debauched),
	  (neq, ":captor_rep", lrep_quarrelsome),
	
     #Prisoner is a noble, or lord is goodnatured
    (this_or_next|eq, ":captor_rep", lrep_goodnatured),
    (this_or_next|troop_slot_eq, ":prisoner", "slot_troop_occupation", slto_kingdom_hero),
    (troop_slot_eq, ":prisoner", "slot_troop_occupation", slto_kingdom_lady),
	
	(call_script, "script_troop_get_relation_with_troop", ":captor", ":prisoner"),
##	(display_message, "str_relation_of_prisoner_with_captor_is_reg0"),
	(ge, reg0, -10),		
	]),

	("neutral_behavior_in_fight", 
	[
      (get_player_agent_no, ":player_agent"),
      (agent_get_position, pos3, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),
	
      (try_begin),
        (gt, "$g_main_attacker_agent", 0),
      							  (agent_is_active, "$g_main_attacker_agent"), #Floris chief - bugfix
        (agent_get_team, ":attacker_team_no", "$g_main_attacker_agent"),
        (agent_get_position, pos5, "$g_main_attacker_agent"),
      (else_try),
                              #(eq, ":attacker_team_no", -1), #Floris chief - bugfix - stupid native coding
							  (assign, ":attacker_team_no", -1), #Floris - bugfix
        (agent_get_position, pos5, ":player_agent"),
      (try_end),
           
      (set_fixed_point_multiplier, 100),
	
      (try_for_agents, ":agent"),	
        (agent_get_team, ":other_team", ":agent"),
        (neq, ":other_team", ":attacker_team_no"),
        (neq, ":other_team", ":player_team"),
        
        (agent_get_troop_id, ":troop_id", ":agent"),
   		(neg|is_between, ":troop_id", "trp_jute_recruit", "trp_looter"), #chief cambia para que coja todas las tropas
       
        (agent_get_position, pos4, ":agent"),
			
        (assign, ":best_position_score", 0),
        (assign, ":best_position", -1),
        
        (try_begin),        
          (neg|agent_slot_eq, ":agent", "slot_agent_is_running_away", 0), #if agent is running away
          (agent_get_slot, ":target_entry_point_plus_one",  ":agent", "slot_agent_is_running_away"),
          (store_sub, ":target_entry_point", ":target_entry_point_plus_one", 1),
          (entry_point_get_position, pos6, ":target_entry_point"),
          (get_distance_between_positions, ":agent_distance_to_target", pos6, pos4),
          (lt, ":agent_distance_to_target", 100),
          (agent_set_slot, ":agent", "slot_agent_is_running_away", 0),
        (try_end),
			
        (agent_slot_eq, ":agent", "slot_agent_is_running_away", 0), #if agent is not already running away
        
        (try_begin), #stand in place
          (get_distance_between_positions, ":distance", pos4, pos5),
          (get_distance_between_positions, ":distance_to_player", pos4, pos3),

          (val_min, ":distance", ":distance_to_player"),
		
          (this_or_next|gt, ":distance", 700), #7 meters away from main belligerents
          (main_hero_fallen),

          (agent_set_scripted_destination, ":agent", pos4), 
        (else_try), #get out of the way			                    
          (try_for_range, ":target_entry_point", 0, 64),
            (neg|entry_point_is_auto_generated, ":target_entry_point"),
            (entry_point_get_position, pos6, ":target_entry_point"),
            (get_distance_between_positions, ":agent_distance_to_target", pos6, pos4),
            (get_distance_between_positions, ":player_distance_to_target", pos6, pos3),
            (store_sub, ":position_score", ":player_distance_to_target", ":agent_distance_to_target"),
            (ge, ":position_score", 0),
            (try_begin),
              (ge, ":agent_distance_to_target", 2000),
              (store_sub, ":extra_distance", ":agent_distance_to_target", 2000),
              (val_min, ":extra_distance", 1000),
              (val_min, ":agent_distance_to_target", 2000), #if more than 10 meters assume it is 10 meters far while calculating best run away target
              (val_sub, ":agent_distance_to_target", ":extra_distance"),
            (try_end),
            (val_mul, ":position_score", ":agent_distance_to_target"),
            (try_begin),
              (ge, ":position_score", ":best_position_score"),
              (assign, ":best_position_score", ":position_score"),
              (assign, ":best_position", ":target_entry_point"),
            (try_end),
          (try_end),
          
          (try_begin),
            (ge, ":best_position", 0),
            (entry_point_get_position, pos6, ":best_position"),
            (agent_set_speed_limit, ":agent", 10),
            (agent_set_scripted_destination, ":agent", pos6),
            (store_add, ":best_position_plus_one", ":best_position", 1),
            (agent_set_slot, ":agent", "slot_agent_is_running_away", ":best_position_plus_one"),
          (try_end),
        (try_end),
	  (try_end),
	]),

	("party_inflict_attrition", #parameters from dialog
	[
	(store_script_param, ":party", 1),
	(store_script_param, ":attrition_rate", 2),	
#	(store_script_param, ":attrition_type", 3), #1 = desertion, 2 = sickness	

    (party_clear, "p_temp_casualties"),

	(party_get_num_companion_stacks, ":num_stacks", ":party"),

	#add to temp casualties
	(try_for_range, ":stack", 0, ":num_stacks"),
		(party_stack_get_troop_id, ":troop_type", ":party", ":stack"),
		(neg|troop_is_hero, ":troop_type"),
		(party_stack_get_size, ":size", ":party", ":stack"),
		(store_mul, ":casualties_x_100", ":attrition_rate", ":size"),
		(store_div, ":casualties", ":casualties_x_100", 100),
		(party_add_members, "p_temp_casualties", ":troop_type", ":casualties"),
		
		(store_mul, ":subtractor", ":casualties", 100),
		(store_sub, ":chance_of_additional_casualty", ":casualties_x_100", ":subtractor"),
	
		(try_begin),
			(gt, ":chance_of_additional_casualty", 0),
			(store_random_in_range, ":random", 0, 100),
			(lt, ":random", ":chance_of_additional_casualty"),
			(party_add_members, "p_temp_casualties", ":troop_type", ":casualties"),
		(try_end),

#		(try_begin),
#			(eq, "$cheat_mode", 1),
#			(str_store_party_name, s7, ":party"),
#           		...
#		(try_end),
	(try_end),
	
	#take temp casualties from main party
	(party_get_num_companion_stacks, ":num_stacks", "p_temp_casualties"),

	#add to temp casualties
	(try_for_range, ":stack", 0, ":num_stacks"),
		(party_stack_get_troop_id, ":troop_type", "p_temp_casualties", ":stack"),
		(party_stack_get_size, ":size", "p_temp_casualties", ":stack"),
		(party_remove_members, ":party", ":troop_type", ":size"),
		
		(eq, "$cheat_mode", 1),
		(assign, reg3, ":size"),
		(str_store_troop_name, s4, ":troop_type"),
		(str_store_party_name, s5, ":party"),
#		(display_message, "str_s5_suffers_attrition_reg3_x_s4"), 
		#(str_store_string, s65, "str_s5_suffers_attrition_reg3_x_s4"), 
		(display_debug_message, "str_s5_suffers_attrition_reg3_x_s4"),
		# (try_begin),##gdw this seems to be causing a pop up screen that's unwelcome
		# 	(eq, "$debug_message_in_queue", 0),
		# 	(call_script, "script_add_notification_menu", "mnu_debug_alert_from_s65", 0, 0),
		# 	(assign, "$debug_message_in_queue", 1),
		# (try_end),
	(try_end),
	
	]),
	
	
	
	
	("add_rumor_string_to_troop_notes", #parameters from dialog
	[
      (store_script_param, ":object_1", 1),
      (store_script_param, ":object_2", 2),	
      (store_script_param, ":string", 3),	
	
      (str_store_troop_name, s10, "$g_talk_troop"),
      (str_store_string_reg, s11, ":string"),
	
      (store_current_hours, ":hours"),
      (call_script, "script_game_get_date_text", 0, ":hours"),
	
      (str_store_string, s5, "str_s10_said_on_s1_s11__"),

      (try_begin),
        (is_between, ":object_1", active_npcs_begin, kingdom_ladies_end),
        (troop_get_slot, ":current_rumor_note", ":object_1", "slot_troop_current_rumor"),
        (val_add, ":current_rumor_note", 1),
        (try_begin),
# Lav modifications start (custom lord notes) chief
          (neg|is_between, ":current_rumor_note", 3, 15), # Was 16 in original Native, thus using notes slot #15 as well. Now it will leave notes slot #15 for custom notes.
# Lav modifications end (custom lord notes)
          (assign, ":current_rumor_note", 3),
        (try_end),
        (troop_set_slot, ":object_1", "slot_troop_current_rumor", ":current_rumor_note"),
		
        (add_troop_note_from_sreg, ":object_1", ":current_rumor_note", s5, 0), #troop, note slot, string, show       
		
        (try_begin),
          (eq, "$cheat_mode", 1),
          (str_store_troop_name, s3, ":object_1"),
          (assign, reg4, ":current_rumor_note"),
          (display_message, "str_rumor_note_to_s3s_slot_reg4_s5"),
        (try_end),
      (try_end),
      
      (try_begin),
        (is_between, ":object_2", active_npcs_begin, kingdom_ladies_end),
        (troop_get_slot, ":current_rumor_note", ":object_2", "slot_troop_current_rumor"),
        (val_add, ":current_rumor_note", 1),
        (try_begin),
# Lav modifications start (custom lord notes) chief
          (neg|is_between, ":current_rumor_note", 3, 15), # Was 16 in original Native, thus using notes slot #15 as well. Now it will leave notes slot #15 for custom notes.
# Lav modifications end (custom lord notes)
          (assign, ":current_rumor_note", 3),
        (try_end),
        (troop_set_slot, ":object_2", "slot_troop_current_rumor", ":current_rumor_note"),
        
        (add_troop_note_from_sreg, ":object_2", ":current_rumor_note", s5, 0), #troop, note slot, string, show        
        
        (try_begin),
          (eq, "$cheat_mode", 1),
          (str_store_troop_name, s3, ":object_2"),
          (assign, reg4, ":current_rumor_note"),
          (display_message, "str_rumor_note_to_s3s_slot_reg4_s5"),
        (try_end),
      (try_end),	
	]),

	("lord_find_alternative_faction", #Also, make it so that lords will try to keep at least one center unassigned
	[
	  (store_script_param, ":troop_no", 1),
	  (store_faction_of_troop, ":orig_faction", ":troop_no"),
	  
	  (assign, ":new_faction", -1),
	  (assign, ":score_to_beat", -5),

	  (try_begin),
	    (store_random_in_range, ":advantegous_faction_change_time", 0, 10000), 

	    (this_or_next|le, "$g_advantegous_faction", 0),
		(eq, ":advantegous_faction_change_time", 0),
		(store_random_in_range, "$g_advantegous_faction", kingdoms_begin, kingdoms_end), 
	  (try_end),

	  (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),	  
	    (this_or_next|eq, "$g_give_advantage_to_original_faction", 1),
		(neq, ":faction_no", ":orig_faction"),
	   
	    (faction_slot_eq, ":faction_no", "slot_faction_state", sfs_active),

 #MOTO chief neighbors
        #add this to prevent factions from gaining fiefs (and starting wars) at far end of map TML,F123 - 1.41 -> Submod
        #(store_add, ":slot", "slot_faction_neighbors_begin", ":faction_no"),
        #(val_sub, ":slot", kingdoms_begin),
        #(this_or_next|faction_slot_eq, ":orig_faction", ":slot", 1),
        #(eq, ":faction_no", ":orig_faction"),
        #MOTO chief neighbors end    http://forums.taleworlds.com/index.php/topic,283638.45.html 
         #F123 fix pest lords #http://forums.taleworlds.com/index.php/topic,283638.45.html
	    (assign, ":number_of_walled_centers", 0),
	    (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
		  (store_faction_of_party, ":center_faction", ":center_no"),
		  (eq, ":center_faction", ":faction_no"),

		  (try_begin),
		    (party_slot_eq, ":center_no", "slot_party_type", spt_town),
			(val_add, ":number_of_walled_centers", 2),
		  (else_try),
		    (val_add, ":number_of_walled_centers", 1),
		  (try_end),
		(try_end),

	    (assign, ":number_of_lords", 0),
        (try_for_range, ":troop_id", original_kingdom_heroes_begin, active_npcs_end),
          (store_troop_faction, ":faction_of_troop", ":troop_id"),
          (eq, ":faction_of_troop", ":faction_no"),
		  (val_add, ":number_of_lords", 1),
        (try_end),
        (neq, ":number_of_lords", 0),    #(eliminated?) faction      with no lords Motomataru chief #TMLF123 - Reverted to 1.40/Submod (Apparently a new bug from 1.41, according to ZeroNoID on the Forums, his fix is what was originally in 1.40, so reverting.)
          
        (faction_get_slot, ":liege", ":faction_no", "slot_faction_leader"),
	    (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":liege"),
		(assign, ":relation_with_leader", reg0),

		(store_mul, ":faction_score", ":number_of_walled_centers", 100),
		(val_div, ":faction_score", ":number_of_lords"),
		(val_add, ":faction_score", ":relation_with_leader"),

		(try_begin),
		  (eq, ":faction_no", ":orig_faction"),
		  (eq, "$g_give_advantage_to_original_faction", 1),
		  (val_add, ":faction_score", 100),
		(try_end),

		(try_begin),
		  (eq, "$g_advantegous_faction", ":faction_no"),
		  (val_add, ":faction_score", 50),
		(try_end),

		(try_begin),
		  (eq, ":faction_no", "$players_kingdom"),
		  (val_sub, ":faction_score", 100),
		  (val_add, "$player_right_to_rule"),
		(try_end),

		(gt, ":faction_score", ":score_to_beat"),

		(assign, ":score_to_beat", ":faction_score"),
        (assign, ":new_faction", ":faction_no"),
	  (try_end),
	  	  
	  (assign, reg0, ":new_faction"),	
	]),
		
	("set_up_duel_with_troop", #now the setup is handled through the menu
	[
	  (store_script_param, "$g_duel_troop", 1),	
	  (assign, "$g_start_arena_fight_at_nearest_town", 1),
	  (try_begin),
	    (eq, "$g_start_arena_fight_at_nearest_town", 1),
	  (try_end),  
	  (unlock_achievement, ACHIEVEMENT_PUGNACIOUS_D),
      (jump_to_menu, "mnu_arena_duel_fight"),
	  (finish_mission),

	]),

	("deduct_casualties_from_garrison", #after a battle in a center, deducts any casualties from "$g_encountered_party"
	[
	##(display_message, "str_totalling_casualties_caused_during_mission"),
	
	(try_for_agents, ":agent"),
		(agent_get_troop_id, ":troop_type", ":agent"),
		(is_between, ":troop_type", regular_troops_begin, regular_troops_end),
		
		(neg|agent_is_alive, ":agent"),
		
		(try_begin), #if troop not present, search for another type which is
			(store_troop_count_companions, ":number", ":troop_type", "$g_encountered_party"),
			(eq, ":number", 0),
			(assign, ":troop_type", 0),
			(try_for_range, ":new_tier", "slot_faction_tier_1_troop", "slot_faction_tier_5_troop"),
			(faction_get_slot, ":troop_type", "$g_encountered_party_faction", ":new_tier"),
				(faction_get_slot, ":new_troop_type", "$g_encountered_party_faction", ":new_tier"),
				(store_troop_count_companions, ":number", ":new_troop_type", "$g_encountered_party"),
				(gt, ":number", 0), 
				(assign, ":troop_type", ":new_troop_type"),
			(try_end),
		(try_end),
		
		(gt, ":troop_type", 0),
			
		(party_remove_members, "$g_encountered_party", ":troop_type", 1),
		(str_store_troop_name, s4, ":troop_type"),
		(str_store_party_name, s5, "$g_encountered_party"),
	(try_end),		
	]),		
								
	("npc_decision_checklist_take_stand_on_issue",
	#Called from dialogs, and from simple_triggers
	
	#This a very inefficient checklist, and if I did it again, I would score for each troop. That way the troop could answer "why not" to an individual lord
	[
	(store_script_param, ":troop_no", 1),
	(store_faction_of_troop, ":troop_faction", ":troop_no"),
	
	(assign, ":result", -1),
	(faction_get_slot, ":faction_issue", ":troop_faction", "slot_faction_political_issue"),
	
	(assign, ":player_declines_honor", 0),
	(try_begin),
		(is_between, ":faction_issue", centers_begin, centers_end),
	    (gt, "$g_dont_give_fief_to_player_days", 1),
		(assign, ":player_declines_honor", 1),
	(else_try),
	    (gt, "$g_dont_give_marshalship_to_player_days", 1),
		(assign, ":player_declines_honor", 1),	
	(try_end),
	
	
	(assign, ":total_faction_renown", 0),
	(troop_set_slot, "trp_player", "slot_troop_temp_slot", 0),
	(try_begin),
		(eq, "$players_kingdom", ":troop_faction"),
		(eq, "$player_has_homage", 1),
		(troop_get_slot, ":total_faction_renown", "trp_player", "slot_troop_renown"),
	(try_end),
	
	(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
		(troop_set_slot, ":active_npc", "slot_troop_temp_slot", 0), #reset to zero
	
		(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
		(eq, ":active_npc_faction", ":troop_faction"),
		(troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_kingdom_hero),
		
		(troop_get_slot, ":renown", ":active_npc", "slot_troop_renown"),
		(val_add, ":total_faction_renown", ":renown"),
	(try_end),
	
	
	(assign, ":total_faction_center_value", 0),
	(try_for_range, ":center", centers_begin, centers_end),
		(store_faction_of_party, ":center_faction", ":center"),
		(eq, ":center_faction", ":troop_faction"),
		
		(assign, ":center_value", 1),
		(try_begin),
			(is_between, ":center", towns_begin, towns_end),
			(assign, ":center_value", 2),
		(try_end),
		
		(val_add, ":total_faction_center_value", ":center_value"),
		
		(party_get_slot, ":town_lord", ":center", "slot_town_lord"),
		(gt, ":town_lord", -1),
		
		(troop_get_slot, ":temp_slot", ":town_lord", "slot_troop_temp_slot"),
		(val_add, ":temp_slot", ":center_value"),
		(troop_set_slot, ":town_lord", "slot_troop_temp_slot", ":temp_slot"),
	(try_end),
	(val_max, ":total_faction_center_value", 1),
	
	(store_div, ":average_renown_per_center_point", ":total_faction_renown", ":total_faction_center_value"),

	
	(try_begin),
		(is_between, ":faction_issue", centers_begin, centers_end),
		#NOTE -- The algorithms here might seem a bit repetitive, but are designed that way to create internal cliques among the lords in a faction.
	
	
	
		(try_begin),#If the center is a village, and a lord has no fief, choose him
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_selfrighteous),
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_quarrelsome),
			
			(is_between, ":faction_issue", villages_begin, villages_end),
			(assign, ":favorite_lord_without_center", -1),
			(assign, ":score_to_beat", -1),
			
			
			(try_begin),
				(eq, "$players_kingdom", ":troop_faction"),
				(eq, "$player_has_homage", 1),
				(eq, ":player_declines_honor", 0),	
				
				(troop_slot_eq, "trp_player", "slot_troop_temp_slot", 0),
				(call_script, "script_troop_get_relation_with_troop", "trp_player", ":troop_no"),
				(assign, ":relation", reg0),
				
				(gt, ":relation", ":score_to_beat"),
				(neg|troop_slot_ge, "trp_player", "slot_troop_controversy", 75),
				(assign, ":favorite_lord_without_center", "trp_player"),
				(assign, ":score_to_beat", ":relation"),
			(try_end),
			(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":troop_faction"),
				(troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_kingdom_hero),
			
				(troop_slot_eq, ":active_npc", "slot_troop_temp_slot", 0),
				(try_begin),
					(eq, ":active_npc", ":troop_no"),
					(assign, ":relation", 50),
				(else_try),	
					(call_script, "script_troop_get_relation_with_troop", ":active_npc", ":troop_no"),
					(assign, ":relation", reg0),
				(try_end),
				(neg|troop_slot_ge, ":active_npc", "slot_troop_controversy", 75),
				
				(gt, ":relation", ":score_to_beat"),
				(assign, ":favorite_lord_without_center", ":active_npc"),
				(assign, ":score_to_beat", ":relation"),
			(try_end),
			
			(gt, ":favorite_lord_without_center", -1),
			(assign, ":result", ":favorite_lord_without_center"),
			(assign, ":result_explainer", "str_political_explanation_lord_lacks_center"),
			
		(else_try),	#taken by troop
			(is_between, ":faction_issue", walled_centers_begin, walled_centers_end),
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_selfrighteous),
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_cunning),
			
			(party_get_slot, ":last_taken_by_troop", ":faction_issue", "slot_center_last_taken_by_troop"),
			(try_begin),
				(try_begin),
					(neq, ":troop_faction", "$players_kingdom"),
					(assign, ":last_taken_by_troop", -1),
				(else_try),
					(eq, "$player_has_homage", 0),
					(assign, ":last_taken_by_troop", -1),
				(else_try),
					(eq, ":faction_issue", "$g_castle_requested_by_player"),
					(assign, ":last_taken_by_troop", "trp_player"),
				(else_try),
					(eq, ":faction_issue", "$g_castle_requested_for_troop"),
					(assign, ":last_taken_by_troop", "trp_player"),
				(else_try), #ie, the fellow who took it is no longer in the faction
					(gt, ":last_taken_by_troop", -1),
					(store_faction_of_troop, ":last_take_by_troop_faction", ":last_taken_by_troop"),
					(neq, ":last_take_by_troop_faction", ":troop_faction"),
					(assign, ":last_taken_by_troop", -1),
				(try_end),
			(try_end),	
			(gt, ":last_taken_by_troop", -1),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(gt, ":last_taken_by_troop", -1),
				(str_store_troop_name, s3, ":last_taken_by_troop"),
				(display_message, "@{!}Castle taken by {s3}"),
			(try_end),

			
			(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":last_taken_by_troop"),
			(ge, reg0, 0),
			
			(neg|troop_slot_ge, ":last_taken_by_troop", "slot_troop_controversy", 25),
			
			(troop_get_slot, ":renown", ":last_taken_by_troop", "slot_troop_renown"),
			(troop_get_slot, ":center_points", ":last_taken_by_troop", "slot_troop_temp_slot"),
			(val_max, ":center_points", 1),
			(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),
			(val_mul, ":renown_divided_by_center_points", 6), #was five
			(val_div, ":renown_divided_by_center_points", 4),
			
			(ge, ":renown_divided_by_center_points", ":average_renown_per_center_point"),
			
			
			(assign, ":result", ":last_taken_by_troop"),
			(assign, ":result_explainer", "str_political_explanation_lord_took_center"),
			
			
		#Check self, immediate family
		#This is done instead of a single weighted score to create cliques -- groups of NPCs who support one another
		(else_try),
			(assign, ":most_deserving_close_friend", -1),
			(assign, ":score_to_beat", ":average_renown_per_center_point"),
			(val_div, ":score_to_beat", 3),
			(val_mul, ":score_to_beat", 2),
			
			(try_begin),
				(eq, "$cheat_mode", 1),
				(assign, reg3, ":score_to_beat"),
				(display_message, "@{!}Two-thirds average_renown = {reg3}"),
			(try_end),
			
			(try_begin),
				(eq, "$players_kingdom", ":troop_faction"),
				(eq, "$player_has_homage", 1),
				(eq, ":player_declines_honor", 0),	
				
				(call_script, "script_troop_get_relation_with_troop", "trp_player", ":troop_no"),
				(assign, ":relation", reg0),
				(ge, ":relation", 20),
				(neg|troop_slot_ge, "trp_player", "slot_troop_controversy", 50),

				(troop_get_slot, ":renown", "trp_player", "slot_troop_renown"),
				(troop_get_slot, ":center_points", "trp_player", "slot_troop_temp_slot"),
				(val_max, ":center_points", 1),
				(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),
				
				
				(assign, ":most_deserving_close_friend", "trp_player"),
				(assign, ":score_to_beat", ":renown_divided_by_center_points"),
			(try_end),
			(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":troop_faction"),			
				(troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_kingdom_hero),
				
				(call_script, "script_troop_get_relation_with_troop", ":active_npc", ":troop_no"),
				(assign, ":relation", reg0),
				
				(this_or_next|eq, ":active_npc", ":troop_no"),
					(ge, ":relation", 20),
				(neg|troop_slot_ge, ":active_npc", "slot_troop_controversy", 50),
				
				(troop_get_slot, ":renown", ":active_npc", "slot_troop_renown"),
				(troop_get_slot, ":center_points", ":active_npc", "slot_troop_temp_slot"),
				(val_max, ":center_points", 1),
				(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),
				
				
				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_troop_name, s10, ":active_npc"),
					(assign, reg3, ":renown_divided_by_center_points"),
					(display_message, "@{!}DEBUG -- Colleague test: score for {s10} = {reg3}"),
				(try_end),
				
				
				(gt, ":renown_divided_by_center_points", ":score_to_beat"),
		
				(assign, ":most_deserving_close_friend", ":active_npc"),
				(assign, ":score_to_beat", ":renown_divided_by_center_points"),
			(try_end),

			(gt, ":most_deserving_close_friend", -1),
			
			
			(assign, ":result", ":most_deserving_close_friend"),
			(assign, ":result_explainer", "str_political_explanation_most_deserving_friend"),
			

			
		(else_try),
		#Most deserving in entire faction, minus those with no relation
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_selfrighteous),
			(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_quarrelsome),
		
			(assign, ":most_deserving_in_faction", -1),
			(assign, ":score_to_beat", 0),
			
			(try_begin),
				(eq, "$players_kingdom", ":troop_faction"),
				(eq, "$player_has_homage", 1),
				(eq, ":player_declines_honor", 0),	
				
				(call_script, "script_troop_get_relation_with_troop", "trp_player", ":troop_no"),
				(assign, ":relation", reg0),
				(ge, ":relation", 0),
				(troop_get_slot, ":renown", "trp_player", "slot_troop_renown"),
				(troop_get_slot, ":center_points", "trp_player", "slot_troop_temp_slot"),
				(neg|troop_slot_ge, "trp_player", "slot_troop_controversy", 25),

				(val_max, ":center_points", 1),
				(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),
				
				(assign, ":most_deserving_in_faction", "trp_player"),
				(assign, ":score_to_beat", ":renown_divided_by_center_points"),
			(try_end),
			(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":troop_faction"),			
				(troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_kingdom_hero),

				(call_script, "script_troop_get_relation_with_troop", ":active_npc", ":troop_no"),
				(assign, ":relation", reg0),
				(this_or_next|eq, ":active_npc", ":troop_no"),
					(ge, ":relation", 0),
				(neg|troop_slot_ge, ":active_npc", "slot_troop_controversy", 25),

				(troop_get_slot, ":renown", ":active_npc", "slot_troop_renown"),
				(troop_get_slot, ":center_points", ":active_npc", "slot_troop_temp_slot"),
				(val_max, ":center_points", 1),
				
				(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),
				(gt, ":renown_divided_by_center_points", ":score_to_beat"),

				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_string, s10, ":active_npc"),
					(assign, reg3, ":renown_divided_by_center_points"),
					(display_message, "@{!}DEBUG -- Open test: score for {s10} = {reg3}"),
				(try_end),

				
				(assign, ":most_deserving_in_faction", ":active_npc"),
				(assign, ":score_to_beat", ":renown_divided_by_center_points"),
			(try_end),

			
			(gt, ":most_deserving_in_faction", -1),
			(assign, ":result", ":most_deserving_in_faction"),
			(assign, ":result_explainer", "str_political_explanation_most_deserving_in_faction"),
		
		(else_try),
			(assign, ":result", ":troop_no"),
			(assign, ":result_explainer", "str_political_explanation_self"),
		(try_end),

		
	(else_try),
		(eq, ":faction_issue", 1),
		
		(assign, ":relationship_threshhold", 15),
		(try_begin),
			(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
			(assign, ":relationship_threshhold", 5),
		(else_try),
			(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
			(assign, ":relationship_threshhold", 25),
		(try_end),
		
		#For marshals, score marshals according to renown divided by controversy - first for friends and family, then for everyone
		(assign, ":marshal_candidate", -1),
		(assign, ":score_to_beat", 0),
		(try_begin),
			(eq, "$players_kingdom", ":troop_faction"),
			(eq, "$player_has_homage", 1),
			(eq, "$g_player_is_captive", 0),
			(eq, ":player_declines_honor", 0),	
			
			
			(call_script, "script_troop_get_relation_with_troop", "trp_player", ":troop_no"),
			(ge, reg0, ":relationship_threshhold"),
			(party_is_active, "p_main_party"),	#MOTO check for test below
			(assign, ":marshal_candidate", "trp_player"),
			(troop_get_slot, ":renown", "trp_player", "slot_troop_renown"),
			#MOTO chief avoid electing small parties for marshal
			(store_party_size_wo_prisoners, ":party_size", "p_main_party"),
			(val_add, ":renown", ":party_size"),
			(val_add, ":renown", ":party_size"),
			#MOTO end avoid electing small parties for marshal
			(troop_get_slot, ":controversy_divisor", "trp_player", "slot_troop_controversy"),
			(val_add, ":controversy_divisor", 50),
			(store_div, ":score_to_beat", ":renown", ":controversy_divisor"),
		(try_end),
		
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":troop_faction"),		
			(troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_kingdom_hero),
			(troop_slot_eq, ":active_npc", "slot_troop_prisoner_of_party", -1),
			
			(neg|faction_slot_eq, ":troop_faction", "slot_faction_leader", ":active_npc"),
			
			(call_script, "script_troop_get_relation_with_troop", ":active_npc", ":troop_no"),
			(assign, ":relation", reg0),
			(this_or_next|eq, ":active_npc", ":troop_no"),
				(ge, ":relation", ":relationship_threshhold"),
				
			(troop_get_slot, ":renown", ":active_npc", "slot_troop_renown"),
			#MOTO chief avoid electing small parties for marshal
			(troop_get_slot, ":active_party", ":active_npc", "slot_troop_leaded_party"),
			(party_is_active, ":active_party"),
			(store_party_size_wo_prisoners, ":party_size", ":active_party"),
			(val_add, ":renown", ":party_size"),
			(val_add, ":renown", ":party_size"),
			#MOTO end avoid electing small parties for marshal
			(troop_get_slot, ":controversy_divisor", ":active_npc", "slot_troop_controversy"),
			(val_add, ":controversy_divisor", 50),
			(store_div, ":score", ":renown", ":controversy_divisor"),
		
			(gt, ":score", ":score_to_beat"),
			
			(assign, ":marshal_candidate", ":active_npc"),
			(assign, ":score_to_beat", ":score"),
		
		(try_end),
		
		(assign, ":result", ":marshal_candidate"),
		(assign, ":result_explainer", "str_political_explanation_marshal"),
	(try_end),
	
	(try_begin),
		(eq, "$cheat_mode", 1),
		(gt, ":result", -1),
		(str_store_troop_name, s8, ":troop_no"),
		(str_store_troop_name, s9, ":result"),
		(str_store_string, s10, ":result_explainer"),
		(display_message, "@{!}DEBUG -- {s8} backs {s9}:{s10}"),
	(try_end),
	
	(assign, reg0, ":result"),
	(assign, reg1, ":result_explainer"),
	
	]),

	
	("npc_decision_checklist_evaluate_faction_strategy",
	[
	#Decides whether the strategy is good or bad -- to be added
	]),

  # script_replace_scene_items_with_spawn_items_before_ms
  # Input: none
  # Output: none
  ("replace_scene_items_with_spawn_items_before_ms",
    [
      (try_for_range, ":item_no", all_items_begin, all_items_end),
        (scene_item_get_num_instances, ":num_instances", ":item_no"),
        (item_set_slot, ":item_no", "slot_item_num_positions", 0),
        (assign, ":num_positions", 0),
        (try_for_range, ":cur_instance", 0, ":num_instances"),
          (scene_item_get_instance, ":scene_item", ":item_no", ":cur_instance"),
          (prop_instance_get_position, "$g_position_to_use_for_replacing_scene_items", ":scene_item"),
          (store_add, ":cur_slot", "slot_item_positions_begin", ":num_positions"),
          (item_set_slot, ":item_no", ":cur_slot", "$g_position_to_use_for_replacing_scene_items"),
          (val_add, ":num_positions", 1),
          (val_add, "$g_position_to_use_for_replacing_scene_items", 1),
          (item_set_slot, ":item_no", "slot_item_num_positions", ":num_positions"),
        (try_end),
        (replace_scene_items_with_scene_props, ":item_no", "spr_empty"),
      (try_end),
     ]),

  # script_replace_scene_items_with_spawn_items_after_ms
  # Input: none
  # Output: none
  ("replace_scene_items_with_spawn_items_after_ms",
    [
      (try_for_range, ":item_no", all_items_begin, all_items_end),
        (item_get_slot,  ":num_positions", ":item_no", "slot_item_num_positions"),
        (try_for_range, ":cur_position", 0, ":num_positions"),
          (store_add, ":cur_slot", "slot_item_positions_begin", ":cur_position"),
          (item_get_slot, ":pos_no", ":item_no", ":cur_slot"),
          (set_spawn_position, ":pos_no"),
          (spawn_item, ":item_no", 0),
        (try_end),
      (try_end),
     ]),

  # script_cf_is_melee_weapon_for_tutorial
  # Input: arg1 = item_no
  # Output: none (can fail)
  ("cf_is_melee_weapon_for_tutorial",
    [
      (store_script_param, ":item_no", 1),
      (assign, ":result", 0),
      (try_begin),
        (this_or_next|eq, ":item_no", "itm_quarter_staff"),
        (eq, ":item_no", "itm_practice_sword"),
        (assign, ":result", 1),
      (try_end),
      (eq, ":result", 1),
     ]),

  # script_iterate_pointer_arrow
  # Input: none
  # Output: none
  ("iterate_pointer_arrow",
    [
      (store_mission_timer_a_msec, ":cur_time"),
      (try_begin),
        (assign, ":up_down", ":cur_time"),
        (assign, ":turn_around", ":cur_time"),
        (val_mod, ":up_down", 1080),
        (val_div, ":up_down", 3),
        (scene_prop_get_instance, ":prop_instance", "spr_pointer_arrow", 0),
        (prop_instance_get_position, pos0, ":prop_instance"),
        (position_set_z_to_ground_level, pos0),
        (position_move_z, pos0, "$g_pointer_arrow_height_adder", 1),
        (set_fixed_point_multiplier, 100),
        (val_mul, ":up_down", 100),
        (store_sin, ":up_down_sin", ":up_down"),
        (position_move_z, pos0, ":up_down_sin", 1),
        (position_move_z, pos0, 100, 1),
        (val_mod, ":turn_around", 2880),
        (val_div, ":turn_around", 8),
        (init_position, pos1),
        (position_rotate_z, pos1, ":turn_around"),
        (position_copy_rotation, pos0, pos1),
        (prop_instance_set_position, ":prop_instance", pos0),
      (try_end),
     ]),
  
   ("find_center_to_attack_alt", #moto chief cambia entero
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":attack_by_faction", 2),
      (store_script_param, ":all_vassals_included", 3),
      
      (assign, ":result", -1),
      (assign, ":score_to_beat", 0),
      
	  #MOTO of walled centers, consider only the closest
	  (try_for_range, ":troop_faction_no", kingdoms_begin, kingdoms_end),
		(faction_set_slot, ":troop_faction_no", "slot_faction_temp_slot", 0),
      (try_end),
	  
	  #find troop's kingdom's center
      (store_faction_of_troop, ":troop_faction_no", ":troop_no"),
      (assign, ":number_of_walled_centers", 0),
      (assign, ":avg_pos_x", 0),
      (assign, ":avg_pos_y", 0),
	  
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":walled_center_faction", ":center_no"),
        (eq, ":walled_center_faction", ":troop_faction_no"),
        
		(party_get_position, pos34, ":center_no"),
        (position_get_x, reg0, pos34),
        (val_add, ":avg_pos_x", reg0),
        (position_get_y, reg0, pos34),
        (val_add, ":avg_pos_y", reg0),
        (val_add, ":number_of_walled_centers", 1),
      (try_end),
	  
	  (try_begin),
        (gt, ":number_of_walled_centers", 0),
	    (val_div, ":avg_pos_x", ":number_of_walled_centers"),
	    (val_div, ":avg_pos_y", ":number_of_walled_centers"),
	    (init_position, pos34),	#position used only by battle AI.
		(position_set_x, pos34, ":avg_pos_x"),
		(position_set_y, pos34, ":avg_pos_y"),
	  (try_end),
	  
	  #store closest walled center of every faction
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":walled_center_faction", ":center_no"),
		(faction_get_slot, ":cur_closest_center", ":walled_center_faction", "slot_faction_temp_slot"),
		
		(try_begin),
		  (eq, ":cur_closest_center", 0),
		  (faction_set_slot, ":walled_center_faction", "slot_faction_temp_slot", ":center_no"),
		(else_try),
               (party_get_position, pos36, ":center_no"), #moto chief
                (get_distance_between_positions, ":test_distance", pos34, pos36),
                (party_get_position, pos36, ":cur_closest_center"),
                (get_distance_between_positions, ":cur_distance", pos34, pos36),
                  (lt, ":test_distance", ":cur_distance"),
		  (faction_set_slot, ":walled_center_faction", "slot_faction_temp_slot", ":center_no"),
		(try_end),
      (try_end),

	  #NOW evaluate targets
      # (try_for_range, ":center_no", centers_begin, centers_end),            
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),	#MOTO leave raiding to individual lords
        (store_faction_of_party, ":center_faction", ":center_no"),
		(neq, ":center_faction", ":troop_faction_no"),
		
        (this_or_next|party_slot_eq, ":center_no", "slot_center_ex_faction", ":troop_faction_no"),    #always consider      former belongings
              (this_or_next|party_slot_eq, ":center_no", "slot_center_original_faction", ":troop_faction_no"),
                (this_or_next|faction_slot_eq, ":center_faction", "slot_faction_temp_slot", ":center_no"),	#this center is the closest walled center OR
		(neg|is_between, ":center_no", walled_centers_begin, walled_centers_end),	#is a village
	  #MOTO end of walled centers, consider only the closest
        (call_script, "script_npc_decision_checklist_evaluate_enemy_center_for_attack",	":troop_no", ":center_no", ":attack_by_faction", ":all_vassals_included"),
        (assign, ":score", reg0),
                
        (gt, ":score", ":score_to_beat"),
        
        (assign, ":result", ":center_no"),
        (assign, ":score_to_beat", ":score"),
      (try_end),
      
      (assign, reg0, ":result"),
      (assign, reg1, ":score_to_beat"),      
	]),
	
  ("npc_decision_checklist_evaluate_enemy_center_for_attack",
    [
      #NOTES -- LAST OFFENSIVE TIME SCORE IS NOT USED
      
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":potential_target", 2),
      (store_script_param, ":attack_by_faction", 3),
      (store_script_param, ":all_vassals_included", 4),
      
      (assign, ":result", -1),
      (assign, ":explainer_string", -1),
      #(assign, ":reason_is_obvious", 0),
      (assign, ":power_ratio", 0),
      #(assign, ":hours_since_last_recce", -1),
      
      #(assign, ":value_of_target", 0),
      #(assign, ":difficulty_of_capture", 0),
      (store_faction_of_troop, ":faction_no", ":troop_no"),
      
      (try_begin),
        (eq, ":attack_by_faction", 1),
        (faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
        (ge, ":faction_marshal", 0), #STEVE ADDITION TO AVOID MESSAGE SPAM
        (troop_get_slot, ":party_no", ":faction_marshal", "slot_troop_leaded_party"),
      (else_try),
        (troop_get_slot, ":party_no", ":troop_no", "slot_troop_leaded_party"),
      (try_end),
      
      (assign, "$g_use_current_ai_object_as_s8", 0),
            
      #THE FIRST BATCH OF DISQUALIFYING CONDITIONS DO NOT REQUIRE THE ATTACKING PARTY TO HAVE CURRENT INTELLIGENCE ON THE TARGET
      (try_begin),
        (neg|party_is_active, ":party_no"),
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_party_not_active"),
        #(assign, ":reason_is_obvious", 1),
      (else_try), 
        (store_faction_of_party, ":potential_target_faction", ":potential_target"),
        (store_relation, ":relation", ":potential_target_faction", ":faction_no"),
        (ge, ":relation", 0),
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_is_friendly"),
        #(assign, ":reason_is_obvious", 1),
      (else_try),
        (is_between, ":potential_target", walled_centers_begin, walled_centers_end),
        (assign, ":faction_of_besieger_party", -1),
        (try_begin),
          (neg|party_slot_eq, ":potential_target", "slot_center_is_besieged_by", -1), 
          (party_get_slot, ":besieger_party", ":potential_target", "slot_center_is_besieged_by"),
          (party_is_active, ":besieger_party"),
          (store_faction_of_party, ":faction_of_besieger_party", ":besieger_party"),
        (try_end),
        
        (neq, ":faction_of_besieger_party", -1),
        (neq, ":faction_of_besieger_party", ":faction_no"),	
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_is_already_besieged"),
        #(assign, ":reason_is_obvious", 1),
      (else_try),
        (is_between, ":potential_target", villages_begin, villages_end),
        (assign, ":village_is_looted_or_raided_already", 0),
        (try_begin),
          (party_slot_eq, ":potential_target", "slot_village_state", svs_being_raided),
          (party_get_slot, ":raider_party", ":potential_target", "slot_village_raided_by"),
		  (party_is_active, ":raider_party"),
          (store_faction_of_party, ":raider_faction", ":raider_party"),
          (neq, ":raider_faction", ":faction_no"),
          (assign, ":raiding_by_one_other_faction", 1),
        (else_try),
          (assign, ":raiding_by_one_other_faction", 0),
        (try_end),
        
        (try_begin),
          (this_or_next|party_slot_eq, ":potential_target", "slot_village_state", svs_looted),
          (eq, ":raiding_by_one_other_faction", 1),
          (assign, ":village_is_looted_or_raided_already", 1),
        (try_end),
        
        (eq, ":village_is_looted_or_raided_already", 1),
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_is_looted_or_raided_already"),
        #(assign, ":reason_is_obvious", 1),
      (else_try),
        (this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_goodnatured),
        
        (is_between, ":potential_target", villages_begin, villages_end),	
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_marshal_does_not_want_to_attack_innocents"),
      (else_try),
        (assign, ":distance_from_our_closest_walled_center", 1000),
        (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
           (store_faction_of_party, ":cur_center_faction", ":cur_center"),
           (eq, ":cur_center_faction", ":faction_no"),
           (store_distance_to_party_from_party, ":distance_from_cur_center", ":cur_center", ":potential_target"),
           (lt, ":distance_from_cur_center", ":distance_from_our_closest_walled_center"),
           (assign, ":distance_from_our_closest_walled_center", ":distance_from_cur_center"),
        (try_end),
                                                
        (gt, ":distance_from_our_closest_walled_center", 75),
		##diplomacy start+ Add support for companion / lady personality types: cautious chief
		##OLD:
        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_goodnatured),
        #(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_cunning),
		##NEW:
		(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		(gt, reg0, 0),
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_far_away_our_cautious_marshal_does_not_wish_to_reconnoiter"),				
      #RECONNOITERING BEGINS HERE - VALUE WILL BE TEN OR LESS
      (else_try),
        (gt, ":distance_from_our_closest_walled_center", 90),
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_far_away_even_for_our_aggressive_marshal_to_reconnoiter"),
        #(assign, ":reason_is_obvious", 1),	
      (else_try),
        (is_between, ":potential_target", walled_centers_begin, walled_centers_end),
		##diplomacy start+ Add support for companion / lady personality types: aggessive chief
		##OLD:
        #(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_martial),
        #(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_quarrelsome),
        #(neg|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_selfrighteous),
		##NEW:
		(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		(lt, reg0, 0),
        
        (assign, ":close_center_found", 0),
        (try_for_range, ":friendly_walled_center", walled_centers_begin, walled_centers_end),
          (eq, ":close_center_found", 0),
          (store_faction_of_party, ":friendly_walled_center_faction", ":friendly_walled_center"),
          (eq, ":friendly_walled_center_faction", ":faction_no"),
          (store_distance_to_party_from_party, ":distance_from_walled_center", ":potential_target", ":friendly_walled_center"),
          (lt, ":distance_from_walled_center", 60),
          (assign, ":close_center_found", 1),
        (try_end),
        (eq, ":close_center_found", 0),
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_is_indefensible"),	
      #(else_try),
        #For now it is removed as Armagan's decision, we can add this option in later patchs. I and Armagan accept it has good potential. But this system needs also
        #scouting quests and scouting AI added together. If we only add this then we limit AI very much, it can attack only very few of centers, this damages 
        #variability of game and surprise attacks of AI. Player can predict where AI will attack and he can full garnisons of only this center. 
        #We can add asking travellers about how good defended center X by paying 100 denars for example to equalize situations of AI and human player.
        #But these needs much work and detailed AI tests so Armagan decided to skip this for now.
        
        #(store_sub, ":faction_recce_slot", ":faction_no", kingdoms_begin),
        #(val_add, ":faction_recce_slot", "slot_center_last_reconnoitered_by_faction_time"),
        #(party_get_slot, ":last_recce_time", ":potential_target", ":faction_recce_slot"),
        #(store_current_hours, ":hours_since_last_recce"),
        #(val_sub, ":hours_since_last_recce", ":last_recce_time"),
        
        #(this_or_next|eq, ":last_recce_time", 0),
        #(gt, ":hours_since_last_recce", 96), #Information is presumed to be accurate for four days
        
        #(store_sub, ":150_minus_distance_div_by_10", 150, ":distance_from_party"),
        #(val_div, ":150_minus_distance_div_by_10", 10),
        
        #(assign, ":result", ":150_minus_distance_div_by_10"),
        #(assign, ":explainer_string", "str_center_has_not_been_scouted"),
      #DECISIONS BASED ON ENEMY STRENGTH BEGIN HERE
      (else_try),
        (party_get_slot, ":party_strength", ":party_no", "slot_party_cached_strength"),
        (party_get_slot, ":follower_strength", ":party_no", "slot_party_follower_strength"),
        (party_get_slot, ":strength_of_nearby_friend", ":party_no", "slot_party_nearby_friend_strength"),                
        
        (store_add, ":total_strength", ":party_strength", ":follower_strength"),
        (val_add, ":total_strength", ":strength_of_nearby_friend"),
        
        #(party_get_slot, ":potential_target_nearby_enemy_exact_strength", ":potential_target", "slot_party_nearby_friend_strength"),
        #(assign, ":potential_target_nearby_enemy_strength", ":potential_target_nearby_enemy_exact_strength"),                
        (try_begin),
          (is_between, ":potential_target", villages_begin, villages_end),
          (assign, ":enemy_strength", 10),
        (else_try),
          (party_get_slot, ":enemy_strength", ":potential_target", "slot_party_cached_strength"),
          (party_get_slot, ":enemy_strength_nearby", ":potential_target", "slot_party_nearby_friend_strength"),
          (val_add, ":enemy_strength", ":enemy_strength_nearby"),
        (try_end),
        (val_max, ":enemy_strength", 1),                

		##diplomacy start+  Add support for lady/companion personalities: aggressive
		##OLD:
        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_martial),
        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_quarrelsome),
        #(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_selfrighteous),
		##NEW:
		(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		(lt, reg0, 0),
		###xxx yyy zzz TODO: The logic here seems backwards!
		###Later look at this and verify that it's what we want.
		##diplomacy end+ chief
        
        (store_mul, ":power_ratio", ":total_strength", 100),
        (val_div, ":power_ratio", ":enemy_strength"),
        (lt, ":power_ratio", 150), 
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_protected_by_enemy_army_aggressive"),
      (else_try),
        (ge, ":enemy_strength", ":total_strength"), #if enemy is powerful
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_protected_by_enemy_army_cautious"),
      (else_try),               
        (store_mul, ":power_ratio", ":total_strength", 100),
        (val_div, ":power_ratio", ":enemy_strength"),
        (lt, ":power_ratio", 185), 
        
		##diplomacy start+ Add support for companion/lady personalities: cautious
		##OLD:
        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_goodnatured),
        #(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_cunning),
		##NEW:
		(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		(gt, reg0, 0),
		##diplomacy end+ chief
        
        #equations here
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_cautious_marshal_believes_center_too_difficult_to_capture"),
      (else_try),
        (lt, ":power_ratio", 140), #it was 140
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_even_aggressive_marshal_believes_center_too_difficult_to_capture"),
      #To Steve - I moved below two if statement here from upper places, to enable in answering different different answers even 
      #if we are close to an unlooted enemy village. For example now it can say "center X" is too far too while our army is 
      #looting a village because of its closeness.
      (else_try),
        #if the party has already started the siege
        (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_raiding_village),
        (faction_get_slot, ":current_object", ":faction_no", "slot_faction_ai_object"),
        (is_between, ":current_object", villages_begin, villages_end),
        (neq, ":potential_target", ":current_object"),
        (party_slot_eq, ":current_object", "slot_village_state", svs_under_siege),
        
        (store_current_hours, ":hours_since_siege_began"),
        (party_get_slot, ":hour_that_siege_began", ":current_object", "slot_center_siege_begin_hours"),
        (val_sub, ":hours_since_siege_began", ":hour_that_siege_began"),
        (gt, ":hours_since_siege_began", 4),
        
        (call_script, "script_npc_decision_checklist_evaluate_enemy_center_for_attack", ":troop_no", ":current_object", ":attack_by_faction", 0),
        (gt, reg0, -1),
        
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_we_have_already_committed_too_much_time_to_our_present_siege_to_move_elsewhere"),
      (else_try),
        #If the party is close to an unlooted village
        (faction_slot_eq, ":faction_no", "slot_faction_ai_state", sfai_raiding_village),
        (faction_get_slot, ":current_object", ":faction_no", "slot_faction_ai_object"),
        (neq, ":potential_target", ":current_object"),
        (is_between, ":current_object", villages_begin, villages_end),
        (store_distance_to_party_from_party, ":distance_to_cur_object", ":party_no", ":current_object"),
        (lt, ":distance_to_cur_object", 10),
        
        (call_script, "script_npc_decision_checklist_evaluate_enemy_center_for_attack", ":troop_no", ":current_object", ":attack_by_faction", 0),
        (gt, reg0, -1),
        
        (assign, "$g_use_current_ai_object_as_s8", 1),
                
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_we_are_already_here_we_should_at_least_loot_the_village"),
      #DECISION TO ATTACK IS HERE
      #(else_try),
        #To Steve - I removed below lines, as here decided. We will use pre-function to evaluate assailability scores for centers rather than below lines to make AI 
        #selecting better targets. If you want to make some marshals to select not-best options I can add that option into script_calculate_center_assailability_score, 
        #for that we can need seed values for each center and for each lord, so we can add these seed values to create variability, clever marshals have seeds with less 
        #standard deviation and less values and less-clever marshals have bigger seeds. Then probability of some lords to disagree marshal increases because their seed 
        #values will be different from marshal's. If Steve wants it from me to implement I can add this.
      
        #(try_begin),
        #  (is_between, ":potential_target", villages_begin, villages_end),
        #  (party_get_slot, ":score", ":potential_target", "slot_town_prosperity"),
        #  (val_add, ":score", 50), #average 100
        #(else_try),
        #  (is_between, ":potential_target", castles_begin, castles_end),
        #  (assign, ":score", ":power_ratio"), #ie, at least 140
        #(else_try),	
        #  (party_get_slot, ":score", ":potential_target", "slot_town_prosperity"),
        #  (val_add, ":score", 75),
        #  (val_mul, ":score", ":power_ratio"),
        #  (val_div, ":score", 100), #ie, at least about 200
        #(try_end),
        # 
        #(val_sub, ":score", ":distance_from_party"),
        #(lt, ":score", -1),
      
        #(assign, ":result", -1),
        #(assign, ":explainer_string", "str_center_value_outweighed_by_difficulty_of_capture"),
      (else_try),
        (try_begin),
          (eq, "$cheat_mode", 1),
          (eq, ":faction_no", "fac_kingdom_3"),
          (store_faction_of_party, ":potential_target_faction", ":potential_target"),
          (store_relation, ":relation", ":potential_target_faction", ":faction_no"),
          (lt, ":relation", 0),
        (try_end),  

        (call_script, "script_calculate_center_assailability_score", ":troop_no", ":potential_target", ":all_vassals_included"),
        (assign, ":score", reg0),
        (assign, ":power_ratio", reg1),
        #(assign, ":distance_score", reg2),
      
        (assign, ":result", ":score"),
      
        (try_begin),
          (le, ":power_ratio", 100),
          (try_begin),
			##diplomacy start+ Add support for companion / lady personalities: cautious chief
			##OLD:
            #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
            #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
            #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_goodnatured),
            #(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_cunning),
			##NEW:
			(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
			(gt, reg0, 0),
			##diplomacy end+
            (assign, ":explainer_string", "str_center_cautious_marshal_believes_center_too_difficult_to_capture"),
          (else_try),
            (assign, ":explainer_string", "str_center_even_aggressive_marshal_believes_center_too_difficult_to_capture"),
          (try_end),
        (else_try),
          (le, ":power_ratio", 150),
        
          (try_begin),
			##diplomacy start+ Add support for companion / lady personalities: cautious chief
			##OLD
	        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
	        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
	        #(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_goodnatured),
	        #(troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_cunning),
			##NEW:
			(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
			(lt, reg0, 0),
			##diplomacy end+
	        (assign, ":explainer_string", "str_center_protected_by_enemy_army_cautious"),
	      (else_try),
	        (assign, ":explainer_string", "str_center_protected_by_enemy_army_aggressive"),
	      (try_end),
	    (else_try),
	      (try_begin),
	        (le, ":score", "$g_faction_object_score"),
	        (assign, ":explainer_string", "str_center_value_outweighed_by_difficulty_of_capture"),
	      (else_try),
	        #To Steve, does not this sentence needs to explain why we are not attacking that city? 
	        #This sentence says it justifies, so why we are not attacking?
	        (assign, ":explainer_string", "str_center_value_justifies_the_difficulty_of_capture"),
	      (try_end),
	    (try_end),
	  (try_end),
	  	  
	  (assign, reg0, ":result"),
	  (assign, reg1, ":explainer_string"),
	  (assign, reg2, ":power_ratio"),	  	  
     ]),
              
 	(
	"npc_decision_checklist_faction_ai_alt", #This is called from within decide_faction_ai, or from 
	[
		(store_script_param, ":troop_no", 1),
		
		(store_faction_of_troop, ":faction_no", ":troop_no"),
		
		(str_store_troop_name, s4, ":troop_no"),
		(str_store_faction_name, s33, ":faction_no"),
		(try_begin),
			(eq, "$cheat_mode", 1),
		    (display_debug_message, "@{!}DEBUG -- {s4} produces a faction strategy for {s33}"),
		(try_end),
		  		  
		#INFORMATIONS COLLECTING STEP 0: Here we obtain general information about current faction like how much parties that faction has, which lord is the marshall, current ai state and current ai target object
		#(faction_get_slot, ":faction_strength", ":faction_no", "slot_faction_number_of_parties"),
		(faction_get_slot, ":faction_marshal", ":faction_no", "slot_faction_marshall"),
		(faction_get_slot, ":current_ai_state", ":faction_no", "slot_faction_ai_state"),
		(faction_get_slot, ":current_ai_object", ":faction_no", "slot_faction_ai_object"),
		
		(assign, ":marshal_party", -1),
		(assign, ":marshal_party_strength", 0),
		  
		(try_begin),
		  (gt, ":faction_marshal", 0),
		  (troop_get_slot, ":marshal_party", ":faction_marshal", "slot_troop_leaded_party"),
		  (party_is_active, ":marshal_party"),
		  (party_get_slot, ":marshal_party_itself_strength", ":marshal_party", "slot_party_cached_strength"),
		  (party_get_slot, ":marshal_party_follower_strength", ":marshal_party", "slot_party_follower_strength"),
		  (store_add, ":marshal_party_strength", ":marshal_party_itself_strength", ":marshal_party_follower_strength"),
	    (try_end),
					
	    #INFORMATIONS COLLECTING STEP 1: Here we are learning how much hours past from last offensive situation/feast concluded/current state started
	    (store_current_hours, ":hours_since_last_offensive"),
	    (faction_get_slot, ":last_offensive_time", ":faction_no", "slot_faction_last_offensive_concluded"),
	    (val_sub, ":hours_since_last_offensive", ":last_offensive_time"),
	      
	    (store_current_hours, ":hours_since_last_feast_start"),
	    (faction_get_slot, ":last_feast_time", ":faction_no", "slot_faction_last_feast_start_time"),
	    (val_sub, ":hours_since_last_feast_start", ":last_feast_time"),
                
	    (store_current_hours, ":hours_at_current_state"),
	    (faction_get_slot, ":current_state_started", ":faction_no", "slot_faction_ai_current_state_started"),
	    (val_sub, ":hours_at_current_state", ":current_state_started"),
	      
	    (store_current_hours, ":hours_since_last_faction_rest"),
	    (faction_get_slot, ":last_rest_time", ":faction_no", "slot_faction_ai_last_rest_time"),
	    (val_sub, ":hours_since_last_faction_rest", ":last_rest_time"),
			  
	    (try_begin), #calculating ":last_offensive_time_score", this will be used in #11 and #12
	        (ge, ":hours_since_last_offensive", 1080), #more than 45 days (100p)
	        (assign, ":last_offensive_time_score", 100),
	    (else_try),
	        (ge, ":hours_since_last_offensive", 480), #more than 20 days (65p..99p)
	        (store_sub, ":last_offensive_time_score", ":hours_since_last_offensive", 480),
	        (val_div, ":last_offensive_time_score", 20), 
	        (val_add, ":last_offensive_time_score", 64),
	    (else_try),
	        (ge, ":hours_since_last_offensive", 240), #more than 10 days (41p..64p)
	        (store_sub, ":last_offensive_time_score", ":hours_since_last_offensive", 240),
	        (val_div, ":last_offensive_time_score", 10), 
	        (val_add, ":last_offensive_time_score", 40),
	    (else_try), #less than 10 days (0p..40p)
	        (store_div, ":last_offensive_time_score", ":hours_since_last_offensive", 6), #0..40
	    (try_end),
									
	    #INFORMATION COLLECTING STEP 3: Here we are finding the most threatened center
	    (call_script, "script_find_center_to_defend", ":troop_no"),
	    (assign, ":most_threatened_center", reg0),
	    (assign, ":threat_danger_level", reg1),
	    (assign, ":enemy_strength_near_most_threatened_center", reg2), #NOTE! This will be off by as much as 50%
		  		 	      		
	    #INFORMATION COLLECTING STEP 4: Here we are finding number of vassals who are already following the marshal, and the assigned vassal ratio of current faction.
	    (assign, ":vassals_already_assembled", 0),
	    (assign, ":total_vassals", 0),	
	    (try_for_range, ":lord", active_npcs_begin, active_npcs_end),
	        (store_faction_of_troop, ":lord_faction", ":lord"),
	        (eq, ":lord_faction", ":faction_no"),
	        (troop_get_slot, ":led_party", ":lord", "slot_troop_leaded_party"),
	        (party_is_active, ":led_party"),
	        (val_add, ":total_vassals", 1),
			
            (this_or_next|party_slot_eq, ":led_party", "slot_party_ai_state", spai_screening_army),	#MOTO don't forget screeners
	        (party_slot_eq, ":led_party", "slot_party_ai_state", spai_accompanying_army),
	        (party_slot_eq, ":led_party", "slot_party_ai_object", ":marshal_party"),
			
	        (party_is_active, ":marshal_party"),
	        (store_distance_to_party_from_party, ":distance_to_marshal", ":led_party", ":marshal_party"),
	        (lt, ":distance_to_marshal", 15),
	        (val_add, ":vassals_already_assembled", 1),
	    (try_end),
	    (assign, ":ratio_of_vassals_assembled", -1),
	    (try_begin),
	        (gt, ":total_vassals", 0),
	        (store_mul, ":ratio_of_vassals_assembled", ":vassals_already_assembled", 100),
	        (val_div, ":ratio_of_vassals_assembled", ":total_vassals"),
	    (try_end),
		
	    #50% of vassals means that the campaign hour limit is ten days
	    (store_mul, ":campaign_hour_limit", ":ratio_of_vassals_assembled", 3),
	    (val_add, ":campaign_hour_limit", 90), 
	    
	    #To Steve - I understand your concern about some marshals will gather army and some will not be able to find any valueable center to attack after gathering,
	    #and these marshals will be questioned by other marshals ext. This is ok but if we search for a target without adding all other vassals what if 
	    #AI cannot find any target for long time because of its low power ratio if enemy cities are equal defended? Do not forget if we do not count other vassals in 
	    #faction while making target search we can only add marshal army's power and vassals around him. And if there is any threat in our centers even it is smaller, 
	    #its threat_danger_level will be more than target_value_level if marshal new started gathering for ofensive. Because we only assume marshal and around vassals 
	    #will join attack. And in our scenarios currently there are less vassals are around him. So power ratio will be low and any small threat will be enought to stop 
	    #an offensive. Then when players finds out this they periodically will take under siege to enemy's any center and they will be saved from any kind of newly started 
	    #offensive they will be faced. So we have to calculate both attack levels and select highest one to compare with threat level. Please do not change this part.
		
		(try_begin),
		  (ge, ":faction_marshal", 0),
		  (ge, ":marshal_party", 0),
		  (party_is_active, ":marshal_party"),

		  (call_script, "script_party_count_fit_for_battle", ":marshal_party"),
		  (assign, ":number_of_fit_soldiers_in_marshal_party", reg0),
		  (ge, ":number_of_fit_soldiers_in_marshal_party", 40),
		  
		  (call_script, "script_find_center_to_attack_alt", ":troop_no", 1, 0),
		  (assign, ":center_to_attack_all_vassals_included", reg0),
		  (assign, ":target_value_level_all_vassals_included", reg1),
		  
		  (call_script, "script_find_center_to_attack_alt", ":troop_no", 1, 1),
		  (assign, ":center_to_attack_only_marshal_and_followers", reg0),
		  (assign, ":target_value_level_only_marshal_and_followers", reg1),
		(else_try),  
		  (assign, ":target_value_level_all_vassals_included", 0),
		  (assign, ":target_value_level_only_marshal_and_followers", 0),
		  (assign, ":center_to_attack_all_vassals_included", -1),
		  (assign, ":center_to_attack_only_marshal_and_followers", -1),
		(try_end),
		
		(try_begin),
		  (ge, ":target_value_level_all_vassals_included", ":center_to_attack_only_marshal_and_followers"),
		  (assign, ":center_to_attack", ":center_to_attack_all_vassals_included"),
		  (assign, ":target_value_level", ":target_value_level_all_vassals_included"),
		(else_try),  
		  (assign, ":center_to_attack", ":center_to_attack_only_marshal_and_followers"),
		  (assign, ":target_value_level", ":target_value_level_only_marshal_and_followers"),
		(try_end),
		  		  
		# (try_begin),	MOTO chief not sure this is needed
		  # (eq, ":current_ai_state", sfai_attacking_center),
		  # (val_mul, ":target_value_level", 3),
		  # (val_div, ":target_value_level", 2),
		# (try_end),

		(try_begin),
		  (eq, "$cheat_mode", 1),
		  (try_begin),
		    (is_between, ":center_to_attack", centers_begin, centers_end),
		    (str_store_party_name, s4, ":center_to_attack"),
		    (display_message, "@{!}Best offensive target {s4} has value level of {reg1}"),
		  # (else_try),
		  #   (display_message, "@{!}No center found to attack"),
		  (try_end),	
		
		  (try_begin),
		    (is_between, ":most_threatened_center", centers_begin, centers_end),
		    (str_store_party_name, s4, ":most_threatened_center"),
		    (assign, reg1, ":threat_danger_level"),
		    (display_message, "@{!}Best threat of {s4} has value level of {reg1}"),
		  #(else_try),
		   # (display_message, "@{!}No center found to defend"),
		  (try_end),  
		(try_end),
		
		(try_begin),
		  (eq, "$cheat_mode", 1),
		  
		  (try_begin),
  		    (is_between, ":most_threatened_center", centers_begin, centers_end),
 		    (str_store_party_name, s4, ":most_threatened_center"),
		    (assign, reg1, ":threat_danger_level"),
		    (display_message, "@Best threat of {s4} has value level of {reg1}"),
		  #(else_try),
		  #  (display_message, "@No center found to defend"),
		  (try_end),  
		(try_end),  
				
	    (assign, "$g_target_after_gathering", -1),
	    
	    (store_current_hours, ":hours"),	      
	    (try_begin),
	      (ge, ":target_value_level", ":threat_danger_level"),
	      (faction_set_slot, ":faction_no", "slot_faction_last_safe_hours", ":hours"),
	    (try_end),  
	    (faction_get_slot, ":last_safe_hours", ":faction_no", "slot_faction_last_safe_hours"),
	    (try_begin),
	      (eq, ":last_safe_hours", 0),
	      (faction_set_slot, ":faction_no", "slot_faction_last_safe_hours", ":hours"),
	    (try_end),
	    (faction_get_slot, ":last_safe_hours", ":faction_no", "slot_faction_last_safe_hours"),
	    (store_sub, ":hours_since_days_defensive_started", ":hours", ":last_safe_hours"),
	    (str_store_faction_name, s7, ":faction_no"),

		(assign, ":at_peace_with_everyone", 1),
		(try_for_range, ":faction_at_war", kingdoms_begin, kingdoms_end),
			(store_relation, ":relation", ":faction_no", ":faction_at_war"),
			(lt, ":relation", 0),
			(assign, ":at_peace_with_everyone", 0),
		(try_end),

	    
	    #INFORMATIONS ARE COLLECTED, NOW CHECK ALL POSSIBLE ACTIONS AND DECIDE WHAT TO DO	NEXT
		#Player marshal
		(try_begin), # a special case to end long-running feasts
			(eq, ":troop_no", "trp_player"),
			
			(eq, ":current_ai_state", sfai_feast),
			(ge, ":hours_at_current_state", 72),
		
			(assign, ":action", sfai_default),
			(assign, ":object", -1),
			
			#Normally you are not supposed to set permanent values in this state, but this is a special case to end player-called feasts
			(assign, "$player_marshal_ai_state", sfai_default),
			(assign, "$player_marshal_ai_object", -1),

		(else_try), #another special state, to make player-called feasts last for a while when the player is the leader of the faction, but not the marshal
			(eq, "$players_kingdom", "fac_player_supporters_faction"),
			(faction_slot_eq, "$players_kingdom", "slot_faction_leader", "trp_player"),
			(neq, ":troop_no", "trp_player"),
			
			(eq, ":current_ai_state", sfai_feast),
			(le, ":hours_at_current_state", 48),
			
			(party_slot_eq, ":current_ai_object", "slot_town_lord", "trp_player"),
			(store_faction_of_party, ":current_ai_object_faction", ":current_ai_object"),
			(eq, ":current_ai_object_faction", "$players_kingdom"),
			
			(assign, ":action", sfai_feast),
			(assign, ":object", ":current_ai_object"),

			
		(else_try), #this is the main player marshal state

			(eq, ":troop_no", "trp_player"),
			
			(str_clear, s14),
			(assign, ":action", "$player_marshal_ai_state"),
			(assign, ":object", "$player_marshal_ai_object"),
			
	    #1-RESTING IF NEEDED 
	    #If not currently attacking a besieging a center and vassals did not rest for long time, let them rest.
	    #If we do not take this part to toppest level, tired vassals already did not accept any order, so that 
	    #faction cannot do anything already. So first let vassals rest if they need. Thats why it should be toppest.
		(else_try),
			(neq, ":current_ai_state", sfai_default),
			(neq, ":current_ai_state", sfai_feast),
			(party_is_active, ":marshal_party"),
		
			(party_slot_eq, ":marshal_party", "slot_party_ai_state", spai_retreating_to_center),
			
			(assign, ":action", sfai_default),
			(assign, ":object", -1),
			(str_store_string, s14, "str_the_enemy_temporarily_has_the_field"),
				
		(else_try), 
		    (neq, ":current_ai_state", sfai_feast),
		    
		    (assign, ":currently_besieging", 0),
		    (try_begin),
			    (eq, ":current_ai_state", sfai_attacking_center),
			    (is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
			    (party_get_slot, ":besieger_party", ":current_ai_object", "slot_center_is_besieged_by"),
			    (party_is_active, ":besieger_party"),
			    (store_faction_of_party, ":besieger_faction", ":besieger_party"),
			    (eq, ":besieger_faction", ":faction_no"),
			    (assign, ":currently_besieging", 1),
		    (try_end),
		    
		    (assign, ":currently_defending_center", 0),
	        (try_begin),
		        (eq, ":current_ai_state", sfai_attacking_enemies_around_center),
		        (gt, ":marshal_party", 0),
		        (party_is_active, ":marshal_party"),

				(assign, ":besieged_center", -1),          
				(try_begin),
					(party_slot_eq, ":marshal_party", "slot_party_ai_state", spai_holding_center), #if commander is holding a center
					(party_get_slot, ":marshal_object", ":marshal_party", "slot_party_ai_object"), #get commander's ai object (center they are holding)
                    (ge, ":marshal_object", 0), #if commander has an object MOTO chief needed
                                        (party_get_battle_opponent, ":besieger_enemy", ":marshal_object"), #get this object's battle opponent
					(ge, ":besieger_enemy", 0),
					(assign, ":besieged_center", ":marshal_object"),
				(else_try),
					(party_slot_eq, ":marshal_party", "slot_party_ai_state", spai_engaging_army), #if commander is engaging an army
					(party_get_slot, ":marshal_object", ":marshal_party", "slot_party_ai_object"), #get commander's ai object (army which they engaded)
					# (ge, ":marshal_object", 0), #if commander has an object MOTO chief not needed (see next line)
					(neg|is_between, ":marshal_object", centers_begin, centers_end), #if this object is not a center, so it is a party
					(party_is_active, ":marshal_object"),
					(party_get_battle_opponent, ":besieged_center", ":marshal_object"), #get this object's battle opponent
				(try_end),
	          
				(eq, ":besieged_center", ":current_ai_object"),
				(assign, ":currently_defending_center", 1),
	        (try_end),

		    (eq, ":currently_besieging", 0),	    
		    (eq, ":currently_defending_center", 0),
		    (ge, ":hours_since_last_faction_rest", 1240),

			(assign, ":action", sfai_default),
			(assign, ":object", -1),
			(str_store_string, s14, "str_the_vassals_are_tired_we_let_them_rest_for_some_time"),	    
		
	  #2-DEFENSIVE ACTIONS : GATHERING ARMY FOR DEFENDING
          (else_try),
            (party_is_active, ":marshal_party"),
			(eq, ":at_peace_with_everyone", 0),
            
            (is_between, ":most_threatened_center", centers_begin, centers_end),
			(this_or_next|eq, ":current_ai_state", sfai_default),	#MOTO chief not going to attack anyway
			(this_or_next|eq, ":current_ai_state", sfai_feast),	#MOTO not going to attack anyway (THIS is the emergency to stop feast)
            (gt, ":threat_danger_level", ":target_value_level"),
                        
            (assign, ":continue_gathering", 0),
            (assign, ":start_gathering", 0),
            
            (try_begin),
              (is_between, ":most_threatened_center", villages_begin, villages_end),

              (assign, ":continue_gathering", 0),
            (else_try),
              (try_begin),
                (lt, ":hours_since_days_defensive_started", 3),
                (assign, ":multiplier", 150),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 6),
                (assign, ":multiplier", 140),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 9),
                (assign, ":multiplier", 132),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 12),
                (assign, ":multiplier", 124),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 15),
                (assign, ":multiplier", 118),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 18),
                (assign, ":multiplier", 114),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 21),
                (assign, ":multiplier", 110),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 24),
                (assign, ":multiplier", 106),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 27),
                (assign, ":multiplier", 102),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 31), 
                (assign, ":multiplier", 98),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 34),
                (assign, ":multiplier", 94),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 37),
                (assign, ":multiplier", 90),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 40),
                (assign, ":multiplier", 86),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 43),
                (assign, ":multiplier", 82),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 46),
                (assign, ":multiplier", 79),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 49),
                (assign, ":multiplier", 76),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 52),
                (assign, ":multiplier", 73),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 56),
                (assign, ":multiplier", 70),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 60),
                (assign, ":multiplier", 68),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 66),
                (assign, ":multiplier", 66),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 72),
                (assign, ":multiplier", 64),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 80),
                (assign, ":multiplier", 62),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 90),
                (assign, ":multiplier", 60),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 100),
                (assign, ":multiplier", 58),
              (else_try),
                (assign, ":multiplier", 56),
              (try_end),
		  
              (store_mul, ":enemy_strength_multiplied", ":enemy_strength_near_most_threatened_center", ":multiplier"),
              (val_div, ":enemy_strength_multiplied", 100),
		  
              (try_begin),		  
                (lt, ":marshal_party_strength", ":enemy_strength_multiplied"),
                (assign, ":continue_gathering", 1),
              (try_end),
            (else_try),  
              (eq, ":current_ai_state", sfai_attacking_enemies_around_center),
              (neq, ":most_threatened_center", ":current_ai_object"),
		  
              (assign, ":marshal_is_already_defending_a_center", 0),
              (try_begin),
                (gt, ":marshal_party", 0),
                (party_is_active, ":marshal_party"),
       
                (assign, ":besieged_center", -1),          
                (try_begin),
                  (party_slot_eq, ":marshal_party", "slot_party_ai_state", spai_holding_center), #if commander is holding a center
                  (party_get_slot, ":marshal_object", ":marshal_party", "slot_party_ai_object"), #get commander's ai object (center they are holding)
                  (party_get_battle_opponent, ":besieger_enemy", ":marshal_object"), #get this object's battle opponent
                  (ge, ":besieger_enemy", 0),
                  (assign, ":besieged_center", ":marshal_object"),
                (else_try),              
                  (party_slot_eq, ":marshal_party", "slot_party_ai_state", spai_engaging_army), #if commander is engaging an army
                  (party_get_slot, ":marshal_object", ":marshal_party", "slot_party_ai_object"), #get commander's ai object (army which they engaded)
                  (ge, ":marshal_object", 0), #if commander has an object
                  (neg|is_between, ":marshal_object", centers_begin, centers_end), #if this object is not a center, so it is a party
				  (party_is_active, ":marshal_object"),
                  (party_get_battle_opponent, ":besieged_center", ":marshal_object"), #get this object's battle opponent
                (try_end),

                (eq, ":besieged_center", ":current_ai_object"),
            
                (assign, ":marshal_is_already_defending_a_center", 1),
              (try_end),
                    
              (eq, ":marshal_is_already_defending_a_center", 0),
		  
              (store_mul, ":enemy_strength_multiplied", ":enemy_strength_near_most_threatened_center", 80),
              (val_div, ":enemy_strength_multiplied", 100),
              (lt, ":marshal_party_strength", ":enemy_strength_multiplied"),
              
              (this_or_next|is_between, ":most_threatened_center", walled_centers_begin, walled_centers_end),
              (neq, ":faction_no", "$players_kingdom"),              
              
              (assign, ":start_gathering", 1),
            (try_end),
		
            (this_or_next|eq, ":continue_gathering", 1),
            (eq, ":start_gathering", 1),
		
            (assign, ":action", sfai_gathering_army),
            (assign, ":object", -1),		
            (str_store_party_name, s21, ":most_threatened_center"),
            (str_store_string, s14, "str_we_should_prepare_to_defend_s21_but_we_should_gather_our_forces_until_we_are_strong_enough_to_engage_them"),
            
            (try_begin),
              (eq, ":faction_no", "$players_kingdom"),
              (assign, "$g_gathering_reason", ":most_threatened_center"),
            (try_end),
			
	    #3-DEFENSIVE ACTIONS : RIDE TO BREAK ENEMY SIEGE / DEFEAT ENEMIES NEAR OUR CENTER
		(else_try),
			# (party_is_active, ":marshal_party"),	MOTO chief faction lords should defend even if they have no marshall
			(is_between, ":most_threatened_center", walled_centers_begin, walled_centers_end),
			(this_or_next|eq, ":current_ai_state", sfai_default),	#MOTO not going to attack anyway
			(this_or_next|eq, ":current_ai_state", sfai_feast),	#MOTO not going to attack anyway (THIS is the emergency to stop feast)
			(ge, ":threat_danger_level", ":target_value_level"),
			(party_slot_ge, ":most_threatened_center", "slot_center_is_besieged_by", 0),

			(assign, ":action", sfai_attacking_enemies_around_center),
			(assign, ":object", ":most_threatened_center"),
						
			(str_store_party_name, s21, ":most_threatened_center"),
			(str_store_string, s14, "str_we_should_ride_to_break_the_siege_of_s21"),
			
		#3b - DEFEAT ENEMIES NEAR CENTER - similar to above, but a different string
		(else_try),
			# (party_is_active, ":marshal_party"),	MOTO chief faction lords should defend even if they have no marshall
			(this_or_next|eq, ":current_ai_state", sfai_default),	#MOTO not going to attack anyway
			(this_or_next|eq, ":current_ai_state", sfai_feast),	#MOTO not going to attack anyway (THIS is the emergency to stop feast)
			(ge, ":threat_danger_level", ":target_value_level"),
			(is_between, ":most_threatened_center", villages_begin, villages_end),
		
			(assign, ":action", sfai_attacking_enemies_around_center),
			(assign, ":object", ":most_threatened_center"),
			(str_store_party_name, s21, ":most_threatened_center"),
			(str_store_string, s14, "str_we_should_ride_to_defeat_the_enemy_gathered_near_s21"),
				
		#4-DEMOBILIZATION
		#Let vassals attend their own business
		(else_try),
			(this_or_next|eq, ":current_ai_state", sfai_gathering_army), 				
			(this_or_next|eq, ":current_ai_state", sfai_attacking_center),
			(eq, ":current_ai_state", sfai_raiding_village),

			(ge, ":hours_since_last_faction_rest", ":campaign_hour_limit"), #Effected by ratio of vassals
			(ge, ":hours_at_current_state", 24),
			
			#Ozan : I am adding some codes here because sometimes armies demobilize during last seconds of an important event like taking a castle, ext.
			(assign, ":there_is_an_important_situation", 0),
			(try_begin), #do not demobilize during taking a castle/town (fighting in the castle)
				(is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
				(party_get_battle_opponent, ":besieger_party", ":current_ai_object"),
				(party_is_active, ":besieger_party"),
				(store_faction_of_party, ":besieger_faction", ":besieger_party"),
				(this_or_next|eq, ":besieger_faction", ":faction_no"),
				(eq, ":besieger_faction", "fac_player_faction"),
				(assign, ":there_is_an_important_situation", 1),
			(else_try), #do not demobilize during besieging a siege (holding around castle)
				(is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
				(party_get_slot, ":besieger_party", ":current_ai_object", "slot_center_is_besieged_by"),
				(party_is_active, ":besieger_party"),
				(store_faction_of_party, ":besieger_faction", ":besieger_party"),
				(this_or_next|eq, ":besieger_faction", ":faction_no"),
				(eq, ":besieger_faction", "fac_player_faction"),		  
				(assign, ":there_is_an_important_situation", 1),
			(else_try), #do not demobilize during raiding a village (holding around village)
				(is_between, ":current_ai_object", centers_begin, centers_end),
				(neg|is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),		  
				(party_slot_eq, ":current_ai_object", "slot_village_state", svs_being_raided),
				(assign, ":there_is_an_important_situation", 1),
			(try_end),
			
			(eq, ":there_is_an_important_situation", 0),
			#end addition ozan
						
			(assign, reg7, ":hours_since_last_faction_rest"),
			(assign, reg8, ":campaign_hour_limit"),
		
			(str_store_string, s14, "str_this_offensive_needs_to_wind_down_soon_so_the_vassals_can_attend_to_their_own_business"),		
			(assign, ":action", sfai_default),
			(assign, ":object", -1),
			
		#6-GATHERING BECAUSE OF NO REASON
		#Start to gather the army
		(else_try),
			(party_is_active, ":marshal_party"),
			(eq, ":at_peace_with_everyone", 0),
			
			
			(eq, ":current_ai_state", sfai_default),
			(ge, ":hours_since_last_offensive", 60),
			(lt, ":hours_since_last_faction_rest", 120),
			
			#There should not be a center as a precondition for attack	
			#Otherwise, we are unlikely to have a situation in which the army gathers, but does nothing -- which is important to have for role-playing purposes
			
			(assign, ":action", sfai_gathering_army),
			(assign, ":object", -1),	
			(str_store_string, s14, "str_it_is_time_to_go_on_the_offensive_and_we_must_first_assemble_the_army"),
		
            (try_begin),
              (eq, ":faction_no", "$players_kingdom"),
              (assign, "$g_gathering_reason", -1),
            (try_end),

		#7-OFFENSIVE ACTIONS : CONTINUE GATHERING
		(else_try),		
			(party_is_active, ":marshal_party"),
			(eq, ":current_ai_state", sfai_gathering_army),
			(eq, ":at_peace_with_everyone", 0),

			(lt, ":hours_at_current_state", 54), #gather army for 54 hours
			
			(lt, ":ratio_of_vassals_assembled", 12),

			(str_store_string, s14, "str_we_must_continue_to_gather_the_army_before_we_ride_forth_on_an_offensive_operation"),
			(assign, ":action", sfai_gathering_army),
			(assign, ":object", -1),


		#7-OFFENSIVE ACTIONS PART 2 : CONTINUE GATHERING
		(else_try),
		    (assign, ":minimum_possible_attackable_target_value_level", 50),
			(eq, ":at_peace_with_everyone", 0),

            (try_begin), #agressive marshal            
			  ##diplomacy start+ chief
			  ##OLD:
			  #(troop_get_slot, ":reputation", ":troop_no", "slot_lord_reputation_type"),
			  #(this_or_next|eq, ":reputation", lrep_martial),
			  #(this_or_next|eq, ":reputation", lrep_quarrelsome),
			  #(eq, ":reputation", lrep_selfrighteous),
			  ##NEW:
			  (call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
			  (lt, reg0, 0),
			  ##diplomacy end+
			  (val_mul, ":minimum_possible_attackable_target_value_level", 9),
			  (val_div, ":minimum_possible_attackable_target_value_level", 10),
            (try_end),		              

			(party_is_active, ":marshal_party"),
			(eq, ":current_ai_state", sfai_gathering_army),
								
			(try_begin),
				(lt, ":hours_at_current_state", 6),
				(assign, ":minimum_needed_target_value_level", 1500),
			(else_try),
				(lt, ":hours_at_current_state", 10),
				(assign, ":minimum_needed_target_value_level", 1000),
			(else_try),  
		        (lt, ":hours_at_current_state", 14),
		        (assign, ":minimum_needed_target_value_level", 720),
			(else_try),  
				(lt, ":hours_at_current_state", 18),
				(assign, ":minimum_needed_target_value_level", 480),
			(else_try),  
				(lt, ":hours_at_current_state", 22),
				(assign, ":minimum_needed_target_value_level", 360),
			(else_try),  
				(lt, ":hours_at_current_state", 26),
				(assign, ":minimum_needed_target_value_level", 240),
			(else_try),  
				(lt, ":hours_at_current_state", 30),
				(assign, ":minimum_needed_target_value_level", 180),
			(else_try),  
				(lt, ":hours_at_current_state", 34),
				(assign, ":minimum_needed_target_value_level", 120),
			(else_try),  
				(lt, ":hours_at_current_state", 38),
				(assign, ":minimum_needed_target_value_level", 100),
			(else_try),  
				(lt, ":hours_at_current_state", 42),
				(assign, ":minimum_needed_target_value_level", 80),
			(else_try),  
				(lt, ":hours_at_current_state", 46),
				(assign, ":minimum_needed_target_value_level", 65),
			(else_try),  
				(lt, ":hours_at_current_state", 50),
				(assign, ":minimum_needed_target_value_level", 55),
			(else_try),	
				(assign, ":minimum_needed_target_value_level", ":minimum_possible_attackable_target_value_level"),
			(try_end),  

            (try_begin), #agressive marshal            
			  ##diplomacy start+ chief
			  ##OLD:
			  #(troop_get_slot, ":reputation", ":troop_no", "slot_lord_reputation_type"),
			  #(this_or_next|eq, ":reputation", lrep_martial),
			  #(this_or_next|eq, ":reputation", lrep_quarrelsome),
			  #(eq, ":reputation", lrep_selfrighteous),
			  ##NEW:
			  (call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
			  (lt, reg0, 0),
			  ##diplomacy end+
			  (val_mul, ":minimum_needed_target_value_level", 9),
			  (val_div, ":minimum_needed_target_value_level", 10),
            (try_end),		  
						
			(le, ":target_value_level", ":minimum_needed_target_value_level"),
			(le, ":hours_at_current_state", 54),
		
			(str_store_string, s14, "str_we_have_assembled_some_vassals"),
			(assign, ":action", sfai_gathering_army),
			(assign, ":object", -1),
				
		#8-ATTACK AN ENEMY CENTER case 1, reconnaissance against walled center
		#(else_try),
			#(party_is_active, ":marshal_party"),
			#(neq, ":current_ai_state", sfai_default),
			#(neq, ":current_ai_state", sfai_feast),
			#(is_between, ":center_to_attack", walled_centers_begin, walled_centers_end),

			#(store_sub, ":faction_recce_slot", ":faction_no", kingdoms_begin),
			#(val_add, ":faction_recce_slot", "slot_center_last_reconnoitered_by_faction_time"),
			#(store_current_hours, ":hours_since_last_recon"),			
			#(party_get_slot, ":last_recon_time", ":center_to_attack", ":faction_recce_slot"), 
			#(val_sub, ":hours_since_last_recon", ":last_recon_time"),
			#(this_or_next|eq, ":last_recon_time", 0),
			#(gt, ":hours_since_last_recon", 96),
						
		    #(assign, ":action", sfai_attacking_center),
			#(assign, ":object", ":center_to_attack"),
			#(str_store_string, s14, "str_we_are_conducting_recce"),
			
		#8-ATTACK AN ENEMY CENTER case 2, reconnaissance against village
		#(else_try),  
			#(party_is_active, ":marshal_party"),
			#(neq, ":current_ai_state", sfai_default),
			#(neq, ":current_ai_state", sfai_feast),
			#(is_between, ":center_to_attack", villages_begin, villages_end),

			#(store_sub, ":faction_recce_slot", ":faction_no", kingdoms_begin),
			#(val_add, ":faction_recce_slot", "slot_center_last_reconnoitered_by_faction_time"),
			#(store_current_hours, ":hours_since_last_recon"),
			#(party_get_slot, ":last_recon_time", ":center_to_attack", ":faction_recce_slot"), 
			#(val_sub, ":hours_since_last_recon", ":last_recon_time"),
			#(this_or_next|eq, ":last_recon_time", 0),
			#(gt, ":hours_since_last_recon", 96),

			
			#(assign, ":action", sfai_raiding_village),
			#(assign, ":object", ":center_to_attack"),
			#(str_store_string, s14, "str_we_are_conducting_recce"),
		(else_try),
			(party_is_active, ":marshal_party"),
			(neq, ":current_ai_state", sfai_default),
			(neq, ":current_ai_state", sfai_feast),
			
			(assign, ":center_to_attack", ":center_to_attack_only_marshal_and_followers"),
			
			(is_between, ":center_to_attack", walled_centers_begin, walled_centers_end),
			
			(ge, ":target_value_level", ":minimum_possible_attackable_target_value_level"),
						
		    (assign, ":action", sfai_attacking_center),
			(assign, ":object", ":center_to_attack"),
			(str_store_string, s14, "str_we_believe_the_fortress_will_be_worth_the_effort_to_take_it"),
		(else_try),
			(party_is_active, ":marshal_party"),
			(neq, ":current_ai_state", sfai_default),
			(neq, ":current_ai_state", sfai_feast),
			
			(assign, ":center_to_attack", ":center_to_attack_only_marshal_and_followers"),
			
			(is_between, ":center_to_attack", villages_begin, villages_end),
			
			(ge, ":target_value_level", ":minimum_possible_attackable_target_value_level"),
		
			(assign, ":action", sfai_raiding_village),
			(assign, ":object", ":center_to_attack"),
			(str_store_string, s14, "str_we_shall_leave_a_fiery_trail_through_the_heart_of_the_enemys_lands_targeting_the_wealthy_settlements_if_we_can"),
		
		#9 -- DISBAND THE ARMY
		(else_try),
			(eq, ":current_ai_state", sfai_gathering_army),			

			(str_store_string, s14, "str_the_army_will_be_disbanded_because_we_have_been_waiting_too_long_without_a_target"),

			(assign, ":action", sfai_default),
			(assign, ":object", -1),
		#OFFENSIVE OPERATIONS END

		#FEAST-RELATED OPERATIONS BEGIN
		#10-CONCLUDE CURRENT FEAST
		(else_try),
			(eq, ":current_ai_state", sfai_feast),
			(gt, ":hours_at_current_state", 72),
		
			(assign, ":action", sfai_default),
			(assign, ":object", -1),		
			(str_store_string, s14, "str_it_is_time_for_the_feast_to_conclude"),

		#11-CONTINE FEAST UNLESS THERE IS AN EMERGENCY
		(else_try),
			(eq, ":current_ai_state", sfai_feast),
			(le, ":hours_at_current_state", 72),
		
			(assign, ":action", sfai_feast),
			(assign, ":object", ":current_ai_object"),		
			(str_store_string, s14, "str_we_should_continue_the_feast_unless_there_is_an_emergency"),
		
		#12-HOLD A FEAST BECAUSE THE PLAYER WANTS TO ORGANIZE ONE
		(else_try),
			(check_quest_active, "qst_organize_feast"),
			(eq, "$players_kingdom", ":faction_no"),
		
			(quest_get_slot, ":target_center", "qst_organize_feast", "slot_quest_target_center"),
			
			(assign, ":action", sfai_feast),
			(assign, ":object", ":target_center"),		
			(str_store_string, s14, "str_you_had_wished_to_hold_a_feast"),
		
		#13-HOLD A FEAST BECAUSE FEMALE PLAYER SCHEDULED TO GET MARRIED
		(else_try),
			(check_quest_active, "qst_wed_betrothed_female"),
				 
			(quest_get_slot, ":groom", "qst_wed_betrothed_female", "slot_quest_giver_troop"),
			(troop_slot_eq, ":groom", "slot_troop_prisoner_of_party", -1),
		
			(store_faction_of_troop, ":groom_faction", ":groom"),
			(eq, ":groom_faction", ":faction_no"),
				 
			(faction_get_slot, ":faction_leader", ":groom_faction", "slot_faction_leader"),
				 
			(assign, ":location_feast", -1),
			(try_for_range, ":possible_location", walled_centers_begin, walled_centers_end),
			   (eq, ":location_feast", -1),
			    (party_slot_eq, ":possible_location", "slot_town_lord", ":groom"),
			    (party_slot_ge, ":possible_location", "slot_center_is_besieged_by", 0),
			    (assign, ":location_feast", ":possible_location"),
			(try_end),
			
			(try_for_range, ":possible_location", walled_centers_begin, walled_centers_end),
				(eq, ":location_feast", -1),
				(party_slot_eq, ":possible_location", "slot_town_lord", ":faction_leader"),
				(party_slot_ge, ":possible_location", "slot_center_is_besieged_by", 0),
				(assign, ":location_feast", ":possible_location"),
			(try_end),
		 
			(is_between, ":location_feast", walled_centers_begin, walled_centers_end),

			(assign, ":action", sfai_feast),
			(assign, ":object", ":location_feast"),		
			(str_store_string, s14, "str_your_wedding_day_approaches_my_lady"),
		
		#14-HOLD A FEAST BECAUSE A MALE CHARACTER WANTS TO GET MARRIED
		(else_try),
			(check_quest_active, "qst_wed_betrothed"),
			(neg|quest_slot_ge, "qst_wed_betrothed", "slot_quest_expiration_days", 362),
		
			(quest_get_slot, ":bride", "qst_wed_betrothed", "slot_quest_target_troop"),
			(call_script, "script_get_kingdom_lady_social_determinants", ":bride"),
			(assign, ":feast_host", reg0),
			(store_faction_of_troop, ":feast_host_faction", ":feast_host"),
			(eq, ":feast_host_faction", ":faction_no"),
		
			(troop_slot_eq, ":feast_host", "slot_troop_prisoner_of_party", -1),
			(assign, ":wedding_venue", reg1),
		
			(is_between, ":wedding_venue", centers_begin, centers_end),
			(party_slot_eq, ":wedding_venue", "slot_center_is_besieged_by", -1),
		
			(assign, ":action", sfai_feast),
			(assign, ":object", ":wedding_venue"),		
			(str_store_string, s14, "str_your_wedding_day_approaches"),
		
		#15-HOLD A FEAST BECAUSE AN NPC WANTS TO GET MARRIED
		(else_try),	
            (ge, ":hours_since_last_feast_start", 192), #If at least eight days past last feast start time
					(assign, ":location_feast", -1),
		
			(try_for_range, ":kingdom_lady", kingdom_ladies_begin, kingdom_ladies_end),
				(troop_get_slot, ":groom", ":kingdom_lady", "slot_troop_betrothed"),
				(gt, ":groom", 0), #not the player

				(store_faction_of_troop, ":lady_faction", ":kingdom_lady"),
				(store_faction_of_troop, ":groom_faction", ":groom"),
				
				(try_begin), #The groom checks if he wants to continue or break off relations. This causes actions, rather than just returns a value, so it probably should be moved elsewhere
					(troop_slot_ge, ":groom", "slot_troop_prisoner_of_party", 0),
				(else_try),
					(neq, ":groom_faction", ":lady_faction"),
					(neq, ":groom_faction", "fac_player_faction"),
					(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":kingdom_lady", ":groom"),
				(else_try),
		            (eq, ":lady_faction", ":faction_no"),
		            (store_current_hours, ":hours_since_betrothal"),
		            (troop_get_slot, ":betrothal_time", ":kingdom_lady", "slot_troop_betrothal_time"),
		            (val_sub, ":hours_since_betrothal", ":betrothal_time"),
		            (ge, ":hours_since_betrothal", 719), #30 days
							
					(call_script, "script_get_kingdom_lady_social_determinants", ":kingdom_lady"), 
					(assign, ":wedding_venue", reg1),
				
		            (assign, ":location_feast", ":wedding_venue"),
		            (assign, ":final_bride", ":kingdom_lady"),
		            (assign, ":final_groom", ":groom"),
				(try_end),	
			(try_end),
		
			(ge, ":location_feast", centers_begin),
				 
			(assign, ":action", sfai_feast),
			(assign, ":object", ":location_feast"),
				
			(str_store_troop_name, s22, ":final_bride"),
			(str_store_troop_name, s23, ":final_groom"),		
			(str_store_string, s14, "str_s22_and_s23_wish_to_marry"),

		#16-HOLD A FEAST ANYWAY
		(else_try),
			(eq, ":current_ai_state", sfai_default),
            (gt, ":hours_since_last_feast_start", 240), #If at least 10 days past after last feast. (added by ozan)
                
			(assign, ":location_high_score", 0),
			(assign, ":location_feast", -1),
        
			(try_for_range, ":location", walled_centers_begin, walled_centers_end),
				(store_faction_of_party, ":location_faction", ":location"),
				(eq, ":location_faction", ":faction_no"),

				(try_begin),
			        (neg|party_slot_eq, ":location", "slot_village_state", svs_under_siege),
		            (party_get_slot, ":location_lord", ":location", "slot_town_lord"),
		            (is_between, ":location_lord", active_npcs_begin, active_npcs_end),
		            (troop_get_slot, ":location_score", ":location_lord", "slot_troop_renown"),
		            (store_random_in_range, ":random", 0, 1000), #will probably be king or senior lord
		            (val_add, ":location_score", ":random"),
		            (gt, ":location_score", ":location_high_score"),
		            (assign, ":location_high_score", ":location_score"),
		            (assign, ":location_feast", ":location"),				
				(else_try), #do not start new feasts if any place is under siege or being raided
		            (this_or_next|party_slot_eq, ":location", "slot_village_state", svs_under_siege),
						(party_slot_eq, ":location", "slot_village_state", svs_being_raided),
		            (assign, ":location_high_score", 9999),
		            (assign, ":location_feast", -1),
				(try_end),
			(try_end),

			(is_between, ":location_feast", walled_centers_begin, walled_centers_end),
			(party_get_slot, ":feast_host", ":location_feast", "slot_town_lord"),
			(troop_slot_eq, ":feast_host", "slot_troop_prisoner_of_party", -1),
		
			(assign, ":action", sfai_feast),
			(assign, ":object", ":location_feast"),		
			(str_store_string, s14, "str_it_has_been_a_long_time_since_the_lords_of_the_realm_gathered_for_a_feast"),	
		
		#17-DO NOTHING
		(else_try),
			(neq, ":current_ai_state", sfai_default),
		
			(assign, ":action", sfai_default),
			(assign, ":object", -1),		
			(str_store_string, s14, "str_the_circumstances_which_led_to_this_decision_no_longer_apply_so_we_should_stop_and_reconsider_shortly"),	
	
		#18-DO NOTHING
		(else_try),
			(eq, ":current_ai_state", sfai_default),

			(eq, ":at_peace_with_everyone", 1),
				
		    (assign, ":action", sfai_default),
		    (assign, ":object", -1),		
			(str_store_string, s14, "str_we_are_currently_at_peace"),		
		(else_try),
			(eq, ":current_ai_state", sfai_default),
			(faction_slot_eq, ":faction_no", "slot_faction_marshall", -1),
		    (assign, ":action", sfai_default),
		    (assign, ":object", -1),		
			(str_store_string, s14, "str_we_are_waiting_for_selection_of_marshal"),		
		
		(else_try),
			(eq, ":current_ai_state", sfai_default),
								
		    (assign, ":action", sfai_default),
		    (assign, ":object", -1),		
			(str_store_string, s14, "str_the_vassals_still_need_time_to_attend_to_their_own_business"),		
		(try_end),
				
		(assign, reg0, ":action"),
		(assign, reg1, ":object"),		
	]),
  
 	(
	"faction_last_reconnoitered_center", #This is called from within decide_faction_ai, or from 
	[
		(store_script_param, ":faction_no", 1), 
		(store_script_param, ":center_no", 2), 
		
		(store_sub, ":faction_recce_slot", ":faction_no", kingdoms_begin),
		(val_add, ":faction_recce_slot", "slot_center_last_reconnoitered_by_faction_time"),
		(store_current_hours, ":hours_since_last_recon"),
		(party_get_slot, ":last_recon_time", ":center_no", ":faction_recce_slot"), 
		
		(try_begin),
			(lt, ":last_recon_time", 1),
			(assign, ":hours_since_last_recon", 1000),
		(else_try),	
			(val_sub, ":hours_since_last_recon", ":last_recon_time"),
		(try_end),
 
		(assign, reg0, ":hours_since_last_recon"),
		(assign, reg1, ":last_recon_time"),		
	]),
 	
 	(
	"reduce_exact_number_to_estimate",
	#This is used to simulate limited intelligence
	#It is roughly analogous to the descriptive strings which the player will receive from alarms
	#Information is presumed to be accurate for four days
	#This is obviously cheating for the AI, as the AI will have exact info for four days, and no info at all after that.
	#It would be fairly easy to log the strength at a center when it is scouted, if we want, but I have not done that at this point,
	#The AI also has a hive mind -- ie, each party knows what its allies are thinking. In this, AI factions have an advantage over the player
	#It would be a simple matter to create a set of arrays in which each party's knowledge is individually updated, but that would also take up a lot of data space
	
	[
		(store_script_param, ":exact_number", 1), 
		
		(try_begin),
			(lt, ":exact_number", 500),
			(assign, ":estimate", 0),
		(else_try),
			(lt, ":exact_number", 1000),
			(assign, ":estimate", 750),
		(else_try),
			(lt, ":exact_number", 2000),
			(assign, ":estimate", 1500),
		(else_try),
			(lt, ":exact_number", 4000),
			(assign, ":estimate", 3000),
		(else_try),
			(lt, ":exact_number", 8000),
			(assign, ":estimate", 6000),
		(else_try),
			(lt, ":exact_number", 16000),
			(assign, ":estimate", 12000),
		(else_try),
			(assign, ":estimate", 24000),
		(try_end),
				
		(assign, reg0, ":estimate"),		
	]),

   #script_calculate_castle_prosperities_by_using_its_villages
 	(
	"calculate_castle_prosperities_by_using_its_villages", #This is called from within decide_faction_ai, or from 
	[	  	
	  (try_for_range, ":cur_castle", castles_begin, castles_end),	  
	    (assign, ":total_prosperity", 0),
	    (assign, ":total_villages", 0),
	    
	    (try_for_range, ":cur_village", villages_begin, villages_end),	  
	      (party_get_slot, ":bound_center", ":cur_village", "slot_village_bound_center"),
	      (eq, ":cur_castle", ":bound_center"),
	      
	      (party_get_slot, ":village_prosperity", ":cur_village", "slot_town_prosperity"),
	      
	      (val_add, ":total_prosperity", ":village_prosperity"),
	      (val_add, ":total_villages", 1),
	    (try_end),
	    
	    (try_begin),
	      (store_div, ":castle_prosperity", ":total_prosperity", ":total_villages"),
	    (else_try),  
	      (assign, ":castle_prosperity", 50),
	    (try_end),
	    
	    (party_set_slot, ":cur_castle", "slot_town_prosperity", ":castle_prosperity"),
	  (try_end),
	]),
      
   #script_initialize_tavern_variables
   (
   "initialize_tavern_variables",
   [
     (assign, "$g_main_attacker_agent", 0),
     (assign, "$g_attacker_drawn_weapon", 0),
     (assign, "$g_start_belligerent_drunk_fight", 0),
     (assign, "$g_start_hired_assassin_fight", 0),
     (assign, "$g_belligerent_drunk_leaving", 0),   
   ]),
  
   (
   "change_player_right_to_rule",
   [
     (store_script_param_1, ":right_to_rule_dif"),
     (val_add, "$player_right_to_rule", ":right_to_rule_dif"),
     (val_clamp, "$player_right_to_rule", 0, 100),
     (try_begin),
       (gt, ":right_to_rule_dif", 0),
       (display_message, "@You gain right to rule."),
     (else_try),
       (lt, ":right_to_rule_dif", 0),
       (display_message, "@You lose right to rule."),
     (try_end),
   ]),   
 ##gdw below script from floris 081415 Reports of excessive indictments   
("indict_lord_for_treason",#originally included in simple_triggers. Needed to be moved here to allow player to indict
                          [
                            (store_script_param, ":troop_no", 1),
                            (store_script_param, ":faction", 2),
                            
							##diplomacy start+ use gender script
							#(troop_get_type, reg4, ":troop_no"),
							(assign, ":save_reg0", reg0),
							(assign, ":save_reg3", reg3),
							(assign, ":save_reg4", reg4),
							##diplomacy end+
                            ##by moto BW
							# Gender fix chief altura	                   
							(troop_get_type, reg4, ":troop_no"),
							## Gender fix
							(val_mod, reg4, 2),
							###gender fix chief	

							(try_for_range, ":center", centers_begin, centers_end), #transfer properties to liege
								(party_slot_eq, ":center", "slot_town_lord", ":troop_no"),
								(party_set_slot, ":center", "slot_town_lord", stl_unassigned),
							(try_end),

							(faction_get_slot, ":faction_leader", ":faction", "slot_faction_leader"),
							(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_leader"),
							(assign, ":liege_to_lord_relation", reg0),
							(store_sub, ":base_relation_modifier", -150, ":liege_to_lord_relation"),
							(val_div, ":base_relation_modifier", 40),#-1 at -100, -2 at -70, -3 at -30,etc.
							(val_min, ":base_relation_modifier", -1),
							
							#Indictments, cont: Influence relations
							##diplomacy start+ Alter to include promoted ladies
							##OLD:
							#(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end), #this effects all lords in all factions
							##NEW:
							(try_for_range, ":active_npc", heroes_begin, heroes_end), #this effects all lords in all factions
								(this_or_next|is_between, ":active_npc", active_npcs_begin, active_npcs_end),
									(troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_kingdom_hero),
							##diplomacy end+
								(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
								(eq, ":faction", ":active_npc_faction"),

								(call_script, "script_troop_get_family_relation_to_troop", ":troop_no", ":active_npc"),
								(assign, ":family_relation", reg0),

								##diplomacy start+
								(val_max, ":family_relation", 0),
								#Take into account friendship or enmity
								(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_leader"),
								(assign, ":liking_relation", reg0),
								(try_begin),
									(ge, ":liking_relation", 20),
									(store_div, reg0, ":liking_relation", 20),
									(val_add, ":family_relation", reg0),
								(else_try),
									(lt, ":liking_relation", 0),
									(store_div, reg0, ":liking_relation", 20),
									(val_sub, reg0, 1),
									(val_add, ":family_relation", reg0),
								(try_end),
								(store_random_in_range, reg0, 0, 3),#+0, +1, or +2 (because below we divide by three...)
								(val_add, ":family_relation", reg0),
								(assign, reg0, ":family_relation"),
								##diplomacy end+
								(assign, ":relation_modifier", ":base_relation_modifier"),
								(try_begin),
									##diplomacy start+
									#(gt, ":family_relation", 1),##OLD
									(neq, ":family_relation", 0),##NEW (allow lessening penalty for hated characters)
									##diplomacy end+
									(store_div, ":family_multiplier", reg0, 3),
									(val_sub, ":relation_modifier", ":family_multiplier"),
								(try_end),

								(lt, ":relation_modifier", 0),

								(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":active_npc", ":relation_modifier"),
								(val_add, "$total_indictment_changes", ":relation_modifier"),
								(try_begin),
									(eq, "$cheat_mode", 1),
									(str_store_troop_name, s17, ":active_npc"),
									(str_store_troop_name, s18, ":faction_leader"),

									(assign, reg3, ":relation_modifier"),
									(assign, reg4, ":liege_to_lord_relation"),##gdwtest
									(display_message, "str_trial_influences_s17s_relation_with_s18_by_reg3"),
								(try_end),
							(try_end),
                            
                            #Indictments, cont: Check for other factions
                            (assign, ":new_faction", "fac_outlaws"),
                            (try_begin),
                              (eq, ":troop_no", "trp_player"),
                              (assign, ":new_faction", 0), #kicked out of faction
                            (else_try),
                              (call_script, "script_lord_find_alternative_faction", ":troop_no"),
                              (assign, ":new_faction", reg0),
                            (try_end),
                            
                            #Indictments, cont: Finalize where the lord goes
                            (try_begin),
                              (is_between, ":new_faction", kingdoms_begin, kingdoms_end),
                              ## Begin 1.134
                              (try_begin),
                                (ge, "$cheat_mode", 1),
                                (str_store_troop_name, s4, ":troop_no"),
                                (display_debug_message, "@{!}DEBUG - {s4} faction changed in indictment"),
                              (try_end),
                              ## End 1.134
                              (call_script, "script_change_troop_faction", ":troop_no", ":new_faction"),
                              (try_begin), #new-begin
                                (neq, ":new_faction", "fac_player_supporters_faction"), ##1.134
                                (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_inactive),
                                (troop_set_slot, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),
                              (try_end), #new-end
                              (str_store_faction_name, s10, ":new_faction"),
                              (str_store_string, s11, "str_with_the_s10"),
							(else_try),
								(neq, ":troop_no", "trp_player"),
								##diplomacy start+
								#Set "exile" occupation to differentiate between someone outside of Calradia
								#and an outlaw lord leading a party of bandits.
								(troop_set_slot, ":troop_no", "slot_troop_occupation", dplmc_slto_exile),
								##diplomacy end+
								(call_script, "script_change_troop_faction", ":troop_no", "fac_outlaws"),
								(str_store_string, s11, "str_outside_calradia"),
							(else_try),
								(eq, ":troop_no", "trp_player"),
								(call_script, "script_player_leave_faction", 1),
							(try_end),

							#Indictments, cont: Set up string
							(try_begin),
								(eq, ":troop_no", "trp_player"),
								(str_store_string, s9, "str_you_have_been_indicted_for_treason_to_s7_your_properties_have_been_confiscated_and_you_would_be_well_advised_to_flee_for_your_life"),
							(else_try),
								(str_store_troop_name, s4, ":troop_no"),
								(str_store_faction_name, s5, ":faction"),
								(str_store_troop_name, s6, ":faction_leader"),

								# ##diplomacy start+
								# #(troop_get_type, reg4, ":troop_no"),
								# (call_script, "script_dplmc_store_troop_is_female", ":troop_no"),
								# (assign, reg4, reg0),
								# ##diplomacy end+
							## Gender fix chief altura	                   
					        (troop_get_type, reg4, ":troop_no"),
							## Gender fix
							(val_mod, reg4, 2),
							###gender fix chief	
							(str_store_string, s9, "str_by_order_of_s6_s4_of_the_s5_has_been_indicted_for_treason_the_lord_has_been_stripped_of_all_reg4herhis_properties_and_has_fled_for_reg4herhis_life_he_is_rumored_to_have_gone_into_exile_s11"),
							(try_end),
							##diplomacy start+ important political events should be in the log
							(display_message, "str_trial_influences_s17s_relation_with_s18_by_reg3"),
							(display_message, "@{!}Original liege relation before event was {reg4}"),
							(display_log_message, "@{!}{s9}"),#display_message changed to display_log_message
							(display_message, "@{!}{s9}"),

							##diplomacy end+

							#Indictments, cont: Remove party
							(troop_get_slot, ":led_party", ":troop_no", "slot_troop_leaded_party"),
							(try_begin),
								(party_is_active, ":led_party"),
								(neq, ":led_party", "p_main_party"),
								(remove_party, ":led_party"),
								(troop_set_slot, ":troop_no", "slot_troop_leaded_party", -1),
							(try_end),

							(try_begin),
								(eq, "$cheat_mode", 1),
								##diplomacy start+
								(this_or_next|eq, ":faction", "fac_player_supporters_faction"),
								(this_or_next|eq, ":new_faction", "fac_player_supporters_faction"),
								##diplomacy end+
								(this_or_next|eq, ":faction", "$players_kingdom"),
									(eq, ":new_faction", "$players_kingdom"),
								(call_script, "script_add_notification_menu", "mnu_notification_treason_indictment", ":troop_no", ":faction"),
							(try_end),
							##diplomacy start+
							(assign, reg0, ":save_reg0"),
							(assign, reg3, ":save_reg3"),
							(assign, reg4, ":save_reg4"),
							##diplomacy end+
						   ]),
                        


  # script_give_center_to_faction_aux
  # Input: arg1 = center_no, arg2 = faction
  ("give_center_to_faction_while_maintaining_lord",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":faction_no"),

      (store_faction_of_party, ":old_faction", ":center_no"),
      (party_set_slot, ":center_no", "slot_center_ex_faction", ":old_faction"),
      (party_set_faction, ":center_no", ":faction_no"),

      (try_begin),
        (party_slot_eq, ":center_no", "slot_party_type", spt_village),
        (party_get_slot, ":farmer_party", ":center_no", "slot_village_farmer_party"),
        (gt, ":farmer_party", 0),
        (party_is_active, ":farmer_party"),
        (party_set_faction, ":farmer_party", ":faction_no"),
      (try_end),

      (call_script, "script_update_faction_notes", ":faction_no"),
      (call_script, "script_update_center_notes", ":center_no"),

      (try_for_range, ":other_center", centers_begin, centers_end),
        (party_slot_eq, ":other_center", "slot_village_bound_center", ":center_no"),
        (call_script, "script_give_center_to_faction_while_maintaining_lord", ":other_center", ":faction_no"),
      (try_end),
  ]),   
  

  # script_check_concilio_calradi_achievement  
  ("check_concilio_calradi_achievement",
  [
   (try_begin),
     (eq, "$players_kingdom", "fac_player_supporters_faction"),
     (faction_get_slot, ":player_faction_king", "fac_player_supporters_faction", "slot_faction_leader"),
     (eq, ":player_faction_king", "trp_player"),
     (assign, ":number_of_vassals", 0),
     (try_for_range, ":cur_troop", active_npcs_begin, active_npcs_end),
       (troop_slot_eq, ":cur_troop", "slot_troop_occupation", slto_kingdom_hero),
       (store_faction_of_troop, ":cur_faction", ":cur_troop"),
       (eq, ":cur_faction", "fac_player_supporters_faction"),
       (val_add, ":number_of_vassals", 1),
     (try_end),
     (ge, ":number_of_vassals", 3),
     (unlock_achievement, ACHIEVEMENT_CONCILIO_CALRADI),
   (try_end),  
  ]),

    # This script is taken from Companions Overseer, remove it if you are already using Companions Overseer in your mod.
    ("lco_create_mesh",
        [
            (store_script_param, ":mesh", 1),
            (store_script_param, ":x", 2),
            (store_script_param, ":y", 3),
            (store_script_param, ":x_ratio", 4),
            (store_script_param, ":y_ratio", 5),
            (set_fixed_point_multiplier, 1000),
            (create_mesh_overlay, reg0, ":mesh"),
            (position_set_x, pos60, ":x"),
            (position_set_y, pos60, ":y"),
            (overlay_set_position, reg0, pos60),
            (position_set_x, pos61, ":x_ratio"),
            (position_set_y, pos61, ":y_ratio"),
            (overlay_set_size, reg0, pos61),
        ]
    ),

    # This script is taken from Companions Overseer, remove it if you are already using Companions Overseer in your mod.
    ("lco_create_button",
        [
            (store_script_param, ":caption", 1),
            (store_script_param, ":x", 2),
            (store_script_param, ":y", 3),
            (store_script_param, ":x_size", 4),
            (store_script_param, ":y_size", 5),
            (set_fixed_point_multiplier, 1000),
            (create_game_button_overlay, reg0, ":caption"),
            (position_set_x, pos60, ":x"),
            (position_set_y, pos60, ":y"),
            (overlay_set_position, reg0, pos60),
            (position_set_x, pos61, ":x_size"),
            (position_set_y, pos61, ":y_size"),
            (overlay_set_size, reg0, pos61),
        ]
    ),

    # This script is taken from Companions Overseer, remove it if you are already using Companions Overseer in your mod.
    ("lco_create_label",
        [
            (store_script_param, ":caption", 1),
            (store_script_param, ":x", 2),
            (store_script_param, ":y", 3),
            (store_script_param, ":scale", 4),
            (store_script_param, ":alignment", 5),
            (set_fixed_point_multiplier, 1000),
            (create_text_overlay, reg0, ":caption", ":alignment"),
            (position_set_x, pos60, ":x"),
            (position_set_y, pos60, ":y"),
            (overlay_set_position, reg0, pos60),
            (position_set_x, pos62, ":scale"),
            (position_set_y, pos62, ":scale"),
            (overlay_set_size, reg0, pos62),
        ]
    ),

    # This script is taken from Companions Overseer, remove it if you are already using Companions Overseer in your mod.
    ("lco_create_container",
        [
            (store_script_param, ":x", 1),
            (store_script_param, ":y", 2),
            (store_script_param, ":width", 3),
            (store_script_param, ":height", 4),
            (store_script_param, ":auto_start", 5),
            (set_fixed_point_multiplier, 1000),
            (str_clear, s40),
            (create_text_overlay, reg0, s40, 0x00002000),
            (position_set_x, pos60, ":x"),
            (position_set_y, pos60, ":y"),
            (overlay_set_position, reg0, pos60),
            (position_set_x, pos61, ":width"),
            (position_set_y, pos61, ":height"),
            (overlay_set_area_size, reg0, pos61),
            (try_begin),
                (neq, ":auto_start", 0),
                (set_container_overlay, reg0),
            (try_end),
        ]
    ),

    ("lco_create_troop_portrait",
        [
            (store_script_param, ":troop_id", 1),
            (store_script_param, ":x", 2),
            (store_script_param, ":y", 3),
            (store_script_param, ":x_scale", 4),
            (store_script_param, ":y_scale", 5),
            (create_mesh_overlay_with_tableau_material, reg0, -1, "tableau_troop_note_mesh", ":troop_id"),
            (set_fixed_point_multiplier, 1000),
            (position_set_x, pos60, ":x"),
            (position_set_y, pos60, ":y"),
            (overlay_set_position, reg0, pos60),
            (position_set_x, pos61, ":x_scale"),
            (position_set_y, pos61, ":y_scale"),
            (overlay_set_size, reg0, pos61),
        ]
    ),

    ("lco_create_textbox",
        [
            (store_script_param, ":x", 1),
            (store_script_param, ":y", 2),
            (store_script_param, ":width", 3),
            (store_script_param, ":height", 4),
            (set_fixed_point_multiplier, 1000),
            (create_simple_text_box_overlay, reg0),
            (position_set_x, pos60, ":x"),
            (position_set_y, pos60, ":y"),
            (overlay_set_position, reg0, pos60),
            (position_set_x, pos61, ":width"),
            (position_set_y, pos61, ":height"),
            (overlay_set_size, reg0, pos61),
        ]
    ),

# Lav modifications end (custom lord notes) chief

#para piedras y boil en multiplayer chief
  ("agent_deliver_damage_to_agent",
                          [
                            (store_script_param, ":agent_deliverer", 1),
                            (store_script_param, ":agent", 2),
                            (store_script_param, ":damage", 3),
                            (store_agent_hit_points,":health",":agent",1),
                            (val_sub,":health",":damage"),
                            (val_max,":health",0),
                            (agent_set_hit_points,":agent",":health",1),
                            (this_or_next|gt, ":health", 0),
                            (agent_deliver_damage_to_agent,":agent_deliverer",":agent"),
                            (assign,reg0,":health"),
]),
("cf_flail_reaction", [
			
       (store_script_param, ":event_type", 1),
       (store_script_param,":attacker_agent_no",2),
       (store_script_param, ":player_no", 3),
       (player_is_active, ":player_no"),
        (player_get_agent_id, ":agent_no", ":player_no"),
        (agent_is_active, ":agent_no"),
       (eq,":event_type", action_react_to_flail_attack),
       
       (try_begin),
          (agent_is_active, ":attacker_agent_no"),
          #(agent_is_alive, ":attacker_agent_no"),
          (agent_get_wielded_item_slot_no, ":slot_no", ":attacker_agent_no"),
          (val_add, ":slot_no", bmm_item_1),
          (agent_body_meta_mesh_set_vertex_keys_time_point, ":attacker_agent_no", ":slot_no", 10),
          (agent_set_slot, ":attacker_agent_no", "slot_agent_flail_using", 1),
          (agent_get_bone_position,pos1,":attacker_agent_no",hb_item_r, 1),
          (play_sound_at_position, "snd_chain", pos1),
        (try_end),
]),

("explosion_at_pos1",
                          [
                            (set_fixed_point_multiplier, 100),
                            (store_script_param, ":range",1),
                            (store_script_param, ":damage",2),
                            (store_script_param, ":agent_deliverer",3),
                            (particle_system_burst, "psys_cooking_smoke", pos1, 30),
                            (particle_system_burst, "psys_cooking_smoke", pos1, 30),
                            (particle_system_burst, "psys_small_explosion", pos1, 3),
                            (particle_system_burst, "psys_cooking_fire_1", pos1, 3),
                            (particle_system_burst, "psys_boiling_water", pos1, 30),
                            (particle_system_burst, "psys_boiling_water", pos1, 30),
                            #ym - should use groundhit sounds, but the ones we have are too annoying right now.
                            (store_random_in_range,reg1,0,4),
                            (val_add,reg1,"snd_shield_hit_wood_wood"),
                            (play_sound,reg1),
                           
                            (try_begin),
                              (multiplayer_is_server),
                              (try_for_agents,":agent"),
                                (agent_is_alive,":agent"),
                                (agent_is_human,":agent"),
                                (assign,":explosion_area",":range"),
                                (assign,":explosion_damage",":damage"),
                                (agent_get_position,pos2,":agent"),
                                (position_move_z,pos2,100),
                                (get_distance_between_positions,":distance",pos1,pos2),
                                (gt,":explosion_area",":distance"),
                                (store_sub,":distance_inverse",":explosion_area",":distance"),
                                (val_mul,":explosion_damage",":distance_inverse"), #([explosion_area-distance)*explosion_damage]/explosion_area
                                (val_div,":explosion_damage",":explosion_area"),
                                (try_begin),
                                  (ge,":agent_deliverer",0),
                                  (call_script,"script_agent_deliver_damage_to_agent",":agent_deliverer",":agent",":explosion_damage"),
                                (else_try),
                                  (call_script,"script_agent_deliver_damage_to_agent",":agent",":agent",":explosion_damage"),
                                (try_end),
                              (try_end),
                              (try_for_agents,":agent"),
                                (store_mul,":explosion_damage",":damage", 2),
                                (store_mul,":explosion_area",":range", 2),
                                (agent_is_alive,":agent"),
                                (neg|agent_is_human,":agent"),
                                (agent_get_position,pos2,":agent"),
                                (position_move_z,pos2,100),
                                (get_distance_between_positions,":distance",pos1,pos2),
                                (gt,":explosion_area",":distance"),
                                (store_sub,":distance_inverse",":explosion_area",":distance"),
                                (val_mul,":explosion_damage",":distance_inverse"),
                                (val_div,":explosion_damage",":explosion_area"),
                                (try_begin),
                                  (ge,":agent_deliverer",0),
                                  (call_script,"script_agent_deliver_damage_to_agent",":agent_deliverer",":agent",":explosion_damage"),
                                (else_try),
                                  (call_script,"script_agent_deliver_damage_to_agent",":agent",":agent",":explosion_damage"),
                                (try_end),
                              (try_end),
                            (try_end),
]),
  #chief acaba
#dunde alturas chief
("troop_random_type",
 [(try_begin),
     (store_script_param_1, ":troop_no"),
     (neg|troop_is_hero, ":troop_no"),
    #  (troop_get_type, ":type", ":troop_no"),
      (troop_slot_eq, ":troop_no", "slot_troop_default_type", tf_male),  # make sure only troops with originally normal tf_male in module_troops has the value 0
     (store_random_in_range, ":rand", 0, 3),
     (val_mul, ":rand", 2),
     (troop_set_type, ":troop_no", ":rand"), # next agent spawned will be tf_male, tf_alto or tf_bajo
  (try_end), ]),
#dunde alturas acaba chief
#rigale smoke food chief
   ("rigale_smoke_food",
    [
       (store_script_param,":raw_food_type",1),
	   (store_script_param, ":smoked_food_type",2),

			(troop_get_inventory_capacity, ":inv_size", "trp_player"),
			(assign,":numb_hours_needed_for_smoke",1),
			(try_for_range, ":i_slot", 0, ":inv_size"),
				(troop_get_inventory_slot, ":cur_item", "trp_player", ":i_slot"),

				(eq, ":cur_item", ":raw_food_type"),#verify in inv if the slot is fish
				(val_add,":numb_hours_needed_for_smoke",1),#+1 heure
				
				(store_random_in_range,":chance_item_destroyed",1,15),
				(assign, ":temporary_cooking",3),
				(val_add,":temporary_cooking",5),
				
				(try_begin),
				(call_script, "script_cf_player_has_item_without_modifier", ":raw_food_type", imod_rotten),				
					(try_begin),
						(gt,":chance_item_destroyed",":temporary_cooking"),#25% chance of failure
						(troop_remove_item,"trp_player",":raw_food_type"),#(in this case, remove object 
					(else_try),
						(le,":chance_item_destroyed",":temporary_cooking"),#success 
						(troop_remove_item,"trp_player",":raw_food_type"),#remove object					
						(troop_add_item,"trp_player",":smoked_food_type"),#create smoked object
					(try_end),
				(try_end),
			(try_end),				
			(rest_for_hours, ":numb_hours_needed_for_smoke", 6, 0),
		  	(change_screen_return),
     ]),
###rigale chief acaba
#########freelancer chief code
   ("freelancer_attach_party",
    [
	    #prepare player to be part of lord's party
        (party_attach_to_party, "p_main_party", "$enlisted_party"),
        (set_camera_follow_party, "$enlisted_party"),
        (party_set_flags, "$enlisted_party", pf_always_visible, 1),
        (disable_party, "p_main_party"),

		#initialize service variable
		(assign, "$freelancer_state", 1),		
    ]),

   ("freelancer_detach_party",
    [
	    #removes player from commanders party
		(enable_party, "p_main_party"),
        (party_detach, "p_main_party"),
		
		(try_begin),
			(party_is_active, "$enlisted_party"),
			(party_relocate_near_party, "p_main_party", "$enlisted_party", 2),
			(party_set_flags, "$enlisted_party", pf_always_visible, 0),
		(try_end),	
		
	    (set_camera_follow_party, "p_main_party"),
		(assign, "$g_player_icon_state", pis_normal),
	]),

# ADDS THE PLAYER TO THE LORD'S PARTY  
    ("event_player_enlists",
    [
	    #initialize service variables
        (troop_get_xp, ":xp", "trp_player"),
		(troop_set_slot, "trp_player", "slot_troop_freelancer_start_xp", ":xp"),
        (store_current_day, ":day"), 
        (troop_set_slot, "trp_player", "slot_troop_freelancer_start_date", ":day"),
		(party_get_morale, ":morale", "p_main_party"),
		(party_set_slot, "p_main_party", "slot_party_orig_morale", ":morale"),
        #(assign, "$freelancer_state", 1), #moved to script
	
        #needed to stop bug where parties attack the old player party
        (call_script, "script_set_parties_around_player_ignore_player", 2, 4),
        #set lord as your commander
		(assign, "$enlisted_lord", "$g_talk_troop"),
		(troop_get_slot, "$enlisted_party", "$enlisted_lord", "slot_troop_leaded_party"),
        #removes troops from player party
        (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
        (try_for_range_backwards, ":cur_stack", 1, ":num_stacks"), #lower bound is 1 to ignore player character
           (party_stack_get_troop_id, ":cur_troops", "p_main_party", ":cur_stack"),
           (party_stack_get_size, ":cur_size", "p_main_party", ":cur_stack"),
           (party_remove_members, "p_main_party", ":cur_troops", ":cur_size"),
        (try_end),
        
		#set faction relations to allow player to join battles
        (store_troop_faction, ":commander_faction", "$enlisted_lord"),
		(try_begin),
			(store_relation, ":player_relation", ":commander_faction", "fac_player_supporters_faction"),
			(lt, ":player_relation", 5),
			(call_script, "script_set_player_relation_with_faction", ":commander_faction", 5),
		(try_end),
        (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
           (neq, ":commander_faction", ":cur_faction"),
		   (faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
		   (store_relation, ":player_relation", ":cur_faction", "fac_player_supporters_faction"),
		   (ge, ":player_relation", 0),
           (call_script, "script_set_player_relation_with_faction", ":cur_faction", -5),
        (try_end),		

        #adds standard issued equipment
		(try_begin),
			(neg|faction_slot_eq, ":commander_faction", "slot_faction_freelancer_troop", 0),
			(faction_get_slot, "$player_cur_troop", ":commander_faction", "slot_faction_freelancer_troop"),
		(else_try),
			(faction_get_slot, "$player_cur_troop", ":commander_faction", "slot_faction_tier_1_troop"),
		(try_end),		
		(call_script, "script_freelancer_equip_troop", "$player_cur_troop"),

		(call_script, "script_freelancer_attach_party"),
		#makes Lords banner the players
		(troop_get_slot, ":banner", "$enlisted_lord", "slot_troop_banner_scene_prop"),
		(troop_set_slot, "trp_player", "slot_troop_banner_scene_prop", ":banner"),
        (display_message, "@You have been enlisted!"),				

		
        (str_store_troop_name_link, s13, "$enlisted_lord"),
		(str_store_faction_name_link, s14, ":commander_faction"),
		(quest_set_slot, "qst_freelancer_enlisted", "slot_quest_target_party", "$enlisted_party"),
		(quest_set_slot, "qst_freelancer_enlisted", "slot_quest_importance", 3), # TML Reduced relation gain for freelancer. F123 - Submod -> 1.41#gdw tml1 BW5
		(quest_set_slot, "qst_freelancer_enlisted", "slot_quest_xp_reward", 1250), # TML Increased XP reward for freelancer, all three of these are now modified by days in service.
		(quest_set_slot, "qst_freelancer_enlisted", "slot_quest_gold_reward", 250), # TML Increased gold reward for freelancer.
		(setup_quest_text, "qst_freelancer_enlisted"),
		(str_clear, s2), #description. necessary?
        (call_script, "script_start_quest", "qst_freelancer_enlisted", "$enlisted_lord"),
		(str_store_troop_name, s5, "$player_cur_troop"),
		(str_store_string, s5, "@Current rank: {s5}"),
        (add_quest_note_from_sreg, "qst_freelancer_enlisted", 3, s5, 1),		

    ]),

#  RUNS IF THE PLAYER LEAVES THE ARMY

   ("event_player_discharge",
    [
		#removes faction relation given at enlist
		(store_troop_faction, ":commander_faction", "$enlisted_lord"),
		(call_script, "script_change_player_relation_with_faction_ex", ":commander_faction", -5), #chief resta 5 para que el player pierda relacion por irse, y asi cuando baje por debajo de 5 no pueda reengancharse
		(try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
            (neq, ":commander_faction", ":cur_faction"),
			(faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
			(store_relation, ":player_relation", ":cur_faction", "fac_player_supporters_faction"),
			(lt, ":player_relation", 0),
            (call_script, "script_set_player_relation_with_faction", ":cur_faction", 0),
        (try_end),
		# removes standard issued equipment
		# (try_for_range, ":cur_inv_slot", ek_item_0, ek_food),
			# (troop_get_inventory_slot, ":soldier_equipment", "$player_cur_troop", ":cur_inv_slot"),
			# (ge, ":soldier_equipment", 0),
			# (troop_remove_item, "trp_player", ":soldier_equipment"),
		# (try_end),
		
		(store_current_day, ":cur_day"),  # Added to make reward depend on service length. TML. F123 - Submod -> 1.41
		(troop_get_slot, ":service_day_start", "trp_player", "slot_troop_freelancer_start_date"),
		(store_sub, ":service_length", ":cur_day", ":service_day_start"),
		(val_mul, ":service_length", 4), # Added to make reward depend on service length end. TML
		
		(call_script, "script_freelancer_unequip_troop", "$player_cur_troop"),		
		(troop_equip_items, "trp_player"),
		

		(troop_set_slot, "trp_player", "slot_troop_current_mission", 0),
		(troop_set_slot, "trp_player", "slot_troop_days_on_mission", 0),
		(troop_set_slot, "trp_player", "slot_troop_banner_scene_prop", 0),
		(assign, "$freelancer_state", 0),
		(call_script, "script_freelancer_detach_party"),
		(rest_for_hours, 0,0,0),
		(display_message, "@You have left your commander!"),        

        #(call_script, "script_cancel_quest", "qst_freelancer_enlisted"),
			(call_script, "script_finish_quest", "qst_freelancer_enlisted", ":service_length"), # TML - Changed to depend on service length. F123 - Submod -> 1.41
    ]),
	
#  RUNS IF THE PLAYER GOES ON VACATION

    ("event_player_vacation",
    [
	    (troop_set_slot, "trp_player", "slot_troop_current_mission", plyr_mission_vacation), ###move to quests, not missions
		(troop_set_slot, "trp_player", "slot_troop_days_on_mission", 14),
	
		#removes faction relation given at enlist
		(store_troop_faction, ":commander_faction", "$enlisted_lord"),
		(try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
            (neq, ":commander_faction", ":cur_faction"),
			(faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
            (call_script, "script_set_player_relation_with_faction", ":cur_faction", 0),
        (try_end),

		(assign, "$freelancer_state", 2),
		(call_script, "script_freelancer_detach_party"),
		(rest_for_hours, 0,0,0),
		(display_message, "@You have been granted leave!"), 	

		(str_store_troop_name_link, s13, "$enlisted_lord"),
		(str_store_faction_name_link, s14, ":commander_faction"),
		(quest_set_slot, "qst_freelancer_vacation", "slot_quest_target_party", "$enlisted_party"),
		(quest_set_slot, "qst_freelancer_vacation", "slot_quest_importance", 0),
		(quest_set_slot, "qst_freelancer_vacation", "slot_quest_xp_reward", 50),
		(quest_set_slot, "qst_freelancer_vacation",	"slot_quest_expiration_days", 14),
		(setup_quest_text, "qst_freelancer_vacation"),
		(str_clear, s2), #description. necessary?
        (call_script, "script_start_quest", "qst_freelancer_vacation", "$enlisted_lord"),
    ]),

# RUNS WHEN PLAYER RETURNS FROM VACATION

  ("event_player_returns_vacation",
    [
        (troop_set_slot, "trp_player", "slot_troop_current_mission", 0),
		(troop_set_slot, "trp_player", "slot_troop_days_on_mission", 0),
		
		#needed to stop bug where parties attack the old player party
        (call_script, "script_set_parties_around_player_ignore_player", 2, 4),

        #removes troops from player party #Caba--could use party_clear? and then add the player back?
        (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
        (try_for_range_backwards, ":cur_stack", 1, ":num_stacks"), #lower bound is 1 to ignore player character
           (party_stack_get_troop_id, ":cur_troops", "p_main_party", ":cur_stack"),
           (party_stack_get_size, ":cur_size", "p_main_party", ":cur_stack"),
           (party_remove_members, "p_main_party", ":cur_troops", ":cur_size"),
        (try_end),
		
        #To fix any errors of the lord changing parties
		(troop_get_slot, "$enlisted_party", "$enlisted_lord", "slot_troop_leaded_party"),
		
		#set faction relations to allow player to join battles
		(store_troop_faction, ":commander_faction", "$enlisted_lord"),
		(try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
           (neq, ":commander_faction", ":cur_faction"),
		   (faction_slot_eq, ":cur_faction", "slot_faction_state", sfs_active),
           (call_script, "script_set_player_relation_with_faction", ":cur_faction", -5),
        (try_end),	
		(try_begin),
			(store_relation, ":player_relation", ":commander_faction", "fac_player_supporters_faction"),
			(lt, ":player_relation", 5),
			(call_script, "script_set_player_relation_with_faction", ":commander_faction", 5),
		(try_end),

		(call_script, "script_freelancer_attach_party"),
		(display_message, "@You have rejoined your commander!"), 		
    ]),
	
	
  # RUNS IF PLAYER DESERTS OR IS AWOL
  ("event_player_deserts",
   [     
   	(store_troop_faction, ":commander_faction", "$enlisted_lord"),
	(call_script, "script_change_player_relation_with_faction_ex", ":commander_faction", -20), #chief cambia de -10 a -30, la faccion odia al player #gdw-30
    (call_script, "script_change_player_relation_with_troop", "$enlisted_lord", -30), #chief cambia de -10 a -50, su lord no quiere desertoresgdw-50
    (call_script, "script_change_player_honor", -20),
	
	(troop_set_slot, "trp_player", "slot_troop_current_mission", 0),
	(troop_set_slot, "trp_player", "slot_troop_days_on_mission", 0),
	(faction_set_slot, ":commander_faction", "slot_faction_freelancer_troop", 0),
	(troop_set_slot, "trp_player", "slot_troop_banner_scene_prop", 0),
	(rest_for_hours, 0,0,0),
	(assign, "$freelancer_state", 0),
	#(display_message, "@You have deserted your commander!"), #Taken care of elsewhere
	(call_script, "script_fail_quest", "qst_freelancer_enlisted"),
   ]),	
	
	
	# RETURNS PART OF THE ORIGINAL PARTY
    ("party_restore", 
    [
        (store_current_day, ":cur_day"),
        #formula for soldier desertion chance
		(troop_get_slot, ":service_day_start", "trp_player", "slot_troop_freelancer_start_date"),
        (store_sub, ":service_length", ":cur_day", ":service_day_start"), #gets number of days served
		(party_get_slot, ":morale", "p_main_party", "slot_party_orig_morale"),
        (store_add, ":return_chance", 800, ":morale"), #up to 100
        (val_sub, ":return_chance", ":service_length"), #up to far over 100

        #loop that looks at each troop stack in a party, 
        #then decides if troops of that stack will return, 
        #and randomly assigns a number of troops in that stack to return
        (party_get_num_companion_stacks, ":num_stacks", "p_freelancer_party_backup"),
        (try_for_range, ":cur_stack", 0, ":num_stacks"),
			(assign, ":stack_amount", 0),
			(party_stack_get_troop_id, ":return_troop", "p_freelancer_party_backup", ":cur_stack"),
			(neq, ":return_troop", "trp_player"),
			(try_begin),
				(troop_is_hero, ":return_troop"), #bugfix for companions (simple, they always return)
				(assign, ":stack_amount", 1),
			(else_try),
				#limit may need changed for more accurate probability
				(store_random_in_range, ":return_random", 0, 1000),
				(is_between, ":return_random", 0, ":return_chance"),
				(party_stack_get_size, ":stack_size", "p_freelancer_party_backup", ":cur_stack"),
				#checks what chance there is that all troops in stack will return
				(store_random_in_range, ":return_random", 0, 1000),
				(try_begin),
					(is_between, ":return_random", 0, ":return_chance"),
					(assign, ":stack_amount", ":stack_size"),
				(else_try),
					#else random number of troops return
					(store_random_in_range, ":stack_amount", 0, ":stack_size"),
				(try_end),
			(try_end),
			(ge, ":stack_amount", 1),
			(party_add_members, "p_main_party", ":return_troop", ":stack_amount"),
        (try_end),
		(party_clear, "p_freelancer_party_backup"),
    ]),

#  CALCULATES NUMBER OF DESERTING TROOPS

   ("get_desert_troops", #CABA - check this
    [
        (party_get_morale, ":commander_party_morale", "$enlisted_party"), #does this actually get tracked for non-player parties?
        (store_current_day, ":cur_day"),
        #formula for soldier desertion chance
        #gets number of days served
		(troop_get_slot, ":service_day_start", "trp_player", "slot_troop_freelancer_start_date"),
        (store_sub, ":service_length", ":cur_day", ":service_day_start"),
        #inverts the commander's party morale
        (store_sub, ":commander_neg_morale", 100, ":commander_party_morale"), #still a positive number... 100-80 = 20
        (store_skill_level, ":cur_leadership", "skl_leadership", "trp_player"),
        (store_skill_level, ":cur_persuasion", "skl_persuasion", "trp_player"),
        #had to multiply these skills to give them a decent effect on desertion chance
        (val_mul, ":cur_leadership", 10), #up to 100
        (val_mul, ":cur_persuasion", 10), #up to 100
        (store_add, ":desert_chance", ":cur_leadership", ":cur_persuasion"), #up to 200
		(val_add, ":desert_chance", ":service_length"), #up to 400 maybe
        (val_add, ":desert_chance", ":commander_neg_morale"), #up to 450, maybe? if party morale is down to 50
        #loop that looks at each troop stack in a party, 
        #then decides if troops of that stack will desert, 
        #and randomly assigns a number of troops in that stack to desert
        (party_get_num_companion_stacks, ":num_stacks", "$enlisted_party"),
        (try_for_range_backwards, ":cur_stack", 1, ":num_stacks"),
            #limit may need changed for more accurate probability
            (store_random_in_range, ":desert_random", 0, 1000),
            (is_between, ":desert_random", 0, ":desert_chance"),
			#switching deserting troops to player party
			(party_stack_get_troop_id, ":desert_troop", "$enlisted_party", ":cur_stack"),
			(party_stack_get_size, ":stack_size", "$enlisted_party", ":cur_stack"),
			(store_random_in_range, ":stack_amount", 0, ":stack_size"),
			(party_remove_members, "$enlisted_party", ":desert_troop", ":stack_amount"),
			(party_add_members, "p_main_party", ":desert_troop", ":stack_amount"),
        (try_end),        		
    ]),
	
  ("freelancer_keep_field_loot",
   [
	(get_player_agent_no, ":player"),
	(try_for_range, ":ek_slot", ek_item_0, ek_head),
		(agent_get_item_slot, ":item", ":player", ":ek_slot"), 
		(gt, ":item", 0),
		(neg|troop_has_item_equipped, "trp_player", ":item"),
		(troop_add_item, "trp_player", ":item"),
	(try_end),
	(agent_get_horse, ":horse", ":player"),
	(try_begin),
	  (gt, ":horse", 0),
	  (agent_get_item_id, ":horse", ":horse"),
	  (troop_get_inventory_slot, ":old_horse", "trp_player", ek_horse),
	  (neq, ":horse", ":old_horse"),
	  (try_begin),
		(gt, ":old_horse", 0),
		(troop_get_inventory_slot_modifier, ":horse_imod", "trp_player", ek_horse),
		(troop_add_item, "trp_player", ":old_horse", ":horse_imod"),
	  (try_end),
	  (troop_set_inventory_slot, "trp_player", ek_horse, ":horse"),
	(try_end),
   ]),
	  
   ("cf_freelancer_player_can_upgrade",
   #Reg0 outputs reason for failure
   [
	(store_script_param_1, ":source_troop"),
	
	(troop_get_inventory_capacity, ":troop_cap", ":source_troop"),	
	(assign, ":continue", 1),
	
	(assign, ":type_available", 0),
	(assign, ":type_count", 0),
	(assign, ":end", itp_type_arrows),
	(try_for_range, ":type", itp_type_one_handed_wpn, ":end"),
		#Count Items from Source Troop
		(assign, ":end2", ":troop_cap"),
		(try_for_range, ":inv_slot", 0, ":end2"),
		    (troop_get_inventory_slot, ":item", ":source_troop", ":inv_slot"),
			(gt, ":item", 0),
			(item_get_type, ":item_type", ":item"),
			(eq, ":item_type", ":type"),
			(val_add, ":type_count", 1),
			(call_script, freelancer_can_use_item, "trp_player", ":item", 0),
			(eq, reg0, 1),		
			(assign, ":type_available", 1),
			(assign, ":end2", 0), #break
		(try_end),
		(eq, ":type_available", 1),
		(assign, ":end", itp_type_one_handed_wpn), #break
	(try_end), #Melee loop
	(try_begin),
		(eq, ":type_available", 0),
		(gt, ":type_count", 0), #only care if there were items possible to equip
		(assign, ":continue", 0),
		(assign, reg0, 0),
	(try_end),
	(eq, ":continue", 1),
	
	(assign, ":type_available", 0),
	(assign, ":type_count", 0),
	(assign, ":end2", ":troop_cap"),
	(try_for_range, ":inv_slot", 0, ":end2"),
		(troop_get_inventory_slot, ":item", ":source_troop", ":inv_slot"),
		(gt, ":item", 0),
		(item_get_type, ":item_type", ":item"),
		(eq, ":item_type", itp_type_body_armor),
		(val_add, ":type_count", 1),
		(call_script, freelancer_can_use_item, "trp_player", ":item", 0),
		(eq, reg0, 1),		
		(assign, ":type_available", 1),
		(assign, ":end2", 0), #break
	(try_end),
	(try_begin),
		(eq, ":type_available", 0),
		(gt, ":type_count", 0), #only care if there were items possible to equip
		(assign, ":continue", 0),
		(assign, reg0, 1),
	(try_end),
	(eq, ":continue", 1),
	
	(try_begin),
		(troop_is_guarantee_ranged, ":source_troop"),
		(assign, ":type_available", 0),
		(assign, ":type_count", 0),
		(assign, ":end", itp_type_goods),
		(try_for_range, ":type", itp_type_bow, ":end"),
			#Count Items from Source Troop
			(assign, ":end2", ":troop_cap"),
			(try_for_range, ":inv_slot", 0, ":end2"),
				(troop_get_inventory_slot, ":item", ":source_troop", ":inv_slot"),
				(gt, ":item", 0),
				(item_get_type, ":item_type", ":item"),
				(eq, ":item_type", ":type"),
				(val_add, ":type_count", 1),
				(call_script, freelancer_can_use_item, "trp_player", ":item", 0),
				(eq, reg0, 1),		
				(assign, ":type_available", 1),
				(assign, ":end2", 0), #break
			(try_end),
			(eq, ":type_available", 1),
			(assign, ":end", itp_type_bow), #break
		(try_end), #Ranged loop
		(eq, ":type_available", 0),
		(gt, ":type_count", 0), #only care if there were items possible to equip
		(assign, ":continue", 0),
		(assign, reg0, 2), 
	(try_end),
	(eq, ":continue", 1),
	
	(try_begin),
		(troop_is_guarantee_horse, ":source_troop"),
		(assign, ":type_available", 0),
		(assign, ":type_count", 0),
		(assign, ":end2", ":troop_cap"),
		(try_for_range, ":inv_slot", 0, ":end2"),
			(troop_get_inventory_slot, ":item", ":source_troop", ":inv_slot"),
			(gt, ":item", 0),
			(item_get_type, ":item_type", ":item"),
			(eq, ":item_type", itp_type_horse),
			(val_add, ":type_count", 1),
			(call_script, freelancer_can_use_item, "trp_player", ":item", 0),
			(eq, reg0, 1),		
			(assign, ":type_available", 1),
			(assign, ":end2", 0), #break
		(try_end),
		(eq, ":type_available", 0),
		(gt, ":type_count", 0), #only care if there were items possible to equip
		(assign, ":continue", 0),
		(assign, reg0, 3),
	(try_end),
	(eq, ":continue", 1),	
   ]),
   
   
    ("freelancer_equip_troop",
   [
    (store_script_param_1, ":source_troop"),
	
	(str_clear, s2),
	(set_show_messages, 0),
	
	(assign, ":recording_slot", "slot_freelancer_equip_begin"),
	(troop_get_inventory_capacity, ":troop_cap", ":source_troop"),
	(assign, ":melee_given", 0),
	(assign, ":needs_ammo", 0),
	(assign, ":open_weapon_slot", 0),
	(try_for_range, ":type", itp_type_horse, itp_type_pistol),
	    (neq, ":type", itp_type_goods),
		(neq, ":type", itp_type_arrows),
		(neq, ":type", itp_type_bolts),
		
		#Assign Prob. of Getting Type
		(assign, ":continue", 0),
		(try_begin),
			(troop_is_guarantee_horse, ":source_troop"),
		    (eq, ":type", itp_type_horse),
			(assign, ":continue", 1),
		(else_try),
		    (troop_is_guarantee_ranged, ":source_troop"),
		    (this_or_next|eq, ":type", itp_type_bow),
			(this_or_next|eq, ":type", itp_type_crossbow),
			(eq, ":type", itp_type_thrown),
			(assign, ":continue", 1),
		(else_try),
		    (this_or_next|eq, ":type", itp_type_shield), #Shields and all armor pieces are guaranteed
		    (ge, ":type", itp_type_head_armor),
			(assign, ":continue", 1),
		(else_try),
		    (neq, ":type", itp_type_horse),
		    (lt, ":open_weapon_slot", 4),
			(store_random_in_range, ":continue", 0, 3), # 1 chance in three of being 1
		(try_end),
		(eq, ":continue", 1),		
		
		#Clear Temp Array
		(try_for_range, ":inv_slot", 0, 20),
			(troop_set_slot, "trp_temp_array_a", ":inv_slot", 0),
		(try_end),	
		
		#Collect Items from Source Troop
		(assign, ":type_count", 0),
		(try_for_range, ":inv_slot", 0, ":troop_cap"),
		    (troop_get_inventory_slot, ":item", ":source_troop", ":inv_slot"),
			(gt, ":item", 0),
			(item_get_type, ":item_type", ":item"),
			(eq, ":item_type", ":type"),
			(call_script, freelancer_can_use_item, "trp_player", ":item", 0),
			(eq, reg0, 1),		
			(troop_set_slot, "trp_temp_array_a", ":type_count", ":item"),
			(val_add, ":type_count", 1),
		(try_end),
		(gt, ":type_count", 0),
		
		#Pick Random Item of Type from Troop
		(try_begin),
		    (eq, ":type_count", 1),
			(assign, ":index", 0),
		(else_try),
			(store_random_in_range, ":index", 0, ":type_count"),
		(try_end),
		(troop_get_slot, ":item", "trp_temp_array_a", ":index"),
		(gt, ":item", 0),		
		(str_store_item_name, s3, ":item"),
		(str_store_string, s2, "@{s3}, {s2}"),
		
		#Select correct EK slot to force equip
		(try_begin),
		    (eq, ":type", itp_type_horse),
			(assign, ":ek_slot", ek_horse),
		(else_try),
		    (is_between, ":type", itp_type_head_armor, itp_type_pistol),
			(store_sub, ":shift", ":type", itp_type_head_armor),
			(store_add, ":ek_slot", ek_head, ":shift"),
		(else_try),
			(store_add, ":ek_slot", ek_item_0, ":open_weapon_slot"),
		(try_end),
		
		#Check for item already there, move it if present
		(try_begin),
		    (troop_get_inventory_slot, ":old_item", "trp_player", ":ek_slot"),
			(gt, ":old_item", 0),
			(troop_get_inventory_slot_modifier, ":old_item_imod", "trp_player", ":ek_slot"),
			(troop_add_item, "trp_player", ":old_item", ":old_item_imod"),
		(try_end),
		
		#Add Item
		(troop_set_inventory_slot, "trp_player", ":ek_slot", ":item"),
		(party_set_slot, "p_freelancer_party_backup", ":recording_slot", ":item"),
		(val_add, ":recording_slot", 1),
		(try_begin),
		    (is_between, ":type", itp_type_one_handed_wpn, itp_type_head_armor), #Uses one of the 4 weapon slots
		    (val_add, ":open_weapon_slot", 1),
			(try_begin),
				(is_between, ":type", itp_type_one_handed_wpn, itp_type_arrows),
				(assign, ":melee_given", 1),
            (else_try),
				(eq, ":type", itp_type_bow),
				(assign, ":needs_ammo", itp_type_arrows),
			(else_try),
				(eq, ":type", itp_type_crossbow),
				(assign, ":needs_ammo", itp_type_bolts),
			(try_end),
		(try_end),
	(try_end), #Item Types Loop
	 
    #add ammo for any equipped bow
    (try_begin),
	    (neq, ":needs_ammo", 0),		
		#Check for item already in the last slot, move it if present
		(try_begin), 
		    (troop_get_inventory_slot, ":old_item", "trp_player", ek_item_3),
			(gt, ":old_item", 0),
			(troop_get_inventory_slot_modifier, ":old_item_imod", "trp_player", ek_item_3),
			(troop_add_item, "trp_player", ":old_item", ":old_item_imod"), 
		(try_end),
		
		(assign, ":end", ":troop_cap"),
		(try_for_range, ":inv_slot", 0, ":end"),
		    (troop_get_inventory_slot, ":item", ":source_troop", ":inv_slot"),
			(gt, ":item", 0),
			(item_get_type, ":type", ":item"),
			(eq, ":type", ":needs_ammo"),
			(troop_set_inventory_slot, "trp_player", ek_item_3, ":item"),
			(party_set_slot, "p_freelancer_party_backup", ":recording_slot", ":item"),
		    (val_add, ":recording_slot", 1),
			(assign, ":open_weapon_slot", 4),
			(str_store_item_name, s3, ":item"),
		    (str_store_string, s2, "@{s3}, {s2}"),
			(assign, ":end", 0),
		(try_end),
	(try_end), 
	
	#double check melee was given
	(try_begin),
	    (eq, ":melee_given", 0),
		(assign, ":end", ":troop_cap"),
		(try_for_range, ":inv_slot", 0, ":end"),
		    (troop_get_inventory_slot, ":item", ":source_troop", ":inv_slot"),
			(gt, ":item", 0),
			(item_get_type, ":type", ":item"),
			(is_between, ":type", itp_type_one_handed_wpn, itp_type_arrows),
			(call_script, freelancer_can_use_item, "trp_player", ":item", 0),
			(eq, reg0, 1),	
			(try_begin),
			    (gt, ":open_weapon_slot", 3),
			    (assign, ":open_weapon_slot", 2),
			(try_end),
			
			#Check for item already there
			(try_begin),
				(troop_get_inventory_slot, ":old_item", "trp_player", ":open_weapon_slot"),
				(gt, ":old_item", 0),
				(troop_get_inventory_slot_modifier, ":old_item_imod", "trp_player", ":open_weapon_slot"),
				(troop_add_item, "trp_player", ":old_item", ":old_item_imod"),
			(try_end),
			
			(troop_set_inventory_slot, "trp_player", ":open_weapon_slot", ":item"),		
			(party_set_slot, "p_freelancer_party_backup", ":recording_slot", ":item"),
		    (val_add, ":recording_slot", 1),
			(str_store_item_name, s3, ":item"),
		    (str_store_string, s2, "@{s3}, {s2}"),
		    (assign, ":end", 0),
		(try_end),
	(try_end), 
	
    (set_show_messages, 1),
	(try_begin),
		(neg|str_is_empty, s2),
		(val_sub, ":recording_slot", "slot_freelancer_equip_begin"),
		(party_set_slot, "p_freelancer_party_backup", "slot_freelancer_equip_number_items", ":recording_slot"),	#Record Number of Items Added
		
		(str_store_troop_name, s1, ":source_troop"),
		(display_message, "@The equipment of a {s1}: {s2}is assigned to you."),	
	(try_end),
   ]),
	
  ("freelancer_unequip_troop",
   [
    (store_script_param_1, ":source_troop"),

	(str_clear, s2),	
	(set_show_messages, 0),
	
	(party_get_slot, ":num_items", "p_freelancer_party_backup", "slot_freelancer_equip_number_items"), #Num of items previously given
	
    (troop_get_inventory_capacity, ":cap", "trp_player"),		
	(try_for_range, ":i", 0, ":num_items"),
	    (store_add, ":slot", "slot_freelancer_equip_begin", ":i"),
	    (party_get_slot, ":given_item", "p_freelancer_party_backup", ":slot"),
		(gt, ":given_item", 0),
		
		(assign, ":end", ":cap"),
		(try_for_range, ":inv_slot", 0, ":end"),
			(troop_get_inventory_slot, ":item", "trp_player", ":inv_slot"),
			(eq, ":item", ":given_item"),			
			(troop_get_inventory_slot_modifier, ":imod", "trp_player", ":inv_slot"),
			(eq, ":imod", 0), #Native troop items never have modifiers
			
			(troop_set_inventory_slot, "trp_player", ":inv_slot", -1),
			(str_store_item_name, s3, ":item"),
			(str_store_string, s2, "@{s3}, {s2}"),
			
			(assign, ":end", 0), #Break
		(try_end), #Player Inventory Loop
	(try_end), #Item Given Slot Loop

	(set_show_messages, 1),
	(try_begin),
		(neg|str_is_empty, s2),
		(party_set_slot, "p_freelancer_party_backup", "slot_freelancer_equip_number_items", 0),	#Reset Number of Items Added
		(str_store_troop_name, s1, ":source_troop"),
		(display_message, "@The equipment of a {s1}: {s2}is taken from you."),
	(try_end),	
	(troop_equip_items, "trp_player"),
   ]), 
#+freelancer end
###################################
  # Can a troop qualify to use this item?
  # Returns 1 = yes, 0 = no.
  ("dplmc_troop_can_use_item",
  [
     (store_script_param, ":troop", 1),
     (store_script_param, ":item", 2),
     (store_script_param, ":item_modifier", 3),

     (item_get_slot, ":difficulty", ":item", "slot_item_difficulty"),
     (item_get_type, ":type", ":item"),
     (try_begin),
       (eq, ":difficulty", 0), # don't apply imod modifiers if item has no requirement
     (else_try),
       (eq, ":item_modifier", imod_stubborn),
       (val_add, ":difficulty", 1),
     (else_try),
       (eq, ":item_modifier", imod_timid),
       (val_sub, ":difficulty", 1),
     (else_try),
       (eq, ":item_modifier", imod_heavy),
       (neq, ":type", itp_type_horse), #heavy horses don't increase difficulty
       (val_add, ":difficulty", 1),
     (else_try),
       (eq, ":item_modifier", imod_strong),
       (val_add, ":difficulty", 2),
     (else_try),
       (eq, ":item_modifier", imod_masterwork),
       (val_add, ":difficulty", 4),
     (try_end),

     (item_get_type, ":type", ":item"),
     (try_begin),
       (eq, ":type", itp_type_horse),
       (store_skill_level, ":skill", skl_riding, ":troop"),
     (else_try),
       (this_or_next|eq, ":type", itp_type_crossbow),
       (this_or_next|eq, ":type", itp_type_one_handed_wpn),
       (this_or_next|eq, ":type", itp_type_two_handed_wpn),
       (this_or_next|eq, ":type", itp_type_polearm),
       (this_or_next|eq, ":type", itp_type_head_armor),
       (this_or_next|eq, ":type", itp_type_body_armor),
       (this_or_next|eq, ":type", itp_type_foot_armor),
       (eq, ":type", itp_type_hand_armor),
       (store_attribute_level, ":skill", ":troop", ca_strength),
     (else_try),
       (eq, ":type", itp_type_shield),
       (store_skill_level, ":skill", skl_shield, ":troop"),
     (else_try),
       (eq, ":type", itp_type_bow),
       (store_skill_level, ":skill", skl_power_draw, ":troop"),
     (else_try),
       (eq, ":type", itp_type_thrown),
       (store_skill_level, ":skill", skl_power_throw, ":troop"),
     (try_end),

     (try_begin),
       (lt, ":skill", ":difficulty"),
       (assign, reg0, 0),
     (else_try),
       (assign, reg0, 1),
     (try_end),
  ]),
#+freelancer end code chief acaba
  
###gambling items chief
  ## CC gambling begin
  ("refresh_mystic_merchant_items",
    [
      (store_script_param_1, ":troop_no"),
     
      (troop_get_inventory_capacity, ":inv_cap", ":troop_no"),
      (try_for_range, ":i_slot", 10, ":inv_cap"),
        (troop_set_inventory_slot, ":troop_no", ":i_slot", -1),
        (troop_set_slot, ":troop_no", ":i_slot", 0), # 0 = not_hidden , 1 = hidden
      (try_end),
      (reset_item_probabilities, 100),
      (set_merchandise_modifier_quality, 120),
      (troop_add_merchandise, ":troop_no", itp_type_horse,15),
      (troop_add_merchandise, ":troop_no", itp_type_body_armor,16),
      (troop_add_merchandise, ":troop_no", itp_type_head_armor,8),
      (troop_add_merchandise, ":troop_no", itp_type_foot_armor,8),
      (troop_add_merchandise, ":troop_no", itp_type_hand_armor,4),
      (troop_add_merchandise, ":troop_no", itp_type_one_handed_wpn,5),
      (troop_add_merchandise, ":troop_no", itp_type_two_handed_wpn,5),
      (troop_add_merchandise, ":troop_no", itp_type_polearm,5),
      (troop_add_merchandise, ":troop_no", itp_type_shield,6),
      (troop_add_merchandise, ":troop_no", itp_type_bow,4),
      (troop_add_merchandise, ":troop_no", itp_type_crossbow,3),
      (troop_add_merchandise, ":troop_no", itp_type_thrown,5),
      (try_for_range, ":i_slot", 10, ":inv_cap"),
        (troop_get_inventory_slot, ":item", ":troop_no", ":i_slot"),
        (gt, ":item", -1),
        (troop_set_slot, ":troop_no", ":i_slot", 1), # 0 = not_hidden , 1 = hidden
      (try_end),
   ]),

  #  ("get_item_value_with_imod",##gdw i cut and pasted this from near the bottom need to be mreged
  # [# returns the sell price based on the item's money value and its imod
  #   (store_script_param, ":item", 1),
  #   (store_script_param, ":imod", 2),

  #   (store_item_value, ":score", ":item"),
  #   (item_get_slot, ":imod_multiplier", ":imod", "slot_item_modifier_multiplier"),
  #   (val_mul, ":score", ":imod_multiplier"),
  #   (assign, reg0, ":score"),
  # ]),
  ("get_item_value_with_imod",
    [# returns the sell price based on the item's money value and its imod
      (store_script_param, ":item", 1),
      (store_script_param, ":imod", 2),

      (store_item_value, ":score", ":item"),
      (try_begin),
        (eq, ":imod", imod_plain),
        (assign, ":imod_multiplier", 100),
      (else_try),
        (eq, ":imod", imod_cracked),
        (assign, ":imod_multiplier", 48),#gdw
      (else_try),
        (eq, ":imod", imod_rusty),
        (assign, ":imod_multiplier", 58),#gdw
      (else_try),
        (eq, ":imod", imod_bent),
        (assign, ":imod_multiplier", 63),#gdw
      (else_try),
        (eq, ":imod", imod_chipped),
        (assign, ":imod_multiplier", 70),#gdw
      (else_try),
        (eq, ":imod", imod_battered),
        (assign, ":imod_multiplier", 72),#gdw
      (else_try),
        (eq, ":imod", imod_poor),
        (assign, ":imod_multiplier", 78),#gdw
      (else_try),
        (eq, ":imod", imod_crude),
        (assign, ":imod_multiplier", 83),#gdw
      (else_try),
        (eq, ":imod", imod_old),
        (assign, ":imod_multiplier", 84),#gdw
      (else_try),
        (eq, ":imod", imod_cheap),
        (assign, ":imod_multiplier", 87),#gdw
      (else_try),
        (eq, ":imod", imod_fine),
        (assign, ":imod_multiplier", 172),#gdw10
      (else_try),
        (eq, ":imod", imod_well_made),
        (assign, ":imod_multiplier", 230),#gdw
      (else_try),
        (eq, ":imod", imod_sharp),
        (assign, ":imod_multiplier", 145),#gdw
      (else_try),
        (eq, ":imod", imod_balanced),
        (assign, ":imod_multiplier", 325),#gdw8%
      (else_try),
        (eq, ":imod", imod_tempered),
        (assign, ":imod_multiplier", 545),#gdw
      (else_try),
        (eq, ":imod", imod_deadly),
        (assign, ":imod_multiplier", 790),#gdw
      (else_try),
        (eq, ":imod", imod_exquisite),
        (assign, ":imod_multiplier", 1130),#gdw10%
      (else_try),
        (eq, ":imod", imod_masterwork),
        (assign, ":imod_multiplier", 1375),#gdw
      (else_try),
        (eq, ":imod", imod_heavy),
        (assign, ":imod_multiplier", 178),#gdw
      (else_try),
        (eq, ":imod", imod_strong),
        (assign, ":imod_multiplier", 490),#gdw
      (else_try),
        (eq, ":imod", imod_powerful),
        (assign, ":imod_multiplier", 320),#gdw
      (else_try),
        (eq, ":imod", imod_tattered),
        (assign, ":imod_multiplier", 50),#gdw
      (else_try),
        (eq, ":imod", imod_ragged),
        (assign, ":imod_multiplier", 70),#gdw
      (else_try),
        (eq, ":imod", imod_rough),
        (assign, ":imod_multiplier", 60),#gdw
      (else_try),
        (eq, ":imod", imod_sturdy),
        (assign, ":imod_multiplier", 160),#gdw
      (else_try),
        (eq, ":imod", imod_thick),
        (assign, ":imod_multiplier", 250),#gdw
      (else_try),
        (eq, ":imod", imod_hardened),
        (assign, ":imod_multiplier", 360),#gdw
      (else_try),
        (eq, ":imod", imod_reinforced),
        (assign, ":imod_multiplier", 500),#gdw
      (else_try),
        (eq, ":imod", imod_superb),
        (assign, ":imod_multiplier", 250),#gdw10%
      (else_try),
        (eq, ":imod", imod_lordly),
        (assign, ":imod_multiplier", 700),#gdw1150
      (else_try),
        (eq, ":imod", imod_lame),
        (assign, ":imod_multiplier", 43),#gdwincreased from 40
      (else_try),
        (eq, ":imod", imod_swaybacked),
        (assign, ":imod_multiplier", 55),#gdw
      (else_try),
        (eq, ":imod", imod_stubborn),
        (assign, ":imod_multiplier", 83),#gdw
      (else_try),
        (eq, ":imod", imod_timid),
        (assign, ":imod_multiplier", 162),#gdw10%
      (else_try),
        (eq, ":imod", imod_meek),
        (assign, ":imod_multiplier", 162),#gdw10%
      (else_try),
        (eq, ":imod", imod_spirited),
        (assign, ":imod_multiplier", 428),#gdw10%
      (else_try),
        (eq, ":imod", imod_champion),
        (assign, ":imod_multiplier", 917),#gdw10%
      (else_try),
        (eq, ":imod", imod_fresh),
        (assign, ":imod_multiplier", 100),
      (else_try),
        (eq, ":imod", imod_day_old),
        (assign, ":imod_multiplier", 100),
      (else_try),
        (eq, ":imod", imod_two_day_old),
        (assign, ":imod_multiplier", 85),#gdw1
      (else_try),
        (eq, ":imod", imod_smelling),
        (assign, ":imod_multiplier", 40),
      (else_try),
        (eq, ":imod", imod_rotten),
        (assign, ":imod_multiplier", 5),
      (else_try),
        (eq, ":imod", imod_large_bag),
        (assign, ":imod_multiplier", 162),
      (try_end),
      (val_mul, ":score", ":imod_multiplier"),
      (assign, reg0, ":score"),
    ]),
   #(gdw moved to match floris
  ("init_item_score", initialize_items_slots()),
 
  ("get_item_score_with_imod", [
    (store_script_param, ":item", 1),
    (store_script_param, ":imod", 2),

    (item_get_type, ":type", ":item"),
    (try_begin),
      (eq, ":type", itp_type_book),
      (item_get_slot, ":i_score", ":item", "slot_item_intelligence_requirement"),
    (else_try),
      (eq, ":type", itp_type_horse),
      (item_get_slot, ":horse_speed", ":item", "slot_item_horse_speed"),
      (item_get_slot, ":horse_armor", ":item", "slot_item_horse_armor"),
      (item_get_slot, ":horse_charge", ":item", "slot_item_horse_charge"),
      (try_begin),
        (eq, ":imod", imod_swaybacked),
        (val_add, ":horse_speed", -2),
      (else_try),
        (eq, ":imod", imod_lame),
        (val_add, ":horse_speed", -5),
      (else_try),
        (eq, ":imod", imod_heavy),
        (val_add, ":horse_armor", 3),
        (val_add, ":horse_charge", 4),
      (else_try),
        (eq, ":imod", imod_spirited),
        (val_add, ":horse_speed", 1),
        (val_add, ":horse_armor", 1),
        (val_add, ":horse_charge", 1),
      (else_try),
        (eq, ":imod", imod_champion),
        (val_add, ":horse_speed", 2),
        (val_add, ":horse_armor", 2),
        (val_add, ":horse_charge", 2),
      (try_end),

      (store_mul, ":i_score", ":horse_speed", ":horse_armor"),
      (val_mul, ":i_score", ":horse_charge"),
    (else_try),
      (eq, ":type", itp_type_shield),
      (item_get_slot, ":shield_size", ":item", "slot_item_length"),
      (item_get_slot, ":shield_armor", ":item", "slot_item_body_armor"),
      (item_get_slot, ":shield_speed", ":item", "slot_item_speed"),

      (try_begin),
        (eq, ":imod", imod_cracked),
        (val_add, ":shield_armor", -4),
      (else_try),
        (eq, ":imod", imod_battered),
        (val_add, ":shield_armor", -2),
      (else_try),
        (eq, ":imod", imod_thick),
        (val_add, ":shield_armor", 2),
      (else_try),
        (eq, ":imod", imod_reinforced),
        (val_add, ":shield_armor", 4),
      (try_end),

      (val_add, ":shield_armor", 5),
      (store_mul, ":i_score", ":shield_armor", ":shield_size"),
      (val_mul, ":i_score", ":shield_speed"),
    (else_try),
      (this_or_next|eq, ":type", itp_type_head_armor),
      (this_or_next|eq, ":type", itp_type_body_armor),
      (this_or_next|eq, ":type", itp_type_foot_armor),
      (eq, ":type", itp_type_hand_armor),
      (item_get_slot, ":head_armor", ":item", "slot_item_head_armor"),
      (item_get_slot, ":body_armor", ":item", "slot_item_body_armor"),
      (item_get_slot, ":leg_armor", ":item", "slot_item_leg_armor"),
      (store_add, ":i_score", ":head_armor", ":body_armor"),
      (val_add, ":i_score", ":leg_armor"),

      (assign, ":imod_effect_mul", 0),
      (try_begin),
        (gt, ":head_armor", 0),
        (val_add, ":imod_effect_mul", 1),
      (try_end),
      (try_begin),
        (gt, ":body_armor", 0),
        (val_add, ":imod_effect_mul", 1),
      (try_end),
      (try_begin),
        (gt, ":leg_armor", 0),
        (val_add, ":imod_effect_mul", 1),
      (try_end),

      (try_begin),
        (eq, ":imod", imod_plain),
        (assign, ":imod_effect", 0),
      (else_try),
        (eq, ":imod", imod_cracked),
        (assign, ":imod_effect", -4),
      (else_try),
        (eq, ":imod", imod_rusty),
        (assign, ":imod_effect", -3),
      (else_try),
        (eq, ":imod", imod_battered),
        (assign, ":imod_effect", -2),
      (else_try),
        (eq, ":imod", imod_crude),
        (assign, ":imod_effect", -1),
      (else_try),
        (eq, ":imod", imod_tattered),
        (assign, ":imod_effect", -3),
      (else_try),
        (eq, ":imod", imod_ragged),
        (assign, ":imod_effect", -2),
      (else_try),
        (eq, ":imod", imod_sturdy),
        (assign, ":imod_effect", 1),
      (else_try),
        (eq, ":imod", imod_thick),
        (assign, ":imod_effect", 2),
      (else_try),
        (eq, ":imod", imod_hardened),
        (assign, ":imod_effect", 3),
      (else_try),
        (eq, ":imod", imod_reinforced),
        (assign, ":imod_effect", 4),
      (else_try),
        (eq, ":imod", imod_lordly),
        (assign, ":imod_effect", 6),
      (try_end),

      (val_mul, ":imod_effect", ":imod_effect_mul"),
      (val_add, ":i_score", ":imod_effect"),
    (else_try),
      (this_or_next|eq, ":type", itp_type_polearm),
      (this_or_next|eq, ":type", itp_type_two_handed_wpn),
      (this_or_next|eq, ":type", itp_type_bow),
      (this_or_next|eq, ":type", itp_type_one_handed_wpn),
      (eq, ":type", itp_type_crossbow),
      (item_get_slot, ":item_speed", ":item", "slot_item_speed"),
      (item_get_slot, ":item_length", ":item", "slot_item_length"),
      (item_get_slot, ":swing_damage", ":item", "slot_item_swing_damage"),
      (item_get_slot, ":thrust_damage", ":item", "slot_item_thrust_damage"),
      (val_mod, ":swing_damage", 256),
      (val_mod, ":thrust_damage", 256),
      (assign, ":item_damage", ":swing_damage"),
      (val_max, ":item_damage", ":thrust_damage"),

      (try_begin),
        (eq, ":imod", imod_cracked),
        (val_add, ":item_damage", -5),
      (else_try),
        (eq, ":imod", imod_rusty),
        (val_add, ":item_damage", -3),
        (val_add, ":item_speed", -2),
      (else_try),
        (eq, ":imod", imod_bent),
        (val_add, ":item_damage", -3),
        (val_add, ":item_speed", -3),
      (else_try),
        (eq, ":imod", imod_chipped),
        (val_add, ":item_damage", -2),
      (else_try),
        (eq, ":imod", imod_balanced),
        (val_add, ":item_damage", 3),
        (val_add, ":item_speed", 3),
      (else_try),
        (eq, ":imod", imod_tempered),
        (val_add, ":item_damage", 4),
        (val_add, ":item_speed", 3),
      (else_try),
        (eq, ":imod", imod_masterwork),
        (val_add, ":item_damage", 6),
        (val_add, ":item_speed", 2),
      (else_try),
        (eq, ":imod", imod_heavy),
        (val_add, ":item_damage", 2),
        (val_add, ":item_speed", -2),
      (else_try),
        (eq, ":imod", imod_strong),
        (val_add, ":item_damage", 3),
        (val_add, ":item_speed", -3),
      (try_end),

      (try_begin),
        (this_or_next|eq, ":type", itp_type_bow),
        (eq, ":type", itp_type_crossbow),
        (store_mul, ":i_score", ":item_damage", ":item_speed"),
      (else_try),
        (this_or_next|eq, ":type", itp_type_one_handed_wpn),
        (this_or_next|eq, ":type", itp_type_two_handed_wpn),
        (eq, ":type", itp_type_polearm),
        (store_mul, ":i_score", ":item_damage", ":item_speed"),
        (val_mul, ":i_score", ":item_length"),
      (try_end),
    (else_try),
      (this_or_next|eq, ":type", itp_type_arrows),
      (this_or_next|eq, ":type", itp_type_bolts),
      (eq, ":type", itp_type_thrown),
      (item_get_slot, ":thrust_damage", ":item", "slot_item_thrust_damage"),
      (val_mod, ":thrust_damage", 256),
      (assign, ":i_score", ":thrust_damage"),
      (val_add, ":i_score", 3), # +3 to make sure damage > 0

      (try_begin),
        (eq, ":imod", imod_plain),
        (val_mul, ":i_score", 2),
      (else_try),
        (eq, ":imod", imod_large_bag),
        (val_mul, ":i_score", 2),
        (val_add, ":i_score", 1),
      (else_try),
        (eq, ":imod", imod_bent),
        (val_sub, ":i_score", 3),
        (val_mul, ":i_score", 2),
      (else_try),
        (eq, ":imod", imod_heavy),
        (val_add, ":i_score", 2),
        (val_mul, ":i_score", 2),
      (else_try),
        (eq, ":imod", imod_balanced),
        (val_add, ":i_score", 3),
        (val_mul, ":i_score", 2),
      (try_end),
    (try_end),

    (assign, reg0, ":i_score"),
    (assign, reg1, ":item"),
    (assign, reg10, ":item_damage"),
    ]),


## CC gambling end chief acaba gambling

#-## Outposts begin chief
  # script_set_walker_to_type
  # Input: arg1 = walker_id, arg2 = troop_id
  # Output: none
  ("set_walker_to_type",
   [
       (store_script_param, ":walker_id", 1),
       (store_script_param, ":troop_id", 2),
       # transfer items
       (try_for_range,":item_no",horses_end,ranged_weapons_end),
          (store_item_kind_count,":num_items",":item_no",":walker_id"),
          (ge,":num_items",1),
          (troop_remove_items,":walker_id",":item_no",":num_items"),
       (try_end),
       (try_for_range,":item_no",horses_end,ranged_weapons_end),
          (store_item_kind_count,":num_items",":item_no",":troop_id"),
          (ge,":num_items",1),
          (store_item_kind_count,":num_items",":item_no",":walker_id"),
          (lt,":num_items",1),
          (troop_add_items,":walker_id",":item_no",1),
       (try_end),
       (troop_equip_items,":walker_id"),
     ]),

  # script_init_fort_patrols
  # Input: none
  # Output: none
  ("init_fort_patrols",
    [
     (try_for_agents, ":cur_agent"),
       (agent_get_troop_id, ":cur_troop", ":cur_agent"),
       (agent_get_entry_no, ":entry_no", ":cur_agent"),
       (try_begin),
         (eq, ":cur_troop", "trp_merc_infantryt2"),
         (entry_point_get_position, pos1, ":entry_no"),
         (agent_set_position, ":cur_agent", pos1),		# force agents into the proper spot to prevent wonkyness
         (val_add, ":entry_no", 1),
         (agent_set_slot, ":cur_agent", 0, ":entry_no"),
         (entry_point_get_position, pos2, ":entry_no"),
         
         (agent_set_speed_limit, ":cur_agent", 1),
         (agent_set_scripted_destination, ":cur_agent", pos2, 0),
       (else_try),
         (this_or_next|eq, ":cur_troop", "trp_tutorial_rider_1"),
         (eq, ":entry_no", 20),
         (agent_is_human, ":cur_agent"),
         (call_script, "script_init_mounted_patrol", ":cur_agent"),
       (try_end),
     (try_end),
  ]),
  
  # script_init_mounted_patrol
  # Input: arg1 = agent number
  # Output: none
  ("init_mounted_patrol",
    [
       (store_script_param, ":cur_agent", 1),
       (agent_get_entry_no, ":entry_no", ":cur_agent"),
       (agent_set_stand_animation, ":cur_agent", "anim_ride_0"),
       (agent_set_walk_forward_animation, ":cur_agent", "anim_ride_1"),
       (agent_set_animation, ":cur_agent", "anim_ride_0"),
       (agent_set_animation_progress, ":cur_agent", 10),
       
       (store_add, ":target_entry_point", ":entry_no", 1),
       (entry_point_get_position, pos1, ":target_entry_point"),
       (agent_set_slot, ":cur_agent", 0, ":target_entry_point"),
       (agent_set_speed_limit, ":cur_agent", mount_patrol_max_speed),
       (agent_set_scripted_destination, ":cur_agent", pos1, 0),
       
  ]),
  
  # script_tick_fort_patrol
  # Input: arg1 = agent_id, arg2 = number of way points
  # Output: none
  ("cf_tick_fort_patrol",
    [
     (store_script_param, ":agent_id", 1),
     (store_script_param, ":num_points", 2),
     
     (agent_get_entry_no, ":entry_no", ":agent_id"),
     (agent_get_slot, ":target_entry_point", ":agent_id", 0),
     (agent_get_class, ":agent_class", ":agent_id"),
     (entry_point_get_position, pos1, ":target_entry_point"),
     (agent_get_position, pos2, ":agent_id"),
     (get_distance_between_positions, ":distance", pos1, pos2),
     (try_begin),
       (eq, ":agent_class", grc_cavalry),
       (lt, ":distance", mount_patrol_closing_dist),
       (store_sub, ":speed_adjust", mount_patrol_closing_dist, ":distance"),
       (val_mul, ":speed_adjust", 100),
       (val_div, ":speed_adjust", mount_patrol_closing_dist),
       (store_sub, ":speed_limit", mount_patrol_max_speed, mount_patrol_min_speed),
       (val_mul, ":speed_limit", -1),
       (val_mul, ":speed_adjust", ":speed_limit"),
       (val_div, ":speed_adjust", 100),
       (val_add, ":speed_adjust", mount_patrol_max_speed), # maxspeed - 10*(6000-dist)/6000 scales from max to min speed as we close to destination
       (agent_set_speed_limit, ":agent_id", ":speed_adjust"), # once agent is within closing distance, it scales down from max speed to min speed as it reaches target
       (assign, reg3, ":agent_id"),
       (assign, reg4, ":speed_adjust"),
       #(display_message, "@Agent #{reg3} reducing max speed to {reg4}."),
     (try_end),
     (lt, ":distance", 400),
     (store_random_in_range, ":random_no", 0, 100),
     (lt, ":random_no", 20),
     (store_add, ":max_point", ":entry_no", ":num_points"),
     (val_add, ":target_entry_point", 1),
     (try_begin),
       (gt, ":target_entry_point", ":max_point"),
       (assign, ":target_entry_point", ":entry_no"),
     (try_end),
     (try_begin),
       (eq, ":agent_class", grc_cavalry),
       (agent_set_speed_limit, ":agent_id", 15),
     (try_end),
     (entry_point_get_position, pos1, ":target_entry_point"),
     (agent_set_slot, ":agent_id", 0, ":target_entry_point"),
     (agent_set_scripted_destination, ":agent_id", pos1, 0),
  ]),
 #-## Outposts end
  
#chief entretenimiento skill bardo
# script_entertain_income
# input_1 = income
# input_2 = income_type
# used on playing music or making a speech
  ("entertain_income",
   [(store_script_param, reg12, 1),
	(store_script_param, ":income_type", 2),
	(try_begin),
	######### HONOR #########
	  (eq, ":income_type", income_honor),
	  (val_div, reg12, 30),
	  (val_add, "$player_honor", reg12),
	  (assign, reg13, "$player_honor"),
	  (try_begin),
		(gt, reg12, 0),
		(display_message, "@Your reputation has increased {reg12}, and it is {reg13} now.", 0x33ff33),
	  (else_try),
		(lt, reg12, 0),
		(val_mul, reg12, -1),
		(display_message, "@Your reputation has decreased {reg12}, and it is {reg13} now.", 0xff3333),
	  (else_try),
		(display_message, "@People think neither better or worse of you.", 0xff3333),
	  (try_end),
	(else_try),
	######### REPUTATION #########
	  (eq, ":income_type", income_reputation),
	  (val_div, reg12, 30),
	  (troop_get_slot, ":reputation", "trp_player", "slot_troop_renown"),
	  (val_add, ":reputation", reg12),
	  (troop_set_slot, "trp_player", "slot_troop_renown", ":reputation"),
	  (assign, reg13, ":reputation"),
	  (try_begin),
		(gt, reg12, 0),
		(display_message, "@You gained {reg12} renown, and it is {reg13} now.", 0x33ff33),
	  (else_try),
		(lt, reg12, 0),
		(val_mul, reg12, -1),
		(display_message, "@You lost {reg12} renown, and it is {reg13} now.", 0xff3333),
	  (else_try),
		(display_message, "@No one listens to you.", 0xff3333),
	  (try_end),
	(else_try),
	######### RIGHT TO RULE #########
     (eq, ":income_type", income_right_to_rule),

      (val_div, reg12, 30),
      (try_begin),
        (neq, reg12, 0),

        (party_get_slot, ":influence", "$current_town", "slot_town_prosperity"),

        (store_random_in_range, ":roll", 0, 500),    #expectation that player can gain 100 RtR after doing this half the game

        (try_begin),
          (gt, ":roll", ":influence"),
          (assign, reg12, 0),
        (else_try),
          (gt, reg12, 0),
          (assign, reg12, 1),
        (else_try),
          (assign, reg12, -1),
        (try_end),

      (try_end),

      (val_add, "$player_right_to_rule", reg12),
      (assign, reg13, "$player_right_to_rule"),
      (try_begin),
        (gt, reg12, 0),

        (display_message, "@You gained {reg12} right to rule, and you have {reg13} now.", 0x33ff33),

      (else_try),
        (lt, reg12, 0),
        (val_mul, reg12, -1),

        (display_message, "@You lost {reg12} right to rule, and you have {reg13} now.", 0xff3333),
     (else_try),
        (display_message, "@Your claims to rule fall on deaf ears.", 0xff3333),
      (try_end),
    (else_try),
    ######### BARDIC REPUTATION #########
     (eq, ":income_type", income_bard_reputation),

     #MOTO tweak entertainment start
     # (val_div, reg12, 2),
     (val_mul, reg12, "$entertainment_skill_required"),    #bardic rep grows with performance of more difficult works of music

     (store_skill_level, ":skill", "skl_entertain", "trp_player"),      #use as declining multiplier (to make bonus 1-54)
     (convert_to_fixed_point, ":skill"),
     (store_sqrt, reg0, ":skill"),
     (convert_from_fixed_point, reg0),
     (val_mul, reg12, reg0),

     (assign, reg0, "$bardic_reputation"),
     (val_max, reg0, 2),    #allow major coup for debut (but not above 50 renown)
     (val_div, reg12, reg0),    #undo basis of income on bardic rep (see mnu_perform_music)

     (try_begin),
       (gt, reg12, 0),
       (troop_get_slot, ":reputation", "trp_player", "slot_troop_renown"),
       (val_add, ":reputation", reg12),
       (troop_set_slot, "trp_player", "slot_troop_renown", ":reputation"),
     (try_end),
     #MOTO tweak entertainment end

     (val_add, "$bardic_reputation", reg12),
     (assign, reg13, "$bardic_reputation"),
     (try_begin),
       (gt, reg12, 0),
       (display_message, "@You gained {reg12} bardic reputation, and it is {reg13} now. Also {reg12} renown.", 0x33ff33),    #MOTO tweak entertainment
     (else_try),
       (lt, reg12, 0),
       (val_mul, reg12, -1),
       (display_message, "@You lost {reg12} bardic reputation, and it is {reg13} now.", 0xff3333),    #MOTO tweak entertainment
     (try_end),
   (else_try),
    ######### DENARS #########
      (try_begin),
        (gt, reg12, 0),
        (set_show_messages, 0),
        (troop_add_gold, "trp_player", reg12),
        (set_show_messages, 1),
        (store_troop_gold, reg13, "trp_player"),
        (display_message, "@You got {reg12} scillingas, and you have {reg13} now.", 0x33ff33),
      (else_try),
        (lt, reg12, 0),
        (val_mul, reg12, -1),
        (store_troop_gold, reg13, "trp_player"),
        (val_min, reg12, reg13),    #avoid removing more than player has
        (set_show_messages, 0),
        (troop_remove_gold, "trp_player", reg12),
        (set_show_messages, 1),
        (store_troop_gold, reg13, "trp_player"),
        (display_message, "@You lost {reg12} scillingas, and you have {reg13} now.", 0xff3333),
      (try_end),
	(try_end),
   ]),

#LAZERAS MODIFIED  {Top Tier Troops Recruit} chief
   # ##script_upgrade_troop_to_hero
   # ##usage   : (call_script,"script_upgrade_troop_to_hero",<troop_ID>,<hero_ID>),
   # ##Input 1 : <troop_ID> should be one of troop_id of top tier troop
   # ##Input 2 : <hero_ID> should be one of troop_id of inactive hero on module_troops.py
   # ##This must be passed.  The code block calling this script should have already checked if there is that troop.
   # ##Output: None, will adjust p_main_party
   # ##May call a dialog to communicate this happening
   ("upgrade_troop_to_hero",
      [(store_script_param,":troop_id",1),
       (store_script_param,":hero_id",2),
       (try_begin),
          (main_party_has_troop, ":troop_id"),
          (troop_slot_eq, ":hero_id", "slot_troop_occupation", ":troop_id"),
          (troop_set_slot,":hero_id", "slot_troop_occupation", slto_player_companion),
          (party_remove_members,"p_main_party",":troop_id",1),      # ##remove the regular troop
          (party_add_members,"p_main_party",":hero_id",1),          # ##Add the hero found
       (try_end),
      ]),
#LAZERAS MODIFIED  {Top Tier Troops Recruit}
 ###somebody patrullas chief de mercenarios
   #identify party as patrol
   #input: party
   #output: reg0    MOTO remove
   #0 yes, 1 no

   ("cf_is_patrol", [    #MOTO make a proper T/F function
       (store_script_param, ":cur_party", 1),
       # (assign, reg0, 1),
       (store_faction_of_party,":cur_faction",":cur_party"),
       (eq, ":cur_faction", "fac_player_supporters_faction"),
       (party_stack_get_troop_id,":cur_troop",":cur_party",0),
       #(neq,":cur_troop","trp_player"),
       # (try_begin),
           #(this_or_next|party_slot_eq, ":cur_party", "slot_party_type", spt_raiders),
           #(troop_is_hero, ":cur_troop"),
           (eq, ":cur_troop", "trp_mercenary_leader"),
           # (assign, reg0, 0),
       # (try_end),
     ]
   ),

   #find all patrols and count them
   #input: none
   #output: reg0
   #amount of existing patrols

   ("check_for_patrols", [
       (assign,":num",0),
       (try_for_parties,":cur_party"),
           (call_script, "script_cf_is_patrol",":cur_party"),
           # (eq,reg0,0),    MOTO not needed
           (val_add,":num",1),
       (try_end),
       (assign,reg0,":num"),
     ]
   ),
  
   #enforce patrol party size limit
   #it is assumed that the party prisoner limit equals zero
   #except for npc prisoners

   #input: party, mode
   #mode 0: delete all troops w/o doing anything else
   #mode 1: all deleted troops are being added to the player party

   #output: none (it uses reg0, but the information is useless outside of this script and its recursive brother)
   #MOTO furthermore never INTENDED as condition, so change to always return TRUE

   ("cf_fix_party_size", [
   (store_script_param, ":cur_party", 1),
   (store_script_param, ":mode", 2),
   # (call_script, "script_cf_is_patrol",":cur_party"),    MOTO avoid returning a FALSE (not handled properly in calls)
   (try_begin),
       # (eq,reg0,0),    MOTO not needed...
       (call_script, "script_cf_is_patrol",":cur_party"),    #MOTO ...when calling directly
       (party_stack_get_troop_id,":cur_troop",":cur_party",0),
       (call_script,"script_game_get_party_companion_limit2",":cur_troop"),
       # (call_script,"script_cf_fix_party_size_recursive",":cur_party",":mode"),    MOTO rename
       (call_script,"script_fix_party_size_recursive",":cur_party",":mode"),

       # (assign,":bool",0),
       # (party_get_num_prisoner_stacks, ":num_stacks",":cur_party"),
       # (try_for_range_backwards,":index",0,":num_stacks"),
           # (party_prisoner_stack_get_troop_id,":cur_troop",":cur_party",":index"),

           # (try_for_range,":num",companions_begin,heroes_end),
               # (eq,":cur_troop",":num"),
               # (assign,":bool",1),
           # (try_end),
   ##                                (try_begin),
   ##                                  (neg|is_between, ":cur_troop",companions_begin,heroes_end),
   ##                                  (party_prisoner_stack_get_size,":cur_size",":cur_party",":index"),
   ##                                  # (assign, ":bool", 1),
   ##                                # (try_end),
   ##                                # (try_begin),
   ##                                  # (neq,":bool",1),
   ##                                  (party_remove_prisoners,":cur_party",":cur_troop",":cur_size"),
   ##                                (try_end),
       # (try_end),
   (try_end),
   ]
   ),

   #a while do loop for cf_fix_party_size
   #don't use it outside of the previous script

   # ("cf_fix_party_size_recursive", #I am not exactly happy about the recursive
   ("fix_party_size_recursive", [ #MOTO rename; not a T/F function
       (store_script_param, ":cur_party", 1),
       (store_script_param, ":mode", 2),
       (assign,":reg0_backup",reg0),
       (store_party_size_wo_prisoners,":num",":cur_party"),
       (try_begin),
           (gt,":num",reg0),
           (neq,0,reg0),
           (store_sub,":delta",":num",reg0),
           (party_get_num_companion_stacks,":num_stacks",":cur_party"),
           (assign, ":to_del_stack",0),
           (assign, ":checker", 100),
           (try_for_range,":index",1,":num_stacks"), #do not get rid of comapnion
               (party_stack_get_troop_id,":cur_troop",":cur_party",":index"),
               (store_character_level,":cur_level",":cur_troop"),
               (le,":cur_level",":checker"),
               (assign,":checker",":cur_level"),
               (assign,":to_del_stack",":index"),
           (try_end),
           (party_stack_get_size,":num_troop",":cur_party",":to_del_stack"),
           (party_stack_get_troop_id,":cur_troop",":cur_party",":to_del_stack"),
           # (try_begin),
           # (le,":num_troop",":delta"),
           # (assign, ":delta", ":num_troop"),
           # (try_end),
           (val_min, ":delta", ":num_troop"),
           (party_remove_members,":cur_party",":cur_troop",":delta"),
           (try_begin),
               (eq,":mode",1),
               (assign, reg0, ":delta"),
               (str_store_troop_name_by_count, s1, ":cur_troop", ":delta"),
               (str_store_string, s2, "@lack of room"),
               (party_add_members,"p_main_party",":cur_troop",":delta"),
               (display_message, "str_custom_reinforce"),
           (try_end),
           (assign,reg0,":reg0_backup"),
           # (call_script,"script_cf_fix_party_size_recursive",":cur_party",":mode"),    MOTO rename
           (call_script,"script_fix_party_size_recursive",":cur_party",":mode"),
       (try_end),
     ]
   ),
  #----------------------------------------------------------------------------------


###somebody patrullas chief
###patrullas player chief
  ##chief rigale
 # script_rigale_random_troop_death_or_wounded
("rigale_random_troop_death_or_wounded",
 [ 
  (store_script_param, ":chance_to_die",1),
  (store_script_param, ":chance_to_be_wounded",2),
  (store_script_param, ":party_no",3),

 
 
 
       (party_get_num_companion_stacks, ":num_stacks",":party_no"), 
	   
       (try_for_range, ":i_stack", 0, ":num_stacks"),   
			(party_stack_get_size, ":stack_size",":party_no",":i_stack"),
			(party_stack_get_troop_id, ":troop_id", ":party_no", ":i_stack"),

			(str_store_troop_name,s1,":troop_id"),
			(try_for_range,":troop_id",0,":stack_size"), #chief cambia variable suelta
				(neg|troop_is_hero,":troop_id"),
				(store_random_in_range,":random_check",1,101),				
				(try_begin),
					(le,":random_check",":chance_to_die"),
					(party_remove_members,":party_no",":troop_id",1),
					(display_message,"@A {s1} dies"),
				(else_try),
					(le,":random_check",":chance_to_be_wounded"),
					#(party_wound_members,":party_no",":troop_id",1),
					(troop_set_health,":troop_id",10),
					(display_message,"@A {s1} is wounded"),		
				(try_end),
			(try_end),
	  (try_end),
	(str_clear,s1), 
	]), #Floris/STAT end

  # script_rigale_learn_from_failure
("rigale_learn_from_failure",
 [
	(store_script_param_1, ":min_xp_bonus"),
	(store_script_param_2, ":max_xp_bonus"),

	(store_attribute_level,":bonus_intelligence","trp_player",ca_intelligence),
	(store_random_in_range, ":rand_bonus_intelligence", 1, 21),
	(store_add,":total_int_bonus",":rand_bonus_intelligence",":bonus_intelligence"),
	(try_begin),
		(lt,":total_int_bonus",19),#gdw22	
		(str_store_string, s16, "@You globaly don't understand why you failed."),
	(else_try),
		(ge,":total_int_bonus",19),#gdw22
		(store_random_in_range, ":overall_xp_gain", ":min_xp_bonus", ":max_xp_bonus"),
		(add_xp_to_troop, ":overall_xp_gain", "trp_player"),
		(assign,reg6,":overall_xp_gain"),
		(str_store_string, s16, "@You globaly understand why you failed, and so gain {reg6} extra experience from your failure."),	
	(try_end),			
	]
	),

 ("rigale_check_sneaking_success",
 [
	(try_begin),
		(is_between,"$player_honor",-20,-5),
		(assign,":dishonor_bonus",1),(display_message,"@You have a slight dishonor Bonus"),
	(else_try),
		(is_between,"$player_honor",-50,-20),
		(assign,":dishonor_bonus",2), (display_message,"@You have a mild dishonor Bonus"),
 	(else_try),
		(lt,"$player_honor",-50),
		(assign,":dishonor_bonus",3), 
	(try_end),

	(party_get_current_terrain,":ambush_terrain","p_main_party"),

	(try_begin),
	(eq,":ambush_terrain",rt_plain),
	(assign,":terrain_modificator", -1), (display_message,"@You have a slight terrain malus on this plain."),
	(else_try),
	(eq,":ambush_terrain",rt_mountain),
	(assign,":terrain_modificator", 2), (display_message,"@You have a slight terrain bonus on this mountain."),
	(else_try),
	(eq,":ambush_terrain",rt_steppe),
	(assign,":terrain_modificator", -5),(display_message,"@You have a strong terrain malus on this steppe."),
	(else_try),
	(eq,":ambush_terrain",rt_snow),
	(assign,":terrain_modificator",-1 ), (display_message,"@You have a slight terrain malus on this snowy plain."),
	(else_try),
	(eq,":ambush_terrain",rt_desert),
	(assign,":terrain_modificator",-1 ), (display_message,"@You have a slight terrain malus on this desert."),
	(else_try),
	(eq,":ambush_terrain",rt_bridge),
	(assign,":terrain_modificator", -1), (display_message,"@You have a slight terrain malus on this bridge."),
	(else_try),
	(eq,":ambush_terrain",rt_mountain_forest),(display_message,"@You have a very strong terrain bonus on this mountainous forest."),
	(assign,":terrain_modificator",6 ), 
	(else_try),
	(eq,":ambush_terrain",rt_steppe_forest),
	(assign,":terrain_modificator", 5), (display_message,"@You have a strong terrain bonus on this steppe forest."),
	(else_try),
	(eq,":ambush_terrain",rt_forest),
	(assign,":terrain_modificator", 5), (display_message,"@You have a strong terrain bonus on this forest."),
	(else_try),
	(eq,":ambush_terrain",rt_snow_forest),
	(assign,":terrain_modificator", 5), (display_message,"@You have a strong terrain bonus on this snowy forest."),
	(else_try),
	(eq,":ambush_terrain",rt_desert_forest),
	(assign,":terrain_modificator", 5), (display_message,"@You have a strong terrain bonus on this desert forest."),
	(try_end),

	
	(party_get_num_companions,":party_size","p_main_party"),
	(val_div,":party_size",10),
	(try_begin),
	(gt,":party_size",1),
	(display_message,"@Your big party imposes you a malus to sneaking."),
	(try_end),

	(store_random_in_range,":sneak_factor",1,2),#chief anade
	(assign,":sneak_final",":sneak_factor"),#chief anade	
		(party_get_skill_level, ":skill_sneaking1", "p_main_party", skl_tactics), #chief anade 
		(party_get_skill_level, ":skill_sneaking2", "p_main_party", skl_tracking), #chief anade 
	(val_add,":sneak_final",":skill_sneaking1"),#chief anade
	(val_add,":sneak_final",":skill_sneaking2"),#chief anade
  	(try_begin),
		(is_between,":sneak_final",0,8),
		(assign,":modificateur",-4),
	(else_try),
		(is_between,":sneak_final",8,12),
		(assign,":modificateur",-2),
 	(else_try),
		(is_between,":sneak_final",12,16),
		(assign,":modificateur",0),
 	(else_try),
		(is_between,":sneak_final",16,19),
		(assign,":modificateur",2),
 	(else_try),
		(is_between,":sneak_final",19,22),
		(assign,":modificateur",4),
 	(else_try),
		(ge,":sneak_final",22),
		(assign,":modificateur",7),		
	(try_end),
 

 
	(store_random_in_range,":random_factor",1,21),
	(assign,":final_factor",":random_factor"),
	
	(val_add,":final_factor",":dishonor_bonus"),
	(val_add,":final_factor",":terrain_modificator"),
	(val_sub,":final_factor",":party_size"),	
	
	
	(val_add,":final_factor",":modificateur"),
	
	(try_begin),
		(this_or_next|eq,":random_factor",1),
		(le,":final_factor",3),
		(neq,":modificateur",7),#no critical failure for grand masters
		(assign, "$type_of_sneaking_success", 4),
	(else_try),
		(is_between,":final_factor",4,11),
		(assign, "$type_of_sneaking_success", 3),
 	(else_try),
		(is_between,":final_factor",11,18),
		(assign, "$type_of_sneaking_success", 2), 
	(else_try),
 		(this_or_next|eq,":random_factor",20),
		(ge,":final_factor",18),
		(assign, "$type_of_sneaking_success", 1),
	(try_end),
  ]
 ),
 
 
("rigale_check_ambushing_success",
 [
	(try_begin),
		(is_between,"$player_honor",-20,-5),
		(assign,":dishonor_bonus",1),(display_message,"@You have a slight dishonor Bonus"),
	(else_try),
		(is_between,"$player_honor",-50,-20),
		(assign,":dishonor_bonus",2), (display_message,"@You have a mild dishonor Bonus"),
 	(else_try),
		(lt,"$player_honor",-50),
		(assign,":dishonor_bonus",3), 
	(try_end),

	(party_get_current_terrain,":ambush_terrain","p_main_party"),

	(try_begin),
	(eq,":ambush_terrain",rt_plain),
	(assign,":terrain_modificator", -1), (display_message,"@You have a slight terrain malus on this plain."),
	(else_try),
	(eq,":ambush_terrain",rt_mountain),
	(assign,":terrain_modificator", 2), (display_message,"@You have a slight terrain bonus on this mountain."),
	(else_try),
	(eq,":ambush_terrain",rt_steppe),
	(assign,":terrain_modificator", -5),(display_message,"@You have a strong terrain malus on this steppe."),
	(else_try),
	(eq,":ambush_terrain",rt_snow),
	(assign,":terrain_modificator",-1 ), (display_message,"@You have a slight terrain malus on this snowy plain."),
	(else_try),
	(eq,":ambush_terrain",rt_desert),
	(assign,":terrain_modificator",-1 ), (display_message,"@You have a slight terrain malus on this desert."),
	(else_try),
	(eq,":ambush_terrain",rt_bridge),
	(assign,":terrain_modificator", -1), (display_message,"@You have a slight terrain malus on this bridge."),
	(else_try),
	(eq,":ambush_terrain",rt_mountain_forest),(display_message,"@You have a very strong terrain bonus on this mountainous forest."),
	(assign,":terrain_modificator",6 ), 
	(else_try),
	(eq,":ambush_terrain",rt_steppe_forest),
	(assign,":terrain_modificator", 5), (display_message,"@You have a strong terrain bonus on this steppe forest."),
	(else_try),
	(eq,":ambush_terrain",rt_forest),
	(assign,":terrain_modificator", 5), (display_message,"@You have a strong terrain bonus on this forest."),
	(else_try),
	(eq,":ambush_terrain",rt_snow_forest),
	(assign,":terrain_modificator", 5), (display_message,"@You have a strong terrain bonus on this snowy forest."),
	(else_try),
	(eq,":ambush_terrain",rt_desert_forest),
	(assign,":terrain_modificator", 5), (display_message,"@You have a strong terrain bonus on this desert forest."),
	(try_end),

		
	(store_random_in_range,":ambush_factor",1,2),#chief anade
	(assign,":ambush_final",":ambush_factor"),#chief anade	
		(party_get_skill_level, ":skill_ambush1", "p_main_party", skl_tactics), #chief anade 
		(party_get_skill_level, ":skill_ambush2", "p_main_party", skl_tracking), #chief anade 
	(val_add,":ambush_final",":skill_ambush1"),#chief anade
	(val_add,":ambush_final",":skill_ambush2"),#chief anade 
  	(try_begin),
		(is_between,":ambush_final",0,8),
		(assign,":modificateur",-4),
	(else_try),
		(is_between,":ambush_final",8,12),
		(assign,":modificateur",-2),
 	(else_try),
		(is_between,":ambush_final",12,15),
		(assign,":modificateur",0),
 	(else_try),
		(is_between,":ambush_final",16,19),
		(assign,":modificateur",2),
 	(else_try),
		(is_between,":ambush_final",19,22),
		(assign,":modificateur",4),
 	(else_try),
		(ge,":ambush_final",22),
		(assign,":modificateur",7),		
	(try_end),
 

 
	(store_random_in_range,":random_factor",1,21),
	(assign,":final_factor",":random_factor"),
	
	(val_add,":final_factor",":dishonor_bonus"),
	(val_add,":final_factor",":terrain_modificator"),	
	
	(val_add,":final_factor",":modificateur"),
	
	(try_begin),
		(this_or_next|eq,":random_factor",1),
		(le,":final_factor",3),
		(neq,":modificateur",7),#no critical failure for grand masters
		(assign, "$type_of_ambushing_success", 4),
	(else_try),
		(is_between,":final_factor",4,11),
		(assign, "$type_of_ambushing_success", 3),
 	(else_try),
		(is_between,":final_factor",11,18),
		(assign, "$type_of_ambushing_success", 2), 
	(else_try),
 		(this_or_next|eq,":random_factor",20),
		(ge,":final_factor",18),
		(assign, "$type_of_ambushing_success", 1),
	(try_end),
  ]
 ),
      # script_get_total_equipment_weight:called by game_get_skill_modifier_for_troop
   # INPUT:##gdw added this from Diplom via Floris 110815
   # param1: troop_no
   # OUTPUT: total equipment weight
  ("get_total_equipment_weight",
     [
       (store_script_param_1, ":troop_no"),
       
       (assign, ":total_weight", 0),
       (try_for_range, ":cur_slot", 0, 8),#equipment slots
         (troop_get_inventory_slot, ":cur_item", ":troop_no", ":cur_slot"),
         (ge, ":cur_item", 0),
         #(item_get_slot, ":cur_item_weight", ":cur_item", "slot_item_weight"),
         (item_get_weight, ":cur_item_weight",":cur_item"),
         (val_add, ":total_weight", ":cur_item_weight"),
       (try_end),
       #(val_div, ":total_weight", 100),
       (assign, reg0, ":total_weight"),
   ]),
#morir desangrado y perdida de dano por heridas hecho por amarillo chief blood loss
  ("monitor_health",
    [
        (try_for_agents,":agent_id"),
            (agent_is_alive,":agent_id"),
            (store_agent_hit_points,":current_hp",":agent_id", 1),
            (agent_get_slot,":old_hp",":agent_id","slot_agent_hp"),
            (try_begin),
                (gt,":old_hp",":current_hp"),   # Damage taken
                (agent_set_slot,":agent_id","slot_agent_hp",":current_hp"),
                (store_sub,":new_rate",":old_hp",":current_hp"),
                (gt,":new_rate",dmg_threshold),
               
##                #debug start
##                (str_store_agent_name,s1,":agent_id"),
##                (assign,reg1,":new_rate"),
##                (try_begin),
##                    (agent_is_human,":agent_id"),
###                    (display_message,"@{s1} recived {reg1} damage"),
##                (else_try),
###                    (display_message,"@{s1}s horse recived {reg1} damage"),
##                (try_end),
##                #debug end
               
                (val_sub,":new_rate",dmg_threshold),
                (store_random_in_range,":mul",dmg_low_range,dmg_hi_range),
                (val_mul,":new_rate",":mul"),
                (val_div,":new_rate",10),
               
##                #debug start
##                (assign,reg1,":new_rate"),
##                (display_message,"@damage reduced to {reg1}"),
##                #debug end
               
                (agent_get_slot,":old_rate",":agent_id","slot_agent_rate"),
                (val_add,":new_rate",":old_rate"),
                (agent_set_slot,":agent_id","slot_agent_rate",":new_rate"),
            (else_try),
                (eq,":old_hp",0),   # Init agent
                (agent_set_slot,":agent_id","slot_agent_hp",":current_hp"),
            (try_end),
        (try_end),
    ]),
   
    ("bleed",
    [
        (try_for_agents,":agent_id"),
            (agent_is_alive,":agent_id"),
            (agent_get_slot,":rate",":agent_id","slot_agent_rate"),
            (gt,":rate",0),
            (agent_get_slot,":blood",":agent_id","slot_agent_bleed"),
            (val_add,":blood",":rate"),
            (store_div,":hp_loss",":blood",blood_per_hp),
            (try_begin),
                (gt,":hp_loss",0), # the agent has lost enough blood to lose hitpoints
                (store_agent_hit_points,":hp",":agent_id", 1),
                (val_sub,":hp",":hp_loss"),
               
##                #debug start
##                (str_store_agent_name,s1,":agent_id"),
##                (assign,reg1,":rate"),
##                (assign,reg2,":hp"),
##                (try_begin),
##                    (agent_is_human,":agent_id"),
##                    (display_message,"@{s1} is bleeding: rate = {reg1}, HP = {reg2}"),
##                (else_try),
##                    (display_message,"@{s1}s horse is bleeding: rate = {reg1}, HP = {reg2}"),
##                (try_end),
##                #debug end
               
                (get_player_agent_no, ":player_agent"),
                (try_begin),
                    (agent_is_human,":agent_id"),
                    (try_begin),
                        (eq, ":agent_id", ":player_agent"),
                        (assign, reg0, ":hp_loss"),
                        (display_message, "@You take {reg0} damage from blood loss."),
                    (try_end),
                (else_try),
                    (agent_get_rider, ":agent_rider", ":agent_id"),
                    (eq, ":agent_rider", ":player_agent"),
                    (assign, reg0, ":hp_loss"),
                    (display_message, "@Your horse takes {reg0} damage from blood loss."),
                (try_end),
                # (try_begin),
                    # (gt,":hp",0),
                    (agent_set_hit_points,":agent_id",":hp", 1),
                    (agent_set_slot,":agent_id","slot_agent_hp",":hp"),
                    (store_mul,":tmp",":hp_loss",blood_per_hp),
                    (val_sub,":blood",":tmp"),
                    (agent_set_slot,":agent_id","slot_agent_bleed",":blood"),
                # (else_try),    MOTO avoid masses of damage delivered messages, esp after player death
                    # (call_script,"script_get_enemy_agent",":agent_id"),
                    # (agent_deliver_damage_to_agent,reg0,":agent_id"),
               (try_begin),
                    (le, ":hp", 0),
                    (set_show_messages, 0),    #MOTO prevent "agent killed self" messages chief
                    (agent_deliver_damage_to_agent, ":agent_id", ":agent_id"),
                    (set_show_messages, 1),
                (try_end),
            (else_try),
                (agent_set_slot,":agent_id","slot_agent_bleed",":blood"),
            (try_end),
        (try_end),
    ]),

    #chief desangrado acaba
###chief asegurar que tienen jabalinas
    ("force_weapon",
     [(store_script_param, ":agent", 1),
      (try_begin),
      (this_or_next|multiplayer_is_server),
      (neg|game_in_multiplayer_mode),
      (agent_is_alive, ":agent"),
      (agent_is_non_player, ":agent"),
      (agent_get_troop_id, ":troop", ":agent"),
	#meter tropas aqui
	(this_or_next|eq, ":troop", "trp_cantaber_iuventus"), 
	(this_or_next|eq, ":troop", "trp_fresna_footmant2"),
	(this_or_next|eq, ":troop", "trp_fresna_infantryt3"),
	(this_or_next|eq, ":troop", "trp_fresna_horseman"), 
	(this_or_next|eq, ":troop", "trp_merc_infantryt3"),
	(this_or_next|eq, ":troop", "trp_merc_infantryt4"),
	(this_or_next|eq, ":troop", "trp_merc_infantryt5"), 
	#(this_or_next|eq, ":troop", "trp_frisian_warrior"),
	(this_or_next|eq, ":troop", "trp_mercenary_horseman"),
	(this_or_next|eq, ":troop", "trp_mercenary_cavalry"), 
	(this_or_next|eq, ":troop", "trp_jute_skirmishert3"),
	(this_or_next|eq, ":troop", "trp_jute_infantryt3"), 
	(this_or_next|eq, ":troop", "trp_fresna_footmant2"),
	(this_or_next|eq, ":troop", "trp_jute_skirmishert4"),
	(this_or_next|eq, ":troop", "trp_jute_horsemant4"), 
	(this_or_next|eq, ":troop", "trp_jute_skirmishert5"),
	(this_or_next|eq, ":troop", "trp_jute_infantryt4"),
	(this_or_next|eq, ":troop", "trp_jute_infantryelitet5"), 
	(this_or_next|eq, ":troop", "trp_jute_deserter"),
	(this_or_next|eq, ":troop", "trp_briton_infantryt3"), 
	(this_or_next|eq, ":troop", "trp_briton_infantryt4"),
	(this_or_next|eq, ":troop", "trp_briton_skirmt3"),
	(this_or_next|eq, ":troop", "trp_briton_skirmishert4"), 
	(this_or_next|eq, ":troop", "trp_briton_horseman"),
	(this_or_next|eq, ":troop", "trp_briton_cavalry"),
	(this_or_next|eq, ":troop", "trp_briton_deserter"), 
	(this_or_next|eq, ":troop", "trp_saxon_infantryt3"),
	(this_or_next|eq, ":troop", "trp_saxon_skirmishert4"),
	(this_or_next|eq, ":troop", "trp_saxon_horseman1"), 
	(this_or_next|eq, ":troop", "trp_saxon_skirmishert5"),
	(this_or_next|eq, ":troop", "trp_saxon_infantryt4"),
	(this_or_next|eq, ":troop", "trp_saxon_infantryt5"), 
	(this_or_next|eq, ":troop", "trp_saxon_deserter"),
	(this_or_next|eq, ":troop", "trp_pict_woman"),
	(this_or_next|eq, ":troop", "trp_pict_footmant2"), 
	(this_or_next|eq, ":troop", "trp_pict_skirmishert3"),
	(this_or_next|eq, ":troop", "trp_pict_horsesquiret3"), 
	(this_or_next|eq, ":troop", "trp_pict_skirmishert4"),
	(this_or_next|eq, ":troop", "trp_pict_infantryt4"),
	(this_or_next|eq, ":troop", "trp_pict_infantryt5"), 
	(this_or_next|eq, ":troop", "trp_pict_horseman"),
	(this_or_next|eq, ":troop", "trp_pict_noblecavalry"), 
	(this_or_next|eq, ":troop", "trp_pict_deserter"),
	(this_or_next|eq, ":troop", "trp_engle_skirmishert3"),
	(this_or_next|eq, ":troop", "trp_engle_infantryt3"), 
	(this_or_next|eq, ":troop", "trp_engle_skirmishert4"),
	(this_or_next|eq, ":troop", "trp_engle_horseman"),
	(this_or_next|eq, ":troop", "trp_engle_skirmishert5"), 
	(this_or_next|eq, ":troop", "trp_engle_infantryt4"),
	(this_or_next|eq, ":troop", "trp_engle_infantryt5"),
	(this_or_next|eq, ":troop", "trp_engle_deserter"), 
	(this_or_next|eq, ":troop", "trp_irish_footmant2"),
	(this_or_next|eq, ":troop", "trp_irish_infantryt3"),
	(this_or_next|eq, ":troop", "trp_irish_skirmishert3"), 
	(this_or_next|eq, ":troop", "trp_irish_skirmishert4"),
	(this_or_next|eq, ":troop", "trp_irish_infantryt4"),
	(this_or_next|eq, ":troop", "trp_irish_infantryt5"), 
	(this_or_next|eq, ":troop", "trp_irish_horseman"),
	(this_or_next|eq, ":troop", "trp_irish_noblecavalry"),
	(this_or_next|eq, ":troop", "trp_irish_deserter"), 
	(this_or_next|eq, ":troop", "trp_brigand"),
	(this_or_next|eq, ":troop", "trp_sea_raider"),
	(this_or_next|eq, ":troop", "trp_steppe_bandit"), 
	(this_or_next|eq, ":troop", "trp_taiga_bandit"),
	(this_or_next|eq, ":troop", "trp_dena_pirate"),
	(this_or_next|eq, ":troop", "trp_sea_raider_leader2"), 
	(this_or_next|eq, ":troop", "trp_manhunter"),
	(this_or_next|eq, ":troop", "trp_slave_driver"),
	(this_or_next|eq, ":troop", "trp_slave_punisher"), 
	(this_or_next|eq, ":troop", "trp_slave_crusher"),
      (eq, ":troop", "trp_slaver_chief"), 
#meter tropas acaba
      (troop_get_inventory_capacity, ":cap", ":troop"),
      (try_for_range, ":i", 0, ":cap"),
        (troop_get_inventory_slot, ":item", ":troop", ":i"),
        (ge, ":item", 0),
        (item_get_type, ":type", ":item"),
        (ge, ":type", itp_type_thrown),
        (le, ":type", itp_type_thrown),
        (neg|agent_has_item_equipped, ":agent", ":item"),
        (agent_equip_item, ":agent", ":item"),
      #  (else_try),#gdw tried070715 it didn't seem to make any difference
      #   (try_for_range, ":i", 0, ":cap"),
      #   (troop_get_inventory_slot, ":item", ":troop", ":i"),
      #   (ge, ":item", 0),
      #   (item_get_type, ":type", ":item"),
      #   (ge, ":type", itp_type_polearm),
      #   (le, ":type", itp_type_polearm),
      #   (neg|agent_has_item_equipped, ":agent", ":item"),
      #   (agent_equip_item, ":agent", ":item"),
      (try_end), #try inventory
    (try_end),
    ]),
  #chief asegurar tienen jabalinas chief en batallas termina
#seatrade chief rutas de comercio routes
  ("initialize_sea_trade_routes",
    [
     (party_set_slot, "p_town_2", "slot_town_is_coastal", 2), ###Set Seals-ey as a port.
#     (party_set_slot, "p_town_7", "slot_town_is_coastal", 4), #Caer Liwelydd as a port
#     (party_set_slot, "p_town_13", "slot_town_is_coastal", 4), #Set Dun Gonwy as a port.
     (party_set_slot, "p_town_17", "slot_town_is_coastal", 4), #Set Caer Uisc as a port	 
#     (party_set_slot, "p_town_42", "slot_town_is_coastal", 4), #Set Din Cado as a port
     (party_set_slot, "p_town_27", "slot_town_is_coastal", 8), #Set Bebbanburh as a port	
#     (party_set_slot, "p_town_1", "slot_town_is_coastal", 4), #Set Cantwareburh as a port.
#     (party_set_slot, "p_town_33", "slot_town_is_coastal", 4), #Set Aileach as a port.
     (party_set_slot, "p_town_37", "slot_town_is_coastal", 8), #Set Duin Foither as a port
      #RIVACHEG - 2 Routes
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_7"), #Rivacheg - Thir
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_27"), #Rivacheg - Praven
      (call_script, "script_set_trade_route_between_centers", "p_town_17", "p_town_27"), #Tihr - Praven
      (call_script, "script_set_trade_route_between_centers", "p_town_27", "p_town_37"), #Yalen - Shariz
      (call_script, "script_set_trade_route_between_centers", "p_town_37", "p_town_17"), #Yalen - Shariz
      
      #Shariz - 1 Route
      #Yalen
  ]),

##  ("initialize_sea_trade_routes",
##    [
##     (party_set_slot, "p_town_2", "slot_town_is_coastal", 8), ###Set Seals-ey as a port.
##     (party_set_slot, "p_town_7", "slot_town_is_coastal", 8), #Caer Liwelydd as a port.
##     (party_set_slot, "p_town_13", "slot_town_is_coastal", 8), #Set Dun Gonwy as a port.
##     (party_set_slot, "p_town_17", "slot_town_is_coastal", 8), #Set Caer Uisc as a port.	 
##     (party_set_slot, "p_town_19", "slot_town_is_coastal", 8), #Set Dun At as a port.
##     (party_set_slot, "p_town_27", "slot_town_is_coastal", 8), #Set Bebbanburh as a port	
##     (party_set_slot, "p_town_32", "slot_town_is_coastal", 8), #Set Dun Keltair as a port.
##     (party_set_slot, "p_town_33", "slot_town_is_coastal", 8), #Set Aileach as a port.
##     (party_set_slot, "p_town_37", "slot_town_is_coastal", 8), #Set Duin Foither as a port
##      #RIVACHEG - 2 Routes
##      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_17"), #Rivacheg - Thir
##      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_27"), #Rivacheg - Praven
##      
##      #WERCHEG - 2 Routes
##      (call_script, "script_set_trade_route_between_centers", "p_town_7", "p_town_33"), #Wercheg - Thir
##      (call_script, "script_set_trade_route_between_centers", "p_town_7", "p_town_13"), #Wercheg - Sargoth
##      
##      #SARGOTH - 2 routes
##      #Wercheg
##      (call_script, "script_set_trade_route_between_centers", "p_town_13", "p_town_32"), #Sargoth - Tihr
##      (call_script, "script_set_trade_route_between_centers", "p_town_13", "p_town_33"), #Sargoth - Tihr
##      
##      #TIHR - 4 Routes
##      #Rivacheg, Wercheg, Sargoth
##      (call_script, "script_set_trade_route_between_centers", "p_town_17", "p_town_37"), #Tihr - Praven
##      (call_script, "script_set_trade_route_between_centers", "p_town_17", "p_town_13"), #Tihr - Praven
##      
##      #Praven - 3 Routes
##      #Rivacheg, Thir
##      (call_script, "script_set_trade_route_between_centers", "p_town_19", "p_town_7"), #Praven - Yalen
##      (call_script, "script_set_trade_route_between_centers", "p_town_19", "p_town_17"), #Praven - Yalen
##      
##      #Yalen - 2 Routes
##      #Praven
##      (call_script, "script_set_trade_route_between_centers", "p_town_27", "p_town_37"), #Yalen - Shariz
##      (call_script, "script_set_trade_route_between_centers", "p_town_27", "p_town_2"), #Yalen - Shariz
##
##      (call_script, "script_set_trade_route_between_centers", "p_town_32", "p_town_7"), #Yalen - Shariz
##      (call_script, "script_set_trade_route_between_centers", "p_town_32", "p_town_19"), #Yalen - Shariz
##
##      (call_script, "script_set_trade_route_between_centers", "p_town_33", "p_town_19"), #Yalen - Shariz
##      (call_script, "script_set_trade_route_between_centers", "p_town_33", "p_town_32"), #Yalen - Shariz
##
##      (call_script, "script_set_trade_route_between_centers", "p_town_37", "p_town_27"), #Yalen - Shariz
##      (call_script, "script_set_trade_route_between_centers", "p_town_37", "p_town_2"), #Yalen - Shariz
##      
##      #Shariz - 1 Route
##      #Yalen
##  ]),

  #seatrade acaba

####fire arrow scripts chief
    # script_initialize_ship
    # input: arg1 = instance_no :arg2 = durability
    #
    ("initialize_ship",[
        (store_script_param_1, ":instance_no"),
        (store_script_param_2, ":durability"),
        (store_script_param, ":scene_prop_id",3),
        (troop_set_slot, "trp_object_instance_no", "$g_flammable_object_slot", ":instance_no"),
        (troop_set_slot, "trp_object_durability", "$g_flammable_object_slot", ":durability"),
        (troop_set_slot, "trp_stack_selection_amounts", "$g_flammable_object_slot", ":durability"),#durability old
        (try_begin),
            (gt, ":scene_prop_id", 0),
            (troop_set_slot, "trp_scene_prop_id", "$g_flammable_object_slot", ":scene_prop_id"),
        (try_end),
        (try_begin),
            (eq, ":scene_prop_id", "spr_ship"),
            (troop_set_slot, "trp_scene_prop_id", "$g_flammable_object_slot", ":scene_prop_id"),
            (troop_set_slot, "trp_ship_colisions", "$g_flammable_object_slot", -1),
            (troop_set_slot, "trp_ship_num_crew", "$g_flammable_object_slot", 0),
            (troop_set_slot, "trp_ship_speed", "$g_flammable_object_slot", 1000),
            (troop_set_slot, "trp_ship_behavior", "$g_flammable_object_slot", 1),
            (troop_set_slot, "trp_ship_rudder", "$g_flammable_object_slot", 0),
        (try_end),
        (val_add, "$g_flammable_object_slot", 1),
    ]),

   # script_cf_center_lord_is_player_or_companions
    ("cf_center_lord_is_player_or_companions",[
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":negation"), 
      (is_between, ":center_no", centers_begin, centers_end),
      (party_is_active, ":center_no"),
      (party_get_slot, ":town_lord", ":center_no", "slot_town_lord"),
      (ge, ":town_lord", 0),
      (assign, ":result", 1),
      (store_faction_of_party, ":center_faction", ":center_no"),
      (this_or_next|eq, ":center_faction", "fac_player_supporters_faction"),
      (eq, ":center_faction", "$players_kingdom"),
      (try_begin),
        (neq, ":negation", 1),
        (this_or_next|eq, ":town_lord", "trp_player"),
        (troop_slot_eq, ":town_lord", "slot_troop_occupation", slto_player_companion),
      (else_try),
        (eq, ":negation", 1),
        (neq, ":town_lord", "trp_player"),
        (neg|troop_slot_eq, ":town_lord", "slot_troop_occupation", slto_player_companion),
      (else_try),
        (assign, ":result", 0),
      (try_end),
      (eq, ":result", 1),
    ]),

#1 FIRE ARROW

  # script_object_hit
  # input: aug1 = instance_no
  # input: aug2 = damage
  # output: reg60 = dmage
  ("object_hit",
    [
        (store_script_param, ":instance_no", 1),
            (store_script_param, ":damage", 2),
            (assign, reg60, ":damage"),
            (val_div, ":damage", 8),
            (prop_instance_get_position, pos2, ":instance_no"),

  #MOTO chief allow for MP
              (try_begin),
                  (game_in_multiplayer_mode),
	  (multiplayer_get_my_player, ":my_player"),
	  (player_get_agent_id, ":player_agent", ":my_player"),
      (try_for_agents, ":agent"),
	    (agent_is_human, ":agent"),
		(agent_is_alive, ":agent"),
	    (eq, ":agent", ":player_agent"),
              (else_try),
                  (get_player_agent_no, ":player_agent"),
              (try_end),
              #MOTO end allow for MP
        #(get_player_agent_no, ":player_agent"),

        (agent_get_position, pos3, ":player_agent"),
            (try_begin),
                (position_is_behind_position, pos3, pos2),
                (val_mul, ":damage", -1),
            (try_end),
            (position_rotate_x, 2, ":damage"),
            (prop_instance_animate_to_position, ":instance_no", 2, 30),
            (play_sound, "snd_dummy_hit"),
            (particle_system_burst, "psys_dummy_smoke", pos1, 3),
            (particle_system_burst, "psys_dummy_straw", pos1, 10),
	 (try_end)   #gdwadded to fix compilation error   
	   ]),

    # script_object_destroy
    # input: aug1 = instance_no
    ("object_destroy",
    [
        (store_script_param, ":instance", 1),
        (prop_instance_get_position, pos1, ":instance"),#prop_instance_get_starting_position
        (get_player_agent_no, ":player"),
        (agent_get_position, pos2, ":player"),
        (assign, ":rotate", 80),
        (try_begin),
            (position_is_behind_position, pos2, pos1),
            (val_mul, ":rotate", -1),
        (try_end),
        (position_move_z,pos1, -1000,1),
        (position_rotate_x, pos1, ":rotate"),
        (prop_instance_animate_to_position, ":instance", pos1, 100), 
        (play_sound, "snd_dummy_destroyed"),
        (store_add, ":end", "$g_flammable_object_slot", 1),
        (try_for_range, ":i_slot", 0, ":end"),
          (troop_slot_eq, "trp_object_instance_no", ":i_slot", ":instance"),
          (troop_set_slot, "trp_object_durability", ":i_slot", 0),
          (assign, ":end", 0),
        (try_end),  
    ]),
    # script_cf_set_fire_arrow
    # input:aug1 = initial speed
    # input:aug2 = position
    ("cf_set_fire_arrow",[
        (store_script_param_1, ":speed"),
        (store_script_param_2, ":pos"),
        (set_fixed_point_multiplier, 100),
        (copy_position, pos10, ":pos"),
        (assign, ":distance", 99999),
        (assign, ":chosen", -1),
        (try_for_agents, ":agent"),
            (agent_is_alive, ":agent"),
            (agent_is_human, ":agent"),
            (agent_get_look_position, pos2, ":agent"),
            (get_distance_between_positions,":dist",pos10, pos2),
            (lt,":dist",":distance"),
            (assign,":chosen",":agent"),    # who thorow this particle? 
            (assign,":distance",":dist"),
        (try_end),
        (ge, ":chosen", 0),
        (agent_is_alive, ":chosen"),
        (agent_is_human, ":chosen"),
        (assign, ":continue", 0),
        (try_begin),
            (agent_is_ally, ":chosen"),
            (eq, "$g_fire_arrow_mode", 1),
            (assign, ":continue", 1),
        (else_try),
            (neg|agent_is_ally, ":chosen"),
            (eq, "$g_fire_arrow_mode_enemy", 1),
            (assign, ":continue", 1),
        (try_end),
        (eq, ":continue", 1),
        (agent_get_look_position, pos10, ":chosen"),
        (agent_get_horse, ":horse", ":chosen"),
        (try_begin),
            (ge, ":horse", 0),
            (position_move_z, pos10, 230),
            (position_move_y, pos10, 200),
        (else_try),
            (position_move_z, pos10, 150),
            (position_move_y, pos10, 200),
        (try_end),
        (position_get_x, ":x1", pos10),
        (position_get_y, ":y1", pos10),
        (position_get_z, ":z1", pos10),
        (val_add, ":speed", 0),
#       (val_div, ":speed", 27),
        (position_move_y, pos10, ":speed"),
        (position_get_x, ":x2", pos10),
        (position_get_y, ":y2", pos10),
        (position_get_z, ":z2", pos10),
        (val_sub, ":x2", ":x1"),
        (val_sub, ":y2", ":y1"),
        (val_sub, ":z2", ":z1"),
        (troop_set_slot, "trp_fire_arrows", "$g_fire_arrows_no", ":chosen"),
        (troop_set_slot, "trp_x_coordinate", "$g_fire_arrows_no", ":x1"), 
        (troop_set_slot, "trp_y_coordinate", "$g_fire_arrows_no", ":y1"), 
        (troop_set_slot, "trp_z_coordinate", "$g_fire_arrows_no", ":z1"), 
        (troop_set_slot, "trp_x_velocity", "$g_fire_arrows_no", ":x2"), 
        (troop_set_slot, "trp_y_velocity", "$g_fire_arrows_no", ":y2"), 
        (troop_set_slot, "trp_z_velocity", "$g_fire_arrows_no", ":z2"), 
        (troop_set_slot, "trp_fire_arrows_tick_count", "$g_fire_arrows_no", 1), 
        (try_begin),
            (troop_get_slot, ":max_fire_arrows", "trp_global_value", slot_gloval_max_fire_arrow),
            (gt, "$g_fire_arrows_no", ":max_fire_arrows",),
            (assign, "$g_fire_arrows_no", 0),
        (else_try),
            (val_add, "$g_fire_arrows_no", 1),
        (try_end),
#       (assign, reg1, "$g_fire_arrows_no"),(display_message, "@fire_arrows_no:{reg1}"),
#       (assign, reg1, ":x2"),
#       (assign, reg2, ":y2"),
#       (assign, reg3, ":z2"),(display_message, "@x2:{reg1}/y2:{reg2}/z2:{reg3}"),
    ]),
  # script_fire_arrow_routine
  # input:aug1 
  # input:aug2 
  # output:none
    ("fire_arrow_routine",[
    (set_fixed_point_multiplier, 100),
    (try_for_range, ":unused", 0, 5),
        (assign, ":acceleration", 0),
        (troop_get_slot, ":max_fire_arrow", "trp_global_value", slot_gloval_max_fire_arrow),
        (try_for_range, ":i_arrow", 0, ":max_fire_arrow"),
            (troop_get_slot, ":chosen", "trp_fire_arrows", ":i_arrow"),
            (ge, ":chosen", 0),
            (troop_get_slot, ":x1", "trp_x_coordinate", ":i_arrow"), 
            (troop_get_slot, ":y1", "trp_y_coordinate", ":i_arrow"), 
            (troop_get_slot, ":z1", "trp_z_coordinate", ":i_arrow"),
            #(try_begin),
            #  (is_between, ":x1", "$g_min_x", "$g_max_x"),
            #  (is_between, ":y1", "$g_min_y", "$g_max_y"),
            #  (is_between, ":z1", "$g_min_z", "$g_max_z"),
            #(else_try),
            #  (assign, ":chosen", -1),
            #  (display_message, "@DEBUG: (in fire_arrow_routine)flame position is not in bound area."),
            #  (troop_set_slot, "trp_fire_arrows", ":i_arrow", ":chosen"),
            #  (troop_set_slot, "trp_fire_arrows_tick_count", ":i_arrow", 0),
            #(try_end),
            #(ge, ":chosen", 0),
            (troop_get_slot, ":x2", "trp_x_velocity", ":i_arrow"), 
            (troop_get_slot, ":y2", "trp_y_velocity", ":i_arrow"), 
            (troop_get_slot, ":z2", "trp_z_velocity", ":i_arrow"),
            (troop_get_slot, ":tick_count", "trp_fire_arrows_tick_count", ":i_arrow"),
            (store_mul, ":acceleration", -5, ":tick_count"),#gravity -30
            (val_div, ":acceleration", 100),
            (val_add, ":z2", ":acceleration"),#(assign, reg1, ":z2"),(display_message, "@z2:{reg1}"),
            (val_add, ":x1", ":x2"),
            (val_add, ":y1", ":y2"),
            (val_add, ":z1", ":z2"),
            (val_add, ":tick_count", 1),
            (position_set_x, pos10, ":x1"),
            (position_set_y, pos10, ":y1"),
            (position_set_z, pos10, ":z1"),
            (try_begin),
                (troop_slot_eq, "trp_global_value", slot_gloval_show_fire_arrow_particle, 1),
                (particle_system_burst, "psys_greek_fire", pos10, 10),
            (try_end),
            (troop_set_slot, "trp_x_coordinate", ":i_arrow", ":x1"), 
            (troop_set_slot, "trp_y_coordinate", ":i_arrow", ":y1"), 
            (troop_set_slot, "trp_z_coordinate", ":i_arrow", ":z1"), 
            (troop_set_slot, "trp_fire_arrows_tick_count", ":i_arrow", ":tick_count"),
            (copy_position, pos11, pos10),
            (position_set_z_to_ground_level, pos11),
            (position_get_z, ":ground_level_z", pos11),
            (position_get_z, ":particle_level_z", pos10),
            (store_sub, ":dist", ":particle_level_z", ":ground_level_z"),
            #(assign, reg1, ":dist"),(display_message, "@dist:{reg1}"),
            (le, ":dist", 0),
            (troop_set_slot, "trp_fire_arrows", ":i_arrow", -1),
            (troop_set_slot, "trp_fire_arrows_tick_count", ":i_arrow", 0),
            (is_between, ":x1", "$g_min_x", "$g_max_x"),
            (is_between, ":y1", "$g_min_y", "$g_max_y"),
            (is_between, ":ground_level_z", "$g_min_z", "$g_max_z"),
            #
            (party_get_current_terrain, ":cur_terrain", "p_main_party"),
            (neq, ":cur_terrain", rt_snow),
            (neq, ":cur_terrain", rt_snow_forest),
            (neq, ":cur_terrain", rt_desert),
            (neq, ":cur_terrain", rt_desert_forest),
            #
            (try_begin),
              (assign, ":distance", 999999),
              (try_for_agents, ":agent"),
                (agent_is_alive, ":agent"),
                (agent_is_human, ":agent"),
                (agent_get_position, pos11, ":agent"),
                (get_distance_between_positions, ":dist", pos10, pos11),
                (lt, ":dist", ":distance"),
                (assign, ":distance", ":dist"),
                (copy_position, pos12, pos11),
              (try_end),
              #(assign, reg11, ":distance"),
              #(display_message, "@{reg11}"),
              (le, ":distance", 150),
              (position_get_x, ":x1", pos12),
              (position_get_y, ":y1", pos12),
              (position_get_z, ":z1", pos12),
            (try_end),
            (position_set_z, pos10, ":particle_level_z"),
            (troop_get_slot, ":max_flame_slot", "trp_global_value", slot_gloval_max_flame_slot),
            (try_begin),
                (gt, ":max_flame_slot", 0),
                (is_between, ":z1", 100, "$g_max_z"),
                (particle_system_burst, "psys_small_explosion", pos10, ":max_flame_slot"),
                (particle_system_burst, "psys_cooking_fire_1", pos10, ":max_flame_slot"),
                (particle_system_burst, "psys_cooking_smoke", pos10, 5),
                (particle_system_burst, "psys_torch_fire_sparks", pos10, ":max_flame_slot"),
            (try_end),
            
             (try_begin),
                 (gt, "$g_flame_slot", ":max_flame_slot"),
                 (assign, "$g_flame_slot", 0),
             (else_try),
                 (val_add, "$g_flame_slot", 1),
             (try_end),
             #(troop_get_slot, reg5, "trp_frame_tick_count", "$g_flame_slot"),
             #(assign, reg4, "$g_flame_slot"),
             #(display_message, "@flame slot({reg4}):tick count{reg5}"),
             (store_random_in_range, ":random", 0, 10),
             (try_begin),
                 (this_or_next|troop_slot_eq, "trp_frame_tick_count", "$g_flame_slot", 0),
                 (this_or_next|lt, ":random", 3),
                 (eq, ":chosen", "trp_player"),
                 (troop_set_slot, "trp_frame_tick_count", "$g_flame_slot", 1), # tick count set = 6 5*6 = 30 second
                 (troop_set_slot, "trp_x_frame_position", "$g_flame_slot", ":x1"), # flame position
                 (troop_set_slot, "trp_y_frame_position", "$g_flame_slot", ":y1"), # flame position
                 (troop_set_slot, "trp_z_frame_position", "$g_flame_slot", ":z1"), # flame position
                 #(play_sound, "snd_incoming_arrow_hit_ground"),
                 #(assign, reg4, "$g_flame_slot"),
                 #(assign, reg5, ":x1"),
                 #(assign, reg6, ":y1"),
                 #(assign, reg7, ":ground_level_z"),
                 #(display_message, "@set flame({reg4}) {reg5} {reg6} {reg7}"),
             (try_end),
        (try_end),
    (try_end),
    ]),

  # script_hit_prop
  # input: arg1 = Position Register 1: Hit Position : arg2 = flammability
  ("hit_prop",
    [
    # check agent fired arrow collide with this prop .
        (store_script_param_1, ":hit_pos"),
        (set_fixed_point_multiplier, 100),
        (assign, ":dist", 0),
        (assign, ":distance", 999999),
        (assign, ":arrow", -1),
        (assign, ":chosen", -1),
        (play_sound, "snd_arrow_hit_body"),
        (troop_get_slot, ":max_fire_arrow", "trp_global_value", slot_gloval_max_fire_arrow),
        (val_add, ":max_fire_arrow", 1),
        (try_for_range, ":i_arrow", 0, ":max_fire_arrow"),
            (troop_get_slot, ":agent", "trp_fire_arrows", ":i_arrow"),
            (troop_get_slot, ":tick_count", "trp_fire_arrows_tick_count", ":i_arrow"),
            (ge, ":agent", 0),
            (ge, ":tick_count", 2),
            (agent_is_alive, ":agent"),
            (agent_is_human, ":agent"),
            (troop_get_slot, ":x1", "trp_x_coordinate", ":i_arrow"), 
            (troop_get_slot, ":y1", "trp_y_coordinate", ":i_arrow"), 
            (troop_get_slot, ":z1", "trp_z_coordinate", ":i_arrow"),
            (position_set_x, pos10, ":x1"),
            (position_set_y, pos10, ":y1"),
            (position_set_z, pos10, ":z1"),
            (get_distance_between_positions, ":dist", ":hit_pos", pos10),
            (lt, ":dist", ":distance"),
            (assign, ":distance", ":dist"),
            (assign, ":chosen", ":agent"),
            (assign, ":arrow", ":i_arrow"),
        (try_end),
        (try_begin),
            #(assign, reg11, ":distance"),
            #(assign, reg12, ":chosen"),
            #(display_message, "@({reg12})hit dist:{reg11}"),
            (lt,":distance", 600),
            (troop_set_slot, "trp_fire_arrows", ":arrow", -1),
            (troop_set_slot, "trp_fire_arrows_tick_count", ":arrow", -1),
         #   (play_sound,"snd_burn"), #chief off por problemas en sieges que no suenan otros sonidos
        (else_try),
            (assign, ":chosen", -1),
        (try_end),
        (assign, reg0, ":chosen"),
    ]),
    # script_initialize_agents_use_fire_arrow
    # input:
    # output:
    ("initialize_agents_use_fire_arrow",[
        (assign, "$g_fire_arrow_mode", 0),
        (assign, "$g_fire_arrows_no", 0),
        (try_begin),
##            (this_or_next|eq, "$g_next_menu", "mnu_train_peasants_against_bandits_attack_result"),
##            (this_or_next|eq, "$g_next_menu", "mnu_village_infest_bandits_result"),
##            (this_or_next|gt, "$g_encounter_is_in_village", 0),
##            (this_or_next|eq, "$g_encounter_type", enctype_fighting_against_village_raid),
##            (this_or_next|eq, "$g_encounter_type", enctype_catched_during_village_raid),
##            (eq, "$g_next_menu", "mnu_siege_started_defender"),
##            (assign, "$g_fire_arrow_mode_enemy", 1),
##            #(assign, reg1, "$g_next_menu"),
##            #(assign, reg2, "$g_encounter_type"),
##            #(display_message, "@[debug]Enemy uses fire arrow {reg1},{reg2}"), 
##        (else_try),
            (assign, "$g_fire_arrow_mode_enemy", 1), #chief cambia todo el mundo usa fire arrow
            #(display_message, "@[debug]Enemy don't uses fire arrow"),
        (try_end),
        #(try_for_range, ":i_arrow", 0, 100),
        #    (troop_set_slot, "trp_fire_arrows", ":i_arrow", -1),
        #(try_end),
        (troop_get_slot, ":max_fire_arrow", "trp_global_value", slot_gloval_max_fire_arrow),
        (try_for_range, ":i_arrow", 0, ":max_fire_arrow"),
            (troop_set_slot, "trp_fire_arrows", ":i_arrow", -1),
            (troop_set_slot, "trp_fire_arrows_tick_count", ":i_arrow", -1),
            (troop_set_slot, "trp_x_coordinate", ":i_arrow", 0), 
            (troop_set_slot, "trp_y_coordinate", ":i_arrow", 0), 
            (troop_set_slot, "trp_z_coordinate", ":i_arrow", 0), 
        (try_end),
    ]),
    
    # script_toggle_fire_arrow_mode
    # input
    # output
    ("toggle_fire_arrow_mode", [
        (try_begin), 
            (neq , "$g_fire_arrow_mode", 1), 
            (display_message, "@Archer!! use fire!!"), 
            (assign, "$g_fire_arrow_mode", 1), 
        (else_try), 
            (display_message, "@Archer!! extinguish flames!!"), 
            (assign, "$g_fire_arrow_mode", 0), 
        (try_end), 
    ]),
      # script_destructible_object_initialize
    # input: none
    #
    ("destructible_object_initialize",[
        (init_position, pos10),
        (assign, "$g_belfry_was_destroyed", 0),
        (assign, "$g_ram_was_destroyed", 0),
        (assign, "$g_flame_slot", 0),
        (assign, "$g_flammable_object_slot", 0),
        (try_for_range, ":i_num", 0, 150),
            (troop_set_slot, "trp_object_instance_no", ":i_num", -1),
            (troop_set_slot, "trp_object_durability", ":i_num", 0),
            (troop_set_slot, "trp_scene_prop_id", ":i_num", 0),
            (troop_set_slot, "trp_stack_selection_amounts", ":i_num", 0),
            (troop_set_slot, "trp_frame_tick_count",":i_num", 0),
            (troop_set_slot, "trp_x_frame_position",":i_num", 0),
            (troop_set_slot, "trp_y_frame_position",":i_num", 0),
            (troop_set_slot, "trp_z_frame_position",":i_num", 0),
            (troop_set_slot, "trp_burning_object",":i_num", -1),
        (try_end),
    ]),
    # script_flammable_object_initialize
    # input: arg1 = instance_no :arg2 = durability
    #
    ("flammable_object_initialize",[
        (store_script_param_1, ":instance_no"),
        (store_script_param_2, ":durability"),
        (store_script_param, ":scene_prop_id",3),
        (troop_set_slot, "trp_object_instance_no", "$g_flammable_object_slot", ":instance_no"),
        (troop_set_slot, "trp_object_durability", "$g_flammable_object_slot", ":durability"),
        (troop_set_slot, "trp_stack_selection_amounts", "$g_flammable_object_slot", ":durability"),#durability old
        (try_begin),
            (gt, ":scene_prop_id", 0),
            (troop_set_slot, "trp_scene_prop_id", "$g_flammable_object_slot", ":scene_prop_id"),
        (try_end),
        (val_add, "$g_flammable_object_slot", 1),
    ]),
    
    # script_cf_flammable_object_hit
    # input: arg1 = instance_no :arg2 = pos1
    #
    ("cf_flammable_object_hit",[
        (store_script_param_1, ":instance_no"),
        (store_script_param_2, ":pos"),
        (store_script_param  , ":flammability", 3),
        (set_fixed_point_multiplier, 100),
        (assign, reg1, ":instance_no"),
        (assign, ":cur_slot", -1),
        (call_script, "script_hit_prop", ":pos"),
        (assign, ":take_fire", reg0),
        (try_begin),
            (ge, ":take_fire", 0),
            # routine fire arrow hit prop
            (prop_instance_get_position, pos2, ":instance_no"),
            (prop_instance_get_scale, pos5, ":instance_no"),
            (position_transform_position_to_local, pos4, pos2, ":pos"),
            (position_get_x, ":x", pos4),(val_mul, ":x", 100),(position_get_scale_x, ":scale_x", pos5),(val_div, ":x", ":scale_x"),#(assign, reg1, ":x"),
            (position_get_y, ":y", pos4),(val_mul, ":y", 100),(position_get_scale_y, ":scale_y", pos5),(val_div, ":y", ":scale_y"),#(assign, reg2, ":y"),
            (position_get_z, ":z", pos4),(val_mul, ":z", 100),(position_get_scale_z, ":scale_z", pos5),(val_div, ":z", ":scale_z"),#(assign, reg3, ":z"),(display_message, "@x:{reg1}|y:{reg2}|z:{reg3}"),
            (troop_get_slot, ":max_flame", "trp_global_value", slot_gloval_max_flame_slot),
            (try_begin),
                (gt, ":max_flame", 1),
                (store_mul, ":value_period", ":flammability", 90),
                (set_position_delta, ":x", ":y", ":z"),
                (try_begin),
                  (gt, ":value_period", 0),
                  (particle_system_burst, "psys_small_explosion", ":pos", ":max_flame"),
                  (particle_system_add_new, "psys_fire_glow_1"),
                  (particle_system_emit, "psys_fire_glow_1", ":max_flame"),
                  (particle_system_add_new, "psys_cooking_fire_1"),
                  (particle_system_emit, "psys_cooking_fire_1", ":value_period"),
                  (particle_system_add_new, "psys_cooking_smoke"),
                  (particle_system_emit, "psys_cooking_smoke", 10),
                  (particle_system_add_new, "psys_torch_fire_sparks"),
                  (particle_system_emit, "psys_torch_fire_sparks", ":max_flame"),
                (try_end),
                #(assign, reg4, ":x"),
                #(assign, reg5, ":y"),
                #(assign, reg6, ":z"),
                #(display_message, "@DEBUG: x:{reg4} y:{reg5} z:{reg6}"),
                #
                #(particle_system_add_new, "psys_massive_fire"),
                #(particle_system_emit, "psys_massive_fire", 300),
                #(particle_system_add_new, "psys_war_smoke_tall"),
                #(particle_system_emit, "psys_war_smoke_tall", 300),
            (else_try),
                #(assign, reg4, ":x"),
                #(assign, reg5, ":y"),
                #(assign, reg6, ":z"),
                #(display_message, "@DEBUG:over area1 x:{reg4} y:{reg5} z:{reg6}"),
                (assign, ":take_fire", -1),
                
            (try_end),
        (try_end),
        # Is this destructible object?
        (assign, ":durability", -1),
        (store_add, ":end", "$g_flammable_object_slot", 1),
        (try_for_range, ":i_slot", 0, ":end"),
            (troop_slot_eq, "trp_object_instance_no", ":i_slot", ":instance_no"),
            (troop_get_slot, ":durability", "trp_object_durability", ":i_slot"),
            (assign, ":cur_slot", ":i_slot"),
        (try_end),
        (try_begin),
            (le, ":durability", 0),
            (ge, ":instance_no", 0),
            (ge, ":cur_slot", 0),
            (troop_slot_ge, "trp_scene_prop_id", ":cur_slot", 0),
            (try_begin),
              (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_belfry_a"),
              (call_script, "script_object_destroy", ":instance_no"),
              (display_message, "@Belfry was destroyed."),
              (assign, "$g_belfry_was_destroyed", 1),
              (store_add, ":j_end", "$g_flammable_object_slot", 1),
              (try_for_range, ":j_slot", 0, ":j_end"),
        (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_b_platform_a"),
                  (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_platform_a"),
                  (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_platform_b"),
                  (             troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_wheel"),
                  (troop_get_slot,":instance_no", "trp_object_instance_no",":j_slot"),
                  (call_script, "script_object_destroy", ":instance_no"),
                  (troop_set_slot, "trp_object_durability",":j_slot", 0),
                  (particle_system_add_new, "psys_war_smoke_tall"),
                  (particle_system_emit, "psys_war_smoke_tall", 100),
                  (call_script, "script_object_destroy", ":instance_no"),
              (try_end),
            (else_try),
              (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_belfry_b"),
              (call_script, "script_object_destroy", ":instance_no"),
       (display_message, "@Belfry was destroyed."),
      (assign, "$g_belfry_was_destroyed", 1),
      (store_add, ":j_end", "$g_flammable_object_slot", 1),
      (try_for_range, ":j_slot", 0, ":j_end"),
        (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_b_platform_a"),
        (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_platform_a"),
        (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_platform_b"),
        (             troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_wheel"),
        (troop_get_slot,":instance_no", "trp_object_instance_no",":j_slot"),
        (call_script, "script_object_destroy", ":instance_no"),
        (troop_set_slot, "trp_object_durability",":j_slot", 0),
      (try_end),
            (else_try),
              (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_ram_body"),
              (call_script, "script_object_destroy", ":instance_no"),
      (display_message, "@Battering ram was destroyed."),
      (assign, "$g_ram_was_destroyed", 1),
      (store_add, ":j_end", "$g_flammable_object_slot", 1),
      (try_for_range, ":j_slot", 0, ":j_end"),
        (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_ram_shaft"),
        (             troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_ram_wheel"),
        (troop_get_slot,":instance_no", "trp_object_instance_no",":j_slot"),
        (call_script, "script_object_destroy", ":instance_no"),
        (troop_set_slot, "trp_object_durability",":j_slot", 0),
      (try_end),
            (else_try),
              (this_or_next|troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_klabautermann_ship1"),
              (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_klabautermann_ship1"),
              (call_script, "script_destroy_ship", ":instance_no"),
            (else_try),
              (this_or_next|troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_ship_enemy"),
              (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_ship_enemy"),
              (call_script, "script_destroy_ship", ":instance_no"),
            (else_try),
              (call_script, "script_object_destroy", ":instance_no"),
            (try_end),
        (try_end),
        (troop_set_slot, "trp_object_durability", ":cur_slot", ":durability"),
        # routine when object was broken by arrows.
        (try_begin),
            (ge, ":durability", 0),
            (ge, ":take_fire", 0),
            (try_begin),
                (troop_get_slot, ":max_flame_slot", "trp_global_value", slot_gloval_max_flame_slot),
                (gt, "$g_flame_slot", ":max_flame_slot"),
                (assign, "$g_flame_slot", 0),
            (else_try),
                (val_add, "$g_flame_slot", 1),
            (try_end),
            (position_get_x, ":x", ":pos"),
            (position_get_y, ":y", ":pos"),
            (position_get_z, ":z", ":pos"),
            #(assign, reg4, "$g_flame_slot"),
            #(assign, reg5, ":x"),
            #(assign, reg6, ":y"),
            #(assign, reg7, ":z"),
            #(display_message, "@set flame({reg4}) {reg5} {reg6} {reg7}"),
            (troop_set_slot, "trp_frame_tick_count", "$g_flame_slot", ":flammability"), # tick count set = 6 5*6 = 30 second
            (troop_set_slot, "trp_x_frame_position", "$g_flame_slot", ":x"), # flame position
            (troop_set_slot, "trp_y_frame_position", "$g_flame_slot", ":y"), # flame position
            (troop_set_slot, "trp_z_frame_position", "$g_flame_slot", ":z"), # flame position
            (troop_set_slot, "trp_burning_object", "$g_flame_slot", ":instance_no"), # object instance number
        (try_end),
    ]),
    # script_cf_object_set_damage
    ("cf_object_set_damage",[
      (store_script_param_1, ":instance_no"),
      (store_script_param_2, ":damage"),
      (store_script_param  , ":flammability", 3),
      (assign, reg60, ":damage"),
      (assign, ":durability", 0),
      (assign, ":cur_slot", -1),
      (store_add, ":end", "$g_flammable_object_slot", 1),
      (try_for_range, ":i_slot", 0, ":end"),
        (troop_slot_eq, "trp_object_instance_no",":i_slot",":instance_no"),
        (troop_get_slot,":durability", "trp_object_durability",":i_slot"),
        (assign, ":cur_slot", ":i_slot"),
      (try_end),
      (try_begin),
        (gt, ":cur_slot", 0),
        (val_sub, ":durability", ":damage"),
        (val_max, ":durability", 0),
        (troop_set_slot, "trp_object_durability", ":cur_slot", ":durability"),
      (try_end),
      
      (play_sound, "snd_dummy_hit"),
      (particle_system_burst, "psys_dummy_smoke", pos1, 3),
      (particle_system_burst, "psys_dummy_straw", pos1, 10),
      (call_script, "script_cf_flammable_object_hit", ":instance_no", pos1, ":flammability"),
    ]),
    # script_flame_routine
    # input: arg1 = :arg2 = 
    # 
    ("flame_routine",[
    (set_fixed_point_multiplier, 100),
    (assign, ":sound_burn", 0),
    (assign, ":sound_man_cough", 0),
    (assign, ":sound_woman_cough", 0),
    (assign, ":num_flame", 0),
    #(assign, ":burst_strength", 100),
    (troop_get_slot, ":max_flame_slot", "trp_global_value", slot_gloval_max_flame_slot),
    (store_add, ":i_end", ":max_flame_slot", 1),
    (try_for_range, ":i_slot", 0, ":i_end"),# flame_no
        (troop_get_slot, ":tick_count", "trp_frame_tick_count", ":i_slot"),
        (gt, ":tick_count", 0),
        (val_sub, ":tick_count", 1),
        (troop_set_slot, "trp_frame_tick_count", ":i_slot", ":tick_count"),
        # burn object routine
        (troop_get_slot, ":instance_no", "trp_burning_object", ":i_slot"),
        (assign, ":cur_slot", -1),
        (store_add, ":j_end", "$g_flammable_object_slot", 1),
        (try_for_range, ":j_slot", 0, ":j_end"),
            (troop_slot_eq, "trp_object_instance_no",":j_slot",":instance_no"),
            (troop_get_slot,":durability", "trp_object_durability",":j_slot"),
            (assign, ":cur_slot", ":j_slot"),
            (assign, ":j_end", 0),
        (try_end),
        (try_begin),
          (gt, ":cur_slot", 0),
          (store_random_in_range, ":damage", 5, 9),
          (val_add, ":damage", ":tick_count"),
          (val_sub, ":durability", ":damage"),
          (val_max, ":durability", 0),
        (try_end),
        (try_begin),
            (le, ":num_flame", ":max_flame_slot"),
            (troop_get_slot, ":x", "trp_x_frame_position", ":i_slot"), # flame position
            (troop_get_slot, ":y", "trp_y_frame_position", ":i_slot"), # flame position
            (troop_get_slot, ":z", "trp_z_frame_position", ":i_slot"), # flame position
            (troop_set_slot, "trp_object_durability", ":cur_slot", ":durability"),
            (val_add, ":num_flame", 1),
            (le, ":num_flame", ":max_flame_slot"),
            (assign, ":sound_burn", 1),
            (gt, ":cur_slot", 0),
            (position_set_x, pos10,":x"),
            (position_set_y, pos10,":y"),
            (position_set_z, pos10,":z"),
            #test
            #(set_position_delta, ":x", ":y", ":z"),
            #(particle_system_add_new, "psys_massive_fire"),
            #(particle_system_emit, "psys_massive_fire", 300),
            #(particle_system_add_new, "psys_torch_fire_sparks"),
            #(particle_system_emit, "psys_torch_fire_sparks", 300),
            #(particle_system_add_new, "psys_war_smoke_tall"),
            #(particle_system_emit, "psys_war_smoke_tall", 300),
            # delete
            #(assign, reg1,":tick_count"),
            #(assign, reg4, ":i_slot"),
            #(assign, reg5, ":x"),
            #(assign, reg6, ":y"),
            #(assign, reg7, ":z"),
            #(display_message, "@flame({reg4}:{reg1}) {reg5} {reg6} {reg7}"),
            # end
            #(play_sound, "snd_dummy_destroyed"),
            #(store_mul, ":burst_strength", ":tick_count", 10),
            #(val_min, ":burst_strength", 100),
            (particle_system_burst, "psys_massive_fire", pos10, ":max_flame_slot"),
            (particle_system_burst, "psys_torch_fire_sparks", pos10, ":max_flame_slot"),
            (particle_system_burst, "psys_war_smoke_tall", pos10, 5),
        (try_end),
        # burn agent near flame
        (try_begin),
            (gt, ":num_flame", 0),
            (try_for_agents, ":agent"),
                (agent_is_human, ":agent"),
                (agent_is_alive, ":agent"),
                (agent_get_position, pos6, ":agent"),
                (get_distance_between_positions, ":dist", pos6, pos10),
                (assign, reg4, ":dist"),
                #(position_get_x, ":x", pos6),
                #(position_get_y, ":y", pos6),
                #(position_get_z, ":z", pos6),
                #(assign, reg1, ":x"),
                #(assign, reg2, ":y"),
                #(assign, reg3, ":z"),(display_message, "@Agent_dist:{reg4}|x:{reg1}|y:{reg2}|z:{reg3}"),
                (try_begin),
                    (lt, ":dist", 100),
                    #(particle_system_burst, "psys_massive_fire", pos6, 50),
                    (val_add, ":sound_burn", 1),
                    (try_begin),
                        (le, ":sound_burn", 2),
                        (agent_play_sound ,":agent", "snd_sizzle"),
                        (particle_system_burst, "psys_massive_fire", pos10, ":max_flame_slot"),
                        #(particle_system_burst, "psys_torch_fire_sparks", pos10, ":burst_strength"),
                        #(val_max, ":burst_strength", 20),
                        (particle_system_burst, "psys_war_smoke_tall", pos10, 5),
                    (try_end),
                    (store_agent_hit_points, ":hit_points", ":agent", 0),
                    #(store_random_in_range, ":damage", 1, 4),
                    (val_add, ":damage", ":tick_count"),
                    (val_min, ":damage", 5),
                    (val_sub, ":hit_points", ":damage"),
                    (try_begin),
                        (get_player_agent_no, ":player"),
                        (eq, ":player", ":agent"),
                        (assign, reg60, ":damage"),
                        (display_message, "str_delivered_damage"),
                    (try_end),
                    (agent_set_hit_points, ":agent", ":hit_points", 0),
                    (agent_deliver_damage_to_agent, ":agent", ":agent"),
                (else_try),
                    (lt, ":dist", 100), #chief cambia de 300 a 100 la distacia para que tosan para intentar saturar menos los sonidos.
                    (agent_get_troop_id, ":troop", ":agent"),
                    (troop_get_type, ":gender", ":troop"),
                    (try_begin),
###gender fix chief
       (this_or_next|eq, ":gender", 0), #male
       (this_or_next|eq, ":gender", 2), #male
       (this_or_next|eq, ":gender", 4), #male
       (eq, ":gender", 6), #male
#gender fix chief acaba
                        (le, ":sound_man_cough", 1),
                        (agent_play_sound ,":agent", "snd_man_cough"),
                        (val_add, ":sound_man_cough", 1),
                    (else_try),
###gender fix chief
       (this_or_next|eq, ":gender", 1), #female
       (this_or_next|eq, ":gender", 3), #female
       (this_or_next|eq, ":gender", 5), #female
       (eq, ":gender", 7), #female
#gender fix chief acaba
                        (le, ":sound_woman_cough", 1),
                        (agent_play_sound ,":agent", "snd_woman_cough"),
                        (val_add, ":sound_woman_cough", 1),
                    (try_end),
                (try_end),
            (try_end),
        (try_end),
        # when object was broken by flame.
        (try_begin),
            (le, ":durability", 0),
            (ge, ":instance_no", 0),
            (troop_slot_ge, "trp_scene_prop_id", ":cur_slot", 1),
            (try_begin),
                (this_or_next|troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_klabautermann_ship1"),
                (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_klabautermann_ship1"),
                (call_script, "script_destroy_ship", ":instance_no"),
            (else_try),
                 (this_or_next|troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_ship_enemy"),
                (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_ship_enemy"),
                (call_script, "script_destroy_ship", ":instance_no"),
            (else_try),
               (call_script, "script_object_destroy", ":instance_no"),
            (try_end),
            (troop_set_slot, "trp_frame_tick_count", ":i_slot", 0),
            (assign, ":sound_burn", 1),
            (this_or_next|troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_belfry_a"),
            (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_belfry_b"),
            (eq, "$g_belfry_was_destroyed", 0),
            (display_message, "@Belfry was destroyed."),
            (assign, "$g_belfry_was_destroyed", 1),
            (store_add, ":j_end", "$g_flammable_object_slot", 1),
            (try_for_range, ":j_slot", 0, ":j_end"),
       (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_b_platform_a"),
                (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_platform_a"),
                (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_platform_b"),
                (             troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_belfry_wheel"),
                (troop_get_slot,":instance_no", "trp_object_instance_no",":j_slot"),
                (ge, ":instance_no", 0),
                (call_script, "script_object_destroy", ":instance_no"),
                (troop_set_slot, "trp_object_durability",":j_slot", 0),
            (try_end),
            (else_try),
            (troop_slot_eq, "trp_scene_prop_id",":cur_slot","spr_ram_body"),
            (eq, "$g_ram_was_destroyed", 0),
      (display_message, "@Battering ram was destroyed."),
      (assign, "$g_ram_was_destroyed", 1),
      (store_add, ":j_end", "$g_flammable_object_slot", 1),
      (try_for_range, ":j_slot", 0, ":j_end"),
        (this_or_next|troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_ram_shaft"),
        (             troop_slot_eq, "trp_scene_prop_id",":j_slot","spr_ram_wheel"),
        (troop_get_slot,":instance_no", "trp_object_instance_no",":j_slot"),
        (call_script, "script_object_destroy", ":instance_no"),
        (troop_set_slot, "trp_object_durability",":j_slot", 0),
      (try_end),

        (try_end),
    (try_end),
    # display object durability
    (try_begin),
        (gt, ":sound_burn", 0),
      #  (play_sound, "snd_burn",1), #chief poner off por problema que se pierden sonidos en sieges
    (try_end),
    ]),

    # script_destroy_ship Fire arrow chief
    # input: aug1 = instance_no
    ("destroy_ship",
    [
        (store_script_param, ":instance", 1),
        (prop_instance_get_position, pos1, ":instance"),#prop_instance_get_starting_position
        (position_move_z, pos1, -2000, 0),
        (prop_instance_animate_to_position, ":instance", pos1, 4000), 
        (play_sound, "snd_footstep_water"),
        (store_add, ":end", "$g_flammable_object_slot", 1),
        (try_for_range, ":i_slot", 0, ":end"),
          (troop_slot_eq, "trp_object_instance_no", ":i_slot", ":instance"),
          (troop_set_slot, "trp_object_durability", ":i_slot", 0),
          (troop_set_slot, "trp_ship_num_crew", ":i_slot", 0),
          (troop_set_slot, "trp_ship_speed", ":i_slot", 0),
          (troop_set_slot, "trp_ship_colisions", ":i_slot", -1),
          (troop_set_slot, "trp_ship_behavior", ":i_slot", 0),
          (assign, ":end", 0),
        (try_end),  
    ]),

  ####cc chief loot acaba
####siege warfare battering ram chief
    #~ Tutorial: Make 5 entry points, starting from #50 to #55. ~#
  #~ Put the ram_body, ram_shaft and ram_wheels in place and put the whole stuff near entry point #55. ~#
  
  #~ This file goes to the very bottom of module_scripts.py, right before the last ']'. ~#
  ("siege_init_ai_and_ram",
   [(assign, "$cur_ram_pos", 50),
    (assign, ":cur_ram_object_pos", "slot_scene_ram_props_begin"),
    (store_current_scene, ":cur_scene"),
    #Collecting ram objects
    (try_for_range, ":i_ram_instance", 0, 3),
      (scene_prop_get_instance, ":ram_object", "spr_ram_body", ":i_ram_instance"),
      (ge, ":ram_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_ram_object_pos", ":ram_object"),
      (val_add, ":cur_ram_object_pos", 1),
    (try_end),
    (try_for_range, ":i_ram_instance", 0, 3),
      (scene_prop_get_instance, ":ram_object", "spr_ram_shaft", ":i_ram_instance"),
      (ge, ":ram_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_ram_object_pos", ":ram_object"),
      (val_add, ":cur_ram_object_pos", 1),
    (try_end),
    (try_for_range, ":i_ram_instance", 0, 3),
      (scene_prop_get_instance, ":ram_object", "spr_ram_shaft", ":i_ram_instance"),
      (ge, ":ram_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_ram_object_pos", ":ram_object"),
      (val_add, ":cur_ram_object_pos", 1),
    (try_end),
    (assign, "$ram_rotating_objects_begin", ":cur_ram_object_pos"),
    (try_for_range, ":i_ram_instance", 0, 5),
      (scene_prop_get_instance, ":ram_object", "spr_ram_wheel", ":i_ram_instance"),
      (ge, ":ram_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_ram_object_pos", ":ram_object"),
      (val_add, ":cur_ram_object_pos", 1),
    (try_end),
    (assign, "$last_ram_object_pos", ":cur_ram_object_pos"),
    
    # Moving the ram objects to their starting position
    (entry_point_get_position,pos1,55),
    (entry_point_get_position,pos3,50),
    (try_for_range, ":i_ram_object_pos", "slot_scene_ram_props_begin", "$last_ram_object_pos"),
      (assign, ":pos_no", pos_ram_begin),
      (val_add, ":pos_no", ":i_ram_object_pos"),
      (val_sub, ":pos_no", "slot_scene_ram_props_begin"),
      (scene_get_slot, ":cur_ram_object", ":cur_scene", ":i_ram_object_pos"),
      (prop_instance_get_position, pos2, ":cur_ram_object"),
      (position_transform_position_to_local, ":pos_no", pos1, pos2),
      (position_transform_position_to_parent, pos4, pos3, ":pos_no"),
      (prop_instance_animate_to_position, ":cur_ram_object", pos4, 1),
    (try_end),
    (assign, "$ram_positioned", 0),
    (assign, "$ram_num_slots_positioned", 0),
    (assign, "$ram_num_men_pushing", 0),
  ]),

  # Move the ram itself.
  ("cf_siege_move_ram",
   [(neq, "$last_ram_object_pos", "slot_scene_ram_props_begin"),
    (eq, "$g_ram_was_destroyed", 0), #chief fire arrow
    (entry_point_get_position,pos1,50),
    (entry_point_get_position,pos4,55),
    (get_distance_between_positions, ":total_distance", pos4, pos1),
    (store_current_scene, ":cur_scene"),
    (scene_get_slot, ":first_ram_object", ":cur_scene", "slot_scene_ram_props_begin"),
    (prop_instance_get_position, pos2, ":first_ram_object"),
    (entry_point_get_position,pos1,"$cur_ram_pos"),
    (position_transform_position_to_parent, pos3, pos1, pos_ram_begin),
    (position_transform_position_to_parent, pos5, pos4, pos_ram_begin),
    (get_distance_between_positions, ":cur_distance", pos2, pos3),
    (get_distance_between_positions, ":distance_left", pos2, pos5),
    (try_begin),
      (le, ":cur_distance", 10),
      (val_add, "$cur_ram_pos", 1),
      (entry_point_get_position,pos1,"$cur_ram_pos"),
      (position_transform_position_to_parent, pos3, pos1, pos_ram_begin),
      (get_distance_between_positions, ":cur_distance", pos2, pos3),
    (try_end),
    (neq, "$cur_ram_pos", 50),

    (assign, ":base_speed", 10), #velocidad del ram? cambiada de 20 a 10 para que vaya mas rapido
    (store_div, ":slow_range", ":total_distance", 60),
    (store_sub, ":distance_moved", ":total_distance", ":distance_left"),

    (try_begin),
      (lt, ":distance_moved", ":slow_range"),
      (store_mul, ":base_speed", ":distance_moved", -60),
      (val_div, ":base_speed", ":slow_range"),
      (val_add, ":base_speed", 80),
    (else_try),
      (lt, ":distance_left", ":slow_range"),
      (store_mul, ":base_speed", ":distance_left", -60),
      (val_div, ":base_speed", ":slow_range"),
      (val_add, ":base_speed", 80),
    (try_end),
    (store_mul, ":ram_speed", ":cur_distance", ":base_speed"),
    (try_begin),
      (eq, "$ram_num_men_pushing", 0),
      (assign, ":ram_speed", 1000000),
    (else_try),
      (val_div, ":ram_speed", "$ram_num_men_pushing"),
    (try_end),

	
    (try_begin),
      (le, "$cur_ram_pos", 55),
      (init_position, pos3),
      (position_rotate_x, pos3, ":distance_moved"),
      (scene_get_slot, ":base_ram_object", ":cur_scene", "slot_scene_ram_props_begin"),
      (prop_instance_get_position, pos4, ":base_ram_object"),
      (entry_point_get_position,pos1,"$cur_ram_pos"),
      (try_for_range, ":i_ram_object_pos", "slot_scene_ram_props_begin", "$last_ram_object_pos"),
        (scene_get_slot, ":cur_ram_object", ":cur_scene", ":i_ram_object_pos"),
        (try_begin),
          (ge, ":i_ram_object_pos", "$ram_rotating_objects_begin"),
          (prop_instance_get_starting_position, pos5, ":base_ram_object"),
          (prop_instance_get_starting_position, pos6, ":cur_ram_object"),
          (position_transform_position_to_local, pos7, pos5, pos6),
          (position_transform_position_to_parent, pos5, pos4, pos7),
          (position_transform_position_to_parent, pos6, pos5, pos3),
          (prop_instance_set_position, ":cur_ram_object", pos6),
        (else_try),
          (assign, ":pos_no", pos_ram_begin),
          (val_add, ":pos_no", ":i_ram_object_pos"),
          (val_sub, ":pos_no", "slot_scene_ram_props_begin"),
          (position_transform_position_to_parent, pos2, pos1, ":pos_no"),
          (prop_instance_animate_to_position, ":cur_ram_object", pos2, ":ram_speed"),
        (try_end),
      (try_end),
    (try_end),
    (gt, "$cur_ram_pos", 55),
    (assign, "$ram_positioned", 1),
  ]),

#####rotar ram
##  ("cf_siege_rotate_ram_platform",
##   [(eq, "$ram_positioned", 1),
##    (scene_prop_get_instance, ":ram_object", "spr_ram_body", 0),
##    (prop_instance_get_position, pos1, ":ram_object"),
##    (position_rotate_x, pos1, -90),
##    (prop_instance_animate_to_position, ":ram_object", pos1, 400),
##    (assign, "$ram_positioned", 2),
##  ]),


  ("cf_siege_assign_men_to_ram",
   [
    (store_mission_timer_a, ":cur_seconds"),
    (neq, "$last_ram_object_pos", "slot_scene_ram_props_begin"),
    (assign, ":end_trigger", 0),
    (try_begin),
    (eq, "$g_ram_was_destroyed", 0), #chief fire arrow
    (lt, "$ram_positioned", 3),
      (get_player_agent_no, ":player_agent"),
      (store_current_scene, ":cur_scene"),
      (scene_get_slot, ":first_ram_object", ":cur_scene", "slot_scene_ram_props_begin"),
      (prop_instance_get_position, pos2, ":first_ram_object"),
      (assign, ":slot_1_positioned", 0),
      (assign, ":slot_2_positioned", 0),
      (assign, ":slot_3_positioned", 0),
      (assign, ":slot_4_positioned", 0),
      (assign, ":slot_5_positioned", 0),
      (assign, ":slot_6_positioned", 0),
      (assign, "$ram_num_slots_positioned", 0),
      (assign, "$ram_num_men_pushing", 0),
      (try_for_agents, ":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (try_begin),
          (agent_get_slot, ":x_pos", ":cur_agent", "slot_agent_target_x_pos"),
          (neq, ":x_pos", 0),
          (agent_get_slot, ":y_pos", ":cur_agent", "slot_agent_target_y_pos"),
          (try_begin),
            (eq, ":x_pos", -600),
            (try_begin),
              (eq, ":y_pos", 0),
              (assign, ":slot_1_positioned", 1),
            (else_try),
              (eq, ":y_pos", -200),
              (assign, ":slot_2_positioned", 1),
            (else_try),
              (assign, ":slot_3_positioned", 1),
            (try_end),
          (else_try),
            (try_begin),
              (eq, ":y_pos", 0),
              (assign, ":slot_4_positioned", 1),
            (else_try),
              (eq, ":y_pos", -200),
              (assign, ":slot_5_positioned", 1),
            (else_try),
              (assign, ":slot_6_positioned", 1),
            (try_end),
          (try_end),
          (val_add, "$ram_num_slots_positioned", 1),
          (init_position, pos1),
          (position_move_x, pos1, ":x_pos"),
          (position_move_y, pos1, ":y_pos"),
          (init_position, pos3),
          (position_move_x, pos3, ":x_pos"),
          (position_move_y, pos3, -1000),
          (position_transform_position_to_parent, pos4, pos2, pos1),
          (position_transform_position_to_parent, pos5, pos2, pos3),
          (agent_get_position, pos6, ":cur_agent"),
          (get_distance_between_positions, ":target_distance", pos6, pos4),
          (get_distance_between_positions, ":waypoint_distance", pos6, pos5),
          (try_begin),
            (this_or_next|lt, ":target_distance", ":waypoint_distance"),
            (lt, ":waypoint_distance", 600),
            (agent_set_scripted_destination, ":cur_agent", pos4, 1),
          (else_try),
            (agent_set_scripted_destination, ":cur_agent", pos5, 1),
          (try_end),
          (try_begin),
            (le, ":target_distance", 300),
            (val_add, "$ram_num_men_pushing", 1),
          (try_end),
        (else_try),
          (agent_get_team, ":cur_agent_team", ":cur_agent"),
          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
          (             eq, "$attacker_team_2", ":cur_agent_team"),
          (try_begin),
            (gt, ":cur_seconds", 20),
            (agent_get_position, pos1, ":cur_agent"),
            (agent_set_scripted_destination, ":cur_agent", pos1, 0),
          (else_try),
            (try_begin),
              (team_get_movement_order, ":order1", "$attacker_team", grc_infantry),
              (team_get_movement_order, ":order2", "$attacker_team", grc_cavalry),
              (team_get_movement_order, ":order3", "$attacker_team", grc_archers),
              (this_or_next|neq, ":order1", mordr_stand_ground),
              (this_or_next|neq, ":order2", mordr_stand_ground),
              (neq, ":order3", mordr_stand_ground),
              (set_show_messages, 0),
              (team_give_order, "$attacker_team", grc_everyone, mordr_stand_ground),
              (set_show_messages, 1),
            (try_end),
          (try_end),
        (try_end),
      (try_end),
      (try_begin),
        (lt, "$ram_num_slots_positioned", 6),
        (try_for_agents, ":cur_agent"),
          (agent_is_alive, ":cur_agent"),
          (agent_get_team, ":cur_agent_team", ":cur_agent"),
          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
          (             eq, "$attacker_team_2", ":cur_agent_team"),
          (neq, ":player_agent", ":cur_agent"),
          (agent_get_class, ":agent_class", ":cur_agent"),
          (this_or_next|eq, ":agent_class", grc_infantry),
          (eq, ":agent_class", grc_cavalry),
          (agent_get_slot, ":x_pos", ":cur_agent", 1),
          (eq, ":x_pos", 0),
          (assign, ":y_pos", 0),
          (try_begin),
            (eq, ":slot_1_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_1_positioned", 1),
          (else_try),
            (eq, ":slot_2_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_2_positioned", 1),
          (else_try),
            (eq, ":slot_3_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_3_positioned", 1),
          (else_try),
            (eq, ":slot_4_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_4_positioned", 1),
          (else_try),
            (eq, ":slot_5_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_5_positioned", 1),
          (else_try),
            (eq, ":slot_6_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_6_positioned", 1),
          (try_end),
          (val_add, "$ram_num_slots_positioned", 1),
          (agent_set_slot, ":cur_agent", 1, ":x_pos"),
          (agent_set_slot, ":cur_agent", 2, ":y_pos"),
        (try_end),
      (try_end),
      (try_begin),
        (store_mission_timer_a, ":cur_timer"),
        (gt, ":cur_timer", 20),
        (lt, "$ram_num_slots_positioned", 6),
        (try_for_agents, ":cur_agent"),
          (agent_is_alive, ":cur_agent"),
          (agent_get_team, ":cur_agent_team", ":cur_agent"),
          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
          (             eq, "$attacker_team_2", ":cur_agent_team"),
          (neq, ":player_agent", ":cur_agent"),
          (agent_get_slot, ":x_pos", ":cur_agent", 1),
          (eq, ":x_pos", 0),
          (assign, ":y_pos", 0),
          (try_begin),
            (eq, ":slot_1_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_1_positioned", 1),
          (else_try),
            (eq, ":slot_2_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_2_positioned", 1),
          (else_try),
            (eq, ":slot_3_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_3_positioned", 1),
          (else_try),
            (eq, ":slot_4_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_4_positioned", 1),
          (else_try),
            (eq, ":slot_5_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_5_positioned", 1),
          (else_try),
            (eq, ":slot_6_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_6_positioned", 1),
          (try_end),
          (val_add, "$ram_num_slots_positioned", 1),
          (agent_set_slot, ":cur_agent", 1, ":x_pos"),
          (agent_set_slot, ":cur_agent", 2, ":y_pos"),
        (try_end),
      (try_end),
    (else_try),
      (assign, ":end_trigger", 1),
      (try_for_agents, ":cur_agent"),
        (agent_clear_scripted_mode, ":cur_agent"),
      (try_end),
      (set_show_messages, 0),
      (team_give_order, "$attacker_team", grc_everyone, mordr_charge),
      (set_show_messages, 1),
    (try_end),
    (eq, ":end_trigger", 1),
  ]),
####siege warfare battering ram acaba chief
  
    ## FORAGING v1.0 chief #######################################################################
  ## Script food_consumption_display_message
  ## display food consumption
  ## use reg1 and reg2 and reg4 from forage
  ## hooked in simple trigger for food consumption every 14 hours
  ("food_consumption_display_message",
   [
    (store_script_param, ":num_men", 1),

    (assign, reg1, ":num_men"),
    # Display day of food left with current amount and party size
    (assign, ":available_food", 0),
    (troop_get_inventory_capacity, ":capacity", "trp_player"),
    (try_for_range, ":cur_slot", 0, ":capacity"),
      (troop_get_inventory_slot, ":cur_item", "trp_player", ":cur_slot"),
      (try_begin),
      (this_or_next|is_between, ":cur_item", bebidas_begin, bebidas_end), #chief anade para bebidas consumo
        (is_between, ":cur_item", food_begin, food_end),
        (troop_get_inventory_slot_modifier, ":item_modifier", "trp_player", ":cur_slot"),
        (neq, ":item_modifier", imod_rotten),
        (troop_inventory_slot_get_item_amount, ":cur_amount", "trp_player", ":cur_slot"),
        (val_add, ":available_food", ":cur_amount"),
      (try_end),
    (try_end),
   
    (assign, ":num_food_hours", ":available_food"),
    (val_mul, ":num_food_hours", 14),
    (val_div, ":num_food_hours", 24),
    (val_div, ":num_food_hours", ":num_men"),
    (assign, ":num_food_days", ":num_food_hours"),
    (assign, reg2, ":num_food_days"),
   
    (try_begin),
      (lt, reg2, 4),
      (display_message, "@Your party consumed {reg1} units of food{reg4?, {reg4} from foraging : }({reg2} days left).", 0xFF0000),
    (else_try),
      (display_message, "@Your party consumed {reg1} units of food{reg4?, {reg4} from foraging : }({reg2} days left)."),
    (try_end),
   ]),

  # Script forage_for_food
  # Compute foraging amount
  # use s2, reg0, reg1 and reg10
  # for DEBUG, use s1 and reg11
  # use reg4 for return value
  ("forage_for_food",
   [
        # Get max skill in party for foraging
        (call_script, "script_get_max_skill_of_player_party", "skl_foraging"),
        (assign, ":max_foraging_in_party", reg0),
        (assign, ":max_skill_owner", reg1),

        # Initialize foraged food amount and register
        (assign, ":foraged_food", 0),
        (assign, reg4, 0),
       
        (try_begin),
          # stop if no-one has foraging skill
          (gt, ":max_foraging_in_party", 0),

          (try_begin),
            # set limits and range for foraging
            (assign,  ":foraging_limit", ":max_foraging_in_party"),
            (val_mul, ":foraging_limit", 5),
            (assign,  ":foraging_distance", ":max_foraging_in_party"),
            (val_mul, ":foraging_distance", 2),

            # Check distance from village or town
            (try_for_parties,":foraging_site"),
              (assign, ":foraged_food_at_site", 0),
              (this_or_next|party_slot_eq, ":foraging_site", "slot_party_type", spt_town),
              (party_slot_eq, ":foraging_site", "slot_party_type", spt_village),
              (neg|party_slot_eq, ":foraging_site", "slot_village_state", svs_looted), # no foraging from looted village

              # Compute center distance to party
              (store_distance_to_party_from_party, ":distance", ":foraging_site", "p_main_party"),
              (try_begin),
                (le,":distance",":foraging_distance"), # we can forage from this center

                # Forage from fields
                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_acres_grain"),
                (val_div, ":temp_forage", 1000), # 500 was too low, try 1000
                (val_add, ":foraged_food_at_site", ":temp_forage"),

                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_acres_vineyard"),
                (val_div, ":temp_forage", 800), # 400 was too low, try 800
                (val_add, ":foraged_food_at_site", ":temp_forage"),

                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_acres_vineyard"), # second time for fruits
                (val_div, ":temp_forage", 1000), # 500 was too low, try 1000
                (val_add, ":foraged_food_at_site", ":temp_forage"),

                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_acres_olives"),
                (val_div, ":temp_forage", 1200), # 600 was too low, try 1200
                (val_add, ":foraged_food_at_site", ":temp_forage"),

                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_acres_dates"),
                (val_div, ":temp_forage", 960), # 480 was to low, try 960
                (val_add, ":foraged_food_at_site", ":temp_forage"),

                # Forage from herds
                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_head_cattle"),
                (val_div, ":temp_forage", 36),
                (val_add, ":foraged_food_at_site", ":temp_forage"),

                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_head_sheep"),
                (val_div, ":temp_forage", 60),
                (val_add, ":foraged_food_at_site", ":temp_forage"),

                # Forage from gardens and apiaries
                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_household_gardens"),
                (val_add, ":foraged_food_at_site", 2),

                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_apiaries"),
                (val_add, ":foraged_food_at_site", 1),
 
                # Forage game in traps
                (party_get_slot, ":temp_forage", ":foraging_site", "slot_center_fur_traps"),
                (val_add, ":foraged_food_at_site", ":temp_forage"),

                # Add amount foraged off the center to the total
                (val_add, ":foraged_food", ":foraged_food_at_site"),

                # DEBUG message to tweak values, uncomment to display
                #(str_store_party_name, s1, ":foraging_site"),
                #(assign, reg11, ":foraged_food_at_site"),
                #(display_message, "@DEBUG foraging: foraged {reg11} units from {s1}.", 0xFF00FF),
              (try_end),
            (try_end), # end of centers loop

            # Check terrain for foraging from the countryside
            (party_get_current_terrain, ":cur_terrain", "p_main_party"),
            (try_begin),
              (is_between, ":cur_terrain", rt_bridge, rt_desert_forest),
              (assign, reg10, 4),
            (else_try),
              (is_between, ":cur_terrain", rt_steppe, rt_snow),# Changed rt_plain to rt_snow so you can forage on plains. TML. F123 - Submod -> 1.41
              (assign, reg10, 2),
            (else_try),
              (assign, reg10, 0),
            (try_end),

            # Add foraged amount from countryside to total amount
            (val_add, ":foraged_food", reg10),

            # DEBUG message to tweak values, uncomment to display
            #(display_message, "@DEBUG foraging: foraged {reg10} units from countryside.", 0xFF00FF),

            # Tier Multiplier, foraging value multiplied by foraging skill tier bonus
            # Represent experience, less time to find forage means more food foraged
            (try_begin),
              # between 2-4, x1.5 bonus
              (gt, ":max_foraging_in_party", 1),
              (lt, ":max_foraging_in_party", 5),
              (val_mul, ":foraged_food", 3),
              (val_div, ":foraged_food", 2),
            (else_try),
              # between 5-7, x2 bonus
              (gt, ":max_foraging_in_party", 4),
              (lt, ":max_foraging_in_party"),
              (val_mul, ":foraged_food", 2),
            (else_try),
              # between 8-9, x2.5 bonus
              (gt, ":max_foraging_in_party", 7),
              (lt, ":max_foraging_in_party", 10),
              (val_mul, ":foraged_food", 5),
              (val_div, ":foraged_food", 2),
            (else_try),
              # 10 and more, x3 bonus
              (ge, ":max_foraging_in_party", 10),
              (val_mul, ":foraged_food", 3),
            (try_end),

            # Apply Camp bonus x1.5 (represent more time to forage)
            (try_begin),
              #(this_or_next|ge, "$current_camp_party", -1), # uncomment if using Entrenchment
              (this_or_next|eq, "$g_camp_mode", 1),
              (eq, "$g_siege_force_wait", 1),
              (val_mul, ":foraged_food", 3),
              (val_div, ":foraged_food", 2),       
            (try_end),

            # Apply foraging limit according to skill level (modified by party bonus)
            (try_begin),
              (gt, ":foraged_food", ":foraging_limit"),
              (assign, ":foraged_food", ":foraging_limit"),
            (try_end),

            # assign amount foraged to register to deduct from party consumption
            (assign, reg4, ":foraged_food"),

            # End of foraging message
            (try_begin),
              (gt, ":foraged_food", 0),
              (str_store_troop_name, s2, ":max_skill_owner"),
              (display_message, "@{s2} managed to forage {reg4} units of food to complement supplies.", 0x00FF00),
            (try_end),
          (try_end),
        (try_end),
   ]),
## Jrider - chief
  ##CC commander chief empieza
    ("print_kill_count_to_s0",
    [
      (assign, ":total_reported", 0),
      (str_clear, s0),
      (try_for_agents, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_get_troop_id, ":agent_troop_id", ":cur_agent"),
        (troop_is_hero, ":agent_troop_id"),
        (agent_get_kill_count, ":num_killed", ":cur_agent"),
        (agent_get_kill_count, ":num_wounded", ":cur_agent", 1),
        (troop_get_slot, ":troop_kill_count", ":agent_troop_id", "slot_troop_kill_count"),
        (troop_get_slot, ":troop_wound_count", ":agent_troop_id", "slot_troop_wound_count"),
        (val_add, ":troop_kill_count", ":num_killed"),
        (val_add, ":troop_wound_count", ":num_wounded"),
        (troop_set_slot, ":agent_troop_id", "slot_troop_kill_count", ":troop_kill_count"),
        (troop_set_slot, ":agent_troop_id", "slot_troop_wound_count", ":troop_wound_count"),
        (this_or_next|gt, ":num_killed", 0),
        (gt, ":num_wounded", 0),
        (str_store_troop_name, s1, ":agent_troop_id"),
        (store_add, reg3, ":num_killed", ":num_wounded"),
        (assign, reg4, ":num_killed"),
        (assign, reg5, ":num_wounded"),
        (str_store_string, s2, "@{reg4} killed, {reg5} wounded"),
        (try_begin),
          (this_or_next|eq, ":agent_troop_id", "trp_player"),
          (is_between, ":agent_troop_id", companions_begin, companions_end),
          (str_store_string, s0, "@{s0}^{s1}: {reg3} ({s2})"),
        (else_try),
          (agent_is_ally, ":cur_agent"),
          (str_store_string, s0, "@{s0}^{s1}(ally): {reg3} ({s2})"),
        (else_try),
          (str_store_string, s0, "@{s0}^{s1}(enemy): {reg3} ({s2})"),
        (try_end),
        (val_add, ":total_reported", 1),
      (try_end),
      (try_begin),
        (eq, ":total_reported", 0),
        (str_store_string, s0, "@^None"),
      (try_end),
  ]),

    ("change_rain_or_snow",
   [
    (party_get_current_terrain, ":terrain_type", "p_main_party"),
    (try_begin),
      (this_or_next|eq, ":terrain_type", 4),
      (eq, ":terrain_type", 12),
      (assign, ":rain_type", 2),
    (else_try),
      (assign, ":rain_type", 1),
    (try_end),
  
    (assign, reg0, -1), #Floris - weather effects
    (assign, reg1, -1), #Floris - weather effects
    (store_random_in_range, ":rain_power", 1, 100),
    (try_begin),
      (get_global_cloud_amount, ":clouds"), #Floris - weather effects
      (ge, ":clouds", 40), #Floris - weather effects #This fixes rain without any clouds that players have been experiencing
      (lt, ":rain_power", "$g_rand_rain_limit"),
      (store_mul, ":haze_power", ":rain_power", "$g_rand_rain_limit"),
      (val_div, ":haze_power", 100),
      (gt, ":haze_power", 0),
      (set_rain, ":rain_type", ":haze_power"),
      (assign, reg0, ":rain_type"), #Floris - weather effects
      (assign, reg1, ":haze_power"), #Floris - weather effects
    (try_end),
  ]),

  ("get_lord_weekly_income", 
   [
     (store_script_param, ":troop_no", 1),
     
      (assign, ":weekly_income", 500), #let every hero receive 750 denars by default
      
      (store_character_level, ":troop_level", ":troop_no"),
      (store_mul, ":level_income", ":troop_level", 10),
      (val_add, ":weekly_income", ":level_income"),
      
      (store_troop_faction,":faction_no", ":troop_no"),
      (try_begin), #check if troop is kingdom leader
        (faction_slot_eq, ":faction_no", "slot_faction_leader", ":troop_no"),
        (val_add, ":weekly_income", 1000),
      (try_end),
      
      (try_begin), #check if troop is marshall
        (faction_slot_eq, ":faction_no", "slot_faction_marshall", ":troop_no"),
        (val_add, ":weekly_income", 1000),
      (try_end),
      
#     ## CC
#     (store_character_level, ":troop_level", "trp_player"),
#     (val_mul, ":troop_level", 2),
#     (val_add, ":troop_level", 100),
#     (val_mul, ":weekly_income", ":troop_level"),
#     (val_div, ":weekly_income", 100),
#     ## CC
     (assign, reg0, ":weekly_income"),
   ]),

  ##CC chief commander acaba
###reclutar en ciudades chief somebody
##  ("set_max_troops",
##                          [#set max available troops
##                            (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
##                              (store_relation,":relation",":cur_faction","fac_player_faction"),
##                              (troop_get_slot, ":renown", "trp_player", "slot_troop_renown"),
##                              (val_div,":renown",20),
##                              (store_add,":cur_max_troops",":renown",":relation"),
##                              (val_add, ":cur_max_troops", "$player_right_to_rule"),
##                              (val_div,":cur_max_troops",2),
##                              (val_add,":cur_max_troops",2),
##                              (faction_set_slot,":cur_faction","slot_faction_town_troop_pool_max",":cur_max_troops"),
##                            (try_end),
##                        ]),
##                       
##                        ("set_available_troops",
##                          [
##                            # add new available troops
##                            #(assign,":cur_faction",0),
##	(try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
##		(assign,":cur_max_troops",0),
##		(assign,":cur_available_troops",0),
##		(faction_get_slot, ":cur_max_troops", ":cur_faction", "slot_faction_town_troop_pool_max"),
##		(faction_get_slot, ":cur_available_troops", ":cur_faction", "slot_faction_town_troop_pool_available"),
##		(try_begin),
##			(gt,":cur_available_troops",":cur_max_troops"),
##			(assign,":cur_available_troops",":cur_max_troops"),
##			(faction_set_slot, ":cur_faction", "slot_faction_town_troop_pool_available", ":cur_available_troops"),
##		(else_try),
##			(lt,":cur_available_troops",":cur_max_troops"),
##			(store_sub,":cur_open_slots",":cur_max_troops",":cur_available_troops"),
##			(try_for_range,":unused",0,":cur_open_slots"),
##			(store_random_in_range,":random",0,100),
##			(try_begin),
##				(lt,":random",troops_refill_rate),
##				(val_add,":cur_available_troops",1),
##			(try_end),
##			(faction_set_slot,":cur_faction","slot_faction_town_troop_pool_available",":cur_available_troops"),
##			(try_end),
##		(try_end),
##	(try_end),
##                        ]),
#reclutar en ciudades chief somebody acaba  
  #prisioneros escapan de party chief
    # script_prisoners_escape_from_party
  # Checks for each prisoner to escape
  ("prisoners_escape_from_party",
    [
	(assign, ":num_escaped", 0),
	(party_get_num_companions,":num_guards","p_main_party"),
	(val_add, ":num_guards", 1),
	(party_get_num_prisoners,":num_prisoners","p_main_party"),
	(store_div, ":escape_chance",":num_prisoners",":num_guards"),
	(val_mul, ":escape_chance", ":escape_chance"),
	
    (party_get_num_prisoner_stacks, ":num_stacks", "p_main_party"),
    (try_for_range_backwards, ":cur_stack", 0, ":num_stacks"),
       (party_prisoner_stack_get_troop_id, ":cur_troop", "p_main_party", ":cur_stack"),
       (neg|troop_is_hero, ":cur_troop"),
	   (party_prisoner_stack_get_size, ":stack_size","p_main_party",":cur_stack"),
		(try_for_range_backwards, ":unused", 0, ":stack_size"),
	       (store_random_in_range,":random_no",0,100),
	       (lt,":random_no",":escape_chance"),
		   (party_remove_prisoners,"p_main_party",":cur_troop",1),
		   (val_add, ":num_escaped", 1),
		(try_end),
	(try_end),
       (assign, reg0, ":num_escaped"),
	(try_begin),
		(gt, reg0, 0),
       (display_message, "@{reg0} of your prisoners escaped!", color_terrible_news),
	(try_end),
     ]),
  #chief garnier prisioneros escapan

  #---BEGIN LYX HELPER-SCRIPTS--- ramdon eventsn chief

   #script to get a troop's health
   #INPUT: arg1 = troop_no
   #OUTPUT: reg0 - health percentage
   ("get_troop_health",[
      (store_script_param, ":troop_no", 1),
      (store_troop_health, reg0, ":troop_no")
   ]),

   #script to modify a troop's health
   #INPUT: arg1 = troop_no, arg2 = health percentage modifier
   #OUTPUT: none
   ("change_troop_health",[
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":modifier", 2),
      (store_troop_health, ":troop_hp",":troop_no"),
      (val_add, ":troop_hp", ":modifier"),
      (val_clamp, ":troop_hp", 1, 100),
      (troop_set_health, ":troop_no", ":troop_hp"),
   ]),

  #order skirmish caba'drin chief
   
  # script_order_set_slot
  # Input: Order Type   
  # Output: Modified "slot_party_cabadrin_order_d"*; reg0 if shield order
 ("order_set_slot", [
    (store_script_param_1, ":ordertype"),
    (get_player_agent_no, ":player"),
    (agent_get_team, ":playerteam", ":player"),
   
    (try_for_range, ":class", 0, 8),
        (class_is_listening_order, ":playerteam", ":class"), #Listening to Order
        (store_add, ":class_ordered", ":class", "slot_party_cabadrin_orders_begin"),
        (party_get_slot, ":caba_order_index", "p_main_party", ":class_ordered"),
       
        (store_div, ":skirmish_order", ":caba_order_index", 100),
        (store_mul, ":shield_order", ":skirmish_order", 100),
        (val_sub, ":caba_order_index", ":shield_order"),
        (store_div, ":shield_order", ":caba_order_index", 10),
        (store_mul, ":weapon_order", ":shield_order", 10),
        (store_sub, ":weapon_order", ":caba_order_index", ":weapon_order"),
       
        (try_begin),
            (eq, ":ordertype", clear),
            (assign, ":weapon_order", 3),
            (assign, ":shield_order", 3),
        (else_try),
            (eq, ":ordertype", ranged),
            (assign, ":weapon_order", 0),
        (else_try),
            (eq, ":ordertype", onehand),
            (assign, ":weapon_order", 1),
        (else_try),
            (eq, ":ordertype", bothhands),
            (assign, ":weapon_order", 2),
        (else_try),           
            (eq, ":ordertype", shield),
            (try_begin),
                (this_or_next|eq, ":shield_order", 3),
                (eq, ":shield_order", 2),
                (assign, ":shield_order", 1),
                (assign, reg0, 4),
            (else_try),
                (eq, ":shield_order", 1),
                (assign, ":shield_order", 2),
                (assign, reg0, 5),
            (try_end),
        (else_try),
            (eq, ":ordertype", 6),
            (assign, ":skirmish_order", 0),
        (else_try),
            (eq, ":ordertype", 7),
            (assign, ":skirmish_order", 1),
        (try_end),
 
        (val_mul, ":skirmish_order", 100),
        (val_mul, ":shield_order", 10),
        (store_add, ":caba_order_index", ":skirmish_order", ":shield_order"),
        (val_add, ":caba_order_index", ":weapon_order"),             
       
        (party_set_slot, "p_main_party", ":class_ordered", ":caba_order_index"),
    (try_end), #Class Loop
   
    ]),

  # script_order_set_display_text
  # Input: Order Type   
  # Output: None
 ("order_set_display_text", [
    (store_script_param_1, ":ordertype"),
    (get_player_agent_no, ":player"),
    (agent_get_team, ":playerteam", ":player"),
   
    (party_get_num_companion_stacks, ":num_of_stacks", "p_main_party"),
    (try_for_range, ":i", 0, ":num_of_stacks"),
        (party_stack_get_troop_id, ":troop", "p_main_party", ":i"),
        (neq, ":troop", "trp_player"),
        (troop_get_class, ":class", ":troop"),
        (try_begin), #Mark class as in battle
             (eq, ":class", 0),
             (assign, ":group0_in_battle", 1),
         (else_try),
             (eq, ":class", 1),
             (assign, ":group1_in_battle", 1),   
         (else_try),
             (eq, ":class", 2),
             (assign, ":group2_in_battle", 1),         
         (else_try),
             (eq, ":class", 3),
             (assign, ":group3_in_battle", 1),         
         (else_try),
             (eq, ":class", 4),
             (assign, ":group4_in_battle", 1),         
         (else_try),
             (eq, ":class", 5),
             (assign, ":group5_in_battle", 1),   
         (else_try),
             (eq, ":class", 6),
             (assign, ":group6_in_battle", 1),         
         (else_try),
             (eq, ":class", 7),
             (assign, ":group7_in_battle", 1),         
         (else_try),
             (eq, ":class", 8),
             (assign, ":group8_in_battle", 1),                       
         (try_end),
         (class_is_listening_order, ":playerteam", ":class"), #Is the stack's class selected?
         (try_begin), #Mark class as selected
             (eq, ":class", 0),
             (assign, ":group0_is_selected", 1),
         (else_try),
             (eq, ":class", 1),
             (assign, ":group1_is_selected", 1),   
         (else_try),
             (eq, ":class", 2),
             (assign, ":group2_is_selected", 1),         
         (else_try),
             (eq, ":class", 3),
             (assign, ":group3_is_selected", 1),         
         (else_try),
             (eq, ":class", 4),
             (assign, ":group4_is_selected", 1),         
         (else_try),
             (eq, ":class", 5),
             (assign, ":group5_is_selected", 1),   
         (else_try),
             (eq, ":class", 6),
             (assign, ":group6_is_selected", 1),         
         (else_try),
             (eq, ":class", 7),
             (assign, ":group7_is_selected", 1),         
         (else_try),
             (eq, ":class", 8),
             (assign, ":group8_is_selected", 1),                       
         (try_end),
    (try_end), #Stack Loop
   
    (try_begin),
        (eq, ":ordertype", ranged),
        (str_store_string, s1, "@ready bows and missiles"),
    (else_try),
        (eq, ":ordertype", onehand),
        (str_store_string, s1, "@ready side arms"),
    (else_try),
        (eq, ":ordertype", bothhands),
        (str_store_string, s1, "@ready two-handers and polearms"),
    (else_try),           
        (eq, ":ordertype", 4),
        (str_store_string, s1, "@brandish shields"),
    (else_try),
        (eq, ":ordertype", 5),
        (str_store_string, s1, "@doff your shields"),
    (else_try),
        (eq, ":ordertype", 6),
        (str_store_string, s1, "@stand and fight"),
    (else_try),
        (eq, ":ordertype", 7),
        (str_store_string, s1, "@avoid melee"),
    (try_end),
         
    (str_clear, s2),
    (str_clear, s3),
    (assign, ":count_possible", 0),
    (assign, ":count_selected", 0),
    (try_begin),
        (eq, ":group0_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group0_is_selected", 1),
        (val_add, ":count_selected", 1),
        (str_store_class_name, s2, 0),
    (try_end),
    (try_begin),
        (eq, ":group1_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group1_is_selected", 1),
        (val_add, ":count_selected", 1),
        (try_begin),
            (neg|str_is_empty, s2),
            (str_store_class_name, s3, 1),
            (str_store_string, s2, "@{!}{s2}, {s3}"),
        (else_try),
            (str_store_class_name, s2, 1),
        (try_end),
    (try_end),
    (try_begin),
        (eq, ":group2_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group2_is_selected", 1),
        (val_add, ":count_selected", 1),
        (try_begin),
            (neg|str_is_empty, s2),
            (str_store_class_name, s3, 2),
            (str_store_string, s2, "@{!}{s2}, {s3}"),
        (else_try),
            (str_store_class_name, s2, 2),
        (try_end),
    (try_end),
    (try_begin),
        (eq, ":group3_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group3_is_selected", 1),
        (val_add, ":count_selected", 1),
        (try_begin),
            (neg|str_is_empty, s2),
            (str_store_class_name, s3, 3),
            (str_store_string, s2, "@{!}{s2}, {s3}"),
        (else_try),
            (str_store_class_name, s2, 3),
        (try_end),
    (try_end),
    (try_begin),
        (eq, ":group4_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group4_is_selected", 1),
        (val_add, ":count_selected", 1),
        (try_begin),
            (neg|str_is_empty, s2),
            (str_store_class_name, s3, 4),
            (str_store_string, s2, "@{!}{s2}, {s3}"),
        (else_try),
            (str_store_class_name, s2, 4),
        (try_end),
    (try_end),
    (try_begin),
        (eq, ":group5_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group5_is_selected", 1),
        (val_add, ":count_selected", 1),
        (try_begin),
            (neg|str_is_empty, s2),
            (str_store_class_name, s3, 5),
            (str_store_string, s2, "@{!}{s2}, {s3}"),
        (else_try),
            (str_store_class_name, s2, 5),
        (try_end),
    (try_end),
    (try_begin),
        (eq, ":group6_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group6_is_selected", 1),
        (val_add, ":count_selected", 1),
        (try_begin),
            (neg|str_is_empty, s2),
            (str_store_class_name, s3, 6),
            (str_store_string, s2, "@{!}{s2}, {s3}"),
        (else_try),
            (str_store_class_name, s2, 6),
        (try_end),
    (try_end),
    (try_begin),
        (eq, ":group7_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group7_is_selected", 1),
        (val_add, ":count_selected", 1),
        (try_begin),   
            (neg|str_is_empty, s2),
            (str_store_class_name, s3, 7),
            (str_store_string, s2, "@{!}{s2}, {s3}"),
        (else_try),
            (str_store_class_name, s2, 7),
        (try_end),
    (try_end),
    (try_begin),
        (eq, ":group8_in_battle", 1),
        (val_add, ":count_possible", 1),
        (eq, ":group8_is_selected", 1),
        (val_add, ":count_selected", 1),
        (try_begin),
            (neg|str_is_empty, s2),
            (str_store_class_name, s3, 8),
            (str_store_string, s2, "@{!}{s2}, {s3}"),
        (else_try),
            (str_store_class_name, s2, 8),
        (try_end),
    (try_end),
    (try_begin),
        (eq, ":count_selected", ":count_possible"),
        (str_store_string, s2, "@Everyone"),
    (try_end),
    (try_begin),
        (gt, ":count_selected", 0),
        (display_message, "@{!}{s2}, {s1}!", 0xFFDDDD66),
    (try_end),
    (str_clear, s2),
    (str_clear, s3),
   ]),

  # script_order_weapon_type_switch
  # Input: Order Type   
  # Output: Nothing
  # On key depression, try to switch division to appropriate weapon
 ("order_weapon_type_switch", [
    (store_script_param_1, ":ordertype"),
    (get_player_agent_no, ":player"),
    (agent_get_team, ":playerteam", ":player"),
       
        #Change 2-hander order to be shield-less and note in shield slot that shield isn't used
        #If then in set slot, if shield is given after, try to use a shield too
        #what about ..hrm.
    (assign, ":weapon_order_type", ":ordertype"),
    (call_script, "script_order_set_slot", ":weapon_order_type"),
    (try_begin),
        (eq, ":ordertype", shield),
        (assign, ":weapon_order_type", reg0),
    (try_end),
    (call_script, "script_order_set_display_text", ":weapon_order_type"),
     
    (try_for_agents, ":agent"),
        (agent_is_alive, ":agent"),
        (agent_is_human, ":agent"),
        (agent_is_non_player, ":agent"),
        (agent_get_team, ":team", ":agent"),
        (eq, ":team", ":playerteam"), #On Player's side?
        (agent_get_division, ":class", ":agent"),
        (class_is_listening_order, ":team", ":class"), #Is the agent's class selected?
        (agent_get_troop_id, ":troop", ":agent"),     
        (try_begin),
            (troop_is_hero, ":troop"),
            (assign, ":end", ek_head),
            (try_for_range, ":i", ek_item_0, ":end"),
                (troop_get_inventory_slot,":item",":troop",":i"),
                (gt, ":item", 0),
                (item_get_type, ":weapontype", ":item"),
                (try_begin),
                    (eq, ":ordertype", ranged),
                    #(str_store_string, s1, "@ready bows and missiles"),
                    (this_or_next|eq, ":weapontype", itp_type_bow),
                    (this_or_next|eq, ":weapontype", itp_type_crossbow),
                    (eq, ":weapontype", itp_type_thrown),
                    (agent_set_wielded_item, ":agent", ":item"),
                    (assign, ":end", ek_item_0),#loop breaker
                (else_try),
                    (eq, ":ordertype", onehand),
                    #(str_store_string, s1, "@ready side arms"),
                    (eq, ":weapontype", itp_type_one_handed_wpn),
                    (agent_set_wielded_item, ":agent", ":item"),
                    (assign, ":end", ek_item_0),#loop breaker
                (else_try),
                    (eq, ":ordertype", bothhands),
                    #(str_store_string, s1, "@ready two-handers and polearms"),
                    (this_or_next|eq, ":weapontype", itp_type_two_handed_wpn),
                    (eq, ":weapontype", itp_type_polearm),
                    (agent_set_wielded_item, ":agent", ":item"),
                    (assign, ":end", ek_item_0),#loop breaker
                #(else_try),
                 #   (eq, ":ordertype", polearms),
                 #   (str_store_string, s1, "@ready polearms"),#i dvidied this out from twohanders since polearms are often used as blunts gdw51215
                 #   (eq, ":weapontype", itp_type_polearm),
                 #   (agent_set_wielded_item, ":agent", ":item"),
                 #   (assign, ":end", ek_item_0),#loop breaker
                (else_try),
                    (eq, ":ordertype", shield),
                    (agent_get_wielded_item, ":shield", ":agent", 1),
                	(try_begin),
                        (eq, ":weapon_order_type", 5), #Ordered to NOT use shields
                        (gt, ":shield", 0), #Has a shield wielded
                        (agent_unequip_item, ":agent", ":shield"),
                        (agent_equip_item, ":agent", ":shield"), #Moves shield to back
                        #(str_store_string, s1, "@doff your shields"),
                        (assign, ":end", ek_item_0),#loop breaker
                    (else_try),
                        (eq, ":weapon_order_type", 4), #Ordered to use shields
                        #Need to compleximafy
                        (le, ":shield", 0), #No shield currently wielded
                        (eq, ":weapontype", itp_type_shield),
                        (agent_set_wielded_item, ":agent", ":item"), #Moves shield from back to hand
                        #(str_store_string, s1, "@brandish shields"),
                        (assign, ":end", ek_item_0),#loop breaker
                    (try_end),       
                (try_end),
            (try_end),
        (else_try),#regular troops
            (troop_get_inventory_capacity,":cap",":troop"),
            (try_for_range, ":i", 0, ":cap"),#(slots < 10)?
                (troop_get_inventory_slot,":item",":troop",":i"),
                (gt, ":item", 0),
                (item_get_type, ":weapontype", ":item"),
                (try_begin),
                    (eq, ":ordertype", ranged),
                    #(str_store_string, s1, "@ready bows and missiles"),
                    (this_or_next|eq, ":weapontype", itp_type_bow),
                    (this_or_next|eq, ":weapontype", itp_type_crossbow),
                    (eq, ":weapontype", itp_type_thrown),
                    (agent_has_item_equipped, ":agent", ":item"),
                    (agent_set_wielded_item, ":agent", ":item"),
                    (assign, ":cap", 0),#loop breaker
                (else_try),
                    (eq, ":ordertype", onehand),
                    (str_store_string, s1, "@ready side arms"),
                    #(eq, ":weapontype", itp_type_one_handed_wpn),
                    (agent_has_item_equipped, ":agent", ":item"),
                    (agent_set_wielded_item, ":agent", ":item"),
                    (assign, ":cap", 0),#loop breaker
                (else_try),
                    (eq, ":ordertype", bothhands),
                    #(str_store_string, s1, "@ready two-handers and polearms"),
                    (this_or_next|eq, ":weapontype", itp_type_two_handed_wpn),
                    (eq, ":weapontype", itp_type_polearm),
                    (agent_has_item_equipped, ":agent", ":item"),
                    (agent_set_wielded_item, ":agent", ":item"),
                    (assign, ":cap", 0),#loop breaker
                (else_try),
                    (eq, ":ordertype", shield),
                    (agent_get_wielded_item, ":shield", ":agent", 1),
                    (try_begin),
                        (eq, ":weapon_order_type", 5), #Ordered to NOT use shields
                        (gt, ":shield", 0), #Has a shield wielded
                        (agent_unequip_item, ":agent", ":shield"),
                        (agent_equip_item, ":agent", ":shield"), #Moves shield to back
                        #(str_store_string, s1, "@doff your shields"),
                        (assign, ":cap", 0),#loop breaker
                    (else_try),
                        (eq, ":weapon_order_type", 4), #Ordered to use shields
                        (le, ":shield", 0), #No shield currently wielded
                        (eq, ":weapontype", itp_type_shield),
                        (agent_has_item_equipped, ":agent", ":item"),
                        (agent_set_wielded_item, ":agent", ":item"), #Moves shield from back to hand
                        #(str_store_string, s1, "@brandish shields"),
                        (assign, ":cap", 0),#loop breaker
                    (try_end),
                (try_end),
            (try_end),
        (try_end), #Hero v Regular Troop
    (try_end), #Agent Loop
    ]),

  # script_cf_order_skirmish_check
  # Input: Nothing
  # Output: Nothing
  # Check for an active Skirmish Order, in lieu of global variables
 ("cf_order_skirmish_check", [
    (assign, ":skirmish", 0),
    (try_for_range, ":i", "slot_party_cabadrin_orders_begin", "slot_party_cabadrin_orders_end"),
        (party_slot_ge, "p_main_party", ":i", 100),
        (assign, ":skirmish", 1),
    (try_end),
    (eq, ":skirmish", 1),
   ]),   

  # script_order_skirmish_begin_end
  # Input: Nothing
  # Output: Nothing
  # On key depression, determine if beginning or ending skirmish
  # If ending, stop any retreating. If beginning, call order_skirmish_skirmish
  # Display appropriate order text on screen.
 ("order_skirmish_begin_end", [
    (get_player_agent_no, ":player"),
    (agent_get_team, ":playerteam", ":player"),

    (assign, ":skirmish", 0),
    (assign, ":skirmish_order_type", 6),
   
    (try_for_range, ":class", 0, 8),
        (class_is_listening_order, ":playerteam", ":class"), #Listening to Order
        (store_add, ":class_ordered", ":class", "slot_party_cabadrin_orders_begin"),
        (neg|party_slot_ge, "p_main_party", ":class_ordered", 100),
        (assign, ":skirmish", 1),
        (assign, ":skirmish_order_type", 7),
    (try_end), #Class Loop
     
    (call_script, "script_order_set_slot", ":skirmish_order_type"),     
    (call_script, "script_order_set_display_text", ":skirmish_order_type"),
     
    (try_begin),
        (eq, ":skirmish", 0), 
        (try_for_agents, ":agent"),
            (agent_is_alive, ":agent"),
            (agent_is_human, ":agent"),
            (agent_is_non_player, ":agent"),
            (agent_get_team, ":team", ":agent"),
            (eq, ":team", ":playerteam"), #On Player's side?
            (agent_get_division, ":class", ":agent"),
            (class_is_listening_order, ":team", ":class"), #Is the agent's division selected?
            (try_begin),
                (agent_slot_eq, ":agent", "slot_agent_is_running_away", 0), #Is not routing or ordered to retreat
                (agent_stop_running_away, ":agent"),
            (try_end),
        (try_end), #Agent loop
    (else_try),     
        (eq, ":skirmish", 1),
        (call_script, "script_order_skirmish_skirmish"),
    (try_end),     
    ]),

  # script_order_skirmish_skirmish
  # Input: Nothing
  # Output: Nothing
  # Cycle through agents, checking and maintaining distance
 ("order_skirmish_skirmish", [
    (get_player_agent_no, ":player"),
    (agent_get_team, ":playerteam", ":player"),
   
    (set_fixed_point_multiplier, 1),
    (get_scene_boundaries, pos2, pos3),
    (position_get_x, ":bound_right", pos2),
    (position_get_y, ":bound_top", pos2),
    (position_get_x, ":bound_left", pos3),
    (position_get_y, ":bound_bottom", pos3),
     
    (try_for_agents, ":agent"),
        (agent_is_alive, ":agent"),
        (agent_is_human, ":agent"),
        (agent_is_non_player, ":agent"),
        (agent_get_team, ":team", ":agent"),
        (eq, ":team", ":playerteam"), #On Player's side?
        (agent_slot_eq, ":agent", "slot_agent_is_running_away", 0), #Is not routing or ordered to retreat
        (agent_get_division, ":class", ":agent"),
        (store_add, ":ordered_class", ":class", "slot_party_cabadrin_orders_begin"),
        (party_slot_ge, "p_main_party", ":ordered_class", 100), #Division is skirmishing
         
        (agent_get_position, pos1, ":agent"),   
        (position_get_x, ":agent_x", pos1),
        (position_get_y, ":agent_y", pos1),
        (store_sub, ":dist_right", ":agent_x", ":bound_right"),
        (store_sub, ":dist_top", ":agent_y", ":bound_top"),
        (store_sub, ":dist_left", ":bound_left", ":agent_x"),
        (store_sub, ":dist_bottom", ":bound_bottom", ":agent_y"),
        (agent_get_ammo, ":ammo", ":agent"),             
        (try_begin), #If agent is too close to edge of map, stop skirmishing. Will resume when back into map             
            (this_or_next|le, ":ammo", 0), #Stop skirmishing and resume orders if out of ammo
            (this_or_next|le, ":dist_right", 20),  #Limits accidental routing, of cav in particular
            (this_or_next|le, ":dist_top", 20),
            (this_or_next|le, ":dist_left", 20),
            (le, ":dist_bottom", 20),
            (agent_stop_running_away, ":agent"),
        (else_try),
            (call_script, "script_get_closest3_distance_of_enemies_at_pos1", ":team", pos1), # Find distance of nearest 3 enemies
            (assign, ":avg_dist", reg0),
            (assign, ":closest_dist", reg1),
            (try_begin),
                (this_or_next|lt, ":avg_dist", skirmish_min_distance),
                (lt, ":closest_dist", 700), #If enemy group is getting near or an enemy is on top of agent
                (agent_start_running_away, ":agent"),         
            (else_try),
                (ge, ":avg_dist", skirmish_max_distance), #If distance from enemy is (too) large, resume previous order
                (agent_stop_running_away, ":agent"),         
            (try_end), #Distance to enemy
        (try_end), #Distance from edge
    (try_end), #Agent loop
    ]),
  #cambio de armas chief acaba
  #caba'drin fuerza uso de lanzas en batalla chief
  # script_weapon_use_backup_weapon
  # Input: arg1: agent
  # Output: none
 ("weapon_use_backup_weapon",   
    [   
     # Find non-lance/spear/bow item in inventory
    (store_script_param_1, ":agent"),
    (agent_get_troop_id, ":troop",":agent"),     
    (assign,":has_choice",0),
    (try_begin),
        (troop_is_hero, ":troop"),
        (assign, ":end", ek_head),
        (try_for_range, ":i", ek_item_0, ":end"),
            (troop_get_inventory_slot,":item",":troop",":i"),
            (gt, ":item", 0),
            (item_get_type, ":weapontype", ":item"),
            (is_between, ":weapontype", itp_type_one_handed_wpn, itp_type_polearm),#one or two handed
            (assign,":has_choice",1),
            (assign, ":end", ek_item_0),#loop breaker
        (try_end),
    (else_try),#regular troops
        (troop_get_inventory_capacity,":cap",":troop"),
        (try_for_range, ":i", 0, ":cap"),#not sure if reg. troops have equipped items (slots < 10), but w/e
            (troop_get_inventory_slot,":item",":troop",":i"),
            (gt, ":item", 0),
            (item_get_type, ":weapontype", ":item"),
            (is_between, ":weapontype", itp_type_one_handed_wpn, itp_type_polearm),#one or two handed
            (agent_has_item_equipped, ":agent", ":item"),#this step is essential,
            (assign,":has_choice",1),#but I'm not sure if this would work or not
            (assign, ":cap", 0),
        (try_end),
    (try_end),
    (try_begin),# Equip their backup weapon.
        (eq, ":has_choice",1),
        (agent_is_non_player, ":agent"),
    (agent_set_wielded_item, ":agent", ":item"),
    (try_end),
    ]),   
     
  # script_weapon_use_classify_agent
  # Input: None
  # Output: None
 ("weapon_use_classify_agent", [     
    (try_for_agents, ":agent"),
        (agent_is_alive, ":agent"),
    # Isn't a player.
        (agent_is_non_player, ":agent"),
   # Isn't a horse.
        (agent_is_human, ":agent"),
        (agent_get_troop_id, ":troop",":agent"),
   # Get wielded item.
        (agent_get_wielded_item, ":wielded", ":agent", 0),
        (gt, ":wielded", 0),
        (item_get_type, ":wielded_type", ":wielded"),
   # They riding a horse?
        (agent_get_horse, ":horse", ":agent"),
        (try_begin),
            (gt, ":horse", 0),  # Is riding a horse.
            (neg|troop_is_guarantee_ranged, ":troop"), # Not a horsearcher/skirmisher
            (try_begin),
                (eq, ":wielded_type", itp_type_polearm), # Is it a polearm?
                (agent_set_slot, ":agent", "slot_agent_lance", ":wielded"),
            (else_try),   
          # Force the NPC to wield a polearm, but this will only happen if they
          # actually have a polearm equipped.  Otherwise this does nothing.
                (troop_get_inventory_capacity,":cap",":troop"),
                (try_for_range, ":i", 0, ":cap"),#not sure if reg. troops have equipped items (slots < 10), but w/e
                    (troop_get_inventory_slot,":item",":troop",":i"),
                    (gt, ":item", 0),
                    (item_get_type, ":weapontype", ":item"),
                    (eq, ":weapontype", itp_type_polearm),  # Is it a spear?
                    (agent_has_item_equipped, ":agent", ":item"),
                    (agent_set_wielded_item, ":agent", ":item"),
                    (agent_set_slot, ":agent", "slot_agent_lance", ":item"), #Mark 'lancer'
                    (assign, ":cap", 0), #loop Break
                (try_end),
            (try_end),
        (else_try),
            (le, ":horse", 0),  #Agent not mounted
(neg|troop_is_guarantee_ranged, ":troop"), #ADD THIS para que tropas a distancia den prioridad a sus armas sobre lanzas
            (try_begin),
                (eq, ":wielded_type", itp_type_polearm),  # Is it a polearm?
                                # (agent_set_slot, ":agent", "slot_agent_spear",      ":item"), #Mark spearmen
                      (agent_set_slot, ":agent", "slot_agent_spear",      ":wielded"), #Mark spearmen MOTO fix
            (else_try), #Check if there's a spear equipped, if not wielded
                (troop_get_inventory_capacity,":cap",":troop"),
                (try_for_range, ":i", 0, ":cap"),#not sure if reg. troops have equipped items (slots < 10), but w/e
                    (troop_get_inventory_slot,":item",":troop",":i"),
                    (gt, ":item", 0),
                    (item_get_type, ":weapontype", ":item"),
                    (eq, ":weapontype", itp_type_polearm),  # Is it a spear?
                    (agent_has_item_equipped, ":agent", ":item"),
                    (agent_set_slot, ":agent", "slot_agent_spear", ":item"), #Mark spearmen
                    (assign, ":cap", 0), #loop Break
                (try_end),
            (try_end),
        (try_end), #Mounted or Foot
    (try_end), #Agent Loop
    ]),
#chief acaba caba'drin
#relacion presentacion con companeros y caracter chief
    # Jrider +
   ###################################################################################
   # REPORT PRESENTATIONS 1.0 scripts
   # script get_relation_candidate_list_for_presentation
   # return a list of candidate according to type of list and restrict options
   # Use ...
   ("fill_relation_canditate_list_for_presentation",
    [
        (store_script_param, ":pres_type", 1),
        (store_script_param, ":base_candidates_y", 2),
       
        # Type of list from global variable: 0 courtship, 1 known lords
        (try_begin),
        ## For courtship:
            (eq, ":pres_type", 0),

            (try_for_range, ":lady", kingdom_ladies_begin, kingdom_ladies_end),
                (troop_slot_ge, ":lady", "slot_troop_met", 1), # met or better
                (troop_slot_eq, ":lady", "slot_troop_spouse", -1), # unmarried
       
                # use faction filter
                (store_troop_faction, ":lady_faction", ":lady"),
                (val_sub, ":lady_faction", kingdoms_begin),
                (this_or_next|eq, "$g_jrider_faction_filter", -1),
                (eq, "$g_jrider_faction_filter", ":lady_faction"),
       
                (call_script, "script_troop_get_relation_with_troop", "trp_player", ":lady"),
                (gt, reg0, 0),
                (assign, reg3, reg0),
               
                (str_store_troop_name, s2, ":lady"),
               
                (store_current_hours, ":hours_since_last_visit"),
                (troop_get_slot, ":last_visit_hour", ":lady", "slot_troop_last_talk_time"),
                (val_sub, ":hours_since_last_visit", ":last_visit_hour"),
                (store_div, ":days_since_last_visit", ":hours_since_last_visit", 24),
                (assign, reg4, ":days_since_last_visit"),
               
                #(str_store_string, s1, "str_s1_s2_relation_reg3_last_visit_reg4_days_ago"),
                (str_store_string, s1, "@{s2}: {reg3}, {reg4} days"),   
       
                # create custom listbox entry, set the container first
                (set_container_overlay, "$g_jrider_character_relation_listbox"),
       
                # create text overlay for entry
                (create_text_overlay, reg10, s1, tf_left_align),
                (overlay_set_color, reg10, 0xDDDDDD),
                (position_set_x, pos1, 750),
                (position_set_y, pos1, 850),
                (overlay_set_size, reg10, pos1),
                (position_set_x, pos1, 0), 
                (store_mul, ":y_mult", "$num_charinfo_candidates", 18), # adapt y position to entry number
                (store_sub, ":line_y", ":base_candidates_y", ":y_mult"),
                (position_set_y, pos1, ":line_y"),
                (overlay_set_position, reg10, pos1),

                # create button
                (create_image_button_overlay, reg10, "mesh_white_plane", "mesh_white_plane"),
                (position_set_x, pos1, 0), # 590 real, 0 scrollarea
                (position_set_y, pos1, ":line_y"),
                (overlay_set_position, reg10, pos1),
                (position_set_x, pos1, 16000),
                (position_set_y, pos1, 900),
                (overlay_set_size, reg10, pos1),
                (overlay_set_alpha, reg10, 0),
                (overlay_set_color, reg10, 0xDDDDDD),

                # store button id for use in other triggers
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", reg10),
                (troop_set_slot, "trp_temp_array_b", ":current_storage_index", "$num_charinfo_candidates"),

                # candidate found, store troop id for later use
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", "$num_charinfo_candidates"),
                (troop_set_slot, "trp_temp_array_c", ":current_storage_index", ":lady"),

                (try_begin),
                    (eq, "$num_charinfo_candidates", 0),
                    (try_begin),
                        (this_or_next|eq, "$g_jrider_pres_called_from_menu", 1),
                        (eq, "$g_jrider_reset_selected_on_faction", 1),

                        (assign, "$g_jrider_reset_selected_on_faction", 0),
                        (assign, "$character_info_id", ":lady"),
                        (assign, "$g_jrider_last_checked_indicator", reg10),
                        (assign, "$g_latest_character_relation_entry", 0),
                    (try_end),
                (try_end),

                # close the container
                (set_container_overlay, -1),

                # update entry counter
                (val_add, "$num_charinfo_candidates", 1),
            (try_end),
        ## End courtship relations
        (else_try),
        ## For lord relations
            (eq, ":pres_type", 1),

            # Loop to identify 
            (try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
                (troop_set_slot, ":active_npc", "slot_troop_temp_slot", 0),
            (try_end),

            (try_for_range, ":unused", active_npcs_begin, active_npcs_end),

                (assign, ":score_to_beat", -100),
                (assign, ":best_relation_remaining_npc", -1),

                (try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
                        (troop_slot_eq, ":active_npc", "slot_troop_temp_slot", 0),
                        (troop_slot_ge, ":active_npc", "slot_troop_met", 1),
                        (troop_slot_eq, ":active_npc", "slot_troop_occupation", slto_kingdom_hero),

                        (call_script, "script_troop_get_player_relation", ":active_npc"),
                        (assign, ":relation_with_player", reg0),
                        (ge, ":relation_with_player", ":score_to_beat"),

                        (assign, ":score_to_beat", ":relation_with_player"),
                        (assign, ":best_relation_remaining_npc", ":active_npc"),
                (try_end),
                (gt, ":best_relation_remaining_npc", -1),

                (str_store_troop_name, s4, ":best_relation_remaining_npc"),
                (assign, reg4, ":score_to_beat"),

                (str_store_string, s1, "@{s4}: {reg4}"),
                (troop_set_slot, ":best_relation_remaining_npc", "slot_troop_temp_slot", 1),

                # use faction filter
                (store_troop_faction, ":npc_faction", ":best_relation_remaining_npc"),
                (val_sub, ":npc_faction", kingdoms_begin),
                (this_or_next|eq, "$g_jrider_faction_filter", -1),
                (eq, "$g_jrider_faction_filter", ":npc_faction"),       
 
                # candidate found,
                # create custom listbox entry, set the container first
                (set_container_overlay, "$g_jrider_character_relation_listbox"),
       
                # create text overlay for entry
                (create_text_overlay, reg10, s1, tf_left_align),
                (overlay_set_color, reg10, 0xDDDDDD),
                (position_set_x, pos1, 750),
                (position_set_y, pos1, 850),
                (overlay_set_size, reg10, pos1),
                (position_set_x, pos1, 0), 
                (store_mul, ":y_mult", "$num_charinfo_candidates", 18), # adapt y position to entry number
                (store_sub, ":line_y", ":base_candidates_y", ":y_mult"),
                (position_set_y, pos1, ":line_y"),
                (overlay_set_position, reg10, pos1),

                # create button
                (create_image_button_overlay, reg10, "mesh_white_plane", "mesh_white_plane"),
                (position_set_x, pos1, 0), # 590 real, 0 scrollarea
                (position_set_y, pos1, ":line_y"),
                (overlay_set_position, reg10, pos1),
                (position_set_x, pos1, 16000),
                (position_set_y, pos1, 900),
                (overlay_set_size, reg10, pos1),
                (overlay_set_alpha, reg10, 0),
                (overlay_set_color, reg10, 0xDDDDDD),

                # store relation of button id to character number for use in triggers
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", reg10),
                (troop_set_slot, "trp_temp_array_b", ":current_storage_index", "$num_charinfo_candidates"),

                #store troop id for later use (could be merged with the object id)
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", "$num_charinfo_candidates"),
                (troop_set_slot, "trp_temp_array_c", ":current_storage_index", ":best_relation_remaining_npc"),

                (try_begin),
                    (eq, "$num_charinfo_candidates", 0),
                    (try_begin),
                        (this_or_next|eq, "$g_jrider_pres_called_from_menu", 1),
                        (eq, "$g_jrider_reset_selected_on_faction", 1),
       
                        (assign, "$g_jrider_reset_selected_on_faction", 0),
                        (assign, "$character_info_id", ":best_relation_remaining_npc"),
                        (assign, "$g_jrider_last_checked_indicator", reg10),
                        (assign, "$g_latest_character_relation_entry", 0),
                    (try_end),
                (try_end),

                # close the container
                (set_container_overlay, -1),

                # update entry counter 
                (val_add, "$num_charinfo_candidates", 1),
            (try_end),
        ## END Lords relations
        (else_try),
        ## Character and Companions
            (eq, ":pres_type", 2),

            # Character
            (try_begin),
                (str_store_troop_name, s1, "trp_player"),

                # candidate found,
                # create custom listbox entry, set the container first
                (set_container_overlay, "$g_jrider_character_relation_listbox"),
       
                # create text overlay for entry
                (create_text_overlay, reg10, s1, tf_left_align),
                (overlay_set_color, reg10, 0xDDDDDD),
                (position_set_x, pos1, 750),
                (position_set_y, pos1, 850),
                (overlay_set_size, reg10, pos1),
                (position_set_x, pos1, 0), 
                (store_mul, ":y_mult", "$num_charinfo_candidates", 18), # adapt y position to entry number
                (store_sub, ":line_y", ":base_candidates_y", ":y_mult"),
                (position_set_y, pos1, ":line_y"),
                (overlay_set_position, reg10, pos1),

                # create button
                (create_image_button_overlay, reg10, "mesh_white_plane", "mesh_white_plane"),
                (position_set_x, pos1, 0), # 590 real, 0 scrollarea
                (position_set_y, pos1, ":line_y"),
                (overlay_set_position, reg10, pos1),
                (position_set_x, pos1, 16000),
                (position_set_y, pos1, 900),
                (overlay_set_size, reg10, pos1),
                (overlay_set_alpha, reg10, 0),
                (overlay_set_color, reg10, 0xDDDDDD),

                # store relation of button id to character number for use in triggers
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", reg10),
                (troop_set_slot, "trp_temp_array_b", ":current_storage_index", "$num_charinfo_candidates"),

                #store troop id for later use (could be merged with the object id)
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", "$num_charinfo_candidates"),
                (troop_set_slot, "trp_temp_array_c", ":current_storage_index", "trp_player"),

                # init
                (try_begin),
                    (eq, "$num_charinfo_candidates", 0),
                    (try_begin),
                        # only when entering from menu
                        (eq, "$g_jrider_pres_called_from_menu", 1),
                        (assign, "$character_info_id", "trp_player"),
                        (assign, "$g_jrider_last_checked_indicator", reg10),
                        (assign, "$g_latest_character_relation_entry", 0),
                    (try_end),
                (try_end),

                # close the container
                (set_container_overlay, -1),

                # update entry counter 
                (val_add, "$num_charinfo_candidates", 1),
            (try_end),
            # Wife/Betrothed

           # companions
           (try_for_range, ":companion", companions_begin, companions_end),
               (troop_slot_eq, ":companion", "slot_troop_occupation", slto_player_companion),
               (str_store_troop_name, s1, ":companion"),

               (try_begin),
                   (troop_slot_eq, ":companion", "slot_troop_current_mission", npc_mission_kingsupport),
                   (str_store_string, s1, "@{s1} (gathering support)"),
               (else_try),
                   (troop_slot_eq, ":companion", "slot_troop_current_mission", npc_mission_gather_intel),
                   (str_store_string, s1, "@{s1} (intelligence)" ),
               (else_try),
                   (troop_slot_eq, ":companion", "slot_troop_current_mission", npc_mission_rejoin_when_possible),
                   (str_store_string, s1, "@{s1} (attempting to rejoin)"),
               (else_try),
                   (troop_slot_ge, ":companion", "slot_troop_current_mission", npc_mission_peace_request),    #rest are diplomacy
                   (str_store_string, s1, "@{s1} (embassy)"),
               (else_try),
                   (eq, ":companion", "$g_player_minister"),
                   (str_store_string, s1, "@{s1} (minister)"),
               (else_try),
                   (party_slot_eq, "p_main_party", "slot_party_wagon_leader", ":companion"), #tempered chief
                   (str_store_string, s1, "@{s1} (supply wagon)"),
               (else_try),
                   (main_party_has_troop, ":companion"),
                   (str_store_string, s1, "@{s1} (under arms)"),
               (else_try),
                   (troop_slot_ge, ":companion", "slot_troop_cur_center", 1),
                   (str_store_string, s1, "@{s1} (separated after battle)"),
               (try_end),
               # candidate found,
        # candidate found,
                # create custom listbox entry, set the container first
                (set_container_overlay, "$g_jrider_character_relation_listbox"),
       
                # create text overlay for entry
                (create_text_overlay, reg10, s1, tf_left_align),
                (overlay_set_color, reg10, 0xDDDDDD),
                (position_set_x, pos1, 750),
                (position_set_y, pos1, 850),
                (overlay_set_size, reg10, pos1),
                (position_set_x, pos1, 0), 
                (store_mul, ":y_mult", "$num_charinfo_candidates", 18), # adapt y position to entry number
                (store_sub, ":line_y", ":base_candidates_y", ":y_mult"),
                (position_set_y, pos1, ":line_y"),
                (overlay_set_position, reg10, pos1),

                # create button
                (create_image_button_overlay, reg10, "mesh_white_plane", "mesh_white_plane"),
                (position_set_x, pos1, 0), # 590 real, 0 scrollarea
                (position_set_y, pos1, ":line_y"),
                (overlay_set_position, reg10, pos1),
                (position_set_x, pos1, 16000),
                (position_set_y, pos1, 900),
                (overlay_set_size, reg10, pos1),
                (overlay_set_alpha, reg10, 0),
                (overlay_set_color, reg10, 0xDDDDDD),

                # store relation of button id to character number for use in triggers
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", reg10),
                (troop_set_slot, "trp_temp_array_b", ":current_storage_index", "$num_charinfo_candidates"),

                #store troop id for later use (could be merged with the object id)
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", "$num_charinfo_candidates"),
                (troop_set_slot, "trp_temp_array_c", ":current_storage_index", ":companion"),

                (try_begin),
                    (eq, "$num_charinfo_candidates", 0),
                    (try_begin),
                        (eq, "$g_jrider_pres_called_from_menu", 1),
                        (assign, "$character_info_id", ":companion"),
                        (assign, "$g_jrider_last_checked_indicator", reg10),
                        (assign, "$g_latest_character_relation_entry", 0),
                    (try_end),
                (try_end),

                # close the container
                (set_container_overlay, -1),

                # update entry counter 
                (val_add, "$num_charinfo_candidates", 1),
            (try_end),
        ## END Character and Companions
        (try_end),
    ]),

    # script generate_extended_troop_relation_information_string
    # return information about troop according to type (lord, lady, maiden)
    # Use (hm lots of registers and strings)
    # result stored in s1
    ("generate_extended_troop_relation_information_string",
     [
         (store_script_param, ":troop_no", 1),

         # clear the strings and registers we'll use to prevent external interference
         (str_clear, s1),
         (str_clear, s2),
         (str_clear, s60),
         (str_clear, s42),
         (str_clear, s43),
         (str_clear, s44),
         (str_clear, s45),
         (str_clear, s46),
         (str_clear, s47),
         (str_clear, s48),
         (str_clear, s49),
         (str_clear, s50),
         (assign, reg40,0),
         (assign, reg41,0),
         (assign, reg43,0),
         (assign, reg44,0),
         (assign, reg46,0),
         (assign, reg47,0),
         (assign, reg48,0),
         (assign, reg49,0),
         (assign, reg50,0),
         (assign, reg51,0),

         (try_begin),
             (eq, ":troop_no", "trp_player"),
             (overlay_set_display, "$g_jrider_character_faction_filter", 0),

             # Troop name
             (str_store_troop_name, s1, ":troop_no"),

             # Get renown - "slot_troop_renown"
             (troop_get_slot, ":renown", ":troop_no", "slot_troop_renown"),
             (assign, reg40, ":renown"),

             # Controversy - "slot_troop_controversy"
             (troop_get_slot, ":controversy", ":troop_no", "slot_troop_controversy"),
             (assign, reg41, ":controversy"),

             # Honor - $player_honor
             (assign, reg42, "$player_honor"),

             # Right to rule - $player_right_to_rule
             (assign, reg43, "$player_right_to_rule"),

             # Current faction
             (store_add, reg45, "$players_kingdom"),
             (try_begin),
                 (is_between, "$players_kingdom", "fac_player_supporters_faction", npc_kingdoms_end),
                 (str_store_faction_name, s45, "$players_kingdom"),
             (else_try),
                 (assign, reg45, 0),
                 (str_store_string, s45, "@Britannia and Hibernia."),
             (try_end),

             # status
             (assign, ":origin_faction", "$players_kingdom"),
             (try_begin),
                 (is_between, ":origin_faction", npc_kingdoms_begin, npc_kingdoms_end),
                 (str_store_string, s44, "@spear man"),
             (else_try),
                 (eq, ":origin_faction", "fac_player_supporters_faction"),
                 (str_store_string, s44, "@ruler"),
             (else_try),
                 (str_store_string, s44, "@free man"),
             (try_end),

             # Current liege and relation
             (faction_get_slot, ":liege", "$players_kingdom", "slot_faction_leader"),
             (str_store_troop_name, s46, ":liege"),
             (try_begin),
                 (eq, ":liege", ":troop_no"),
                 (assign, reg46, 0),
             (else_try),
                 (assign, reg46, ":liege"),
                 (str_clear, s47),
                 (str_clear, s60),

                 # Relation to liege
                 (call_script, "script_troop_get_player_relation", ":liege"),
                 (assign, ":relation", reg0),

                 (store_add, ":normalized_relation", ":relation", 100),
                 (val_add, ":normalized_relation", 5),
                 (store_div, ":str_offset", ":normalized_relation", 10),
                 (val_clamp, ":str_offset", 0, 20),
                 (store_add, ":str_rel_id", "str_relation_mnus_100_ns",  ":str_offset"),

                 ## Make something if troop has relation but not strong enought to warrant a string
                 (try_begin),
                   (neq, ":str_rel_id", "str_relation_plus_0_ns"),
                   (str_store_string, s47, ":str_rel_id"),
                 (else_try),
                   (neg|eq, reg0, 0),
                   (str_is_empty, s47),
                   (str_store_string, s47, "@ knows of you."),
                 (else_try),
                   (eq, reg0, 0),
                   (str_is_empty, s47),
                   (str_store_string, s47, "@ has no opinion about you."),
                 (try_end),
             (end_try),

             # Holdings
             (assign, ":owned_centers", 0),
             (assign, ":num_centers", 0),
             (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
                 (party_slot_eq, ":cur_center", "slot_town_lord", ":troop_no"),
                 (try_begin),
                   (eq, ":num_centers", 0),
                   (str_store_party_name, s50, ":cur_center"),
                   (val_add, ":owned_centers", 1),
                 (else_try),
                   (eq, ":num_centers", 1),
                   (str_store_party_name, s57, ":cur_center"),
                   (str_store_string, s50, "@{s57} and {s50}"),
                   (val_add, ":owned_centers", 1),
                 (else_try),
                   (str_store_party_name, s57, ":cur_center"),
                   (str_store_string, s50, "@{!}{s57}, {s50}"),
                   (val_add, ":owned_centers", 1),
                 (try_end),
                 (val_add, ":num_centers", 1),
              (try_end),
              (assign, reg50, ":owned_centers"),

             #### Final Storage
             (str_store_string, s1, "@{s1} Renown: {reg40}, Controversy: {reg41}^Honor: {reg42}, Right to rule: {reg43}^\
You are a {s44} of {s45}^{reg45?{reg46?Your liege, {s46},{s47}:You are the ruler of {s45}}:}^^Friends: ^Enemies: ^^Fiefs:^  {reg50?{s50}:no fief}"),
         #######################
         # END Player information
         (else_try),
         #######################
         # Lord information
             (troop_slot_eq, ":troop_no", "slot_troop_occupation", slto_kingdom_hero),

             # Troop name
             (str_store_troop_name, s1, ":troop_no"),

             # relation to player
             (str_clear, s2),
             (str_clear, s60),
             (call_script, "script_troop_get_player_relation", ":troop_no"),
             (assign, ":relation", reg0),

             (store_add, ":normalized_relation", ":relation", 100),
             (val_add, ":normalized_relation", 5),
             (store_div, ":str_offset", ":normalized_relation", 10),
             (val_clamp, ":str_offset", 0, 20),
             (store_add, ":str_rel_id", "str_relation_mnus_100_ns",  ":str_offset"),

             ## Make something if troop has relation but not strong enought to warrant a string
             (try_begin),
               (neq, ":str_rel_id", "str_relation_plus_0_ns"),
               (str_store_string, s2, ":str_rel_id"),
             (else_try),
               (neg|eq, reg0, 0),
               (str_is_empty, s2),
               (str_store_string, s2, "@ knows of you."),
             (else_try),
               (eq, reg0, 0),
               (str_is_empty, s2),
               (str_store_string, s2, "@ has no opinion about you."),
             (try_end),

             # Get renown - "slot_troop_renown"
             (troop_get_slot, ":renown", ":troop_no", "slot_troop_renown"),
             (assign, reg40, ":renown"),
         
             # Controversy - "slot_troop_controversy"
             (troop_get_slot, ":controversy", ":troop_no", "slot_troop_controversy"),
             (assign, reg41, ":controversy"),

             # Get Reputation type - "slot_lord_reputation_type"
             (troop_get_slot, ":reputation", ":troop_no", "slot_lord_reputation_type"),
             (assign, reg42, "str_personality_archetypes"),
             (val_add, reg42, ":reputation"),
             (str_store_string, s42, reg42),

             (assign, reg42, ":reputation"),
             # Intrigue impatience - "slot_troop_intrigue_impatience"
             (troop_get_slot, ":impatience", ":troop_no", "slot_troop_intrigue_impatience"),
             (assign, reg43, ":impatience"),

             # Current faction - store_troop_faction
             (store_troop_faction, ":faction", ":troop_no"),
             (troop_get_slot, ":origin_faction", ":troop_no", "slot_troop_original_faction"),

             # Original faction - "slot_troop_original_faction"
             (try_begin),
               (val_sub, ":origin_faction", npc_kingdoms_begin),
               (val_add, ":origin_faction", "str_kingdom_1_adjective"),
               (str_store_string, s44, ":origin_faction"),
             (end_try),
             (str_store_faction_name, s45, ":faction"),

             # Current liege - deduced from current faction
             (faction_get_slot, ":liege", ":faction", "slot_faction_leader"),
             (str_store_troop_name, s46, ":liege"),
             (try_begin),
               (eq, ":liege", ":troop_no"),
               (assign, reg46, 0),
             (else_try),
               (assign, reg46, ":liege"),
               # Relation to liege
               (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":liege"),
               (assign, reg47, reg0),
             (end_try),

             # Promised a fief ?
             (troop_get_slot, reg51, ":troop_no", "slot_troop_promised_fief"),

             # Holdings
             (assign, ":owned_centers", 0),
             (assign, ":num_centers", 0),
             (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
                 (party_slot_eq, ":cur_center", "slot_town_lord", ":troop_no"),
                 (try_begin),
                   (eq, ":num_centers", 0),
                   (str_store_party_name, s50, ":cur_center"),
                   (val_add, ":owned_centers", 1),
                 (else_try),
                   (eq, ":num_centers", 1),
                   (str_store_party_name, s57, ":cur_center"),
                   (str_store_string, s50, "@{s57} and {s50}"),
                   (val_add, ":owned_centers", 1),
                 (else_try),
                   (str_store_party_name, s57, ":cur_center"),
                   (str_store_string, s50, "@{!}{s57}, {s50}"),
                   (val_add, ":owned_centers", 1),
                 (try_end),
                 (val_add, ":num_centers", 1),
              (try_end),
              (assign, reg50, ":owned_centers"),

              # "slot_troop_prisoner_of_party"
              (assign, reg48, 0),
              (try_begin),
                (troop_slot_ge, ":troop_no", "slot_troop_prisoner_of_party", 0),
                (assign, reg48, 1),
                (troop_get_slot, ":prisoner_party", ":troop_no", "slot_troop_prisoner_of_party"),
                (store_faction_of_party, ":party_faction", ":prisoner_party"),
                (str_store_faction_name, s48, ":party_faction"),
              (try_end),

              # Days since last meeting
              (store_current_hours, ":hours_since_last_visit"),
              (troop_get_slot, ":last_visit_hour", ":troop_no", "slot_troop_last_talk_time"),
              (val_sub, ":hours_since_last_visit", ":last_visit_hour"),
              (store_div, reg49, ":hours_since_last_visit", 24),

              #### Final Storage (8 lines)
              (str_store_string, s1, "@{s1}{s2} {reg46?Reputed to be {s42}:}^Renown: {reg40}, Controversy: {reg41} {reg46?Impatience: {reg43}:}^\
{s44} noble of the {s45}^{reg46?Liege: {s46}, Relation: {reg47}:Ruler of the {s45}}^^{reg48?Currently prisoner of the {s48}:}^\
Days since last meeting: {reg49}^^Fiefs {reg51?(was promised a fief):}:^  {reg50?{s50}:no fief}"),
        ######################
        ## END lord infomation
        (else_try),
        #########################
        # kingdom lady, unmarried
             (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
             (troop_slot_eq, ":troop_no", "slot_troop_spouse", -1),

             (str_store_troop_name, s1, ":troop_no"),

             # relation to player
             (str_clear, s2),
             (str_clear, s60),
             (call_script, "script_troop_get_player_relation", ":troop_no"),
             (assign, ":relation", reg0),

             (store_add, ":normalized_relation", ":relation", 100),
             (val_add, ":normalized_relation", 5),
             (store_div, ":str_offset", ":normalized_relation", 10),
             (val_clamp, ":str_offset", 0, 20),
             (store_add, ":str_rel_id", "str_relation_mnus_100_ns",  ":str_offset"),

             ## Make something if troop has relation but not strong enought to warrant a string
             (try_begin),
               (neq, ":str_rel_id", "str_relation_plus_0_ns"),
               (str_store_string, s2, ":str_rel_id"),
             (else_try),
               (neg|eq, reg0, 0),
               (str_is_empty, s2),
               (str_store_string, s2, "@ knows of you."),
             (else_try),
               (eq, reg0, 0),
               (str_is_empty, s2),
               (str_store_string, s2, "@ has no opinion about you."),
             (try_end),

             # Controversy - "slot_troop_controversy"
             (troop_get_slot, ":controversy", ":troop_no", "slot_troop_controversy"),
             (assign, reg41, ":controversy"),

             # Reputation type
             (troop_get_slot, ":reputation", ":troop_no", "slot_lord_reputation_type"),
             (try_begin),
                 (eq, ":reputation", lrep_conventional),
                 (str_store_string, s42, "@conventional"),
             (else_try),
                 (eq, ":reputation", lrep_adventurous),
                 (str_store_string, s42, "@adventurous"),
             (else_try),
                 (eq, ":reputation", lrep_otherworldly),
                 (str_store_string, s42, "@otherwordly"),
             (else_try),
                 (eq, ":reputation", lrep_ambitious),
                 (str_store_string, s42, "@ambitious"),
             (else_try),
                 (eq, ":reputation", lrep_moralist),
                 (str_store_string, s42, "@moralist"),
             (else_try),
                 (assign, reg42, "str_personality_archetypes"),
                 (val_add, reg42, ":reputation"),
                 (str_store_string, s42, reg42),
             (try_end),

             # courtship state - "slot_troop_courtship_state"
             (troop_get_slot, ":courtship_state", ":troop_no", "slot_troop_courtship_state"),
             (try_begin),
               (eq, ":courtship_state", 1),
               (str_store_string, s43, "@just met"),
             (else_try),
               (eq, ":courtship_state", 2),
               (str_store_string, s43, "@admirer"),
             (else_try),
               (eq, ":courtship_state", 3),
               (str_store_string, s43, "@promised"),
             (else_try),
               (eq, ":courtship_state", 4),
               (str_store_string, s43, "@breakup"),
             (else_try),
               (str_store_string, s43, "@unknown"),
             (try_end),

             # Current faction - store_troop_faction
             (store_troop_faction, ":faction", ":troop_no"),
             (troop_get_slot, ":origin_faction", ":troop_no", "slot_troop_original_faction"),

             # Original faction - "slot_troop_original_faction"
             (try_begin),
               (val_sub, ":origin_faction", npc_kingdoms_begin),
               (val_add, ":origin_faction", "str_kingdom_1_adjective"),
               (str_store_string, s44, ":origin_faction"),
             (end_try),
             (str_store_faction_name, s45, ":faction"),

             # Father/Guardian
             (assign, reg46, 0),
             (try_begin),
                 (troop_slot_ge, ":troop_no", "slot_troop_father", 0),
                 (troop_get_slot, ":guardian", ":troop_no", "slot_troop_father"),
                 (assign, reg46, 1),
             (else_try),
                 (troop_get_slot, ":guardian", ":troop_no", "slot_troop_guardian"),
             (try_end),
             (str_store_troop_name, s46, ":guardian"),

             # Relation with player
             (str_clear, s47),
             (str_clear, s60),
             (call_script, "script_troop_get_player_relation", ":guardian"),
             (assign, ":relation", reg0),

             (store_add, ":normalized_relation", ":relation", 100),
             (val_add, ":normalized_relation", 5),
             (store_div, ":str_offset", ":normalized_relation", 10),
             (val_clamp, ":str_offset", 0, 20),
             (store_add, ":str_rel_id", "str_relation_mnus_100_ns",  ":str_offset"),

             ## Make something if troop has relation but not strong enought to warrant a string
             (try_begin),
               (neq, ":str_rel_id", "str_relation_plus_0_ns"),
               (str_store_string, s47, ":str_rel_id"),
             (else_try),
               (neg|eq, reg0, 0),
               (str_is_empty, s47),
               (str_store_string, s47, "@ knows of you."),
             (else_try),
               (eq, reg0, 0),
               (str_is_empty, s47),
               (str_store_string, s47, "@ has no opinion about you."),
             (try_end),

             # courtship permission - "slot_lord_granted_courtship_permission"
             (try_begin),
                 (troop_slot_ge, ":guardian", "slot_lord_granted_courtship_permission", 1),
                 (assign, reg45, 1),
             (else_try),
                 (assign, reg45, 0),
             (try_end),

             # betrothed
             (assign, reg48, 0),
             (try_begin),
                 (troop_slot_ge, ":troop_no", "slot_troop_betrothed", 0),
                 (troop_get_slot, reg48, ":troop_no", "slot_troop_betrothed"),
                 (str_store_troop_name, s48, reg48),
                 (assign, reg48, 1),
             (try_end),

             # Days since last meeting
             (store_current_hours, ":hours_since_last_visit"),
             (troop_get_slot, ":last_visit_hour", ":troop_no", "slot_troop_last_talk_time"),
             (val_sub, ":hours_since_last_visit", ":last_visit_hour"),
             (store_div, reg49, ":hours_since_last_visit", 24),

             # Heard poems
             (assign, reg50, 0),
             (str_clear, s50),

             (try_begin),
                 (troop_slot_eq, ":troop_no", "slot_lady_courtship_heroic_recited", 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Heroic {s50}"),
             (try_end),
             (try_begin),
                 (troop_slot_eq, ":troop_no", "slot_lady_courtship_allegoric_recited", 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Allegoric {s50}"),
             (try_end),
             (try_begin),
                 (troop_slot_eq, ":troop_no", "slot_lady_courtship_comic_recited", 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Comic {s50}"),
             (try_end),
             (try_begin),
                 (troop_slot_eq, ":troop_no", "slot_lady_courtship_mystic_recited", 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Mystic {s50}"),
             (try_end),
             (try_begin),
                 (troop_slot_eq, ":troop_no", "slot_lady_courtship_tragic_recited", 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Tragic {s50}"),
             (try_end),

             #### Final Storage (8 lines)
             (str_store_string, s1, "@{s1}{s2} Controversy: {reg41}^Reputation: {s42}, Courtship state: {s43}^\
Belongs to the {s45}^{reg46?Her father, {s46}:Her guardian, {s46}}{s47}^Allowed to visit: {reg45?yes:no} {reg48?Betrothed to {s48}:}^^\
Days since last meeting: {reg49}^^Poems:^  {reg50?{s50}:no poem heard}"),
        #########################
        # END kingdom lady, unmarried
        (else_try),
        #########################
        # companions
            (is_between, ":troop_no", companions_begin, companions_end),
            (overlay_set_display, "$g_jrider_character_faction_filter", 0),

            (str_store_troop_name, s1, ":troop_no"),

            (troop_get_slot, ":reputation", ":troop_no", "slot_lord_reputation_type"),

            (assign, reg42, "str_personality_archetypes"),
            (val_add, reg42, ":reputation"),
            (str_store_string, s42, reg42),

            # birthplace
            (troop_get_slot, ":home", ":troop_no", "slot_troop_home"),
            (str_store_party_name, s43, ":home"),
         
            # contacts town - "slot_troop_town_with_contacts"
            (troop_get_slot, ":contact_town", ":troop_no", "slot_troop_town_with_contacts"),
            (str_store_party_name, s44, ":contact_town"),
         
            # current faction of contact town
            (store_faction_of_party, ":town_faction", ":contact_town"),
            (str_store_faction_name, s45, ":town_faction"),

            # "slot_troop_prisoner_of_party"
            (assign, reg48, 0),
            (try_begin),
                (troop_slot_ge, ":troop_no", "slot_troop_prisoner_of_party", 0),
                (assign, reg48, 1),
                (troop_get_slot, ":prisoner_party", ":troop_no", "slot_troop_prisoner_of_party"),
                (store_faction_of_party, ":party_faction", ":prisoner_party"),
                (str_store_faction_name, s48, ":party_faction"),
            (try_end),

            # Days since last meeting
            (store_current_hours, ":hours_since_last_visit"),
            (troop_get_slot, ":last_visit_hour", ":troop_no", "slot_troop_last_talk_time"),
            (val_sub, ":hours_since_last_visit", ":last_visit_hour"),
            (store_div, reg49, ":hours_since_last_visit", 24),

            (try_begin), # Companion gathering support for Right to Rule
                (troop_slot_eq, ":troop_no", "slot_troop_current_mission", npc_mission_kingsupport),
                (str_store_string, s50, "@Gathering support"),
            (else_try), # Companion gathering intelligence
                (troop_slot_eq, ":troop_no", "slot_troop_current_mission", npc_mission_gather_intel),
                (troop_get_slot, ":contact_town", ":troop_no", "slot_troop_town_with_contacts"),
                (store_faction_of_party, ":town_faction", ":contact_town"),
                (str_store_faction_name, s66, ":town_faction"),
                (str_store_string, s50, "@Gathering intelligence in the {s66}"),
            (else_try), # Companion on peace mission
                (troop_slot_ge, ":troop_no", "slot_troop_current_mission", npc_mission_peace_request),
                (neg|troop_slot_ge, ":troop_no", "slot_troop_current_mission", 8),

                (troop_get_slot, ":troop_no", ":troop_no", "slot_troop_mission_object"),
                (str_store_faction_name, s66, ":faction"),

                (str_store_string, s50, "@Ambassy to {s66}"),
            (else_try), # Companion is serving as minister player has court
                (eq, ":troop_no", "$g_player_minister"),
                (str_store_string, s50, "@Minister"),
            (else_try),
                (str_store_string, s50, "@none"),
        (try_end),

            # days left
            (troop_get_slot, reg50, ":troop_no", "slot_troop_days_on_mission"),
         
            #### Final Storage (8 lines)
            (str_store_string, s1, "@{s1}, {s2}^Reputation: {s42}^\
Born at {s43}^Contact in {s44} of the {s45}.^\
^{reg48?Currently prisoner of the {s48}:}^Days since last talked to: {reg49}^^Current mission:^  {s50}{reg50?, back in {reg50} days.:}"),
        #########################
        # END companions
        (try_end),
    ]),

    # Script generate_known_poems_string
    # generate in s1 list of known poems filling with blank lines for unknown ones
    ("generate_knonwn_poems_string",
     [
        # Known poems string
        (assign, ":num_poems", 0),
        (str_store_string, s1, "str_s1__poems_known"),
        (try_begin),
            (gt, "$allegoric_poem_recitations", 0),
            (str_store_string, s1, "str_s1_storming_the_castle_of_love_allegoric"),
            (val_add, ":num_poems", 1),
        (try_end),
        (try_begin),
            (gt, "$tragic_poem_recitations", 0),
            (str_store_string, s1, "str_s1_kais_and_layali_tragic"),
            (val_add, ":num_poems", 1),
        (try_end),
        (try_begin),
            (gt, "$comic_poem_recitations", 0),
            (str_store_string, s1, "str_s1_a_conversation_in_the_garden_comic"),
            (val_add, ":num_poems", 1),
        (try_end),
        (try_begin),
            (gt, "$heroic_poem_recitations", 0),
            (str_store_string, s1, "str_s1_helgered_and_kara_epic"),
            (val_add, ":num_poems", 1),
        (try_end),
        (try_begin),
            (gt, "$mystic_poem_recitations", 0),
            (str_store_string, s1, "str_s1_a_hearts_desire_mystic"),
            (val_add, ":num_poems", 1),
        (try_end),

        # fill blank lines
        (try_for_range, ":num_poems", 5),
            (str_store_string, s1, "@{s1}^"),
        (try_end),
    ]),
   # Jrider -
#relacion en presentacion acaba chief 
####dialogos mejorados chief
  ## DIALOGS v1.0 #########################################################################
  ## Script troop_get_relation_to_player_string (to include in dialogs)
  ## Use reg0, reg1 (unused here, though can be used to set a display context or use the faction relation number)
  ## fills s60 for storage of troop relation and s61 for storage of faction relation
  ("get_relation_to_player_string",
   [
     (store_script_param, ":target_no", 1),
     (store_script_param, ":troop_or_faction", 2),

     (assign, reg0, 0),
     (assign, reg1, 0),
     (try_begin), # target is troop
         (eq, ":troop_or_faction", 0),
         (str_clear, s60),

         (call_script, "script_troop_get_player_relation", ":target_no"),
         (assign, ":relation", reg0),
     
         (store_add, ":normalized_relation", ":relation", 100),
         (val_add, ":normalized_relation", 5),
         (store_div, ":str_offset", ":normalized_relation", 10),
         (val_clamp, ":str_offset", 0, 20), # does 20 works ? only 20 strings in there
         (store_add, ":str_rel_id", "str_relation_mnus_100_ns",  ":str_offset"),

         ## Make something if troop has relation but not strong enought to warrant a string
         (try_begin),
           (neq, ":str_rel_id", "str_relation_plus_0_ns"),
           (str_store_string, s60, ":str_rel_id"),
         (else_try),
           (neg|eq, reg0, 0),
           (str_is_empty, s60),
           (str_store_string, s60, "@ knows of you"),
         (try_end),
     (else_try), # target is Faction
         (eq, ":troop_or_faction", 1),
         (str_clear, s61),

         (store_relation, ":relation", "fac_player_supporters_faction", ":target_no"),
         (try_begin), # update reg0
           (neg|eq, ":relation", 0),
           (assign, reg1, ":relation"),
         (try_end),

         (store_add, ":normalized_relation", ":relation", 100),
         (store_div, ":str_offset", ":normalized_relation", 10),
         (val_clamp, ":str_offset", 0, 20), # does 20 works ? only 20 strings in there
         (store_add, ":str_rel_id", "str_faction_relation_mnus_100_ns",  ":str_offset"),
         (str_store_string, s61, ":str_rel_id"),
     (try_end),
   ]),

  ## Script change_looking_for_dialog_string
  ## Modify string s1
  ## Use s60 (from relation script), s3, s5, s6
  ## Use reg0, reg1 and reg4
  ("change_looking_for_dialog_string",
   [
     (store_script_param, ":troop_no", 1),

     ## Get general relation to use in name strings
     (call_script, "script_get_relation_to_player_string", ":troop_no", 0),

     ## Add family relationship for ladies and relation to player computed earlier and prisoner status
     (try_begin), ## wife of | relation
          (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end), # gender check, only for ladies
          (troop_slot_ge, ":troop_no", "slot_troop_spouse", 0),
          (troop_get_slot, ":spouse_of", ":troop_no", "slot_troop_spouse"),
          (str_store_troop_name, s3, ":spouse_of"),
          (str_store_string, s1, "@{s1}, wife of {s3}{reg0?,{s60}:}"),
     (else_try), ## unmarried daughter/sister of | relation
          (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end), # gender check, for ladies only
          (troop_slot_eq, ":troop_no", "slot_troop_spouse", -1), # unmarried ones
          (assign, reg1, -1),
          (try_begin),
              (troop_slot_ge, ":troop_no", "slot_troop_father",0), # daughters first
              (troop_get_slot, ":daughter_of", ":troop_no", "slot_troop_father"),
              (str_store_troop_name, s3, ":daughter_of"),
              (assign, reg1, 1),
          (else_try),
              (troop_slot_ge, ":troop_no", "slot_troop_guardian",0), # else sister or niece
              (troop_get_slot, ":sister_of", ":troop_no", "slot_troop_guardian"),
              (str_store_troop_name, s3, ":sister_of"),
              (assign, reg1, 0),
      (try_end),

          # check if betrothed
          (assign, reg4, 0),
          (try_begin),
            (troop_slot_ge, ":troop_no", "slot_troop_betrothed", 0),
            (troop_get_slot, ":fiance", ":troop_no", "slot_troop_betrothed"),
            (str_store_troop_name, s5, ":fiance"),
            (assign, reg4, 1),
          (try_end),
          (str_store_string, s1, "@{s1}, {reg1?daughter of:pupil of} {s3}{reg4?, betrothed to {s5}:}{reg0?,{s60}:}"),
     ## For prisoners                                                             
     (else_try), # male
          (neg|is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),

          (assign, reg1, 0),
          (assign, reg4, 0),

          (try_begin), # check if both parents are assigned
            (troop_slot_ge, ":troop_no", "slot_troop_father", 0),
            (troop_slot_ge, ":troop_no", "slot_troop_mother", 0),

            (troop_get_slot, ":father", ":troop_no", "slot_troop_father"),
            (troop_get_slot, ":mother", ":troop_no", "slot_troop_mother"),
            (is_between, ":father", active_npcs_begin, active_npcs_end), # keep only if active npc
            (is_between, ":mother", active_npcs_begin, kingdom_ladies_end), # keep only if active npc

            (str_store_troop_name, s3, ":father"),
            (str_store_troop_name, s6, ":mother"),

            (assign, reg4, 1,),
            (str_store_string, s5, "@{s3} and {s6}"),
          (else_try),
            (troop_slot_ge, ":troop_no", "slot_troop_father", 0),
            (troop_get_slot, ":father", ":troop_no", "slot_troop_father"),
            (is_between, ":father", active_npcs_begin, active_npcs_end), # keep only if active npc

            (str_store_troop_name, s3, ":father"),
            (assign, reg4, 1,),
            (str_store_string, s5, "@{s3}"),
          (else_try),
            (troop_slot_ge, ":troop_no", "slot_troop_mother", 0),
            (troop_get_slot, ":mother", ":troop_no", "slot_troop_mother"),
            (is_between, ":mother", active_npcs_begin, kingdom_ladies_end), # keep only if active npc

            (str_store_troop_name, s3, ":mother"),
            (assign, reg4, 1,),
            (str_store_string, s5, "@{s3}"),
          (try_end),

          # prisoner
          (try_begin),
            (troop_slot_ge, ":troop_no", "slot_troop_prisoner_of_party", 0),
            (assign, reg1, 1),
          (try_end),

          (str_store_string, s1, "@{s1}{reg4?, son of {s5}{reg1?,:{reg0?,:}}:}{reg1? prisoner{reg0?,:}:}{reg0?{s60}:}"),
     (try_end),
   ]),

  ## Script change_minstrel_maiden_dialog_string
  ## Modify string s10
  ## Use s60 (from relation script), s3 and s5
  ## Use reg0, reg1 and reg4
  ("change_minstrel_maiden_dialog_string",
   [
     (store_script_param, ":troop_no", 1),

     ## Get general relation to use in name strings
     (call_script, "script_get_relation_to_player_string", ":troop_no", 0),

     ## modify maiden display name to include closest male relative and current relation with player
     (assign, reg1, -1),
     (try_begin),
       (troop_slot_ge, ":troop_no", "slot_troop_father",0), # daughters first
       (troop_get_slot, ":daughter_of", ":troop_no", "slot_troop_father"),
       (str_store_troop_name, s3, ":daughter_of"),
       (assign, reg1, 1),
     (else_try),
        (troop_slot_ge, ":troop_no", "slot_troop_guardian",0), # else sister or niece
        (troop_get_slot, ":sister_of", ":troop_no", "slot_troop_guardian"),
        (str_store_troop_name, s3, ":sister_of"),
        (assign, reg1, 0),
     (try_end),

     # check if betrothed
     (assign, reg4, 0),
     (try_begin),
        (troop_slot_ge, ":troop_no", "slot_troop_betrothed", 0),
        (troop_get_slot, ":fiance", ":troop_no", "slot_troop_betrothed"),
        (str_store_troop_name, s5, ":fiance"),
        (assign, reg4, 1),
     (try_end),
     ## Modify the display string
     (str_store_string, s10, "@{s10}, {reg1?daughter of:pupil of} {s3}{reg4?, betrothed to {ss5}:}{reg0?,{s60}:}"),
   ]),

  ## Script set_diplomatic_emissary_skill_level_string
  ## diplomatic emissary is evaluated by tiers of the Persuation skill
  ## Use s65
  ## Replace s11
  ## Note: this one is in a slightly unfinished state, as it provides only persusuation skill strings,
  ##       the idea is to extend it other skills, like spotting which is used in diplomacy for some mission types
  ("set_diplomatic_emissary_skill_level_string",
   [
       (store_script_param, ":troop_no", 1),
       (store_script_param, ":skill_selected", 2),
       (store_script_param, ":set_title", 3), # don't forget to reset at end of mission

       # store plural name of troop, (ie. without the title)
       (str_store_troop_name_plural, s65, ":troop_no"),

       (try_begin),       
           # get skill level
           (store_skill_level, ":skill_level", ":skill_selected", ":troop_no"),

           # get title index according to tiers of the selected skill
           (assign, ":title_index", -1), # no change by default
           (try_begin),
             (eq, ":skill_level", 1), # tier 0, novice
             (assign, ":title_index", 0),
             (str_store_string, s65, "@Messenger {s65}"),
           (else_try), # tier 1, between 2-4, some experience
             (is_between, ":skill_level", 2, 4),
             (assign, ":title_index", 1),
             (str_store_string, s65, "@Envoy {s65}"),
           (else_try),  # tier 2, between 5-7, good experience
             (is_between, ":skill_level", 5, 6),#gdwto7
             (assign, ":title_index", 2),
             (str_store_string, s65, "@Consul {s65}"),
           (else_try),  # tier 3, between 8-9, very good experience
             (is_between, ":skill_level", 7, 9),#gdw8-9
             (assign, ":title_index", 3),
             (str_store_string, s65, "@Legate {s65}"),
           (else_try),  # tier 4, 10 or higher, the best
             (ge, ":title_index", 10),
             (assign, ":title_index", 4),
             (str_store_string, s65, "@Missi Dominici {s65}"),
           (try_end),

           # TODO: use strings

           # replace dialog display string (only if there's something to change)
           (try_begin),
               (ge, ":title_index", 0),
               (str_store_string, s11, "@{s65}"),

               # set title if you want to keep it
               (eq, ":set_title", 1),
               (troop_set_name, ":troop_no", s65),
           (else_try), # reset standard troop name in s11
               (str_store_troop_name, s11, ":troop_no"),
           (try_end),
       (try_end),
   ]),

  ## Script change_diplomatic_action_ruler_kingdom_strings
  ## Add ruler's relation to you and kingdom's relation in dialog string
  ## Modify s10 (ruler relation) and s1 (kingdom relation)
  ## Use s60 and s61 from get_relation_to_player
  ## Modify s10 (for ruler relation) and s11 (for kingdom relation)
  ("change_diplomatic_action_ruler_kingdom_strings",
   [
     (store_script_param, ":target_ruler", 1),
     (store_script_param, ":target_faction", 2),

     ## Get general relation to use in ruler name string
     (call_script, "script_get_relation_to_player_string", ":target_ruler", 0),

     ## Get faction relation to use in kingdom string
     (call_script, "script_get_relation_to_player_string", ":target_faction", 1),

     # replace dialog display strings
     (str_store_string, s10, "@{s10}{reg0? (who{s60}):}"),
     (str_store_string, s11, "@{s11} ({s61})"),
   ]),
########dialogos mejorados chief acaba
##diplomacy chief begin
#gdw this is a repeat
  # ("dplmc_get_troop_max_hp",
  #  [
  #   (store_script_param_1, ":troop"),

  #   (store_skill_level, ":skill", skl_ironflesh, ":troop"),
  #   (store_attribute_level, ":attrib", ":troop", ca_strength),
  #   (val_mul, ":skill", 2),
  #   (val_add, ":skill", ":attrib"),
  #   (val_add, ":skill", 35),
  #   (assign, reg0, ":skill"),
  # ]),
  #cc end

  ("dplmc_describe_prosperity_to_s4",
    [
      (store_script_param_1, ":center_no"), 

      (str_store_party_name, s60,":center_no"),
      (party_get_slot, ":prosperity", ":center_no", "slot_town_prosperity"),
      (str_store_string, s4, "str_empty_string"),
      (try_begin),
        (is_between, ":center_no", towns_begin, towns_end),
        (try_begin),
          (eq, ":prosperity", 0),
          (str_store_string, s4, "str_town_prosperity_0"),
        (else_try),
          (is_between, ":prosperity", 1, 11),
          (str_store_string, s4, "str_town_prosperity_10"),
        (else_try),
          (is_between, ":prosperity", 11, 21),
          (str_store_string, s4, "str_town_prosperity_20"),
        (else_try),
          (is_between, ":prosperity", 21, 31),
          (str_store_string, s4, "str_town_prosperity_30"),
        (else_try),
          (is_between, ":prosperity", 31, 41),
          (str_store_string, s4, "str_town_prosperity_40"),
        (else_try),
          (is_between, ":prosperity", 41, 51),
          (str_store_string, s4, "str_town_prosperity_50"),
        (else_try),
          (is_between, ":prosperity", 51, 61),
          (str_store_string, s4, "str_town_prosperity_60"),
        (else_try),
          (is_between, ":prosperity", 61, 71),
          (str_store_string, s4, "str_town_prosperity_70"),
        (else_try),
          (is_between, ":prosperity", 71, 81),
          (str_store_string, s4, "str_town_prosperity_80"),
        (else_try),
          (is_between, ":prosperity", 81, 91),
          (str_store_string, s4, "str_town_prosperity_90"),
        (else_try),
          (is_between, ":prosperity", 91, 101),
          (str_store_string, s4, "str_town_prosperity_100"),      
        (try_end),
      (else_try),
        (is_between, ":center_no", villages_begin, villages_end),
        (try_begin),
          (eq, ":prosperity", 0),
          (str_store_string, s4, "str_village_prosperity_0"),
        (else_try),
          (is_between, ":prosperity", 1, 11),
          (str_store_string, s4, "str_village_prosperity_10"),
        (else_try),
          (is_between, ":prosperity", 11, 21),
          (str_store_string, s4, "str_village_prosperity_20"),
        (else_try),
          (is_between, ":prosperity", 21, 31),
          (str_store_string, s4, "str_village_prosperity_30"),
        (else_try),
          (is_between, ":prosperity", 31, 41),
          (str_store_string, s4, "str_village_prosperity_40"),
        (else_try),
          (is_between, ":prosperity", 41, 51),
          (str_store_string, s4, "str_village_prosperity_50"),
        (else_try),
          (is_between, ":prosperity", 51, 61),
          (str_store_string, s4, "str_village_prosperity_60"),
        (else_try),
          (is_between, ":prosperity", 61, 71),
          (str_store_string, s4, "str_village_prosperity_70"),
        (else_try),
          (is_between, ":prosperity", 71, 81),
          (str_store_string, s4, "str_village_prosperity_80"),
        (else_try),
          (is_between, ":prosperity", 81, 91),
          (str_store_string, s4, "str_village_prosperity_90"),
        (else_try),
          (is_between, ":prosperity", 91, 101),
          (str_store_string, s4, "str_village_prosperity_100"),      
        (try_end),        
      (try_end),
        ]),

  ("dplmc_pay_into_treasury",
    [
      (store_script_param_1, ":amount"),
      (troop_add_gold, "trp_household_possessions", ":amount"),
      (assign, reg0, ":amount"),
      (play_sound, "snd_money_received"),
      (display_message, "@{reg0} scillingas added to treasury."),
  ]),
  
  ("dplmc_withdraw_from_treasury",
    [
      (store_script_param_1, ":amount"),
      (troop_remove_gold, "trp_household_possessions", ":amount"),
      (assign, reg0, ":amount"),
      (play_sound, "snd_money_paid"),
      (display_message, "@{reg0} scillingas removed from treasury."),
  ]),
        
  ("dplmc_describe_tax_rate_to_s50",
    [
      (store_script_param_1, ":tax_rate"),
      (val_div, ":tax_rate", 25),
      (store_add, ":str_id","str_dplmc_tax_normal", ":tax_rate"),
      (str_store_string, s50, ":str_id"),
  ]),
  

  ("dplmc_player_troops_leave",
   [
    (store_script_param_1, ":percent"),

    (try_begin),#debug
     (eq, "$cheat_mode", 1),        
     (assign, reg0, ":percent"),
     (display_message, "@{!}DEBUG : removing player troops: {reg0}%"),
    (try_end),    

    (assign, ":deserters", 0),
    (try_for_parties, ":party_no"),
      (assign, ":remove_troops", 0),
      (try_begin),
        (this_or_next|party_slot_eq, ":party_no", "slot_party_type", spt_town),
        (party_slot_eq|party_slot_eq, ":party_no", "slot_party_type", spt_castle),
        (party_slot_eq, ":party_no", "slot_town_lord", "trp_player"),
        (assign, ":remove_troops", 1),
      (else_try),
         (eq, "p_main_party", ":party_no"),
         (assign, ":remove_troops", 1),
      (try_end),
      
      (eq, ":remove_troops", 1),
      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),                             
        (val_mul, ":stack_size", ":percent"),
        (val_div, ":stack_size", 100),
        (party_stack_get_troop_id, ":troop_id", ":party_no", ":i_stack"),
        (party_remove_members, ":party_no", ":troop_id", ":stack_size"),
        (val_add, ":deserters", ":stack_size"),
      (try_end),
    (try_end),
    (assign, reg0, ":deserters"),
   ]
  ),

  ("dplmc_get_item_buy_price_factor",
    [
	##nested diplomacy start+
    #(store_script_param_1, ":item_kind_id"),
    #(store_script_param_2, ":center_no"),
	#Add two parameters
	(store_script_param, ":item_kind_id", 1),
	(store_script_param, ":center_no", 2),
	(store_script_param, ":customer_no", 3),
	(store_script_param, ":merchant_no", 4),
	##nested diplomacy start+
    (assign, ":price_factor", 100),

	##nested diplomacy start+
    #(call_script, "script_get_trade_penalty", ":item_kind_id"),
	(call_script, "script_dplmc_get_trade_penalty", ":item_kind_id", ":center_no", ":customer_no", ":merchant_no"),
	##nested diplomacy end+
    (assign, ":trade_penalty", reg0),

    (try_begin),
	  ##nested diplomacy start+
	  (gt, ":center_no", 0),
  	  (this_or_next|is_between, ":center_no", centers_begin, centers_end),
		(party_is_active, ":center_no"),
	  
	  (this_or_next|party_slot_eq, ":center_no", "slot_party_type", spt_town),
	  (this_or_next|party_slot_eq, ":center_no", "slot_party_type", spt_village),
	  ##nested diplomacy end+
      (is_between, ":center_no", centers_begin, centers_end),
      (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
      (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
      (val_add, ":item_slot_no", "slot_town_trade_good_prices_begin"),
      (party_get_slot, ":price_factor", ":center_no", ":item_slot_no"),

      (try_begin),
		##nested diplomacy start+
		#OLD:
        #(is_between, ":center_no", villages_begin, villages_end),
        #(party_get_slot, ":market_town", ":center_no", "slot_village_market_town"),
		##NEW:
		(gt, ":center_no", 0),
		(this_or_next|party_slot_eq, ":center_no", "slot_party_type", spt_village),
			(is_between, ":center_no", villages_begin, villages_end),
		(party_get_slot, ":market_town", ":center_no", "slot_village_market_town"),
		
		(ge, ":market_town", centers_begin),
		(this_or_next|party_slot_eq, ":market_town", "slot_party_type", spt_town),
		(this_or_next|party_slot_eq, ":market_town", "slot_party_type", spt_village),
			(is_between, ":market_town", centers_begin, centers_end),
		##nested diplomacy end+
        (party_get_slot, ":price_in_market_town", ":market_town", ":item_slot_no"),
        (val_max, ":price_factor", ":price_in_market_town"),
      (try_end),
	  ##nested diplomacy start+
	  #Enforce constraints
	  (val_clamp, ":price_factor", minimum_price_factor, maximum_price_factor + 1),
	  ##nested diplomacy end+
      
      #For villages, the good will be sold no cheaper than in the market town
      #This represents the absence of a permanent market -- ie, the peasants retain goods to sell on their journeys to town, and are not about to do giveaway deals with passing adventurers  
      
      (val_mul, ":price_factor", 100), #normalize price factor to range 0..100
      (val_div, ":price_factor", average_price_factor),
    (try_end),
    
    (store_add, ":penalty_factor", 100, ":trade_penalty"),
    
    (val_mul, ":price_factor", ":penalty_factor"),
    (val_div, ":price_factor", 100),
    
    (assign, reg0, ":price_factor"),
    (set_trigger_result, reg0),
  ]),

  ("dplmc_party_calculate_strength",
    [
      (store_script_param_1, ":party"), #Party_id
      (store_script_param_2, ":exclude_leader"), #Party_id
      
      (assign, reg0,0),
      (party_get_num_companion_stacks, ":num_stacks", ":party"),
      (assign, ":first_stack", 0),
      (try_begin),
        (neq, ":exclude_leader", 0),
        (assign, ":first_stack", 1),
      (try_end),
      
      (assign, ":sum", 0),
      (try_for_range, ":i_stack", ":first_stack", ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party", ":i_stack"),
        
        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size",":party",":i_stack"),
        (try_end),
        (val_add, ":sum", ":stack_size"),
      (try_end),
      (assign, reg0, ":sum"),
      
      (try_begin), #debug
        (eq, "$cheat_mode", 1),
        (display_message, "@{!}DEBUG : sum: {reg0}"),
      (try_end),
  ]),

# Input: arg1 = faction_no_1, arg2 = faction_no_2
  ("dplmc_get_prisoners_value_between_factions",
   [
       (store_script_param, ":faction_no_1", 1),
       (store_script_param, ":faction_no_2", 2),
       
       (assign, ":faction_no_1_value", 0),
       (assign, ":faction_no_2_value", 0),
	   
       (try_for_parties, ":party_no"),
         (store_faction_of_party, ":party_faction", ":party_no"),
         (try_begin),
           (eq, ":party_faction", ":faction_no_1"),
           (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
           (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
             (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":party_no", ":troop_iterator"),                                 
             (store_troop_faction, ":cur_faction", ":cur_troop_id"),
                          
             (eq, ":cur_faction", ":faction_no_2"),
             (try_begin),
               (troop_is_hero, ":cur_troop_id"),
               (call_script, "script_calculate_ransom_amount_for_troop", ":cur_troop_id"),
               (val_add, ":faction_no_1_value", reg0),  
               
               (try_begin),#debug
                 (eq, "$cheat_mode", 1),        
                 (assign, reg0, ":faction_no_1_value"),
                 (display_message, "@{!}DEBUG : faction_no_1_value: {reg0}"),
               (try_end),
               
             (try_end),
           (try_end),
         (else_try),
           (eq, ":party_faction", ":faction_no_2"),
           (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
           (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
             (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":party_no", ":troop_iterator"),                                 
             (store_troop_faction, ":cur_faction", ":cur_troop_id"),
                          
             (eq, ":cur_faction", ":faction_no_1"),
             (try_begin),
               (troop_is_hero, ":cur_troop_id"),
               (call_script, "script_calculate_ransom_amount_for_troop", ":cur_troop_id"),
               (val_add, ":faction_no_2_value", reg0),
               
               (try_begin), #debug
                 (eq, "$cheat_mode", 1),  
                 (assign, reg0, ":faction_no_2_value"),
                 (display_message, "@{!}DEBUG : faction_no_2_value: {reg0}"),
               (try_end),
               
             (try_end),
           (try_end),         
         (try_end),	 
       (try_end),
       (store_sub, reg0, ":faction_no_1_value", ":faction_no_2_value"),
    ]),
    
# Input: arg1 = faction_no_1, arg2 = faction_no_2
  ("dplmc_get_truce_pay_amount",
   [
       (store_script_param, ":faction_no_1", 1),
       (store_script_param, ":faction_no_2", 2),
       (store_script_param, ":check_peace_war_result", 3),
       
       (assign, ":peace_war_param", 1000), 
       (assign, ":concession_param", 3000), #value of a concession
       
       (try_begin),
         (eq, "$cheat_mode", 1),  
         (assign, reg0, ":check_peace_war_result"), #debug
         (display_message, "@{!}DEBUG : peace_war_result: {reg0}"),#debug
       (try_end),
       
	     (val_sub, ":check_peace_war_result", 1),
	     (val_mul, ":check_peace_war_result", 4),
	     (val_mul, ":check_peace_war_result", ":peace_war_param"),

       (try_begin),
         (eq, "$cheat_mode", 1),  	     
         (assign, reg0, ":check_peace_war_result"), #debug
         (display_message, "@{!}DEBUG : peace_war_result after multi: {reg0}"),#debug
       (try_end),
       	     
       (call_script, "script_dplmc_get_prisoners_value_between_factions", ":faction_no_1", ":faction_no_2"),
       
       (try_begin),
         (eq, "$cheat_mode", 1),  
         (display_message, "@{!}DEBUG : prisonser_value: {reg0}"),#debug
       (try_end),
              
       (val_sub, ":check_peace_war_result", reg0),
       (val_max, ":check_peace_war_result", 0),
       (assign, reg0, ":check_peace_war_result"),

       (try_begin),
         (eq, "$cheat_mode", 1),         
         (display_message, "@{!}DEBUG : peace_war_result after prisoners: {reg0}"),#debug
       (try_end),
       	     
       (assign, reg1, -1),
       (try_begin),
	       (gt, "$g_concession_demanded", 0),
   	     (assign, ":concession_value", 2),
         (try_begin),
           (is_between, "$g_concession_demanded", towns_begin, towns_end),
        	 (assign, ":concession_value", 3),
         (else_try),	
        	  (is_between, "$g_concession_demanded", castles_begin, castles_end),
        	  (assign, ":concession_value", 2),
        	(else_try),
        	  (is_between, "$g_concession_demanded", villages_begin, villages_end),
        	  (assign, ":concession_value", 1),
        	(try_end),
          (val_mul, ":concession_value", ":concession_param"), 
          
          (store_sub, reg1, reg0, ":concession_value"), #reg4 = reg3 - concession_value
          (val_max, reg1, 0),
	   (try_end),
	   
     (try_begin), #debug
       (eq, "$cheat_mode", 1),  
	     (display_message, "@{!}DEBUG : truce_pay_amount0: {reg0}"),
	     (display_message, "@{!}DEBUG : truce_pay_amount1: {reg1}"),
     (try_end),
    ]),
    
  ("dplmc_player_center_surrender",
  [
    (store_script_param, ":center_no", 1),
  
    #protect player for 24 hours
    (store_current_hours,":protected_until"),
    (val_add, ":protected_until", 48),
    (party_get_slot, ":besieger", ":center_no", "slot_center_is_besieged_by"),
    (store_faction_of_party, ":besieger_faction",":besieger"),
    (party_stack_get_troop_id, ":enemy_party_leader", ":besieger", 0),
    
    (party_set_slot,":besieger","slot_party_ignore_player_until",":protected_until"),
    (party_ignore_player, ":besieger", 48),
    (try_for_range, ":lord", active_npcs_begin, active_npcs_end),
      (store_faction_of_troop, ":lord_faction", ":lord"),
      (eq, ":lord_faction", ":besieger_faction"),
      (troop_get_slot, ":led_party", ":lord", "slot_troop_leaded_party"),
      (party_is_active, ":led_party"),
      
      (this_or_next|party_slot_eq, ":led_party", "slot_party_ai_state", spai_screening_army),	#MOTO don't forget screeners
      (party_slot_eq, ":led_party", "slot_party_ai_state", spai_accompanying_army),
      (party_slot_eq, ":led_party", "slot_party_ai_object", ":besieger"),
      
      (party_is_active, ":besieger"),
      (store_distance_to_party_from_party, ":distance_to_marshal", ":led_party", ":besieger"),
      (lt, ":distance_to_marshal", 20),
      
      (party_set_slot,":led_party","slot_party_ignore_player_until",":protected_until"),
      (party_ignore_player, ":led_party", 48),
    (try_end),        
    
    (party_set_faction,"$current_town","fac_neutral"), #temporarily erase faction so that it is not the closest town
    (party_get_num_attached_parties, ":num_attached_parties_to_castle",":center_no"),
    (try_for_range_backwards, ":iap", 0, ":num_attached_parties_to_castle"),
      (party_get_attached_party_with_rank, ":attached_party", ":center_no", ":iap"),
      (party_detach, ":attached_party"),
      (party_get_slot, ":attached_party_type", ":attached_party", "slot_party_type"),
      (eq, ":attached_party_type", spt_kingdom_hero_party),
      (neq, ":attached_party_type", "p_main_party"),
      (store_faction_of_party, ":attached_party_faction", ":attached_party"),
      (call_script, "script_get_closest_walled_center_of_faction", ":attached_party", ":attached_party_faction"),
      (try_begin),
        (gt, reg0, 0),
        (call_script, "script_party_set_ai_state", ":attached_party", spai_holding_center, reg0),
      (else_try),
        (call_script, "script_party_set_ai_state", ":attached_party", spai_patrolling_around_center, ":center_no"),
      (try_end),
    (try_end),
    (call_script, "script_party_remove_all_companions", ":center_no"),
    (change_screen_return),
    (party_collect_attachments_to_party, ":center_no", "p_collective_enemy"), #recalculate so that
    (call_script, "script_party_copy", "p_encountered_party_backup", "p_collective_enemy"), #leaving troops will not be considered as captured
  
   	##nested diplomacy start+
	#Anyone who lost a fief due to your surrender will be irritated
	(try_for_range, ":village_no", centers_begin, centers_end),
       (party_slot_eq, ":village_no", "slot_village_bound_center", ":center_no"),
	   (party_get_slot, ":village_lord", ":village_no", "slot_town_lord"),
	   (neq, ":village_lord", "trp_player"),
	   (is_between, ":village_lord", heroes_begin, heroes_end),
	   (call_script, "script_change_player_relation_with_troop", ":village_lord", -5),
    (try_end),
	##nested diplomacy end+

 (call_script, "script_give_center_to_faction", "$current_town", ":besieger_faction"),
    (call_script, "script_order_best_besieger_party_to_guard_center", ":center_no", ":besieger_faction"),
    
    #relation and controversy
    ##nested diplomacy start+, There should be no relation bonus with the enemy lord
    (call_script, "script_change_player_relation_with_troop", ":enemy_party_leader", -8),
    ##nested diplomacy end+

  	(troop_get_slot, ":controversy", "trp_player", "slot_troop_controversy"),
  	(val_add, ":controversy", 4),
  	(val_min, ":controversy", 100),
  	(troop_set_slot, "trp_player", "slot_troop_controversy", ":controversy"),
    ##nested diplmacy start+ add garrison to fief
    #The average # of troops added by script_cf_reinforce_party is 11.5.
    (assign, ":garrison_strength", 3),#easy: 34.5 for a castle
    (try_begin),
       (party_slot_eq, ":center_no", "slot_party_type", spt_town),
       (assign, ":garrison_strength", 9),#easy: 103.5 for a town
    (try_end),
    #Take into account campaign difficulty.
    (options_get_campaign_ai, ":reduce_campaign_ai"),
    (try_begin),
       (eq, ":reduce_campaign_ai", 0), #hard 166% + 3 waves
       (val_mul, ":garrison_strength", 5),
       (val_div, ":garrison_strength", 3),
       (val_add, ":garrison_strength", 3),
    (else_try),
       (eq, ":reduce_campaign_ai", 1), #moderate 166%
       (val_mul, ":garrison_strength", 5),
       (val_div, ":garrison_strength", 3),
    #(else_try),
    #   (eq, ":reduce_campaign_ai", 2), #easy 100%
    #   (store_mul, ":garrison_strength", 1),
    (try_end),
        
    (try_for_range, ":unused", 0, ":garrison_strength"),
       (call_script, "script_cf_reinforce_party", ":center_no"),
    (try_end),
    (try_for_range, ":unused", 0, 7),# ADD some XP initially
       (store_mul, ":xp_range_min", 150, ":garrison_strength"),
       (store_mul, ":xp_range_max", 200, ":garrison_strength"),
       (store_random_in_range, ":xp", ":xp_range_min", ":xp_range_max"),
       (party_upgrade_with_xp, ":center_no", ":xp", 0),
    (try_end),
    ##nested diplomacy end+
  ]),


  ("dplmc_send_messenger_to_troop",
  [
    (store_script_param, ":target_troop", 1),
    (store_script_param, ":message", 2),
    (store_script_param, ":orders_object", 3),
    
    (troop_get_slot, ":target_party", ":target_troop", "slot_troop_leaded_party"),
    
    (try_begin),
      (eq, ":message", spai_accompanying_army),
      (assign, ":orders_object", "p_main_party"),
    (try_end),

    (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_messenger_party"),
    (assign,":spawned_party",reg0),
    (party_add_members, ":spawned_party", "trp_dplmc_messenger", 1),
    (store_faction_of_troop, ":player_faction", "trp_player"),
    (party_set_faction, ":spawned_party", ":player_faction"),
    (party_set_slot, ":spawned_party", "slot_party_type", spt_messenger),
    (party_set_slot, ":spawned_party", "slot_party_mission_diplomacy", ":message"),
    (party_set_slot, ":spawned_party", "slot_party_home_center", "$current_town"),
    
    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),     
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", "slot_party_ai_object", ":target_party"),
    (party_set_slot, ":spawned_party", "slot_party_orders_object", ":orders_object"),
    
    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_party_name, s13, ":target_party"),
      (display_message, "@{!}DEBUG - Send message to {s13}"),
    (try_end),
  ]
  ),
  
  ("dplmc_send_messenger_to_party",
  [
    (store_script_param, ":target_party", 1),
    (store_script_param, ":message", 2),
    (store_script_param, ":orders_object", 3),

    (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_messenger_party"),
    (assign,":spawned_party",reg0),
    (party_add_members, ":spawned_party", "trp_dplmc_messenger", 1),
    (party_set_faction, ":spawned_party", "fac_player_faction"),
    (party_set_slot, ":spawned_party", "slot_party_type", spt_messenger),
    (party_set_slot, ":spawned_party", "slot_party_mission_diplomacy", ":message"),
    (party_set_slot, ":spawned_party", "slot_party_home_center", "$current_town"),
    
    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),     
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", "slot_party_ai_object", ":target_party"),
    (party_set_slot, ":spawned_party", "slot_party_orders_object", ":orders_object"),
    
    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_party_name, s13, ":target_party"),
      (display_message, "@{!}DEBUG - Send message to {s13}"),
    (try_end),
  ]
  ),

  ("dplmc_send_gift",
    [
    (store_script_param, ":target_troop", 1),
    (store_script_param, ":gift", 2),
    (store_script_param, ":amount", 3),

    (try_begin),
      (troop_slot_eq, ":target_troop", "slot_troop_occupation", slto_kingdom_hero),
      (troop_get_slot, ":target_party", ":target_troop", "slot_troop_leaded_party"),
    (else_try),
      (troop_slot_eq, ":target_troop", "slot_troop_occupation", slto_kingdom_lady),
      (troop_get_slot, ":target_party", ":target_troop", "slot_troop_cur_center"),
    (try_end),


    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_item_name, s12, ":gift"),
      (str_store_party_name, s13, ":target_party"),
      (display_message, "@{!}DEBUG - Bring {s12} to {s13}"),
    (try_end),

    (try_begin),
       #Guard against this being called without an explicit amount
       (lt, ":amount", 1),
       (display_message, "@{!} ERROR: Bad gift amount {reg0}.  (Tell the mod writer he needs to update his code.)  Using a safe default."),
       (assign, ":amount", 1),
       (troop_slot_eq, ":target_troop", "slot_troop_occupation", slto_kingdom_hero),
       (assign, ":amount", 150),
    (try_end),
    (assign, ":original_amount", ":amount"),#Save this here because amount gets modified below! chief

    (call_script, "script_dplmc_withdraw_from_treasury", 50),
    (troop_get_inventory_capacity, ":capacity", "trp_household_possessions"),

  	  (try_for_range, ":inventory_slot", 0, ":capacity"),
  	    (gt, ":amount", 0),
  		  (troop_get_inventory_slot, ":item", "trp_household_possessions", ":inventory_slot"),
  		  (eq, ":item", ":gift"),
  		  (troop_inventory_slot_get_item_amount, ":tmp_amount", "trp_household_possessions", ":inventory_slot"),
  		  (try_begin),
  		    (le, ":tmp_amount", ":amount"),
  		    (troop_inventory_slot_set_item_amount, "trp_household_possessions", ":inventory_slot", 0),
  		    (val_sub, ":amount", ":tmp_amount"),
  		  (else_try),
  		    (val_sub, ":tmp_amount", ":amount"),
  		    (troop_inventory_slot_set_item_amount, "trp_household_possessions", ":inventory_slot", ":tmp_amount"),
  		    (assign, ":amount", 0),
  		  (try_end),
  	  (try_end),

    (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_dplmc_gift_caravan"),
    (assign,":spawned_party",reg0),
    (party_set_slot, ":spawned_party", "slot_party_type", dplmc_spt_gift_caravan),
    (party_set_slot, ":spawned_party", "slot_party_mission_diplomacy", ":gift"),
    (party_set_slot, ":spawned_party",  "slot_party_orders_object",  ":target_troop"),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", "slot_party_ai_object", ":target_party"),
    (party_stack_get_troop_id, ":caravan_master", ":spawned_party", 0),
    (troop_set_slot, ":caravan_master", "slot_troop_leaded_party", ":spawned_party"),
    (party_set_slot, ":spawned_party", "slot_party_mission_parameter_1", ":original_amount"),
    ]),
    
  ("dplmc_send_gift_to_center",
    [
    (store_script_param, ":target_party", 1),
    (store_script_param, ":gift", 2),
    (store_script_param, ":amount", 3),

    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_item_name, s12, ":gift"),
      (str_store_party_name, s13, ":target_party"),
      (display_message, "@{!}DEBUG - Bring {s12} to {s13}"),
    (try_end),

    (try_begin),
       #Guard against this being called without an explicit amount
       (lt, ":amount", 1),
       (display_message, "@{!} ERROR: Bad gift amount {reg0}.  (Tell the mod writer he needs to update his code.)  Using a safe default."),
       (assign, ":amount", 300),
    (try_end),
    (assign, ":original_amount", ":amount"),#Save this here because amount gets modified below!

    (call_script, "script_dplmc_withdraw_from_treasury", 50),
    (troop_get_inventory_capacity, ":capacity", "trp_household_possessions"),
	  (try_for_range, ":inventory_slot", 0, ":capacity"),
	    (gt, ":amount", 0),
		  (troop_get_inventory_slot, ":item", "trp_household_possessions", ":inventory_slot"),
		  (eq, ":item", ":gift"),
		  (troop_inventory_slot_get_item_amount, ":tmp_amount", "trp_household_possessions", ":inventory_slot"),
		  (try_begin),
		    (le, ":tmp_amount", ":amount"),
		    (troop_inventory_slot_set_item_amount, "trp_household_possessions", ":inventory_slot", 0),
		    (val_sub, ":amount", ":tmp_amount"),
		  (else_try),
		    (val_sub, ":tmp_amount", ":amount"),
		    (troop_inventory_slot_set_item_amount, "trp_household_possessions", ":inventory_slot", ":tmp_amount"),
		    (assign, ":amount", 0),
		  (try_end),
	  (try_end),

    (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_dplmc_gift_caravan"),
    (assign,":spawned_party",reg0),
    (party_set_slot, ":spawned_party", "slot_party_type", dplmc_spt_gift_caravan),
    (party_set_slot, ":spawned_party", "slot_party_mission_diplomacy", ":gift"),
    (party_set_slot, ":spawned_party",  "slot_party_orders_object", 0),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", "slot_party_ai_object", ":target_party"),
    (party_stack_get_troop_id, ":caravan_master", ":spawned_party", 0),
    (troop_set_slot, ":caravan_master", "slot_troop_leaded_party", ":spawned_party"),
    (troop_set_slot, ":caravan_master", "slot_troop_leaded_party", ":spawned_party"),
    (party_set_slot, ":spawned_party", "slot_party_mission_parameter_1", ":original_amount"),
    ]),
    
  ("dplmc_troop_political_notes_to_s47",
      [
    (store_script_param, ":troop_no", 1),
    (try_begin),
      (str_clear, s47),
    
      (store_faction_of_troop, ":troop_faction", ":troop_no"),
    
      (faction_get_slot, ":faction_leader", ":troop_faction", "slot_faction_leader"),
    
      (troop_get_type, reg4, ":troop_no"), #F123 - Submod -> 1.41
      (val_mod, reg4, 2), # Added these two here for gender of the troop to show in the strings. TML
      
      (str_clear, s39), # Decoded this from the unofficial bug fix - Are these really needed? Too lazy to look. Was going to add everything from it but realized some of the stuff was definitely unnecessary. TML
      (str_clear, s40),
      (str_clear, s41), # unofficial bug fix. F123 - Submod -> 1.41 (I'll be taking a look at these, tests pending.)
      (assign, ":logged_a_rivalry", 0),
      (try_for_range, ":kingdom_hero", active_npcs_begin, active_npcs_end),
        (neg|troop_slot_ge, ":kingdom_hero", "slot_troop_occupation", slto_inactive_pretender), # unofficial bug fix
        (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":kingdom_hero"),
        (lt, reg0, -10),
      
        (str_store_troop_name_link, s39, ":kingdom_hero"),
        (try_begin),
          (eq, ":logged_a_rivalry", 0),
          (str_store_string, s40, "str_dplmc_s39_rival"),
          (assign, ":logged_a_rivalry", 1),
        (else_try),
          (str_store_string, s41, "str_s40"),
          (str_store_string, s40, "str_dplmc_s41_s39_rival"),
        (try_end),
      
      (try_end),
    
	  (str_clear, s39), # tmlunofficial bug fix
      (str_clear, s46),
      (str_store_troop_name, s46,":troop_no"),
      (try_begin),
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_martial),
        (str_store_string, s46, "str_dplmc_reputation_martial"),
      (else_try),	
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
        (str_store_string, s46, "str_dplmc_reputation_debauched"),
      (else_try),	
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_selfrighteous),
        (str_store_string, s46, "str_dplmc_reputation_pitiless"),
      (else_try),	
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_cunning),
        (str_store_string, s46, "str_dplmc_reputation_calculating"),
      (else_try),	
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_quarrelsome),
        (str_store_string, s46, "str_dplmc_reputation_quarrelsome"),
      (else_try),	
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_goodnatured),
        (str_store_string, s46, "str_dplmc_reputation_goodnatured"),
      (else_try),	
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
        (str_store_string, s46, "str_dplmc_reputation_upstanding"),
      (else_try),
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_conventional),
        (str_store_string, s46, "str_dplmc_reputation_conventional"),
      (else_try),
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_adventurous),
        (str_store_string, s46, "str_dplmc_reputation_adventurous"),
      (else_try),
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_otherworldly),
        (str_store_string, s46, "str_dplmc_reputation_romantic"),
      (else_try),
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_moralist),
        (str_store_string, s46, "str_dplmc_reputation_moralist"),
      (else_try),
        (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_ambitious),
        (str_store_string, s46, "str_dplmc_reputation_ambitious"),
      (else_try),	
        (troop_get_slot, reg11, ":troop_no", "slot_lord_reputation_type"),
        (str_store_string, s46, "str_dplmc_reputation_unknown"),
      (try_end),
    
	(try_begin), # unofficial bugfix
      (troop_slot_eq, ":kingdom_hero", "slot_troop_spouse", -1), # unofficial bugfix
      (is_between, ":kingdom_hero", lords_begin, lords_end), # unofficial bugfix
      (try_for_range, ":love_interest_slot", "slot_troop_love_interest_1", "slot_troop_love_interests_end"),
        (troop_get_slot, ":love_interest", ":troop_no", ":love_interest_slot"),
        (is_between, ":love_interest", kingdom_ladies_begin, kingdom_ladies_end),
        (str_store_troop_name, s39, ":love_interest"),
        (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":love_interest"),
        (str_store_string, s45, "str_dplmc_s40_love_interest_s39"),
        (try_begin),
        	(troop_slot_eq, ":troop_no", "slot_troop_betrothed", ":love_interest"),
        	(str_store_string, s45, "str_dplmc_s40_betrothed_s39"),
        (try_end),
      (try_end),

	(try_end),  #tmlunofficial bugfix
    (str_clear, s44),
    (try_begin),
      (neq, ":troop_no", ":faction_leader"),
      (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_leader"),

      (assign, ":relation", reg0),
      (store_add, ":normalized_relation", ":relation", 100),
      (val_add, ":normalized_relation", 5),
      (store_div, ":str_offset", ":normalized_relation", 10),
      (val_clamp, ":str_offset", 0, 20),
      (store_add, ":str_id", "str_dplmc_relation_mnus_100_ns",  ":str_offset"),
      (try_begin),
        (eq, ":faction_leader", "trp_player"),
        (str_store_string, s59, "@you"),
      (else_try),
        (str_store_troop_name, s59, ":faction_leader"),
      (try_end),
      (str_store_string, s59, ":str_id"),
      (str_store_string, s44, "@{!}^{s59}"),
    (try_end),

    (str_clear, s48),
    
    (try_begin),
      (eq, "$cheat_mode", 1),
      (store_current_hours, ":hours"),
      (gt, ":hours", 0),
      (call_script, "script_calculate_troop_political_factors_for_liege", ":troop_no", ":faction_leader"),
      (str_store_string, s48, "str_sense_of_security_military_reg1_court_position_reg3_"),
    (try_end),
      
    (str_store_string, s47, "str_s46s45s44s48"),
    (str_clear, s48), # tml f123 unofficial bug fix
    (str_clear, s44), # unofficial bug fix
    (str_clear, s45), # unofficial bug fix
    (str_clear, s46), # unofficial bug fix  
  (try_end),	 
    ]),	 

  ("dplmc_init_domestic_policy",
  [
    (try_for_range, ":kingdom", npc_kingdoms_begin, npc_kingdoms_end),    
      (try_begin),
        (store_random_in_range, ":random", -3, 4),
        (faction_set_slot, ":kingdom", "slot_faction_centralization", ":random"),
        (store_random_in_range, ":random", -3, 4),
        (faction_set_slot, ":kingdom", "slot_faction_aristocracy", ":random"),
        (store_random_in_range, ":random", -3, 4),
        (faction_set_slot, ":kingdom", "slot_faction_quality", ":random"),
        (store_random_in_range, ":random", -3, 4),
        (faction_set_slot, ":kingdom", "slot_faction_serfdom", ":random"),
      (try_end),
    (try_end),
  ]),

  ("dplmc_is_affiliated_family_member",
  [
      (store_script_param, ":troop_id", 1),
      (assign, ":is_affiliated_family_member", 0),
      (try_begin),
        (is_between, "$g_player_affiliated_troop", lords_begin, kingdom_ladies_end),
        (try_begin),
          (eq, "$g_player_affiliated_troop", ":troop_id"),
          (assign, ":is_affiliated_family_member", 1),
        (else_try),
          (is_between, ":troop_id", lords_begin, kingdom_ladies_end),
          (call_script, "script_troop_get_family_relation_to_troop", ":troop_id", "$g_player_affiliated_troop"),
          (gt, reg0, 0),
          (call_script, "script_troop_get_relation_with_troop", "$g_player_affiliated_troop", ":troop_id"),
          (ge, reg0, -10),
          (assign, ":is_affiliated_family_member", 1),         
        (try_end),
      (try_end),
      (assign, reg0, ":is_affiliated_family_member"),
  ]),  
  ("dplmc_affiliate_end",
  [
    (store_script_param, ":cause", 1),
    
    (assign, "$g_player_affiliated_troop", 0),
    
    (try_begin),
      (eq, ":cause", 1),
      (assign, ":max_penalty", -16),
      (assign, ":term", 20),
      (assign, ":honor_val", 10),
    (else_try),
      (assign, ":max_penalty", -12),
      (assign, ":honor_val", 5),
      (assign, ":term", 15),
    (try_end),
    
    (try_for_range, ":family_member", lords_begin, kingdom_ladies_end),
      (call_script, "script_dplmc_is_affiliated_family_member", ":family_member"),
      (gt, reg0, 0),
      
      (store_skill_level, ":value", "skl_persuasion", "trp_player"),
      (store_random_in_range, ":value", 0, ":value"),
      (val_add, ":value", ":max_penalty", ":value"),
      (val_min, ":value", 0),
      (call_script, "script_change_player_relation_with_troop", ":family_member", ":value"),
    (try_end),
    
    (try_begin),
      (gt, "$player_honor", ":honor_val"),
      (val_add, ":term", ":honor_val"),
    (else_try),
      (val_add, ":term", "$player_honor"),
    (try_end),
    
    (store_current_hours, ":cur_hours"),
    (store_sub, ":affiliated_hours", ":cur_hours", "$g_player_affiliated_time"),
    (store_div, ":affiliated_days", ":affiliated_hours", 24),
    (val_sub, ":term", ":affiliated_days"),
    (val_max, ":term", 0),
    (val_min, ":term", 40),
    
    
    (troop_get_slot, ":controversy", "trp_player", "slot_troop_controversy"),
    (val_add, ":controversy", ":term"),
    (val_min, ":controversy", 100),
    (troop_set_slot, "trp_player", "slot_troop_controversy", ":controversy"),

  ]),
  ("dplmc_appoint_chamberlain",
  [
   (troop_set_auto_equip, "trp_dplmc_chamberlain", 0),
	 (troop_set_inventory_slot, "trp_dplmc_chamberlain", ek_body, "itm_noblemanshirt4"),
	 (troop_set_inventory_slot, "trp_dplmc_chamberlain", ek_foot, "itm_leather_boots1"),
   (assign, "$g_player_chamberlain", "trp_dplmc_chamberlain"),   
  ]),  

  ("dplmc_appoint_chancellor",
  [
	 (troop_set_inventory_slot, "trp_dplmc_chancellor", ek_body, "itm_mailbyrnieblue"),
	 (troop_set_inventory_slot, "trp_dplmc_chancellor", ek_foot, "itm_leather_boots1"),    
   (assign, "$g_player_chancellor", "trp_dplmc_chancellor"),   
  ]),

  # script_script_dplmc_faction_leader_splits_gold
  # INPUT: arg1 = troop_id, arg2 = new faction_no
  # OUTPUT: none
  ("dplmc_faction_leader_splits_gold",
    [
	(store_script_param_1, ":faction_no"),
    (store_script_param_2, ":king_gold"),
	(assign, ":push_reg0", reg0),#revert register value at end of script
	(assign, ":push_reg1", reg1),#revert register value at end of script
	
	(faction_get_slot, ":faction_liege", ":faction_no", "slot_faction_leader"),
	(faction_get_slot, reg0, ":faction_no", "slot_faction_centralization"),
	(val_clamp, reg0, -3, 4),
	(val_mul, reg0, -5),
	(try_begin),		
		(troop_slot_ge, ":faction_liege", "slot_troop_wealth", 20000),
		(val_add, reg0, 20),#20% if the king is at or above his starting gold
	(else_try),
		(val_add, reg0, 50),#50% otherwise
	(try_end),
	(val_add, reg0, 50),
	(store_mul, ":lord_gold", ":king_gold", reg0),#king splits other half among lords
	(val_div, ":lord_gold", 100),
	(val_sub, ":king_gold", ":lord_gold"),
	(try_begin),
		#If there's enough gold to give a meaningful amount to everyone, do so.
		#(This accomplishes two things.  It makes the distribution more even, and
		#it prevents this script from taking an unreasonably long time for very
		#large amounts of gold.)
		#
		#"Meaningful" is at least 300, because that's the minimum amount of gold a
		#lord will to to a fief to collect (it is also the AI recruitment cost on
		#hard).
		(assign, ":num_lords", 0),#<-- number of lords in faction, not including faction leader
		(try_for_range, ":lord_no", heroes_begin, heroes_end),
			(store_troop_faction, ":lord_faction_no", ":lord_no"),
			(eq, ":faction_no", ":lord_faction_no"),
			(troop_set_slot, ":lord_no", "slot_troop_temp_slot", 0),
			(neg|faction_slot_eq, ":faction_no", "slot_faction_leader", ":lord_no"),
			(troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
			(neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
			(troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
			(ge, ":lord_party", 0),
			(val_add, ":num_lords", 1),
		(try_end),
		(try_begin),
			#handle player
			(eq, "$players_kingdom", ":faction_no"),
			(neq, "trp_player", ":faction_liege"),
			(neg|troop_slot_ge, "trp_player", "slot_troop_prisoner_of_party", 0),
			(val_add, ":num_lords", 1),
		(try_end),
		(gt, ":num_lords", 0),#<-- can fail
		(store_div, ":gold_to_each", ":lord_gold", ":num_lords"),
		(ge, ":gold_to_each", 300),
		(val_div, ":gold_to_each", 150),#regularize (standard reinforcement costs for easy/medium/hard are 600/450/300, which are multiples of 150)
		(val_mul, ":gold_to_each", 150),
		
		#(try_begin),
		#	(ge, "$cheat_mode", 1),
		#	(assign, reg0, ":num_lords"),
		#	(assign, reg1, ":gold_to_each"),
		#	(str_store_faction_name, s5, ":faction_no"),		
		#	(display_message, "@ {reg0} vassals of the {s5} receive {reg1} denars each (dplmc_faction_leader_splits_gold)"),
		#(try_end),
		
		(try_for_range, ":lord_no", heroes_begin, heroes_end),
			(ge, ":lord_gold", ":gold_to_each"),
			#verify lord is vassal of kingdom
			(store_troop_faction, ":lord_faction_no", ":lord_no"),
			(eq, ":faction_no", ":lord_faction_no"),
			(neg|faction_slot_eq, ":faction_no", "slot_faction_leader", ":lord_no"),
			(troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
			(neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
			(troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
			(ge, ":lord_party", 0),
			#give gold to lord
			(val_sub, ":lord_gold", ":gold_to_each"),
			#(troop_get_slot, reg0, ":lord_no", "slot_troop_temp_slot"),
			#(val_add, reg0, ":gold_to_each"),
			#(troop_set_slot, ":lord_no", "slot_troop_temp_slot", reg0),
			##(call_script, "script_troop_add_gold", ":lord_no", ":gold_to_each"),
			(call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", ":gold_to_each", ":lord_no"),
		(try_end),
		(try_begin),
			(ge, ":lord_gold", ":gold_to_each"),
			#give gold to player if player is vassal of kingdom
			(eq, "$players_kingdom", ":faction_no"),
			(neq, "trp_player", ":faction_liege"),
			(neg|troop_slot_ge, "trp_player", "slot_troop_prisoner_of_party", 0),
			(val_sub, ":lord_gold", ":gold_to_each"),
			(troop_get_slot, reg0, "trp_player", "slot_troop_temp_slot"),
			(val_add, reg0, ":gold_to_each"),
			(troop_set_slot, "trp_player", "slot_troop_temp_slot", reg0),
			##(call_script, "script_troop_add_gold", ":lord_no", ":gold_to_each"),
		(try_end),
	(try_end),
	#Now, distribute the remaining gold.  Assign gold in increments of 300,
	#because that's the minimum amount of gold a lord will go to a fief for
	#(also the AI recruitment cost on hard).
	(store_div, ":count", ":lord_gold", 300),
	(val_max, ":count", 1),
	(try_for_range, ":unused", 0, ":count"),
		(ge, ":lord_gold", 300),
		(call_script, "script_cf_get_random_lord_except_king_with_faction", ":faction_no"),
		(is_between, reg0, heroes_begin, heroes_end),
		(assign, ":troop_no", reg0),
		(val_sub, ":lord_gold", 300),
		(troop_get_slot, reg0, ":troop_no", "slot_troop_temp_slot"),
		(val_add, reg0, 300),
		(troop_set_slot, ":troop_no", "slot_troop_temp_slot", reg0),
		#(call_script, "script_troop_add_gold", ":troop_no", 300),
	(try_end),
	
	#Now the distribution is set.  Give each one his allotment.
	(try_for_range, ":lord_no", heroes_begin, heroes_end),
		(ge, ":lord_gold", ":gold_to_each"),
		#verify lord is vassal of kingdom
		(store_troop_faction, ":lord_faction_no", ":lord_no"),
		(eq, ":faction_no", ":lord_faction_no"),
		(neg|faction_slot_eq, ":faction_no", "slot_faction_leader", ":lord_no"),
		(troop_slot_eq, ":lord_no", "slot_troop_occupation", slto_kingdom_hero),
		(neg|troop_slot_ge, ":lord_no", "slot_troop_prisoner_of_party", 0),
		(troop_get_slot, ":lord_party", ":lord_no", "slot_troop_leaded_party"),
		(ge, ":lord_party", 0),
		#get promised gold
		(troop_get_slot, reg0, ":lord_no", "slot_troop_temp_slot"),
		(neq, reg0, 0),
		#(try_begin),
		#	(ge, "$cheat_mode", 1),
		#	(str_store_troop_name, s4, ":lord_no"),
		#	(str_store_faction_name, s5, ":faction_no"),
		#	(str_store_troop_name, s6, ":faction_liege"),			
		#	(display_message, "@{!}{s4} of the {s5} receives {reg0} denars (dplmc_faction_leader_splits_gold)"),
		#(try_end),
		(call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", reg0, ":lord_no"),
		(troop_set_slot, ":lord_no", "slot_troop_temp_slot", 0),
	(try_end),
	
	(val_add, ":king_gold", ":lord_gold"),#Give remaining gold to king
	(try_begin),
		(ge, "$cheat_mode", 1),
		(str_store_troop_name, s4, ":troop_no"),
		(str_store_faction_name, s5, ":faction_no"),
		(str_store_troop_name, s6, ":faction_liege"),			
		(display_message, "@{!}{s6} of the {s5} retains the remaining {reg0} denars (dplmc_faction_leader_splits_gold)"),
	(try_end),
	
	#(call_script, "script_troop_add_gold", ":faction_liege", ":king_gold"),
	(call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", ":king_gold", ":faction_liege"),
	(assign, reg0, ":push_reg0"),#revert register value
	(assign, reg1, ":push_reg1"),#revert register value
	]),

#"script_dplmc_store_troop_personality_caution_level"
#
# INPUT:
#   arg1 :troop_no
# OUTPUT:
#   reg0 -1 for aggressive
#         0 for neither
#         1 for cautious
("dplmc_store_troop_personality_caution_level", [
	#Used a number of places to determine whether a lord is cautious
	#or aggressive.  The standard is something like:
	#
	#For cautious:
	#(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_upstanding),
    #    (this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_debauched),
    #    (this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_goodnatured),
    #    (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_cunning),
	#
	#For aggressive:
	#(this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_martial),
    #    (this_or_next|troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_quarrelsome),
    #    (troop_slot_eq, ":troop_no", "slot_lord_reputation_type", lrep_selfrighteous),
	#
	#I've expanded this for companion/lady personalities.
	#The result can be either:
	# -1  =  aggressive
	#  0  =  neutral
	#  1  =  cautious
	(store_script_param_1, ":troop_no"),
	
	(try_begin),
		(neg|is_between, ":troop_no", heroes_begin, heroes_end),#The player or troops that don't have "slot_lord_reputation_type"
		(assign, reg0, 0),#neither cautious nor aggressive
	(else_try),
		(call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_aristocratic),
		(lt, reg0, 0),#compliments when the player retreats
		(assign, reg0, 1),#cautious
	(else_try),
		(gt, reg0, 0),#complains when the player retreats
		(assign, reg0, -1),#aggressive
	(else_try),
		(troop_get_slot, ":reputation", ":troop_no", "slot_lord_reputation_type"),
		(this_or_next|eq, ":reputation", lrep_adventurous),
		(this_or_next|eq, ":reputation", lrep_martial),
		(this_or_next|eq, ":reputation", lrep_quarrelsome),
			(eq, ":reputation", lrep_selfrighteous),
		(assign, reg0, -1),#aggressive
	(else_try),
		(this_or_next|ge, ":reputation", lrep_conventional),
		(this_or_next|eq, ":reputation", lrep_upstanding),
		(this_or_next|eq, ":reputation", lrep_debauched),
		(this_or_next|eq, ":reputation", lrep_goodnatured),
			(eq, ":reputation", lrep_cunning),
		(assign, reg0, 1),#cautious
	(else_try),
		(assign, reg0, 0),#neither cautious nor aggressive
	(try_end),
]),

  # script_dplmc_time_sorted_heroes_for_center_aux
  # For internal use only
  # param 1: center no
  # param 2: party_no_to_collect_heroes
  # param 3: minimum time since last met (inclusive), or negative for no restriction
  # param 4: maximum time since last met (exclusive), or negative for no restriction
  ("dplmc_time_sorted_heroes_for_center_aux",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (store_script_param, ":min_time", 3),
      (store_script_param, ":max_time", 4),

      (store_current_hours, ":current_hours"),
      
      (party_get_num_companion_stacks, ":num_stacks",":center_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":center_no",":i_stack"),
        (troop_is_hero, ":stack_troop"),
        #get time since last talk
        (troop_get_slot, ":troop_last_talk_time", ":stack_troop", "slot_troop_last_talk_time"),
        (store_sub, ":time_since_last_talk", ":current_hours", ":troop_last_talk_time"),
        #add if time meets constraints
        (this_or_next|ge, ":time_since_last_talk", ":min_time"),
           (lt, ":min_time", 0),
        (this_or_next|lt, ":time_since_last_talk", ":max_time"),
           (lt, ":max_time", 0),
        (party_add_members, ":party_no_to_collect_heroes", ":stack_troop", 1),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":center_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":center_no", ":attached_party_rank"),
        (call_script, "script_dplmc_time_sorted_heroes_for_center_aux", ":attached_party", ":party_no_to_collect_heroes",":min_time",":max_time"),
      (try_end),
  ]),

  # script_dplmc_time_sorted_heroes_for_center
  # Input: arg1 = center_no, arg2 = party_no_to_collect_heroes
  # Output: none, adds heroes to the party_no_to_collect_heroes party
  # The catch is that it returns heroes who haven't been met in a day
  # or more before others, for greater use in feasts.
  ("dplmc_time_sorted_heroes_for_center",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_clear, ":party_no_to_collect_heroes"),

     #Heroes you haven't spoken to in 24+ hours
     (call_script, "script_dplmc_time_sorted_heroes_for_center_aux",
         ":center_no", ":party_no_to_collect_heroes", 24, -1),

     #Heroes you haven't spoken to in 12 to 24 hours
     (call_script, "script_dplmc_time_sorted_heroes_for_center_aux",
         ":center_no", ":party_no_to_collect_heroes", 12, 24),

     #Everyone else
     (call_script, "script_dplmc_time_sorted_heroes_for_center_aux",
         ":center_no", ":party_no_to_collect_heroes", -1, 12),

     #Non-attached pretenders
     (try_for_range, ":pretender", pretenders_begin, pretenders_end),
        (neq, ":pretender", "$supported_pretender"),
        (troop_slot_eq, ":pretender", "slot_troop_cur_center", ":center_no"),
        (party_add_members, ":party_no_to_collect_heroes", ":pretender", 1),
     (try_end),
  ]),


	# script_dplmc_get_faction_truce_length_with_faction
	# INPUT
	#   arg1:  faction_1
	#   arg2:  faction_2
	# OUTPUT
	#   reg0:  The length in days of faction_1's truce with faction_2, if any.
	#          If no truce exists, the appropriate value to return is zero.
    ("dplmc_get_faction_truce_length_with_faction",
	   [
	    (store_script_param, ":faction_1", 1),
		(store_script_param, ":faction_2", 2),
		
		(assign, ":truce_length", 0),
		
		(try_begin),
			(is_between, ":faction_1", kingdoms_begin, kingdoms_end),
			(is_between, ":faction_2", kingdoms_begin, kingdoms_end),
			(neq, ":faction_1", ":faction_2"),
			(store_add, ":truce_slot", ":faction_2", "slot_faction_truce_days_with_factions_begin"),
			(val_sub, ":truce_slot", kingdoms_begin),
			(faction_get_slot, ":truce_length", ":faction_1", ":truce_slot"),
        (try_end),
	    (assign, reg0, ":truce_length"),
	   ]),

  #script_dplmc_get_terrain_code_for_battle
  #
  # Gets the terrain code for a battle between two parties, which
  # is usually a value like rt_desert, but can instead be two
  # special values: -1 for 
  #
  # INPUT: arg1 = attacker_party
  #        arg2 = defender_party
  # OUTPUT: reg0 = terrain code (-1 for invalid, -2 for siege)
  ("dplmc_get_terrain_code_for_battle",
   [
      (store_script_param, ":attacker_party", 1),
      (store_script_param, ":defender_party", 2),

      (assign, reg0, dplmc_terrain_code_unknown), #Terrain code, defined in header_terrain_types.py
	  
	  (try_begin),
		#Check for village missions
         (this_or_next|eq, ":attacker_party", "p_main_party"),
			(eq, ":defender_party", "p_main_party"),
		 (ge, "$g_encounter_is_in_village", 1),
		 (assign, reg0, dplmc_terrain_code_village),#defined in header_terrain_types.py
      (else_try),
		#If the attacker party is a town, a castle, a village, a bandit lair, or a ship,
		#set the terrain code to "none" since we don't have any specific ideas for modifying
		#the unit-type performance in scenarios of that type (whatever they are).
         (ge, ":attacker_party", 0),
         (this_or_next|party_slot_eq, ":attacker_party", "slot_party_type", spt_town),#no modifier for being attacked by garrisoned troops
         (this_or_next|party_slot_eq, ":attacker_party", "slot_party_type", spt_castle),
         (this_or_next|party_slot_eq, ":attacker_party", "slot_party_type", spt_village),
         (this_or_next|party_slot_eq, ":attacker_party", "slot_party_type", spt_bandit_lair),
			(party_slot_eq, ":attacker_party", "slot_party_type", spt_ship),#no modifier for being attacked by a ship
         (assign, reg0, dplmc_terrain_code_unknown),#no terrain options, defined in header_terrain_types.py
	  (else_try),
		#If the attacker party is *attached* to a town/castle/village, a bandit lair, or a ship,
		#set the terrain code to "none" since we don't have any specific ideas for modifying
		#the unit-type performance in scenarios of that type (whatever they are).
	     (ge, ":attacker_party", 0),
	     (party_get_attached_to, ":attachment", ":attacker_party"),
		 (ge, ":attachment", 0),
		 (party_is_active, ":attachment"),
		 (this_or_next|party_slot_eq, ":attachment", "slot_party_type", spt_town),#no modifier for being attacked by garrisoned troops
         (this_or_next|party_slot_eq, ":attachment", "slot_party_type", spt_castle),
         (this_or_next|party_slot_eq, ":attachment", "slot_party_type", spt_village),
         (this_or_next|party_slot_eq, ":attachment", "slot_party_type", spt_bandit_lair),
			(party_slot_eq, ":attachment", "slot_party_type", spt_ship),#no modifier for being attacked by a ship
         (assign, reg0, dplmc_terrain_code_unknown),#no terrain modifiers
      (else_try),
		#If the attacker party isn't a weird type, the terrain is entirely based on the
		#defender (unless the defender is invalid).
         (ge, ":defender_party", 0),
         (try_begin),
			#If the defender is a walled center, use siege mode.
            (this_or_next|party_slot_eq, ":defender_party", "slot_party_type", spt_town),
            (party_slot_eq, ":defender_party", "slot_party_type", spt_castle),
            (assign, reg0, dplmc_terrain_code_siege),#siege mode, defined in header_terrain_types.py
		 (else_try),
			#If the defender is a village
			(party_slot_eq, ":defender_party", "slot_party_type", spt_village),
			(assign, reg0, dplmc_terrain_code_village),
         (else_try),
			#If the defender is a bandit lair or a ship, use no terrain modifier.
            (this_or_next|party_slot_eq, ":defender_party", "slot_party_type", spt_bandit_lair),
				(party_slot_eq, ":defender_party", "slot_party_type", spt_ship),
            (assign, reg0, dplmc_terrain_code_unknown),#no terrain modifiers
 		 (else_try),
			#If the defender is attached, do the same checks but for the attachment.
		    (party_get_attached_to, ":attachment", ":defender_party"),
			(ge, ":attachment", 0),
			(party_is_active, ":attachment"),
			(assign, ":attachment_value", -100),
			(try_begin),
				#Walled centers use siege modifiers
			   (this_or_next|party_slot_eq, ":attachment", "slot_party_type", spt_town),
			      (party_slot_eq, ":attachment", "slot_party_type", spt_castle),
			   (assign, ":attachment_value", dplmc_terrain_code_siege),
			(else_try),
				#Villages
			   (party_slot_eq, ":attachment", "slot_party_type", spt_village),
			   (assign, ":attachment_value", dplmc_terrain_code_village),
			(else_try),
				#bandit-lairs and ships have no modifiers currently
			   (this_or_next|party_slot_eq, ":attachment", "slot_party_type", spt_bandit_lair),
				(party_slot_eq, ":attachment", "slot_party_type", spt_ship),
			   (assign, ":attachment_value", dplmc_terrain_code_unknown),#no terrain modifiers
			(try_end),
			#If neither of the above apply, fall through to the next condition.
			(neq, ":attachment_value", -100),
			(assign, reg0, ":attachment_value"),
         (else_try),
			#Use the terrain under the defender.
			#In the future I might want to change this so there's a tactics contest
			#between the attacker and defender to choose the more favorable ground
			#from their immediate surroundings.  I would also have to change the actual
			#terrain-type code.
            (party_get_current_terrain, reg0, ":defender_party"),
		 (try_end),
      (else_try),
		 #If we get here, it means the defender was invalid, so use the terrain under
		 #the attacker.
         (ge, ":attacker_party", 0),
         (party_get_current_terrain, reg0, ":attacker_party"),#terrain under attacker
      (try_end),
   ]),
   
  #script_dplmc_party_calculate_strength_in_terrain
  # INPUT: arg1 = party_id
  #        arg2 = terrain (from header_terrain_types.py)
  #        arg3 = exclude leader (0 for do-not-exclude, 1 for exclude)
  #        arg4 = cache policy (1 is use terrain, 2 is use non-terrain, 0 is do not use)
  # OUTPUT: reg0 = strength with terrain
  #         reg1 = strength ignoring terrain
  ("dplmc_party_calculate_strength_in_terrain",
    [
      (store_script_param, ":party", 1), #Party_id
      (store_script_param, ":terrain_type", 2),#a value from header_terrain_types.py
      (store_script_param, ":exclude_leader", 3),#(0 for do-not-exclude, 1 for exclude)
      (store_script_param, ":cache_policy", 4),#1 is use terrain, 2 is use non-terrain, 0 is do not use)

      (assign, ":total_strength_terrain", 0),
      (assign, ":total_strength_no_terrain", 0),

      (party_get_num_companion_stacks, ":num_stacks", ":party"),
      (assign, ":first_stack", 0),
      (try_begin),
        (neq, ":exclude_leader", 0),
        (assign, ":first_stack", 1),
      (try_end),
	  #Bonus for heroes on top of the rest
	  (assign, ":hero_percent", 110),
	  ##Moved setting the multipliers out of the loop...
	  (assign, ":guaranteed_horse_percent", 100),
	  (assign, ":guaranteed_ranged_percent", 100),
	  (assign, ":guaranteed_neither_percent", 100),
	  #First, test for some special codes:
	  (try_begin),
	     (eq, ":terrain_type", dplmc_terrain_code_none),#Apply no modifiers
		 (assign, ":hero_percent", 100),
	  (else_try),
	  	(eq, ":terrain_type", dplmc_terrain_code_village),#A dismounted fight at a village (apply hero modifier, nothing else)
      (else_try),
        (eq, ":terrain_type", dplmc_terrain_code_siege),#A siege battle, not including sorties.
        (assign, ":guaranteed_ranged_percent", 120),
	  #The rest are ordinary rt_* codes.
	  #I changed the balance of these to make the variations less extreme (e.g. 150% mounted strength on rt_steppe).
	  #I believe that the version from ArcherOS is trying to create certain map results, rather than solely
	  #make autocalc strength more accurate in terms of "what would happen if they fought the player".
	  (else_try),
        (eq, ":terrain_type", rt_steppe),
		#The 150% increase in the steppe strikes me as excessive.
		#Since the NPC cost increase for mounted troops is 20%, and the PC cost is 65%,
		#it isn't entirely implausible.
	    #(assign, ":guaranteed_horse_percent", 150),
		#Archer uses 150%, Custom Commander uses a flat 125%.
		(assign, ":guaranteed_horse_percent", 120),
	  (else_try),
		#I am unaware of any game mechanic in live battles that gives any disadvantage
		#to horses on snow or sand as opposed to a plain.
		(this_or_next|eq, ":terrain_type", rt_snow),
		(this_or_next|eq, ":terrain_type", rt_desert),
			(eq, ":terrain_type", rt_plain),
		(assign, ":guaranteed_horse_percent", 120),
     (else_try),
		#I suspect that the 120% mounted bonus for steppe forests is inaccurate,
		#but I haven't checked it out yet.
	    (eq, ":terrain_type", rt_steppe_forest),
        (assign, ":guaranteed_horse_percent", 120),
     (else_try),
        (this_or_next|eq, ":terrain_type", rt_forest),
        (this_or_next|eq, ":terrain_type", rt_mountain_forest),
		     (eq, ":terrain_type", rt_snow_forest),
        #(assign, ":guaranteed_neither_percent", 120),
		(assign, ":guaranteed_neither_percent", 110),
	 (try_end),
	  
      (try_for_range, ":i_stack", ":first_stack", ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party", ":i_stack"),
        (store_character_level, ":stack_strength", ":stack_troop"),
        (val_add, ":stack_strength", 4), #new was 12 (patch 1.125)
        (val_mul, ":stack_strength", ":stack_strength"),
        (val_mul, ":stack_strength", 2), #new (patch 1.125)
        #move the next two lines to after terrain advantage
        #(val_div, ":stack_strength", 100), 
        #(val_max, ":stack_strength", 1), #new (patch 1.125)
        (assign, ":terrain_free_strength", ":stack_strength"),
        ##use Arch3r's terrain advantage code (bug-fix changes 2011-04-13; other changes 2011-04-25)
        (try_begin),
           ##AotE terrain advantages
           (assign, ":hero_horse", 0),#added for heroes (any positive number = has a horse)
           (try_begin),
		      (this_or_next|eq, "trp_player", ":stack_troop"),
				(troop_is_hero, ":stack_troop"),
		      (gt, ":guaranteed_horse_percent", ":hero_percent"),#don't bother if we wouldn't use the result
              (neg|troop_is_guarantee_horse, ":stack_troop"),#don't bother if we already know the troop has a horse
			  (store_skill_level, reg0, "skl_riding", ":stack_troop"),
			  (ge, reg0, 2),#don't bother if the troop has no/minimal riding skill
			  #Just checking ek_horse may not work for non-companions, so check the inventory
			  (troop_get_inventory_capacity, ":inv_cap", ":stack_troop"),
			  (ge, ":inv_cap", 1),
			  (val_min, ":inv_cap", (ek_horse * 2) + 1),#Just check near the beginning
			  (try_for_range, ":inv_slot", 0, ":inv_cap"),
				(troop_inventory_slot_get_item_amount, reg1, ":stack_troop", ":inv_slot"),
				(ge, reg1, 1),#quantity must be greater than zero
				(troop_get_inventory_slot, reg0, ":stack_troop", ":inv_slot"),
				(is_between, reg0, horses_begin, horses_end),#item must be a horse
				(assign, ":hero_horse", reg0),
				(assign, ":inv_cap", ":inv_slot"),#break loop
			  (try_end),
			  #If no horse found, set to zero
              (neg|is_between, ":hero_horse", horses_begin, horses_end),
              (assign, ":hero_horse", 0),
           (try_end),
		   (assign, ":stack_strength_multiplier", 100),#<-- percent multiplier
           (try_begin),#Mounted troops
			  (this_or_next|ge, ":hero_horse", 1),
              (troop_is_guarantee_horse, ":stack_troop"),
              (assign, ":stack_strength_multiplier", ":guaranteed_horse_percent"),
		   (else_try),#Ranged troops
              (troop_is_guarantee_ranged, ":stack_troop"),
              (assign, ":stack_strength_multiplier", ":guaranteed_ranged_percent"),
           (else_try),#Infantry
              (assign, ":stack_strength_multiplier", ":guaranteed_neither_percent"),
           (try_end),
			
		   #Use hero/player modifiers if a better one didn't apply
		   (try_begin),
		      (this_or_next|eq, ":stack_troop", "trp_player"),
			     (troop_is_hero, ":stack_troop"),
			  (val_max, ":stack_strength_multiplier", ":hero_percent"),#hero bonus
		   (try_end),
		   
		   (val_mul, ":stack_strength", ":stack_strength_multiplier"),		   
		   (val_add, ":stack_strength", 50),#add this before division for correct rounding
           (val_div, ":stack_strength", 100),
           ##AotE terrain advantages
        (try_end),
        #moved the next two lines here from above
        (val_div, ":stack_strength", 100),#<- moved here from above
        (val_max, ":stack_strength", 1), #new (patch 1.125) #<- moved here from above
        (val_div, ":terrain_free_strength", 100),
        (val_max, ":terrain_free_strength", 1),
        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size",":party",":i_stack"),
          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
          (val_sub, ":stack_size", ":num_wounded"),
          (val_mul, ":stack_strength", ":stack_size"),
          (val_mul, ":terrain_free_strength", ":stack_size"),
        (else_try),
          (troop_is_wounded, ":stack_troop"), #hero & wounded
          (assign, ":stack_strength", 0),
          (assign, ":terrain_free_strength", 0),
        (try_end),
        (val_add, ":total_strength_terrain", ":stack_strength"),
        (val_add, ":total_strength_no_terrain", ":terrain_free_strength"),
      (try_end),
	  #Load results into registers and cache if appropriate
	  (assign, reg0, ":total_strength_terrain"),
	  (assign, reg1, ":total_strength_no_terrain"),
      (try_begin),
         (eq, ":cache_policy", 1),
         (party_set_slot, ":party", "slot_party_cached_strength", reg0),
      (else_try),
         (eq, ":cache_policy", 2),
         (party_set_slot, ":party", "slot_party_cached_strength", reg1),
      (try_end),
  ]),  
  
  
    #script_dplmc_get_troop_morality_value
    # INPUT: arg1 = troop_id, arg2 = morality type
    # OUTPUT: reg0 has morality value, or 0 if inapplicable
    ("dplmc_get_troop_morality_value",
	[
		(store_script_param, ":troop_id", 1),
		(store_script_param, ":morality_type", 2),
		
		(assign, reg0, 0),
		(try_begin),
			(neg|is_between, ":troop_id", companions_begin, companions_end),#<-- result is 0 for non-companions
		(else_try),
			(troop_slot_eq, ":troop_id", "slot_troop_morality_type", ":morality_type"),
			(troop_get_slot, reg0, ":troop_id", "slot_troop_morality_value"),
		(else_try),
			(troop_slot_eq, ":troop_id", "slot_troop_2ary_morality_type", ":morality_type"),
			(troop_get_slot, reg0, ":troop_id", "slot_troop_2ary_morality_value"),
		(try_end),
		
	]),


  #"script_dplmc_distribute_gold_to_lord_and_holdings"
  #
  #Related to script_dplmc_remove_gold_from_lord_and_holdings, divides the gold
  #between the lord and his fortresses in a semi-intelligent way.
  #
  #INPUT:
  #   arg1: the amount of gold
  #   arg2: the lord's ID
  ("dplmc_distribute_gold_to_lord_and_holdings",
   [
	(store_script_param_1, ":gold_left"),
	(store_script_param_2, ":lord_no"),
	
	(try_begin),
		(lt, ":lord_no", 0),#Invalid ID
	(else_try),
		(neq, ":lord_no", "trp_player"),
		(neg|troop_is_hero, ":lord_no"),#Not hero or player
	(else_try),
		#If the number is negative, handle this using script_dplmc_remove_gold_from_lord_and_holdings
		(lt, ":gold_left", 0),
		(val_mul, ":gold_left", -1),
		(call_script, "script_dplmc_remove_gold_from_lord_and_holdings", ":gold_left", ":lord_no"),
		(assign, ":gold_left", 0),
	(else_try),
		#The player doesn't use center wealth to pay garrison wages, so just
		#give it directly.
		(eq, ":lord_no", "trp_player"),
		(troop_add_gold, "trp_player", ":gold_left"),
		(assign, ":gold_left", 0),
	(else_try),
		(troop_get_slot, ":target_gold", ":lord_no", "slot_troop_wealth"),
		(val_max, ":target_gold", 0),
		#If the lord is low on gold, first he takes enough gold so he isn't low on funds,
		#or all of the gold, whichever is less.
		(store_sub, ":gold_to_give", 6000, ":target_gold"),#6000 is the standard starting gold for lords (kings start with more, but don't increase this for them, since I'm using this number as a "low on gold" threshold)
		(val_max, ":gold_to_give", 0),
		(val_min, ":gold_to_give", ":gold_left"),
			
		(val_add, ":target_gold", ":gold_to_give"),
		(troop_set_slot, ":lord_no", "slot_troop_wealth", ":target_gold"),
		(val_sub, ":gold_left", ":gold_to_give"),
		#If gold remains, the lord gives some to any castles or towns he owns that have
		#low wealth.  Note that iterating in this order means that towns get checked
		#before castles do.
		(gt, ":gold_left", 0),
		(try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
			(party_slot_eq, ":center_no", "slot_town_lord", ":lord_no"),
			(party_get_slot, ":target_gold", ":center_no", "slot_town_wealth"),
			#Don't give gold to centers with garrisons more than 50% above the ideal size
			(store_party_size_wo_prisoners, ":garrison_size", ":center_no"),
			(call_script, "script_party_get_ideal_size", ":center_no"),#This script has been modified to support this use
			(val_mul, reg0, 3),
			(val_div, reg0, 2),
			(ge, reg0, ":garrison_size"),
			
			(try_begin),
				(party_slot_eq, ":center_no", "slot_party_type", spt_town),
				(store_sub, ":gold_to_give", 4000, ":target_gold"),#4000 is the standard starting gold for towns
			(else_try),
				(store_sub, ":gold_to_give", 2000, ":target_gold"),#2000 is the standard starting gold for castles
			(try_end),
					
			(val_max, ":gold_to_give", 0),
			(val_min, ":gold_to_give", ":gold_left"),
			(gt, ":gold_to_give", 0),
			(val_add, ":target_gold", ":gold_to_give"),
			(party_set_slot, ":center_no", "slot_town_wealth", ":target_gold"),
			(val_sub, ":gold_left", ":gold_to_give"),
		(try_end),
		#If gold is left -- the lord isn't low on gold, and none of his walled centers are --
		#he pockets the remainder.
		(gt, ":gold_left", 0),
		(troop_get_slot, ":target_gold", ":lord_no", "slot_troop_wealth"),
		(val_add, ":target_gold", ":gold_left"),
		(troop_set_slot, ":lord_no", "slot_troop_wealth", ":target_gold"),
		(assign, ":gold_left", 0),
	(try_end),
	]),

  #"script_dplmc_remove_gold_from_lord_and_holdings"
  #
  #
  #INPUT:
  #   arg1: the amount of money to remove (greater than zero)
  #   arg2: the ID of the lord spending the money
  #
  #OUTPUT:
  #   None
								("dplmc_remove_gold_from_lord_and_holdings",
							   [
								(store_script_param_1, ":gold_cost"),
								(store_script_param_2, ":lord_no"),

								(try_begin),
									(lt, ":lord_no", 0),#Invalid ID
								(else_try),
									(neq, ":lord_no", "trp_player"),
									(neg|troop_is_hero, ":lord_no"),#Not player or hero
								(else_try),
									#If the number is negative, give gold instead of taking it.
									#Handle this using script_dplmc_distribute_gold_to_lord_and_holdings
									(lt, ":gold_cost", 0),
									(val_mul, ":gold_cost", -1),
									(call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", ":gold_cost", ":lord_no"),
									(assign, ":gold_cost", 0),
								(else_try),
									#For the player, first subtract the gold from his treasury (if any).
									(eq, ":lord_no", "trp_player"),
									(store_troop_gold, ":treasury", "trp_household_possessions"),
									(try_begin),
										(ge, ":treasury", 1),
										(val_min, ":treasury", ":gold_cost"),
										(call_script, "script_dplmc_withdraw_from_treasury", ":treasury"),
										(val_sub, ":gold_cost", ":treasury"),
									(try_end),
									(store_troop_gold, ":treasury", "trp_player"),
									(try_begin),
										(ge, ":treasury", 1),
										(val_min, ":treasury", ":gold_cost"),
										(troop_remove_gold, "trp_player", ":treasury"),
										(val_sub, ":gold_cost", ":treasury"),
									(try_end),
									#Fall through to the next section if the treasury didn't cover it.
									(lt, ":gold_cost", 1),
								(else_try),
									#Remove the gold directly from the lord's wealth slot
									(ge, ":gold_cost", 1),
									(ge, ":lord_no", 1),#not the player
									(troop_get_slot, ":treasure", ":lord_no", "slot_troop_wealth"),
									(ge, ":treasure", 1),
									(try_begin),
										(ge, ":treasure", ":gold_cost"),
										(val_sub, ":treasure", ":gold_cost"),
										(assign, ":gold_cost", 0),
									(else_try),
										(val_sub, ":gold_cost", ":treasure"),
										(assign, ":treasure", 0),
									(try_end),
									(troop_set_slot, ":lord_no", "slot_troop_wealth", ":treasure"),
									#Fall through to the next section if his personal wealth didn't cover it.
									(lt, ":gold_cost", 1),
								(else_try),
									#Remove remaining gold from uncollected taxes.
									#We iterate backwards in order to remove from villages before castles and towns.
									(ge, ":gold_cost", 1),
									(try_for_range_backwards, ":center_no", centers_begin, centers_end),
										(ge, ":gold_cost", 1),
										(party_slot_eq, ":center_no", "slot_town_lord", ":lord_no"),
										(party_get_slot, ":treasure", ":center_no", "slot_center_accumulated_rents"),
										(try_begin),
											(gt, ":treasure", 0),
											(ge, ":treasure", ":gold_cost"),
											(val_sub, ":treasure", ":gold_cost"),
											(assign, ":gold_cost", 0),
										(else_try),
											(gt, ":treasure", 0),
											(val_sub, ":gold_cost", ":treasure"),
											(assign, ":treasure", 0),
										(try_end),
										(party_set_slot, ":center_no", "slot_center_accumulated_rents", ":treasure"),

										(ge, ":gold_cost", 1),
										(party_get_slot, ":treasure", ":center_no", "slot_center_accumulated_tariffs"),
										(try_begin),
											(gt, ":treasure", 0),
											(ge, ":treasure", ":gold_cost"),
											(val_sub, ":treasure", ":gold_cost"),
											(assign, ":gold_cost", 0),
										(else_try),
											(gt, ":treasure", 0),
											(val_sub, ":gold_cost", ":treasure"),
											(assign, ":treasure", 0),
										(try_end),
										(party_set_slot, ":center_no", "slot_center_accumulated_tariffs", ":treasure"),
									(try_end),
									#Fall through to the next section if the uncollected taxes didn't cover it.
									(lt, ":gold_cost", 1),
								(else_try),
									#Remove remaining gold from center wealth.  We iterate backwards to remove from
									#castles before towns.
									(ge, ":gold_cost", 1),
									(try_for_range_backwards, ":center_no", centers_begin, centers_end),
										(ge, ":gold_cost", 1),
										(party_slot_eq, ":center_no", "slot_town_lord", ":lord_no"),
										(party_get_slot, ":treasure", ":center_no", "slot_town_wealth"),
										(ge, ":treasure", 1),
										(try_begin),
											(ge, ":treasure", ":gold_cost"),
											(val_sub, ":treasure", ":gold_cost"),
											(assign, ":gold_cost", 0),
										(else_try),
											(val_sub, ":gold_cost", ":treasure"),
											(assign, ":treasure", 0),
										(try_end),
										(party_set_slot, ":center_no", "slot_town_wealth", ":treasure"),
									(try_end),
									(lt, ":gold_cost", 1),
								(else_try),
									#Try to remove the gold from the hero himself
									(store_troop_gold, ":treasure", ":lord_no"),
									(gt, ":treasure", 0),
									(try_begin),
										(ge, ":treasure", ":gold_cost"),
										(troop_remove_gold, ":lord_no", ":gold_cost"),
										(assign, ":gold_cost", 0),
									(else_try),
										(troop_remove_gold, ":lord_no", ":treasure"), #Floris - bugfix for Diplomacy, was missing lord argument
										(val_sub, ":gold_cost", ":treasure"),
									(try_end),
								(try_end),

							   ]),

  
 # script_dplmc_get_trade_penalty
  #
  #This is similar to the old script_get_trade_penalty,
  #except it uses parameters instead of relying on global variables.
  #
  # Input:
  # param1: item_kind_id
  # param2: market center
  # param3: customer troop (-1 for a non-troop-specific answer, -2 to notify the script that this is being used to evaluate a gift)
  # param4: merchant troop (-1 for a non-troop-specific answer)
  # Output: reg0

  ("dplmc_get_trade_penalty",
    [
	  #Additions begin:
     (store_script_param, ":item_kind_id", 1),
	  (store_script_param, ":market_center", 2),
	  (store_script_param, ":customer_troop", 3),
	  (store_script_param, ":merchant_troop", 4),
	  #End Additions
      (assign, ":penalty",0),

	  ##Change this to support alternative customers
      ##(party_get_skill_level, ":trade_skill", "p_main_party", skl_trade),
	  (try_begin),
		 #Player: use skill of player party
	    (eq, ":customer_troop", "trp_player"),
		 (party_get_skill_level, ":trade_skill", "p_main_party", skl_trade),
	  (else_try),
		 #Hero leading a party: use skill of led party
	    (gt, ":customer_troop", -1),
	    (troop_is_hero, ":customer_troop"),
		 (troop_get_slot, ":customer_party", ":customer_troop", "slot_troop_leaded_party"),
		 (gt, ":customer_party", 0),
		 (party_is_active, ":customer_party"),
		 (party_get_skill_level, ":trade_skill", ":customer_party", skl_trade),
	  (else_try),
		 #Troop: use troop skill
		 (gt, ":customer_troop", -1),
		 (store_skill_level, ":trade_skill", ":customer_troop"),
	  (else_try),
		 (assign, ":trade_skill", 0),
	  (try_end),
	  ##End Change
      (try_begin),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (assign, ":penalty", 21), #reduced slightly 20-15-12           MOTO chief #affect more with merchant skill#gdw23
                (store_mul, ":skill_bonus", ":trade_skill", 2),    #MOTO        #affect more with merchant skill, increase from 1
     (else_try),
        (assign, ":penalty",73),    #MOTO chief make non-trade items        more #tradeable, reduce from 100#gdw80
     (store_mul, ":skill_bonus", ":trade_skill", 5),
        (val_sub, ":penalty", ":skill_bonus"),
      (try_end),

      (assign, ":penalty_multiplier", average_price_factor),#<-- replaced 1000 with average_price_factor
##       # Apply penalty if player is hostile to merchants faction
##      (store_relation, ":merchants_reln", "fac_merchants", "fac_player_supporters_faction"),
##      (try_begin),
##        (lt, ":merchants_reln", 0),
##        (store_sub, ":merchants_reln_dif", 10, ":merchants_reln"),
##        (store_mul, ":merchants_relation_penalty", ":merchants_reln_dif", 20),
##        (val_add, ":penalty_multiplier", ":merchants_relation_penalty"),
##      (try_end),

       # Apply penalty if player is on bad terms with the town
      (try_begin),
		(eq, ":customer_troop", "trp_player"),#added
        (is_between, ":market_center", centers_begin, centers_end),#changed $g_encountered_party to :market_center
        (party_get_slot, ":center_relation", ":market_center", "slot_center_player_relation"),#changed $g_encountered_party to :market_center
        (store_mul, ":center_relation_penalty", ":center_relation", -3),
        (val_add, ":penalty_multiplier", ":center_relation_penalty"),
        (try_begin),
          (lt, ":center_relation", 0),
          (store_sub, ":center_penalty_multiplier", 100, ":center_relation"),
          (val_mul, ":penalty_multiplier", ":center_penalty_multiplier"),
          (val_div, ":penalty_multiplier", 100),
        (try_end),
      (try_end),

       # Apply penalty if player is on bad terms with the merchant (not currently used)
	   ##Begin Change
      #(call_script, "script_troop_get_player_relation", "$g_talk_troop"),
      #(assign, ":troop_reln", reg0),
	  (try_begin),
		 (this_or_next|eq, ":merchant_troop", "trp_player"),
			(eq, ":customer_troop", "trp_player"),
		 (gt, ":merchant_troop", -1),
		 (gt, ":customer_troop", -1),
		 (call_script, "script_troop_get_player_relation", ":merchant_troop"),
		 (assign, ":troop_reln", reg0),
	  (else_try),
	    (is_between, ":merchant_troop", heroes_begin, heroes_end),
		 (is_between, ":customer_troop", heroes_begin, heroes_end),		 
		 (call_script, "script_troop_get_relation_with_troop", ":merchant_troop", ":customer_troop"),
		 (assign, ":troop_reln", reg0),
	  (else_try),
	     (assign, ":troop_reln", 0),
	  (try_end),
	  ##End Change
      #(troop_get_slot, ":troop_reln", "$g_talk_troop", "slot_troop_player_relation"),
      (try_begin),
        (lt, ":troop_reln", 0),
        (store_sub, ":troop_reln_dif", 0, ":troop_reln"),
        (store_mul, ":troop_relation_penalty", ":troop_reln_dif", 20),
        (val_add, ":penalty_multiplier", ":troop_relation_penalty"),
      (try_end),


	  (try_begin),
		##Begin Change
		#(is_between, "$g_encountered_party", villages_begin, villages_end),
		(is_between, ":market_center", centers_begin, centers_end),
		(party_slot_eq, ":market_center", "slot_party_type", spt_village),
		##End Change
	    (val_mul, ":penalty", 2),
	  (try_end),

	  (try_begin),
        (is_between, ":market_center", centers_begin, centers_end),#changed $g_encountered_party to :market_center
	    #Double trade penalty if no local production or consumption
	    (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
		##Begin Change
		#(OPTIONAL CHANGE: Do not apply this to food)
		(this_or_next|eq, ":customer_troop", -2),
        (this_or_next|lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		   (neg|is_between, ":item_kind_id", food_begin, food_end),
		   
		(assign, ":save_reg1", reg1),
		(assign, ":save_reg2", reg2),
		##End Change
	    (call_script, "script_center_get_production", ":market_center", ":item_kind_id"),#changed $g_encountered_party to :market_center
	    (eq, reg0, 0),
	    (call_script, "script_center_get_consumption", ":market_center", ":item_kind_id"),#changed $g_encountered_party to :market_center
	    (eq, reg0, 0),
	    (val_mul, ":penalty", 2),
		##Begin Change
		(assign, reg1, ":save_reg1"),
		(assign, reg2, ":save_reg2"),
		##End Change
	  (try_end),

      (val_mul, ":penalty",  ":penalty_multiplier"),
	  ##Begin Change
	  (val_add, ":penalty", average_price_factor // 2),#round in the correct direction (we don't need to worry about penalty < 0)
      (val_div, ":penalty", average_price_factor),#replace the hardcoded constant 1000 with average_price_factor
	  ##End Change
      (val_max, ":penalty", 1),
      (assign, reg0, ":penalty"),
  ]),


  ##diplomacy chief end
#bounty chief
    ("random_bounty",
    [
      (store_script_param_1, ":giver_troop"),
     
      (store_troop_faction, ":giver_faction_no", ":giver_troop"),
     
      (troop_get_slot, ":giver_party_no", ":giver_troop", "slot_troop_leaded_party"),
     
      (assign, ":giver_center_no", -1),
      (try_begin),
        (gt, ":giver_party_no", 0),
        (party_get_attached_to, ":giver_center_no", ":giver_party_no"),
      (else_try),
        (is_between, "$g_encountered_party", centers_begin, centers_end),
        (assign, ":giver_center_no", "$g_encountered_party"),
      (try_end),

     (try_begin),
       (eq, ":giver_faction_no", "fac_commoners"),
      (store_faction_of_party, ":giver_faction_no", ":giver_center_no"),
     (try_end),
     
      (assign, ":result", -1),
      (try_for_range, ":unused", 0, 20), #Repeat trial twenty times
        (eq, ":result", -1),
        (assign, ":quest_target_troop", -1),
        (assign, ":quest_target_center", -1),
        (assign, ":quest_target_faction", -1),
        (assign, ":quest_object_faction", -1),
        (assign, ":quest_object_troop", -1),
        (assign, ":quest_object_center", -1),
        (assign, ":quest_target_party", -1),
        (assign, ":quest_target_party_template", -1),
        (assign, ":quest_target_amount", -1),
        (assign, ":quest_target_dna", -1),
        (assign, ":quest_target_item", -1),
        (assign, ":quest_importance", 1),
        (assign, ":quest_xp_reward", 0),
        (assign, ":quest_gold_reward", 0),
        (assign, ":quest_convince_value", 0),
        (assign, ":quest_expiration_days", 0),
        (assign, ":quest_dont_give_again_period", 0),

      (store_random_in_range, ":quest_no", bounties_begin, bounties_end),
        (neg|check_quest_active,":quest_no"),
        (neg|quest_slot_ge, ":quest_no", "slot_quest_dont_give_again_remaining_days", 1),
      (try_begin),
          (eq, ":quest_no", "qst_bounty_1"),
          (try_begin),
            (ge, "$g_talk_troop_faction_relation", 0),
            (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
            (assign, ":quest_target_center", reg0),
            (store_random_in_range, ":quest_target_dna", 0, 1000000),
            (assign, ":result", ":quest_no"),
            (assign, ":quest_expiration_days", 17),
            (assign, ":quest_dont_give_again_period", 7),
          (try_end),
      (else_try),
          (eq, ":quest_no", "qst_bounty_2"),
          (try_begin),
            (ge, "$g_talk_troop_faction_relation", 0),
            (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
            (assign, ":quest_target_center", reg0),
            (store_random_in_range, ":quest_target_dna", 0, 1000000),
            (assign, ":result", ":quest_no"),
            (assign, ":quest_expiration_days", 17),
            (assign, ":quest_dont_give_again_period", 7),
          (try_end),
      (else_try),
          (eq, ":quest_no", "qst_bounty_3"),
          (try_begin),
            (ge, "$g_talk_troop_faction_relation", 0),
            (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
            (assign, ":quest_target_center", reg0),
            (store_random_in_range, ":quest_target_dna", 0, 1000000),
            (assign, ":result", ":quest_no"),
            (assign, ":quest_expiration_days", 17),
            (assign, ":quest_dont_give_again_period", 7),
          (try_end),
      (else_try),
          (eq, ":quest_no", "qst_bounty_4"),
          (try_begin),
            (ge, "$g_talk_troop_faction_relation", 0),
            (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
            (assign, ":quest_target_center", reg0),
            (store_random_in_range, ":quest_target_dna", 0, 1000000),
            (assign, ":result", ":quest_no"),
            (assign, ":quest_expiration_days", 17),
            (assign, ":quest_dont_give_again_period", 7),
          (try_end),
      (else_try),
          (eq, ":quest_no", "qst_bounty_5"),
          (try_begin),
            (ge, "$g_talk_troop_faction_relation", 0),
            (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
            (assign, ":quest_target_center", reg0),
            (store_random_in_range, ":quest_target_dna", 0, 1000000),
            (assign, ":result", ":quest_no"),
            (assign, ":quest_expiration_days", 17),
            (assign, ":quest_dont_give_again_period", 7),
          (try_end),
      (else_try),
          (eq, ":quest_no", "qst_bounty_6"),
          (try_begin),
            (ge, "$g_talk_troop_faction_relation", 0),
            (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
            (assign, ":quest_target_center", reg0),
            (store_random_in_range, ":quest_target_dna", 0, 1000000),
            (assign, ":result", ":quest_no"),
            (assign, ":quest_expiration_days", 17),
            (assign, ":quest_dont_give_again_period", 7),
          (try_end),
      (try_end),
      (try_end),
      (try_begin),
        (neq, ":result", -1),
       
        (try_begin),
          (ge, ":quest_target_center", 0),
          (store_faction_of_party, ":quest_target_faction", ":quest_target_center"),
        (try_end),
       
        (quest_set_slot, ":result", "slot_quest_target_troop", ":quest_target_troop"),
        (quest_set_slot, ":result", "slot_quest_target_center", ":quest_target_center"),
        (quest_set_slot, ":result", "slot_quest_object_troop", ":quest_object_troop"),
        (quest_set_slot, ":result", "slot_quest_target_faction", ":quest_target_faction"),
        (quest_set_slot, ":result", "slot_quest_object_faction", ":quest_object_faction"),
        (quest_set_slot, ":result", "slot_quest_object_center", ":quest_object_center"),
        (quest_set_slot, ":result", "slot_quest_target_party", ":quest_target_party"),
        (quest_set_slot, ":result", "slot_quest_target_party_template", ":quest_target_party_template"),
        (quest_set_slot, ":result", "slot_quest_target_amount", ":quest_target_amount"),
        (quest_set_slot, ":result", "slot_quest_importance", ":quest_importance"),
        (quest_set_slot, ":result", "slot_quest_xp_reward", ":quest_xp_reward"),
        (quest_set_slot, ":result", "slot_quest_gold_reward", ":quest_gold_reward"),
        (quest_set_slot, ":result", "slot_quest_convince_value", ":quest_convince_value"),
        (quest_set_slot, ":result", "slot_quest_expiration_days", ":quest_expiration_days"),
        (quest_set_slot, ":result", "slot_quest_dont_give_again_period", ":quest_dont_give_again_period"),
        (quest_set_slot, ":result", "slot_quest_current_state", 0),
        (quest_set_slot, ":result", "slot_quest_giver_troop", ":giver_troop"),
        (quest_set_slot, ":result", "slot_quest_giver_center", ":giver_center_no"),
        (quest_set_slot, ":result", "slot_quest_target_dna", ":quest_target_dna"),
        (quest_set_slot, ":result", "slot_quest_target_item", ":quest_target_item"),
      (try_end),
     
      (assign, reg0, ":result"),
  ]),
  #bounty chief acaba
#TEMPERED chief gordo empieza
 #Tempered   chief     ###################  DEPLOY SKIRMISHERS  #################################
 
 ("deploy_skirmishers",
	[
	(store_script_param,"$skirmish_size",1),
	(set_spawn_radius,0),
	(spawn_around_party,"p_main_party","pt_skirmish_party"),
	(assign,"$skirmish_party_no",reg(0)),
	(party_remove_members,"p_main_party","trp_merc_spy","$skirmish_size"),
	(party_add_members,"$skirmish_party_no","trp_merc_spy","$skirmish_size"),
	(party_set_faction,"$skirmish_party_no","fac_neutral"),
	(party_set_ai_behavior, "$skirmish_party_no", ai_bhvr_attack_party),
	(party_set_ai_object,"$skirmish_party_no","$skirmish_target"),
	(party_set_morale,"$skirmish_party_no",100),
	(party_set_name,"$skirmish_party_no" ,"str_skirmisher_name"),
	(party_set_slot,"$skirmish_party_no","slot_party_hired",-1),
	]),

 #Tempered   chief  ###############################    POISON WELL SABOTAGE  ##################################################
  ("poison_well",
	[ (store_script_param_1, ":party_no"),
	  (party_get_num_companion_stacks, ":num_stacks",":party_no"),
	  (party_get_slot,":party_type",":party_no","slot_party_type"),
	  (assign,":max_no",80),
	  (assign,":start_troop",0),
		(try_begin),
			(eq,":party_type",2),
			(assign,":max_no",50),
			(call_script, "script_change_center_prosperity", ":party_no", -3),
		(else_try),
			(eq,":party_type",3),
			(assign,":max_no",30),
			(call_script, "script_change_center_prosperity", ":party_no", -3),
		(else_try),
			(eq,":party_type",4),
			(assign,":max_no",60),
			(call_script, "script_change_center_prosperity", ":party_no", -3),
		(else_try),
			(eq,":party_type",spt_kingdom_hero_party),
			(assign,":start_troop",1),
			(party_stack_get_troop_id,":leader",":party_no",0),
			(troop_raise_attribute, ":leader",ca_strength, -1),
			(troop_raise_attribute, ":leader",ca_agility, -1),
			(troop_raise_skill, ":leader", skl_ironflesh, -1),
		(try_end),
		(try_for_range, ":stack_no", ":start_troop", ":num_stacks"),
			(party_stack_get_troop_id,":cur_troop_id",":party_no",":stack_no"),
			(party_stack_get_size,":num_troops",":party_no",":stack_no"),
			(val_mul,":num_troops",100),
			(store_random_in_range,":wound_percent",10,":max_no"),
			(val_add,":wound_percent",100),
			(store_div,":damage",":num_troops",":wound_percent"),
			(party_wound_members,":party_no",":cur_troop_id",":damage"),
		(try_end),		
	]),
	
 #Tempered                                        ###############################   POISON FOOD/CATTLE SABOTAGE ######################################
  ("poison_food",
	[(store_script_param, ":party_no", 1),
	 (party_get_slot,":party_type",":party_no","slot_party_type"),
		(try_begin),
			(le,":party_type",3),
			(party_get_slot,":cur_food",":party_no","slot_party_food_store"),
			(store_random_in_range,":spoilage",70,90),
			(val_mul,":cur_food",100),
			(val_add,":spoilage",100),
			(val_div,":cur_food",":spoilage"),
			(party_set_slot,":party_no","slot_party_food_store",":cur_food"),
			(call_script, "script_change_center_prosperity", ":party_no", -5),
		(else_try),
			(eq,":party_type",4),			
			(party_get_slot,":cur_cattle",":party_no","slot_village_number_of_cattle"),
			(try_begin),
				(ge,":cur_cattle",8),
				(store_random_in_range,":killed",60,90),
				(val_mul,":cur_cattle",100),
				(val_add,":killed",100),
				(val_div,":cur_cattle",":killed"),
				(party_set_slot,":party_no","slot_village_number_of_cattle",":cur_cattle"),
				(call_script, "script_change_center_prosperity", ":party_no", -5),
			(else_try),
				(le,":cur_cattle",7),
				(party_set_slot,":party_no","slot_village_number_of_cattle",0),
				(call_script, "script_change_center_prosperity", ":party_no", -5),
			(try_end),
		(try_end),
	]),

#Tempered       chief    ##################################  CAUSE DISSENT AND UNREST SABOTAGE  ###########################################
  ("unrest_sabotage",
	[(store_script_param, ":party_no", 1),
	 (party_get_slot,":party_type",":party_no","slot_party_type"),
		(try_begin),
			(eq,":party_type",3), #town
			(party_get_slot,":cur_food",":party_no","slot_party_food_store"),
			(party_set_slot,":party_no", "slot_center_has_bandits","trp_rioter"),
			(store_random_in_range,":spoilage",10,30),
			(val_mul,":cur_food",100),
			(val_add,":spoilage",100),
			(val_div,":cur_food",":spoilage"),
			(party_set_slot,":party_no","slot_party_food_store",":cur_food"),
			(call_script, "script_change_center_prosperity", ":party_no", -5),
		(else_try),
			(eq,":party_type",4), #village	
			(party_set_slot,":party_no", "slot_village_infested_by_bandits","trp_rioter"),
			(party_get_slot,":cur_cattle",":party_no","slot_village_number_of_cattle"),
			(try_begin),
				(ge,":cur_cattle",4),
				(store_random_in_range,":killed",60,90),
				(val_mul,":cur_cattle",100),
				(val_add,":killed",100),
				(val_div,":cur_cattle",":killed"),
				(party_set_slot,":party_no","slot_village_number_of_cattle",":cur_cattle"),
				(call_script, "script_change_center_prosperity", ":party_no", -5),
			(else_try),
				(le,":cur_cattle",3),
				(party_set_slot,":party_no","slot_village_number_of_cattle",0),
				(call_script, "script_change_center_prosperity", ":party_no", -5),
			(try_end),
		(try_end),
	]),

#Tempered        ################################   SPY REPORT BUILD STRINGS  ###################################################

  ("spy_report_info",
	[(store_script_param, ":cur_center", 1),
	 (party_get_slot,":spy_days",":cur_center","slot_spy_in_town"),
	 (store_current_hours,":cur_hour"),
	 (store_sub,":total_time",":cur_hour",":spy_days"),
	 (try_begin),
		(eq,":total_time",":cur_hour"),
		(assign,":total_time",0),
	 (try_end),
	 (store_div,":days",":total_time",24),
	 (party_get_slot,":center_type",":cur_center","slot_party_type"),
	 (party_get_slot,":sabotage",":cur_center","slot_spy_sabotage"),
	 (call_script,"script_get_prosperity_for_spy_report",":cur_center"),
	 (party_get_slot,":town_lord",":cur_center","slot_town_lord"),
        (try_begin),
                  (ge, ":town_lord", 0),
                  (str_store_troop_name,s21,":town_lord"),     
            (ge,":total_time",25),
         (str_clear,s3),
			(str_clear,s5),
			(str_clear,s7),
			(str_clear,s8),
				(try_begin),
					(eq,":center_type",4),
					(party_get_slot,":cur_village_state",":cur_center","slot_village_state"),
					(party_get_slot,reg4,":cur_center","slot_village_number_of_cattle"),
					(str_store_string,s3,"@."),
					(try_begin),
						(eq,":cur_village_state",0),
							(try_begin),
								(ge,reg4,2),
								(str_store_string,s5,"@^The village has a herd of {reg4} cattle.^"),
							(else_try),
								(eq,reg4,1),
								(str_store_string,s5,"@^The village has {reg4} sickly cow.^"),
							(else_try),
								(le,reg4,0),
								(str_store_string,s5,"@^The poor villagers have no cattle.^"),
							(try_end),
					(else_try),
						(eq,":cur_village_state",1),
						(str_store_string,s5,"@^I write this from a nearby hill, as the village is currently being raided."),
					(else_try),
						(ge,":cur_village_state",2),
						(str_store_string,s5,"@^The village has been burnt to the ground ^and the inhabitants scattered. There is no reason^for me to remain here, my lord."),
					(try_end),
				(else_try),
					(le,":center_type",3),
					(party_get_slot, ":center_food_store", ":cur_center", "slot_party_food_store"),
					(call_script, "script_center_get_food_consumption", ":cur_center"),
					(assign, ":food_consumption", reg0),
					(store_div, reg7, ":center_food_store", ":food_consumption"),
					(str_store_string,s3,"@^and food for {reg7} days."),
					(str_store_string,s5,"@^"),
					(assign,":hero_prisoners",0), #Tempered start hero prisoner notes	
					(party_get_num_prisoner_stacks, ":num_prisoner_stacks",":cur_center"), 
						(try_for_range, ":stack_no", 0, ":num_prisoner_stacks"),
							(party_prisoner_stack_get_troop_id, ":stack_troop",":cur_center",":stack_no"),
							(is_between,":stack_troop",companions_begin,kingdom_heroes_end),
							(val_add,":hero_prisoners",1),
							(str_store_troop_name,s6,":stack_troop"),
							(str_store_string,s7,"@{s7} {s6},"),
						(try_end),
						(try_begin),
							(ge,":hero_prisoners",1),
							(str_store_string,s8,"@The following lords are held prisoner here:^{s7}"),
						(else_try),
							(eq,":hero_prisoners",0),
							(str_store_string,s8,"@I am aware of no lords being held prisoner here."),
						(try_end),
				(try_end),
			(try_begin),
				(eq,":center_type",2),
				(str_store_string, s12, "@The drink in {s21}'s drafty castle is good enough,^though the company leaves much to be desired.^The guard is ever watchful and I fear they suspect me."),
			(try_end),
			(try_begin),
				(ge,":sabotage",1),
				(str_store_string,s13,"@^Tonight I shall take care of that business we had discussed earlier."),
			(else_try),
				(eq,":sabotage",0),
				(str_store_string,s13,"@^I am awaiting further orders, my lord."),
			(try_end),
			(party_collect_attachments_to_party, ":cur_center", "p_collective_ally"),
			(party_get_num_companions, reg6, "p_collective_ally"),
			(assign,reg5,":days"),
			(try_begin),
				(eq,":days",1),
				(str_store_string,s10,"@ day."),
			(else_try),
				(ge,":days",2),
				(str_store_string,s10,"@ days."),
			(try_end),
			(str_store_party_name,s4,":cur_center"),
			(str_store_string,s2,"@My lord, I have been in {s4} for {reg5}{s10}^{s12}^I have discovered that {s4} has {reg6} defenders{s3}{s5}{s8}{s13}"),
		(else_try),
			(le,":total_time",23),
			(str_store_party_name,s4,":cur_center"),
			(str_store_string,s2,"@My lord, I have been in {s4} for less than a day.^Have patience as I am still gathering information."),
		(try_end),			
	]),

#Tempered    chief          #############################   SPY TOWN PROSPERITY STRINGS  ###########################################	
  #script_get_prosperity_for_spy_report
  # INPUT: center_no
  # OUTPUT: none
  ("get_prosperity_for_spy_report",
    [(store_script_param, ":center_no", 1),
     (party_get_slot, ":prosperity", ":center_no", "slot_town_prosperity"),
     (val_div, ":prosperity", 20),
	 (party_get_slot,":town_lord",":center_no","slot_town_lord"),
     (try_begin),
               (ge, ":town_lord", 0),     
               (str_store_troop_name,s21,":town_lord"),
               (try_begin),
     (eq, ":prosperity", 0),
       (str_store_string, s12, "@I've no idea why {s21} would own such a miserable dump,^but I shall gleen what information as I can from the wretched peasants."),
     (else_try),
       (eq, ":prosperity", 1),
       (str_store_string, s12, "@{s21} should be ashamed of this dung heap.^ The inhabitants have naught but the rags on their backs.^I shall strive to survive on the piss these locals call ale."),
     (else_try),
       (eq, ":prosperity", 2),
       (str_store_string, s12, "@Not a bad place to stop for a tankard of ale.^{s21} must be a boring man, as I can find nothing^exciting about this place."),
     (else_try),
       (eq, ":prosperity", 3),
       (str_store_string, s12, "@{s21} must be quite wealthy. I believe this is the first^place you've sent me where I did not share my bed with^rats, hags, and lice."),
     (else_try),
       (str_store_string, s12, "@Wish you were here, my lord. The wenches are plump and wear^the finest silks. Wine flows from the fountains and^{s21} has paved the streets in gold."),
     (try_end),
     (try_end),
     ]),
	 
	
#TEMPERED    chief  PARTY ENTRENCH TIME

	("party_entrench_time",
		[
#			(store_current_hours,":cur_hour"),		 
			(call_script, "script_get_max_skill_of_player_party", "skl_engineer"),
			(assign, ":max_skill", reg0),
			(val_mul, ":max_skill",3),#gdw2
			(val_max,":max_skill",1),
			(party_get_num_companions,":party_size","p_main_party"),
			(val_mul,":party_size",4),#gdw3 since only counts companions?
			(val_max,":party_size",3),
			(store_mul,":man_hours",":party_size",":max_skill"),
			(store_div,":construct_time",2000,":man_hours"),		 
			(val_max,":construct_time",2),
			(val_min,":construct_time",31),#gdw32
			(assign,reg5,":construct_time"),
#			(display_message,"@_Fortifications will take {reg5} hours to complete."),
#			(store_add,"$entrench_time",":cur_hour",":construct_time"),  Tempered moved to game menu
		]
	),
  
#TEMPERED    GET NUMBER OF HORSES FOR CAMP SITE
#input: party id of camper
#output: reg0, number of horses based on mounted troops
	("count_horses",
		[	
			(assign,":horse_count",0),
			(party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
			(try_for_range,":cur_stack",0,":num_stacks"),
				(party_stack_get_troop_id,":cur_troop","p_main_party",":cur_stack"),
				(assign,":add_horses",0),
				(try_begin),					
					(troop_is_mounted,":cur_troop"),
					(party_stack_get_size,":add_horses","p_main_party",":cur_stack"),
					(val_add,":horse_count",":add_horses"),
				(try_end),
			(try_end),
			(assign,reg0,":horse_count"),
			
		]
	),

#TEMPERED  RANSACK PLAYER CAMP SITE

  ("loot_camp",
    [ (assign,":food_loss",0),
	  (assign,":horse_loss",0),
	  (store_random_in_range, ":max_horse", 0, 2),
	  (store_random_in_range, ":max_food", 1, 4),
	  (store_random_in_range, ":tool_loss", 0,500),
      (troop_get_inventory_capacity, ":inv_cap", "trp_player"),
	  (str_clear,s1),
	  (str_clear,s2),
	  (str_clear,s3),
	  (str_clear,s4),
	  (str_clear,s5),
	  (str_clear,s6),
      (try_for_range, ":i_slot", 9, ":inv_cap"), #start at 9 so no player items are looted, only inventory items.
        (troop_get_inventory_slot, ":item_id", "trp_player", ":i_slot"),
        (ge, ":item_id", 0),
        (try_begin),
          (is_between, ":item_id", food_begin,food_end),
		  (val_add, ":food_loss", 1),
		  (le,":food_loss",":max_food"),          
		  (troop_remove_item, "trp_player", ":item_id"),
		  (str_store_item_name,s1,":item_id"),
		  (str_store_string,s2,"@{s2}{s1}, "),
		  (str_store_string,s3,"@_The following food items were destroyed or looted: {s2}. "),
        (else_try),
          (is_between, ":item_id", horses_begin, horses_end),
		  (neq,":max_horse",0),
		  (val_add, ":horse_loss", 1),
		  (le,":horse_loss",":max_horse"),          
		  (str_store_string,s5,"@_A pack horse has ran off!!"),
		  (troop_remove_item, "trp_player", ":item_id"),
		(else_try),
		  (eq,":item_id","itm_tools"),
		  (le,":tool_loss",100),
		  (troop_remove_item, "trp_player", ":item_id"),
		  (str_store_string,s6,"@_Some tools have been broken or misplaced."),
        (try_end),
      (try_end),
      (store_troop_gold, ":cur_gold", "trp_player"),
      (store_div, ":max_lost", ":cur_gold", 20),
      (store_div, ":min_lost", ":cur_gold", 40),
      (store_random_in_range, ":lost_gold", ":min_lost", ":max_lost"),
      (troop_remove_gold, "trp_player", ":lost_gold"),
	  (assign,reg3,":lost_gold"),
	  (str_store_string,s4,"@ {reg3}"),
	  (dialog_box,"str_camp_loss","str_camp_overrun"),
      ]),

#Tempered                                       ########################  Remove siege camp props  ########################################################
	("siege_camp_init",
		[	(try_begin),
				(this_or_next|party_slot_eq,"p_main_party","slot_party_siege_camp",0),
				(party_slot_eq,"p_main_party","slot_party_siege_camp",-1),
				(replace_scene_props, "spr_siege_wall_a", "spr_empty"),
				(replace_scene_props, "spr_siege_large_shield_a", "spr_empty"),
				(replace_scene_props, "spr_siege_camp_spikes", "spr_empty"),
				(replace_scene_props, "spr_siege_camp_tower", "spr_empty"),
			(try_end),
		]),
#Tempered                                   ##########################  Remove siege camp for visit #####################################################
	("siege_camp_remove",
		[	
			(replace_scene_props, "spr_siege_wall_a", "spr_empty"),
			(replace_scene_props, "spr_siege_large_shield_a", "spr_empty"),
			(replace_scene_props, "spr_siege_camp_spikes", "spr_empty"),
			(replace_scene_props, "spr_bell_tent", "spr_empty"),
			(replace_scene_props, "spr_bell_tent_inventory", "spr_empty"),
			(replace_scene_props, "spr_arena_sign", "spr_empty"),
			(replace_scene_props, "spr_siege_camp_tower", "spr_empty"),
			(replace_scene_props, "spr_siege_camp_bridge", "spr_empty"),
		]),

#Tempered populate entrenchment scene

  ("visit_camp",
    [	(party_get_current_terrain, ":terrain_type", "p_main_party"),
		(party_get_slot,":entrench","p_main_party","slot_party_entrenched"),		
		(assign, ":scene_to_use", "scn_not_entrenched_steppe"),
		(try_begin),
			(this_or_next|eq,":entrench",1),#entrenched camp
			(party_slot_eq,"p_main_party","slot_party_siege_camp",1),#entrenched siege camp
			(try_begin),
				(eq, ":terrain_type", rt_steppe),
				(assign, ":scene_to_use", "scn_entrenched_steppe"),
			(else_try),
				(eq, ":terrain_type", rt_plain),
				(assign, ":scene_to_use", "scn_entrenched_plain"),
			(else_try),
				(eq, ":terrain_type", rt_snow),
				(assign, ":scene_to_use", "scn_entrenched_snow"),
			(else_try),
				(eq, ":terrain_type", rt_desert),
				(assign, ":scene_to_use", "scn_entrenched_desert"),
			(else_try),
				(eq, ":terrain_type", rt_steppe_forest),
				(assign, ":scene_to_use", "scn_entrenched_steppe_forest"),
			(else_try),
				(eq, ":terrain_type", rt_forest),
				(assign, ":scene_to_use", "scn_entrenched_plain_forest"),
			(else_try),
				(eq, ":terrain_type", rt_snow_forest),
				(assign, ":scene_to_use", "scn_entrenched_snow_forest"),
			(else_try),
				(eq, ":terrain_type", rt_desert_forest),
				(assign, ":scene_to_use", "scn_entrenched_desert_forest"),
			(else_try),
				(assign, ":scene_to_use", "scn_entrenched_plain"),
			(try_end),			
		(else_try),
			(eq,"$g_camp_mode", 1),#camping
			(neq,":entrench",1),#not entrenched
			(set_jump_mission,"mt_entrenched_encounter"),
			(assign,"$camp_supply",1), #Tempered  reset camp supplies before a battle
			(try_begin),
				(eq, ":terrain_type", rt_steppe),
				(assign, ":scene_to_use", "scn_not_entrenched_steppe"),
			(else_try),
				(eq, ":terrain_type", rt_plain),
				(assign, ":scene_to_use", "scn_not_entrenched_plain"),
			(else_try),
				(eq, ":terrain_type", rt_snow),
				(assign, ":scene_to_use", "scn_not_entrenched_snow"),
			(else_try),
				(eq, ":terrain_type", rt_desert),
				(assign, ":scene_to_use", "scn_not_entrenched_desert"),
			(else_try),
				(eq, ":terrain_type", rt_steppe_forest),
				(assign, ":scene_to_use", "scn_not_entrenched_steppe_forest"),
			(else_try),
				(eq, ":terrain_type", rt_forest),
				(assign, ":scene_to_use", "scn_not_entrenched_plain_forest"),
			(else_try),
				(eq, ":terrain_type", rt_snow_forest),
				(assign, ":scene_to_use", "scn_not_entrenched_snow_forest"),
			(else_try),
				(eq, ":terrain_type", rt_desert_forest),
				(assign, ":scene_to_use", "scn_not_entrenched_desert_forest"),
			(else_try),
				(assign, ":scene_to_use", "scn_not_entrenched_plain"),
			(try_end),
		(try_end),
		(modify_visitors_at_site, ":scene_to_use"),
        (reset_visitors),
#        (assign, "$talk_context", tc_camp),
		(assign,":count",15),
		(try_for_range,":current_npc",companions_begin,companions_end),
			(try_begin),
				(main_party_has_troop,":current_npc"),
				(set_visitor,":count",":current_npc"),
			(try_end),
			(val_add,":count",1),
		(try_end),
        (set_jump_mission,"mt_visit_entrenchment"),
        (set_jump_entry, 11),
        (jump_to_scene, ":scene_to_use"),
        (change_screen_mission),

  ]),

  #TEMPERED  script_personal_messenger
#immediate consequences of message
#input personal messenger party id
# s6,s7,s9,reg12
#called from trigger after messenger has reached the target party
  ("personal_messenger",
    [	(store_script_param_1, ":messenger_party_no"),
		(party_get_slot,"$target",":messenger_party_no","slot_message_target"),
		(party_get_slot,"$target_2",":messenger_party_no","slot_message_target_2"),
		(party_get_slot,":message",":messenger_party_no","slot_message_content"),
		(party_get_slot, ":ai_state","$target", "slot_party_ai_state"),
		(str_store_party_name,s6,"$target"),
		(store_current_hours,":cur_hour"),
		(party_stack_get_troop_id, ":leader", "$target", 0),
		(str_store_troop_name,s7,":leader"),
		(store_troop_gold,":cur_wealth","trp_player"),
		(try_begin),
			(gt,"$target_2",0),
			(str_store_party_name,s9,"$target_2"),
		(try_end),
		(assign,"$unable_to_duel",-1),
		(assign,"$unable_to_pay",-1),
		(assign,":check_bit",0),
		(assign,":bit",1),
		(try_for_range,":unused",1,10),
			(store_and,":check_bit",":bit",":message"),
			(try_begin),
				(eq,":bit",1),#choice 1 insult  
				(gt,":check_bit",0),					
				(call_script, "script_change_player_relation_with_troop", ":leader", -3),
				(call_script,"script_describe_player_relations","$target"),
				(try_begin),
					(lt, "$fac_relations",0),
					(party_get_attached_to, ":attached_to_party", "$target"),
					(try_begin),
						(is_between, ":attached_to_party", centers_begin, centers_end),
						(party_detach, "$target"),
					(try_end),
					(party_set_ai_behavior,"$target",ai_bhvr_attack_party),
					(party_set_ai_object,"$target","p_main_party"),
					(party_set_slot, "$target", "slot_party_commander_party", -1),
				(else_try),
					(ge, "$fac_relations",0),					
					(store_add,":end_hour",":cur_hour",24),					
					(troop_set_slot,":leader","slot_troop_duel_challenger",":end_hour"),
					(party_get_position,pos1,"$target_2"),
					(map_get_land_position_around_position,pos2,pos1,1),
					(party_get_attached_to, ":attached_to_party", "$target"),
					(try_begin),
						(is_between, ":attached_to_party", centers_begin, centers_end),
						(party_detach, "$target"),
					(try_end),
					(party_set_ai_behavior,"$target",ai_bhvr_travel_to_point), 
					(party_set_ai_target_position,"$target",pos2),
					(party_set_ai_object, "$target", "$target_2"),
					(party_set_slot,"$target","slot_party_ai_state",spai_patrolling_around_center,"$target_2"),
					(party_set_slot,"$target","slot_party_ai_object","$target_2"),
					(party_set_slot, "$target", "slot_party_commander_party", -1),
				(try_end),
			(else_try),#todo
				(eq,":bit",2),#CHOICE 2  BRIBE TO ATTACK
				(gt,":check_bit",0),
				(gt,"$target_2",0),
				(get_party_ai_behavior,":cur_behavior","$target"),
				(store_faction_of_party, ":party_faction_2", "$target_2"),
				(store_faction_of_party, ":party_faction", "$target"),
				(party_get_slot, ":party_type","$target_2","slot_party_type"),
				(store_relation, ":reln_between_factions",":party_faction" ,":party_faction_2"),
				(call_script,"script_describe_player_relations","$target"),
				(try_begin),
					(eq,":party_type",spt_village),#do not attack neutral or friendly villages due to problem with looting
					(ge,":reln_between_factions",0),
					(val_and,":message",253),
					(party_set_slot,":messenger_party_no","slot_message_content",":message"),
					(assign,"$unable_to_duel",1),
				(else_try),
					(this_or_next|eq,":ai_state",spai_engaging_army),
					(eq,":ai_state",spai_besieging_center),
					(val_and,":message",253),
					(party_set_slot,":messenger_party_no","slot_message_content",":message"),
					(assign,"$unable_to_duel",1),
				(else_try),
					(this_or_next|eq,":cur_behavior",ai_bhvr_attack_party),
					(eq,":cur_behavior",ai_bhvr_escort_party),
					(val_and,":message",253),
					(party_set_slot,":messenger_party_no","slot_message_content",":message"),
					(assign,"$unable_to_duel",1),
				(else_try),
					(neq,":cur_behavior",ai_bhvr_attack_party),
					(neq,":cur_behavior",ai_bhvr_escort_party),
					(neq,":ai_state",spai_besieging_center),
					(neq,":ai_state",spai_engaging_army),
					(try_begin),
						(neq,":party_faction",":party_faction_2"),
						(call_script,"script_bribe_party","$target",3,"$target_2"),
						(assign,reg16,"$bribe_amount"),
						(assign,"$attack_party_question",":messenger_party_no"),
						(question_box,"str_attack_party_question"),
					(else_try),
						(eq,":party_faction",":party_faction_2"),
						(val_and,":message",253),
						(party_set_slot,":messenger_party_no","slot_message_content",":message"),
						(assign,"$unable_to_duel",1),
					(try_end),
				(try_end),
			(else_try), 
				(eq,":bit",4),#CHOICE 3 BUY SUPPLIES
				(gt,":check_bit",0),
				(party_force_add_members,"$target","trp_temp_troop",1),
				(troop_set_auto_equip,"trp_temp_troop",0),
				(troop_get_inventory_capacity,":capacity",":leader"),
				(val_sub,":capacity",10),
				(troop_sort_inventory,":leader"),
				(try_for_range,":slot",10,":capacity"),
					(troop_get_inventory_slot,":cur_item",":leader",":slot"),
					(gt,":cur_item",0),
					(item_get_type,":type",":cur_item"),
					(neq,":type",itp_type_goods),
					(troop_remove_item,":leader",":cur_item"),
					(troop_add_item,"trp_temp_troop",":cur_item"),
				(try_end),
				(jump_to_menu,"mnu_wilderness_trade"),
			(else_try),			
				(eq,":bit",8),#choice 4 challenge to duel
				(gt,":check_bit",0),
				(call_script,"script_duel_ranking",":leader"),
				(try_begin),
					(neq,":cur_behavior",ai_bhvr_attack_party),
					(neq,":cur_behavior",ai_bhvr_escort_party),
					(neq,":ai_state",spai_besieging_center),
					(neq,":ai_state",spai_engaging_army),
					(lt,"$outclassed",1),
					(store_add,":end_hour",":cur_hour",24),					
					(troop_set_slot,":leader","slot_troop_duel_challenged",":end_hour"),
					(party_get_position,pos1,"$target_2"),
					(map_get_land_position_around_position,pos2,pos1,1),
					(party_get_attached_to, ":attached_to_party", "$target"),
					(try_begin),
						(is_between, ":attached_to_party", centers_begin, centers_end),
						(party_detach, "$target"),
					(try_end),
					(party_set_ai_behavior,"$target",ai_bhvr_travel_to_point), 
					(party_set_ai_target_position,"$target",pos2),
					(party_set_ai_object, "$target", "$target_2"),
					(party_set_slot,"$target","slot_party_ai_state",spai_patrolling_around_center),
					(party_set_slot,"$target","slot_party_ai_object","$target_2"),
				(else_try),
					(lt,"$outclassed",1),
					(val_and,":message",247),
					(party_set_slot,":messenger_party_no","slot_message_content",":message"),
					(assign,"$unable_to_duel",1),
				(try_end),
			(else_try),		
				(eq,":bit",16),#choice 5 gift of wine
				(gt,":check_bit",0),					
			(else_try),		
				(eq,":bit",32),#choice 6 gift of poison wine
				(gt,":check_bit",0),
			(else_try),	
				(eq,":bit",64),#choice 7 hire to follow
				(gt,":check_bit",0),
				(call_script,"script_bribe_party","$target",2,-1),
				(try_begin),
					(neq,":cur_behavior",ai_bhvr_attack_party),
					(neq,":cur_behavior",ai_bhvr_escort_party),
					(neq,":ai_state",spai_besieging_center),
					(neq,":ai_state",spai_engaging_army),
					(ge,":cur_wealth","$bribe_amount"),
					(troop_remove_gold,"trp_player","$bribe_amount"),
					(troop_add_gold,":leader","$bribe_amount"),
					(party_get_attached_to, ":attached_to_party", "$target"),
					(try_begin),
						(is_between, ":attached_to_party", centers_begin, centers_end),
						(party_detach, "$target"),
					(try_end),
					(party_set_slot, "$target", "slot_party_commander_party","p_main_party"),
					(call_script, "script_party_set_ai_state", "$target", spai_accompanying_army, "p_main_party"),
					(store_add,":follow_time",":cur_hour",24),
					(party_set_slot,"$target","slot_party_hired",":follow_time"),
					(party_set_slot,"$target","slot_party_follow_player_until_time",":follow_time"),					
				(else_try),
					(lt,":cur_wealth","$bribe_amount"),
					(val_and,":message",191),
					(party_set_slot,":messenger_party_no","slot_message_content",":message"),
					(call_script, "script_change_player_relation_with_troop", ":leader", -1),
					(assign,"$unable_to_pay",1),
				(else_try),
					(ge,":cur_wealth","$bribe_amount"),
					(val_and,":message",191),
					(assign,"$unable_to_duel",1),
				(try_end),
			(else_try),	#todo		
				(eq,":bit",128),#choice 8
				(gt,":check_bit",0),
			(else_try),	#todo		
				(eq,":bit",256),#choice 9
				(gt,":check_bit",0),				
			(try_end),
			(val_add,":bit",":bit"),
		(try_end),
		(str_clear,s6),
		(str_clear,s7),
		(str_clear,s8),

				
      ]),		
		
#TEMPERED chief script_describe_player_relations
#input kingdom hero party
#output "$fac_relations", "$message_tone"

  ("describe_player_relations",
    [	(store_script_param_1, ":party_no"),	    
		(store_faction_of_party, ":party_faction", ":party_no"),
		(store_relation, ":reln_with_player_fac", ":party_faction", "fac_player_supporters_faction"),
		(party_stack_get_troop_id, ":leader", ":party_no", 0),
		(call_script, "script_troop_get_player_relation", ":leader"),
		(assign,":hero_relation",reg0),
		(try_begin),#friendly to player
			(ge,":hero_relation",4),
			(assign,"$message_tone",1),
		(else_try),#neutral to player
			(is_between,":hero_relation",0,4),
			(assign,"$message_tone",2),
		(else_try),#hostile to player
			(lt,":hero_relation",0),
			(assign,"$message_tone",3),
		(try_end),		
		(try_begin),#see if it is a player kingdom hero
			(eq,":party_faction","$players_kingdom"),
			(try_begin),
				#see if player is leader of a faction
				(eq, "$players_kingdom", "fac_player_supporters_faction"),
				(faction_slot_eq, "fac_player_supporters_faction", "slot_faction_state", sfs_active),
				(assign,"$fac_relations",6),
				(display_message,"@Debug:  fac relation is friendly, player is faction leader"),
			(else_try),
				#see if player is marshal
				(faction_slot_eq, "$players_kingdom", "slot_faction_marshall", "trp_player"),
				(assign,"$fac_relations",5),
				(display_message,"@Debug:  fac relation is friendly, player is marshal"),
			(else_try), 
				#player is a lord or mercenary of a faction
				(assign,"$fac_relations",4),
				(display_message,"@Debug:  fac relation is friendly, player is lord or mercenary"),
			(try_end),
		(else_try),#hostile faction kingdom hero
			(lt, ":reln_with_player_fac",0),
			(assign,"$fac_relations",1),
			(display_message,"@Debug:  fac relation is hostile faction"),
		(else_try),#neutral faction kingdom hero
			(is_between,":reln_with_player_fac",0,4),
			(assign,"$fac_relations",2),
			(display_message,"@Debug:  fac relation is neutral faction"),
		(else_try),#friendly faction kingdom hero
			(ge,":reln_with_player_fac",4),
			(assign,"$fac_relations",3),
			(display_message,"@Debug:  fac relation is friendly faction"),
		(try_end),
		
      ]),

#TEMPERED  script_build_message_hero
#input
#output  strings for message, s1,s2,s3,s4,s5,s8,reg16 

  ("build_message_hero",
    [	
		(assign,":party_no","$message_target"),
		(str_store_string,s3,"@_"),
		(str_store_string,s4,"@_"),
		(str_store_string,s5,"@_"),
		(str_store_string,s8,"@_"),
		(assign,":next_presentation",0),
		(party_stack_get_troop_id, ":leader", ":party_no", 0),
		(str_store_troop_name,s1,":leader"),
		(store_faction_of_party, ":party_faction", ":party_no"),
		(str_store_faction_name,s2,":party_faction"),
		(try_begin),
			(eq,"$message_tone",1),#friendly
			(str_store_string,s3,"@My good friend {s1},"),
		(else_try),
			(eq,"$message_tone",2),#neutral
			(str_store_string,s3,"@Greetings {s1},"),
		(else_try),
			(eq,"$message_tone",3),#hostile
			(str_store_string,s3,"@ {s1} ,"),
		(try_end),
		(try_begin),
			(eq,"$fac_relations",6),#player is king
			(str_store_string,s4,"str_player_king_message"),
		(else_try),
			(eq,"$fac_relations",5),#player is marshal
			(str_store_string,s4,"str_player_marshal_message"),
		(else_try),
			(eq,"$fac_relations",4),#player is lord or mercenary
			(str_store_string,s4,"str_player_lord_message"),
		(else_try),
			(eq,"$fac_relations",1),#hostile faction
			(try_begin),
				(gt,"$players_kingdom",0),
				(str_store_string,s4,"@  Though our kingdoms are at war, I have an offer you may find mutally beneficial."),
			(else_try),
				(le,"$players_kingdom",0),#player has no allegiance
				(str_store_string,s4,"@  Though I am no friend of your kingdom, I have an offer you may find beneficial."),
			(try_end),
		(else_try),
			(eq,"$fac_relations",2),#neutral faction
			(try_begin),
				(gt,"$players_kingdom",0),
				(str_store_string,s4,"@  In the spirit of better relations between our kingdoms, I send this letter."),
			(else_try),
				(le,"$players_kingdom",0),
				(str_store_string,s4,"@  Though I am not well known in {s2}, I find myself in need of this communique with thou."),
			(try_end),
		(else_try),
			(eq,"$fac_relations",3),#friendly faction
			(try_begin),
				(gt,"$players_kingdom",0),
				(str_store_string,s4,"@  May our kingdoms continue to prosper under our current alliance."),
			(else_try),
				(le,"$players_kingdom",0),
				(str_store_string,s4,"@  Long have I been a friend of {s2} and would have you consider this message."),
			(try_end),
		(try_end),
		(assign,":check_bit",0),
		(assign,":bit",1),
		(try_for_range,":unused",1,10),
			(store_and,":check_bit",":bit","$message_bits"),
			(try_begin),
				(eq,":bit",1),#choice 1 insult
				(gt,":check_bit",0),
				(store_random_in_range,":random_no",1,91),
				(try_begin),
					(is_between,":random_no",1,8),
					(str_store_string,s3,"@Excuse me Lady,"),
					(str_store_string,s4,"@__I have long pondered this paradox, perhaps you can enlighten me."),
					(str_store_string,s5,"@{s5}__You should be women and yet your beards forbid me to interpret that you are so."),
				(else_try),
					(is_between,":random_no",9,20),
					(str_store_string,s3,"@{s1} Whoremaster,"),
					(str_store_string,s4,"@__I have recently made the acquaintance of one of your kin."),					
					(str_store_string,s5,"@{s5}__Your mother is an easy glove, my lord, she goes off and on at pleasure."),
				(else_try),
					(is_between,":random_no",21,30),
					(str_store_string,s3,"@Sir Gizzardless,"),
					(str_store_string,s4,"@_"),
					(str_store_string,s5,"@{s5}__Boils and plagues plaster you over, that you may be abhorred farther than seen and one infect another against the wind a mile. You souls of geese that bear the shapes of men."),
				(else_try),
					(is_between,":random_no",31,45),
					(str_store_string,s3,"@ Lover of barnyard animals,"),
					(str_store_string,s4,"@_"),
					(str_store_string,s5,"@{s5}__What a slave art thou to hack thy sword as thou hast done, and then say it was in a fight."),
				(else_try),
					(is_between,":random_no",46,58),
					(str_store_string,s3,"@Woman,"),
					(str_store_string,s4,"@_I recall how feminine you were in youth."),
					(str_store_string,s5,"@{s5}__What a maidenly man at arms you have become."),
				(else_try),
					(is_between,":random_no",59,65),
					(str_store_string,s3,"@Run coward,"),
					(str_store_string,s4,"@_."),
					(str_store_string,s5,"@{s5}__Your hearts I'll stamp out with my horse's heel and make a quagmire of your mingled brains."),
				(else_try),
					(is_between,":random_no",66,72),
					(str_store_string,s3,"@ Simpleton,"),
					(str_store_string,s4,"@_I despise you."),
					(str_store_string,s5,"@{s5}__Foul spoken coward, that thund'rest with thy tongue, and with thy weapon nothing dares perform."),
				(else_try),
					(is_between,":random_no",73,90),
					(str_store_string,s3,"@Say wall eyed slave,"),
					(str_store_string,s4,"@_"),
					(str_store_string,s5,"@{s5}__ Whither wouldst thou convey this growing image of thy fiend like face?"),
				(try_end),
			(else_try),			
				(eq,":bit",2),#choice 2 BRIBE TO ATTACK PARTY
				(gt,":check_bit",0),
				(assign,":next_presentation",1),
				(str_store_string,s5,"@{s5}__There is a certain party which stands in my way. What will it cost to have them removed?"),
			(else_try),			
				(eq,":bit",4),#choice 3 BUY SUPPLIES
				(gt,":check_bit",0),
				(str_store_string,s5,"@{s5}__My men and I have traveled far and find ourselves without sustenance. I would pay well for any food you could spare."),
			(else_try),			
				(eq,":bit",8),#choice 4 CHALLENGE TO DUEL
				(gt,":check_bit",0),
				(str_store_string,s4,"@_"),
				(try_begin),
					(eq,"$message_tone",1),#friendly duel
					(str_store_string,s5,"@{s5}_I would test myself against thy sword, if you are so inclined. I propose a friendly duel, so that we may know to count upon one another in the thick of battle."),
				(else_try),
					(eq,"$message_tone",2),#neutral duel
					(str_store_string,s5,"@{s5}_Your renown in battle is such that I would be well schooled to have fought against you. Shall we duel for the pleasure of a good challenge?"),
				(else_try),
					(eq,"$message_tone",3),#hostile duel
					(str_store_string,s5,"@{s5}_I have heard you are a lowly opponent and not fit for sport. Yet your presence offends me. Let us duel so that I may carve the stench away from thee."),
				(try_end),
			(else_try),
				(eq,":bit",16),#choice 5 gift of wine
				(gt,":check_bit",0),
				(str_store_string,s5,"@{s5}__Please except this gift to comfort you on your journeys."),
			(else_try),			
				(eq,":bit",32),#choice 6 gift of poison wine
				(gt,":check_bit",0),
				(str_store_string,s5,"@{s5}__Please except this gift to comfort you on your journeys."),
			(else_try),
				(eq,":bit",64),#choice 7 hire to follow
				(gt,":check_bit",0),
				(call_script,"script_bribe_party",":party_no",10,0),
				(assign,reg16,"$bribe_amount"),
				(str_store_string,s5,"@__The road ahead is hostile, and I am in need of assistance for any altercations that may arise. I would pay you {reg16} scillingas for such assistance."),
			(else_try),			
				(eq,":bit",128),#choice 8
				(gt,":check_bit",0),
				(str_store_string,s5,"@{s5}__choice 5"),
			#(else_try),				
			(try_end),
			(val_add,":bit",":bit"),
		(try_end),
		(str_store_string,s8,"@{s4}{s5}"),
		(try_begin),
			(eq,":next_presentation",0),
			(start_presentation,"prsnt_view_message"),
		(else_try),
			(eq,":next_presentation",1),
			(assign,"$message_party_target",-1),
			(assign,"$pick_party",1),
			#(start_presentation,"prsnt_party_choice"),
		(try_end),
      ]),
	  
#TEMPERED  script_bribe_party
#input party to bribe, bribe multiplyer, party to attack if any
#output  "$bribe_amount"
  ("bribe_party",
    [	(store_script_param, ":party_no", 1),
		(store_script_param, ":bribe_factor",2),
		(store_script_param, ":party_no_2",3),
		(party_get_num_companions,":party_size",":party_no"),
		(try_begin),
			(gt,":party_no_2",0),
			(party_get_num_companions,":party_size_2",":party_no_2"),
			(party_get_slot, ":party_type",":party_no","slot_party_type"),
			(store_faction_of_party, ":party_faction", ":party_no"),
			(store_faction_of_party, ":party_faction_2", ":party_no_2"),
			(store_relation, ":reln_between_factions",":party_faction" ,":party_faction_2"),
			(try_begin),
				(ge,":party_size_2",":party_size"),
				(store_sub,":difference",":party_size_2",":party_size"),
				(val_add,":bribe_factor",":difference"),
			(else_try),
				(gt,":party_size",":party_size_2"),
				(store_sub,":difference",":party_size",":party_size_2"),
				(val_sub,":bribe_factor",":difference"),
			(try_end),
			(try_begin),
				(eq,":party_type",spt_village),
				(val_add,":bribe_factor",2),
			(else_try),
				(eq,":party_type",spt_town),
				(val_add,":bribe_factor",16),
			(else_try),
				(eq,":party_type",spt_kingdom_caravan),
				(val_add,":bribe_factor",5),
			(else_try),
				(eq,":party_type",spt_kingdom_hero_party),
				(val_add,":bribe_factor",6),
			(else_try),
				(eq,":party_type",spt_castle),
				(val_add,":bribe_factor",10),
			(try_end),
			(try_begin),
				(gt,":reln_between_factions",0),
				(val_add,":bribe_factor",20),
			(else_try),
				(lt,":reln_between_factions",0),
				(val_sub,":bribe_factor",5),
			(try_end),	
		(try_end),
		(try_begin),
			(lt,":bribe_factor",2),
			(assign,":bribe_factor",2),
		(try_end),
		(store_skill_level, ":persuasion", "skl_persuasion", "trp_player"),
		(val_mul,":persuasion",4),	
		(store_mul,":base_bribe",":party_size",":bribe_factor"),
		(val_sub,":base_bribe",":persuasion"),
		(val_mul,":base_bribe","$message_tone"),#personal relations can increase bribe by 3x
		(val_div,":base_bribe","$fac_relations"),#faction relations can decrease bribe up to 6x
		(val_abs,":base_bribe"),
		(assign,"$bribe_amount",":base_bribe"),		
      ]),

#TEMPERED  SCRIPT_UPDATE_HERO_INVENTORY
# UPDATES GOLD AND SUPPLIES CARRIED BY KINGDOM HERO, CALLED EVERY 7 DAYS
#input TROOP_ID, WEALTH
#OUTPUT  MODIFIED WEALTH, REG0
  ("update_hero_inventory",
    [	
        (store_script_param,":troop_no",1),
		(store_script_param,":cur_wealth",2),
		(store_troop_gold,":cur_gold",":troop_no"),
		(store_div,":travel_money",":cur_wealth",10),
		(val_min,":travel_money",800),
		(try_begin),
			(lt,":cur_gold",":travel_money"),
			(store_sub,":add_gold",":travel_money",":cur_gold"),
			(troop_add_gold,":troop_no",":add_gold"),
			(val_sub,":cur_wealth",":add_gold"),
			(val_abs,":cur_wealth"),
		(else_try),
			(gt,":cur_gold",":travel_money"),
			(store_sub,":bank_gold",":cur_gold",":travel_money"),
			(val_abs,":bank_gold"),
			(val_add,":cur_wealth",":bank_gold"),
			(troop_remove_gold,":troop_no",":bank_gold"),
		(try_end),
		(assign,":ration_count",0),
		(troop_get_inventory_capacity,":capacity",":troop_no"),
		(try_for_range,":slot",10,":capacity"),			
			(troop_get_inventory_slot,":cur_item",":troop_no",":slot"),
			(gt,":cur_item",0),
			(item_get_type,":item_type", ":cur_item"),
			(eq,":item_type",itp_type_goods),
			(val_add,":ration_count",1),			
		(try_end),
		(try_begin),
			(gt,":ration_count",5),
			(try_for_range_backwards,":slot",":capacity",15),
				(troop_get_inventory_slot,":cur_item",":troop_no",":slot"),
				(gt,":cur_item",0),
				(item_get_type,":item_type", ":cur_item"),
				(eq,":item_type",itp_type_goods),
				(store_item_value,":ration_price",":cur_item"),
				(val_add,":cur_wealth",":ration_price"),
				(troop_remove_item,":troop_no",":cur_item"),
			(try_end),
		(else_try),
			(lt,":ration_count",4),
			(val_sub,":ration_count",4),
			(val_abs,":ration_count"),
			(try_for_range,":unused",0,":ration_count"),
				(store_random_in_range,":food_item",food_begin,food_end),
				(store_item_value,":ration_price",":food_item"),
				(val_sub,":cur_wealth",":ration_price"),
				(store_free_inventory_capacity,":inv_capacity",":troop_no"),
				(ge,":inv_capacity",1),
				(troop_add_item,":troop_no",":food_item"),
			(try_end),
		(try_end),
		(val_max,":cur_wealth",0),
		(assign,reg0,":cur_wealth"),
	
      ]),

#TEMPERED  SCRIPT_WILDERNESS_DUEL_INIT
#input: uses "$g_talk_troop" for opponent, party troops as spectators.  scene to use.
#MOTO chief uses first troop for opponent
	("wilderness_duel_init",
		[
			(store_script_param_1,":scene"),
			(modify_visitors_at_site, ":scene"),
			(set_visitor, 0, "trp_player"),
                                    #MOTO fix for duels without dialog
                  # (set_visitor, 1, "$g_talk_troop"),
                  (party_stack_get_troop_id, ":party_leader", "$g_encountered_party", 0),
                  (set_visitor, 1, ":party_leader"),
                  #MOTO chief fix for duels without dialog end
			(assign,":enemy_count",0),
			(assign,":friend_count",0),
			(assign,":cur_pos",2),
			(party_get_num_companion_stacks, ":num_stacks","$g_encountered_party"),
			(try_for_range, ":i_stack", 0, ":num_stacks"),
				(lt,":enemy_count",10),
				(party_stack_get_size,":stack_size","$g_encountered_party",":i_stack"),
				(party_stack_get_troop_id, ":stack_troop","$g_encountered_party",":i_stack"),
			#MOTO chief fix for duels without dialog
                      # (neq,":stack_troop","$g_talk_troop"),
                      (try_begin),
                          (eq, ":i_stack", 0),
                          (val_sub, ":stack_size", 1),    #pass over      troop being dueled!
                      (try_end),
                      #MOTO fix for duels without dialog
 
				(try_for_range,":unused",1,":stack_size"),					
					(lt, ":cur_pos", 12),
					(set_visitor, ":cur_pos", ":stack_troop"),
					(val_add,":cur_pos", 1),
					(val_add,":enemy_count",1),
				(try_end),
			(try_end),
			(assign,":cur_pos",12),
			(party_get_num_companion_stacks, ":num_stacks","p_main_party"),
			(try_for_range, ":i_stack", 0, ":num_stacks"),
				(lt,":friend_count",10),
				(party_stack_get_size,":stack_size","p_main_party",":i_stack"),
				(party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
				(neq,":stack_troop","trp_player"),
				(try_for_range,":unused",1,":stack_size"),					
					(lt, ":cur_pos", 22),
					(set_visitor, ":cur_pos", ":stack_troop"),
					(val_add,":cur_pos", 1),
					(val_add,":friend_count",1),
				(try_end),
			(try_end),			

  
		]),
		
#TEMPERED chief GET NEAREST FRIENDLY OR NEUTRAL VILLAGE
#input party
#output "$message_party_target"
#called from presentation view message for wilderness duel meeting spot
  ("nearby_village_neutral",
    [
		(store_script_param_1, ":party_no"),
		(assign,"$message_party_target",-1),
		(store_faction_of_party,":faction_no",":party_no"),
		(assign, ":closest_dist", 100000),
		(try_for_range,":cur_village", villages_begin, villages_end),
			(store_distance_to_party_from_party, ":dist", ":cur_village", ":party_no"),
			(store_faction_of_party, ":cur_village_faction", ":cur_village"),
			(store_relation,":relation",":cur_village_faction",":faction_no"),
			(ge, ":relation",0),
			(lt, ":dist", ":closest_dist"),
			(assign, ":closest_dist", ":dist"),
			(assign, "$message_party_target", ":cur_village"),
		(try_end),
	]),

#TEMPERED  script_build_reply
#CALLED FROM MNU_MESSENGER_RETURN
#INPUT party_id  SHOULD BE MESSENGER PARTY
#output  strings for message, s1,s2,s3,s4,s5,s8,s9,s14
  ("build_reply",
    [	
		(store_script_param_1,":party_no"),
		(party_get_slot,":recipient",":party_no","slot_message_target"),
		(party_get_slot,":recipient_target",":party_no","slot_message_target_2"),
		(party_get_slot,":message",":party_no","slot_message_content"),
		(party_stack_get_troop_id, ":leader", ":recipient", 0),
		(str_store_troop_name,s14,":leader"),
		(store_faction_of_party, ":party_faction", ":recipient"),
		(str_store_faction_name,s2,":party_faction"),
		(str_store_troop_name,s1,"trp_player"),
		(str_clear,s5),
		(try_begin),
			(is_between,":recipient_target",villages_begin, villages_end),
			(str_store_party_name,s9,":recipient_target"),
		(try_end),
		(call_script,"script_describe_player_relations",":party_no"),
		(try_begin),
			(eq,"$message_tone",1),#friendly
			(str_store_string,s3,"@My good friend {s1},"),
		(else_try),
			(eq,"$message_tone",2),#neutral
			(str_store_string,s3,"@Greetings {s1},"),
		(else_try),
			(eq,"$message_tone",3),#hostile
			(str_store_string,s3,"@Sir Errand boy,"),
		(try_end),
		(try_begin),
			(eq,"$fac_relations",6),#player is king
			(str_store_string,s4,"@__You honor me with your communique, my Lord."),
		(else_try),
			(eq,"$fac_relations",5),#player is marshal
			(str_store_string,s4,"@__I have considered your message, Lord Marshal, and here is my reply."),
		(else_try),
			(eq,"$fac_relations",4),#player is lord or mercenary
			(str_store_string,s4,"@__I have considered your message and here is my reply."),
		(else_try),
			(eq,"$fac_relations",1),#hostile faction
			(try_begin),
				(gt,"$players_kingdom",0),
				(str_store_string,s4,"@__Though our kingdoms are at war, I felt a need to reply to your missive."),
			(else_try),
				(le,"$players_kingdom",0),#player has no allegiance
				(str_store_string,s4,"@__Here is your answer, mercenary."),
			(try_end),
		(else_try),
			(eq,"$fac_relations",2),#neutral faction
			(try_begin),
				(gt,"$players_kingdom",0),
				(str_store_string,s4,"@__My reply to your message is thus."),
			(else_try),
				(le,"$players_kingdom",0),
				(str_store_string,s4,"@__My reply to your message is thus, mercenary."),
			(try_end),
		(else_try),
			(eq,"$fac_relations",3),#friendly faction
			(try_begin),
				(gt,"$players_kingdom",0),
				(str_store_string,s4,"@__May our kingdoms grow and prosper through our communications."),
			(else_try),
				(le,"$players_kingdom",0),
				(str_store_string,s4,"@__You have proven to be a friend of {s2}, and warrent a reply."),
			(try_end),
		(try_end),
		(try_begin),
			(eq,"$unable_to_duel",1),
			(str_store_string,s5,"@_I am unable to consider your request at this time. I have more important matters to attend to."),
		(try_end),
		(assign,":check_bit",0),
		(assign,":bit",1),
		(try_for_range,":unused",1,10),
			(store_and,":check_bit",":bit",":message"),
			(try_begin),
				(eq,":bit",1),#choice 1 insult
				(gt,":check_bit",0),
				(try_begin),
					(ge, "$fac_relations",0),
					(str_store_string,s5,"@{s5}__I will not abide your insults and demand you recant your words and meet me upon the field of honor, that I may gain satisfaction from your cries for mercy."),
					(str_store_string,s5,"@{s5}_ I will await you near {s9}. Be there within 24 hours or be forever known as a coward and liar."),
				(else_try),
					(lt, "$fac_relations",0),
					(str_store_string,s5,"@{s5}_Die you pompous ass! I am coming for you. Let us see if your sword is as sharp as your tongue."),
				(try_end),
			(else_try),			
				(eq,":bit",2),#choice 2 BRIBE TO ATTACK PARTY
				(gt,":check_bit",0),
				(try_begin),
					(eq,"$unable_to_pay",1),
					(str_store_string,s5,"@{s5}_Only fools and thieves bargain with coin they do not possess!"),
				(else_try),
					(gt,"$attack_party_answer",0),
					(try_begin),
						(eq,"$attack_party_answer",1),
						(str_store_string,s5,"@{s5}_Do not ask of me a task you do not wish committed. I've no time for idle banter."),
					(else_try),
						(eq,"$attack_party_answer",2),
						(str_store_string,s5,"@{s5}_Kill a few peasants, tip a few cows? I'm into that."),
					(else_try),
						(eq,"$attack_party_answer",3),
						(str_store_string,s5,"@{s5}_I shall lay siege to the town, though I doubt much good shall come of it."),
					(else_try),
						(eq,"$attack_party_answer",4),
						(str_store_string,s5,"@{s5}_I shall besiege the castle at your behest, but I do not expect to breech the walls."),
					(else_try),
						(eq,"$attack_party_answer",5),
						(str_store_string,s5,"@{s5}_If I can catch the cowards, I will put them to the sword, but do not expect me to chase them forever."),
					(try_end),
				(try_end),	
			(else_try),			
				(eq,":bit",4),#choice 3 BUY SUPPLIES
				(gt,":check_bit",0),
				(str_store_string,s5,"@{s5}_It is good to meet in commerce instead of war for a change."),
			(else_try),			
				(eq,":bit",8),#choice 4 CHALLENGE TO DUEL
				(gt,":check_bit",0),
				(call_script,"script_duel_ranking",":leader"),
				(try_begin),
					(eq,"$outclassed",1),
					(str_store_string,s5,"@{s5}_It would be less than honorable for me to duel one of such low reputation. Perhaps we can speak of this again when you have proven your self in combat."),
				(else_try),
					(eq,"$message_tone",1),#friendly duel
					(str_store_string,s5,"@{s5}_Yes, let us duel. Meet me near {s9} within 24 hours."),
				(else_try),
					(eq,"$message_tone",2),#neutral duel
					(str_store_string,s5,"@{s5}_I look forward to teaching you the finer arts of combat. Meet me near {s9} within 24 hours and you shall have your duel."),
				(else_try),
					(eq,"$message_tone",3),#hostile duel
					(str_store_string,s5,"@{s5}_Ha! I will gladly deflate your oversized ego. Be prepared to fight with more than words, braggart. Meet me near {s9} within 24 hours, lest you be a dishonorable coward."),
				(try_end),
			(else_try),
				(eq,":bit",16),#choice 5 gift of wine
				(gt,":check_bit",0),
				(call_script,"script_describe_player_relations",":recipient"),
				(call_script,"script_trust_in_player",":recipient"),
				(troop_get_slot,":player_poison_attempts","trp_player","slot_troop_poisoner"),
				(try_begin),
					(troop_slot_ge,":leader","slot_troop_poisoned",1),
					(str_store_string,s5,"@{s5}__I'll have none of your poison, assasin."),
				(else_try),
					(ge,"$trust_in_player",20),
					(str_store_string,s5,"@{s5}__A welcome gift on this dusty road. You have my gratitude."),
					(call_script, "script_change_player_relation_with_troop", ":leader", 2),
				(else_try),
					(lt,"$trust_in_player",20),
					(ge,":player_poison_attempts",3),
					(str_store_string,s5,"@{s5}__I've heard of your dishonorable actions and wish not to become another victim of your poisons. Keep your wine or poison, whichever it may be."),
					(troop_add_item, "trp_player", "itm_wine"),
				(else_try),
					(lt,"$trust_in_player",20),
					(lt,":player_poison_attempts",3),
					(str_store_string,s5,"@{s5}__You have yet to prove yourself trustworthy, thus it would be inappropriate for me to accept your gift at this time."),
					(troop_add_item, "trp_player", "itm_wine"),
				(try_end),
			(else_try),			
				(eq,":bit",32),#choice 6 gift of poison wine
				(gt,":check_bit",0),
				(call_script,"script_describe_player_relations",":recipient"),
				(call_script,"script_trust_in_player",":recipient"),
				(troop_get_slot,":player_poison_attempts","trp_player","slot_troop_poisoner"),
				(try_begin),
					(troop_slot_ge,":leader","slot_troop_poisoned",1),
					(str_store_string,s5,"@{s5}__I'll have none of your poison, assasin."),
					(call_script, "script_change_player_relation_with_troop", ":leader", -20),
					(call_script, "script_change_player_honor", - 10),
					(val_add,":player_poison_attempts",1),
					(troop_set_slot,"trp_player","slot_troop_poisoner",":player_poison_attempts"),
				(else_try),
					(ge,"$trust_in_player",20),
					(str_store_string,s5,"@{s5}__A welcome gift on this dusty road. You have my gratitude."),
					(call_script, "script_change_player_relation_with_troop", ":leader", -20),
					(call_script, "script_change_player_honor", - 10),
					(val_add,":player_poison_attempts",1),
					(troop_set_slot,"trp_player","slot_troop_poisoner",":player_poison_attempts"),
					(troop_set_slot,":leader","slot_troop_poisoned",1),
					(troop_set_health,":leader",5),
					(call_script,"script_poison_well",":recipient"),					
				(else_try),
					(lt,"$trust_in_player",20),
					(display_message,"@  {s14}  has discovered that the wine was poisoned! Your attempt to poison him has failed."),
					(str_store_string,s5,"@{s5}__You think to poison me! I'll see your head on a block for this, you vile son of a leperous whore!"),
					(call_script, "script_change_player_relation_with_troop", ":leader", -20),
					(call_script, "script_change_player_honor", - 10),
					(troop_set_slot,":leader","slot_troop_poisoned",1),
					(val_add,":player_poison_attempts",1),
					(troop_set_slot,"trp_player","slot_troop_poisoner",":player_poison_attempts"),
				(try_end),
			(else_try),
				(eq,":bit",64),#choice 7 hire to follow
				(gt,":check_bit",0),
				(str_store_string,s5,"@_I will take your coin and protect you to the best of my ability. Know that I will not raise my sword against those I count as friends."),
			(else_try),			
				(eq,":bit",128),#choice 8
				(gt,":check_bit",0),
				(str_store_string,s5,"@{s5}__choice 8"),
			#(else_try),				
			(try_end),
			(val_add,":bit",":bit"),
		(try_end),
		(str_store_string,s5,"@ {s5} ^^____________________________________________________________{s14} "),
		(assign,"$unable_to_duel",-1),
		(assign,"$unable_to_pay",-1),
		(assign,"$attack_party_answer",-1),
		(str_store_string,s8,"@{s4}{s5}"),

      ]),  
 
 #TEMPERED Trust in player
#input party to gift
#output "$trust_in_player"  score below 30 means not trusted
#called from script build reply
  ("trust_in_player",
    [
		(store_script_param_1, ":party_no"),
		(assign,"$trust_in_player",0),
		(troop_get_slot,":player_poison_attempts","trp_player","slot_troop_poisoner"),
		(party_stack_get_troop_id, ":leader", ":party_no", 0),
		(call_script, "script_troop_get_player_relation", ":leader"),
		(assign,":troop_relation",reg0),
		(store_add,":total_trust","$trust_in_player",":troop_relation"),
		(val_add,":total_trust","$player_honor"),
		(val_mul,":total_trust","$fac_relations"),
		(try_begin),
			(gt,":player_poison_attempts",3),
			(val_mul,":total_trust",2),
			(val_div,":total_trust",":player_poison_attempts"),
		(try_end),
		(assign,"$trust_in_player",":total_trust"),
		(try_begin),
			(troop_slot_ge,":leader","slot_troop_poisoned",1),
			(assign,"$trust_in_player",-5),
			(val_add,"$trust_in_player",":troop_relation"),
		(try_end),
	]),

#TEMPERED duel_ranking     gets player ranking in renown for appropriatness of duels
#input troop_id  challenged to duel
#output "$outclassed"  eq 1 if player renown is too low
#called from script personal messenger and script build reply
  ("duel_ranking",
    [
		(store_script_param_1, ":troop_no"),
		(assign,"$outclassed",0),
		(troop_get_slot,":player_renown","trp_player","slot_troop_renown"),
		(troop_get_slot,":opponent_renown",":troop_no","slot_troop_renown"),
		(store_sub,":renown_diff",":player_renown",":opponent_renown"),
		(val_abs,":renown_diff"),
		(try_begin),
			(ge,":player_renown",":opponent_renown"),
			(assign,"$outclassed",0),
		(else_try),
			(le,":renown_diff",200),
			(assign,"$outclassed",0),
		(else_try),
			(gt,":renown_diff",200),
			(lt,":player_renown",":opponent_renown"),
			(assign,"$outclassed",1),
		(try_end),

	]),	
	
#TEMPERED SCRIPT_NEARBY_PARTIES
#INPUT  PARTY_NO , DISTANCE
#OUTPUT NONE , SETS "slot_PARTY_NEARBY" FOR THOSE IN RANGE
  ("nearby_parties",
    [
		(store_script_param_1, ":party_to_be_near"),
		(store_script_param_2, ":distance"),
		(try_for_parties,":party_no"),
			(party_set_slot,":party_no","slot_party_nearby",0),
			(neg|is_between,":party_no",spawn_points_begin, spawn_points_end),
			(party_get_template_id,":party_template_id",":party_no"),
			(party_get_battle_opponent, ":opponent",":party_no"),
			(lt, ":opponent", 0), #party is not itself involved in a battle
			(party_get_attached_to, ":attached_to",":party_no"),
			(lt, ":attached_to", 0), #party is not attached to another party in battle
			(get_party_ai_behavior, ":behavior", ":party_no"),
			(neq, ":behavior", 8),#party is not in a town/castle
			(party_get_slot, ":party_type",":party_no","slot_party_type"),				
			(neq, ":party_type", spt_kingdom_caravan),
			(neq, ":party_type", spt_cattle_herd1),
			(neq, ":party_no","p_main_party"),
			(neq, ":party_type", spt_messenger), #do not consider messengers
			(neq,":party_template_id","pt_spy_party"),  #do not consider spy parties
			(neq,":party_template_id","pt_skirmish_party"),  #do not consider skirmisher parties, they have other orders
			(store_distance_to_party_from_party, ":cur_distance", ":party_no", ":party_to_be_near"),
			(try_begin),
				(lt, ":cur_distance", ":distance"),  #party is within distance
				(party_set_slot,":party_no","slot_party_nearby",1),
			(try_end),
		(try_end),
	]),	

  #Temepred  script_create_player_loot_wagon
  # Input: arg1 = party_no (town to trade with)
  # Output: 
  ("create_player_loot_wagon",
	[	
		(set_spawn_radius, 0),
		(spawn_around_party, "p_main_party", "pt_player_loot_wagon"),
		(assign, ":loot_party", reg0),      
		(party_set_faction, ":loot_party", "fac_player_supporters_faction"),
		(party_set_slot, ":loot_party", "slot_party_type", spt_player_loot_wagon),
		(party_set_slot,":loot_party","slot_party_hired",0),
		(party_set_slot,"p_main_party","slot_party_loot_wagon",":loot_party"),
		(party_set_slot, ":loot_party", "slot_party_ai_state", spai_undefined),
		(party_set_slot,":loot_party","slot_party_commander_party",-1),
		(party_set_slot, ":loot_party", "slot_party_following_player", 0),
		(party_set_slot, ":loot_party", "slot_center_accumulated_tariffs", 0),
		(party_set_bandit_attraction, ":loot_party",70),#gdw
		(assign,"$loot_wagon_trade_state",0),
    ]),	
	
  #Temepred  script_move_troops_loot_wagon
  # Input: 
  # Output: 
  ("move_troops_loot_wagon",
   [	
		(party_get_slot,":loot_wagon","p_main_party","slot_party_loot_wagon"),
		(party_get_slot,":wagon_leader","p_main_party","slot_party_wagon_leader"),
		(party_remove_members,"p_main_party",":wagon_leader",1),
		(party_add_members, ":loot_wagon", ":wagon_leader", 1),
		#(troop_set_slot, ":wagon_leader", "slot_troop_leaded_party", ":loot_wagon"),
		(party_get_num_companion_stacks, ":num_stacks","p_temp_loot_wagon"),
		(try_for_range, ":stack_no", 0, ":num_stacks"),
			(party_stack_get_troop_id, ":stack_troop","p_temp_loot_wagon",":stack_no"),
			(gt,":stack_troop",0),
			(party_stack_get_size, ":stack_size","p_temp_loot_wagon",":stack_no"),
			(party_add_members, ":loot_wagon", ":stack_troop", ":stack_size"),			
		(try_end),
		(party_get_num_prisoner_stacks, ":num_stacks","p_temp_loot_wagon"),
		(try_begin),
			(gt,":num_stacks",0),
			(try_for_range, ":stack_no", 0, ":num_stacks"),
				(party_prisoner_stack_get_troop_id, ":stack_troop","p_temp_loot_wagon",":stack_no"),
				(gt,":stack_troop",0),
				(party_prisoner_stack_get_size, ":stack_size","p_temp_loot_wagon",":stack_no"),
				(neg|troop_is_hero, ":stack_troop"),
				(party_add_prisoners, ":loot_wagon", ":stack_troop", ":stack_size"),
			(try_end),
		(try_end),		
		(party_clear,"p_temp_loot_wagon"),
		
    ]),	
	
  #Temepred  script_restore_wagon_troops
  # Input: 
  # Output: 
  ("restore_wagon_troops",
   [	
   
		(party_get_num_companion_stacks, ":num_stacks","p_temp_loot_wagon"),
		(try_for_range, ":stack_no", 0, ":num_stacks"),
			(party_stack_get_troop_id, ":stack_troop","p_temp_loot_wagon",":stack_no"),
			(party_stack_get_size, ":stack_size","p_temp_loot_wagon",":stack_no"),
			(party_remove_members,"p_temp_loot_wagon",":stack_troop",":stack_size"),
			(party_add_members, "p_main_party", ":stack_troop", ":stack_size"),			
		(try_end),
		(party_get_num_prisoner_stacks, ":num_stacks","p_temp_loot_wagon"),
		(try_begin),
			(gt,":num_stacks",0),
			(try_for_range, ":stack_no", 0, ":num_stacks"),
				(party_prisoner_stack_get_troop_id, ":stack_troop","p_temp_loot_wagon",":stack_no"),
				(party_prisoner_stack_get_size, ":stack_size","p_temp_loot_wagon",":stack_no"),			
				(party_remove_prisoners,"p_temp_loot_wagon",":stack_troop",":stack_size"),
				(party_add_prisoners, "p_main_party", ":stack_troop", ":stack_size"),
			(try_end),
		(try_end),
		(display_message,"@                Supply wagon troops have been reassigned to the main party."),

    ]),	
	
#TEMPERED ADD LOOT TO WAGON AFTER A BATTLE
  ("add_wagon_inventory",
    [
		(troop_get_inventory_capacity,":capacity","trp_temp_troop"),
		(troop_sort_inventory,"trp_temp_troop"),
		(troop_sort_inventory,"trp_loot_wagon_storage_1"),
		(try_for_range,":slot",0,":capacity"),
			(troop_get_inventory_slot,":cur_item","trp_temp_troop",":slot"),
			(troop_get_inventory_slot_modifier, ":item_modifier", "trp_temp_troop", ":slot"),
			(try_begin),
				(gt,":cur_item",0),
				(store_free_inventory_capacity,":wagon_free_space","trp_loot_wagon_storage_1"),
				(ge,":wagon_free_space",1),
				(troop_add_item,"trp_loot_wagon_storage_1",":cur_item",":item_modifier"),
			(try_end),
		(try_end),
	]),	
	
#TEMPERED SCRIPT_loot_wagon_ai
  ("loot_wagon_ai",
    [	(party_get_slot,":loot_wagon","p_main_party","slot_party_loot_wagon"),
		(party_get_slot,":trade_town","p_main_party","slot_loot_wagon_target"),
		(party_set_slot, ":loot_wagon", "slot_party_ai_state", spai_trading_with_town),
		(party_set_slot,":loot_wagon","slot_party_ai_object",":trade_town"),
		(party_set_ai_behavior, ":loot_wagon", ai_bhvr_travel_to_party),
		(party_set_ai_object,":loot_wagon",":trade_town"),
		
	]),	

#TEMPERED SCRIPT_loot_wagon_trade
#input: loot wagon party
  ("loot_wagon_trade",
[	(store_script_param_1,":party_no"),
		(party_get_slot,":trade_town","p_main_party","slot_loot_wagon_target"),
		(party_get_slot,":wagon_leader","p_main_party","slot_party_wagon_leader"),
		(store_skill_level, ":trade_skill", "skl_trade", ":wagon_leader"),
		#(val_div,":trade_skill",2),
		#(val_max,":trade_skill",0),
		#(store_mul,":trade_skill_factor",":trade_skill",10),
		#(val_add,":trade_skill_factor",100),
		(troop_get_inventory_capacity,":wagon_capacity","trp_loot_wagon_storage_1"),
		(troop_sort_inventory,"trp_loot_wagon_storage_1"),
		(assign,":total_value",0),
		#(assign,"$g_encountered_party",":trade_town"), 
		(try_for_range,":slot",0,":wagon_capacity"), # Rewrote loot wagon code. TML. F123 - Submod -> 1.41 (Entire script)
			(troop_get_inventory_slot,":cur_item","trp_loot_wagon_storage_1",":slot"),
			(troop_get_inventory_slot_modifier, ":item_modifier", "trp_loot_wagon_storage_1", ":slot"),
			(gt,":cur_item",0),
			(assign, ":price_factor", 100),
      (assign, ":trade_penalty",0),
      (try_begin),
        (is_between, ":cur_item", trade_goods_begin, trade_goods_end),
        (assign, ":trade_penalty", 22),#gdw20
        (store_mul, ":skill_bonus", ":trade_skill", 2),#gdw2 easier to level up tradeskill
        (val_sub, ":trade_penalty", ":skill_bonus"),
		    (val_max, ":trade_penalty", 0),		
      (else_try),
        (assign, ":trade_penalty",75),#gdw80
        (store_mul, ":skill_bonus", ":trade_skill", 5),
        (val_sub, ":trade_penalty", ":skill_bonus"),
        	(val_max, ":trade_penalty", 5),
      (try_end),
      (try_begin),
        (is_between, ":cur_item", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":cur_item", trade_goods_begin),
        (val_add, ":item_slot_no", "slot_town_trade_good_prices_begin"),
        (party_get_slot, ":price_factor", ":trade_town", ":item_slot_no"),
        (store_sub, ":multiplier", ":price_factor", 12),#gdw30
        (val_mul, ":price_factor", 100),
        (val_div, ":price_factor", average_price_factor),
        (store_item_value, ":item_value", ":cur_item"),
        (try_begin),
          (ge, ":item_value", 100),
          (store_sub, ":item_value_sub_100", ":item_value", 100),
          (store_div, ":item_value_sub_100_div_8", ":item_value_sub_100", 8),
          (val_sub, ":multiplier", ":item_value_sub_100_div_8"),
        (try_end),
        (val_max, ":multiplier", minimum_price_factor),
        (party_set_slot, ":trade_town", ":item_slot_no", ":multiplier"),
      (else_try),
        #increase trade penalty while selling weapons, armor, and horses
        (val_mul, ":trade_penalty", 4),
      (try_end),  
      (store_add, ":penalty_divisor", 85, ":trade_penalty"),#gdw100
      (val_mul, ":price_factor", 100),
      (val_div, ":price_factor", ":penalty_divisor"),
			(call_script, "script_get_item_value_with_imod", ":cur_item", ":item_modifier"),
			(store_div, ":item_value", reg0, 100),
			(val_mul, ":item_value", ":price_factor"),
			(val_div, ":item_value", 100),
			(val_add,":total_value",":item_value"),
		(try_end),
		#selling prisoners
		(party_get_num_prisoner_stacks, ":num_stacks",":party_no"),
		(try_begin),
			(ge,":num_stacks",0),
			(try_for_range_backwards, ":stack_no", 0, ":num_stacks"),
				(party_prisoner_stack_get_troop_id, ":stack_troop",":party_no",":stack_no"),
				(store_character_level, ":troop_level",":stack_troop"),
				(assign, ":ransom_amount", ":troop_level"),
				(val_add, ":ransom_amount", 10), 
				(val_mul, ":ransom_amount", ":ransom_amount"),
				(val_div, ":ransom_amount", 6),
				(party_prisoner_stack_get_size, ":stack_size",":party_no",":stack_no"),
				(val_mul,":ransom_amount",":stack_size"),
				(val_add,":total_value",":ransom_amount"),
				(party_remove_prisoners,":party_no",":stack_troop",":stack_size"),
			(try_end),
		(try_end),
		
		#(val_mul,":total_value",":trade_skill_factor"),
		#(store_div,":total_change",":total_value",10),
		#(val_div,":total_change",100),
		#(val_div,":total_value",5), 
		#(val_div,":total_value",100),
		      #Adding tax revenue to the center
		#(party_get_slot, ":accumulated_tariffs", ":trade_town", "slot_center_accumulated_tariffs"),
		#(party_get_slot, ":prosperity", ":trade_town", "slot_town_prosperity"),
		#(store_add, ":tax_gain", ":prosperity", 10),
		#(val_mul, ":tax_gain", ":total_change"),
		#(val_div, ":tax_gain", 2200), #(10 + prosperity) / 110 * 5% of the merchant's revenue.
		#(val_add, ":accumulated_tariffs", ":tax_gain"),
		#(party_set_slot, ":trade_town", "slot_center_accumulated_tariffs", ":accumulated_tariffs"),
		#(assign,reg2,":tax_gain"),
		#(assign,reg3,":total_value"),
		(party_set_slot, ":party_no", "slot_center_accumulated_tariffs", ":total_value"), # Rewrote loot wagon code end. TML
		(troop_clear_inventory,"trp_loot_wagon_storage_1"),
		(assign,"$loot_wagon_trade_state",1),
	]),

#TEMPERED script_check_battle_consequence                          needs work
#CHECKS FOR CONSEQUENCES OF JOINING A BATTLE
#INPUT  ENEMY PARTY
	("check_battle_consequence",
		[	(store_script_param, ":enemy_party", 1),
			(store_faction_of_party,":enemy_faction",":enemy_party"),
			(party_stack_get_troop_id, ":leader",":enemy_party",0),
			(try_begin),#player is leader of faction
				(eq, "$players_kingdom", "fac_player_supporters_faction"),
				(faction_slot_eq, "fac_player_supporters_faction", "slot_faction_state", sfs_active),
				(try_begin),
					(eq,":enemy_faction","$players_kingdom"),
					(call_script,"script_change_player_party_morale",-30),
					(call_script,"script_change_player_honor",-20),
					(call_script, "script_objectionable_action", tmt_honest, "str_trechery"),
					(try_begin),
						(is_between,":leader",companions_begin,companions_end),
						(assign,"$npc_is_quitting",":leader"),#needs more work
					(else_try),
						(is_between,":leader",kingdom_heroes_begin,kingdom_heroes_end),
						(call_script, "script_cf_get_random_active_faction_except_player_faction_and_faction", -1),
						(troop_set_slot, ":leader", "slot_troop_change_to_faction", reg0),
					(try_end),
				(else_try),
					(store_relation, ":enemy_relation", ":enemy_faction", "fac_player_supporters_faction"),
					(lt,":enemy_relation",-5),
					(is_between,":leader",kingdom_heroes_begin,kingdom_heroes_end),
					(call_script, "script_diplomacy_start_war_between_kingdoms", "$players_kingdom", ":enemy_faction", logent_player_faction_declares_war),	#MOTO chief pass log entries
#					(call_script, "script_diplomacy_start_war_between_kingdoms", "$players_kingdom", ":enemy_faction", 1),
				(try_end),
			(else_try),#player is vassal fighting own faction
				(gt, "$players_kingdom", 0),
				(eq,":enemy_faction","$players_kingdom"),
				(call_script,"script_change_player_party_morale",-20),
				(call_script,"script_change_player_honor",-20),
				(call_script, "script_objectionable_action", tmt_honest, "str_trechery"),
				(faction_get_slot,":faction_leader",":enemy_faction","slot_faction_leader"),
				(call_script,"script_change_player_relation_with_troop",":faction_leader",-10),
			(else_try),#player is vassal 
				(gt, "$players_kingdom", 0),
				(neq,":enemy_faction","$players_kingdom"),
				(store_relation, ":enemy_relation", ":enemy_faction", "$players_kingdom"),
				(lt,":enemy_relation",0),
				(is_between,":leader",kingdom_heroes_begin,kingdom_heroes_end),
				(call_script, "script_diplomacy_start_war_between_kingdoms", "$players_kingdom", ":enemy_faction", logent_player_faction_declares_war),	#MOTO chief pass log entries
#				(call_script, "script_diplomacy_start_war_between_kingdoms", "$players_kingdom", ":enemy_faction", 1),
				(faction_get_slot,":faction_leader","$players_kingdom","slot_faction_leader"),
				(call_script,"script_change_player_relation_with_troop",":faction_leader",-10),
			(try_end),
		]),
		
#TEMPERED SCRIPT_PEASANT_APPROVAL

	("peasant_approval",
		[	
			(try_begin),
				(le,"$commoner_trust",-80),
				(str_store_string,s19,"@ Reaper of peasants"),
			(else_try),
				(is_between,"$commoner_trust",-80,-50),
				(str_store_string,s19,"@ Despised"),
			(else_try),
				(is_between,"$commoner_trust",-50,-30),
				(str_store_string,s19,"@ Disliked"),
			(else_try),
				(is_between,"$commoner_trust",-30,-10),
				(str_store_string,s19,"@ Untrusted"),
			(else_try),
				(is_between,"$commoner_trust",-10,10),
				(str_store_string,s19,"@ Indifferent"),
			(else_try),
				(is_between,"$commoner_trust",10,20),
				(str_store_string,s19,"@ Welcome Guest"),
			(else_try),
				(is_between,"$commoner_trust",20,40),
				(str_store_string,s19,"@ Friend"),
			(else_try),
				(is_between,"$commoner_trust",40,60),
				(str_store_string,s19,"@ Trusted Friend"),
			(else_try),
				(is_between,"$commoner_trust",60,100),
				(str_store_string,s19,"@ Hero"),
			(else_try),
				(ge,"$commoner_trust",100),
				(str_store_string,s19,"@ Patron Saint"),
			(try_end),
		]),
	
#TEMPERED SCRIPT_cf_has_wagon_parts
  ("cf_has_wagon_parts",
    [	(troop_get_inventory_capacity,":capacity","trp_player"),
		(assign,":no_pony_horses",0),
		(assign,":has_tools",0),
		(try_for_range,":slot",0,":capacity"),
			(troop_get_inventory_slot,":cur_item","trp_player",":slot"),
			(eq,":cur_item","itm_pony_horse"),
			(val_add,":no_pony_horses",1),
		(try_end),
		(try_begin),
			(lt,":no_pony_horses",2),
			(display_message,"@ You need 2 ponies to pull the wagon!!"),
		(try_end),
		(try_begin),
			(player_has_item,"itm_tools"),
			(assign,":has_tools",1),
		(else_try),
			(eq,":has_tools",0),
			(display_message,"@ You must have tools in inventory to build a wagon!!"),
		(try_end),
		(ge,":no_pony_horses",2),
		(player_has_item,"itm_tools"),
	]),
################chief tempered acaba##################  
#habilidades chel chief
    ("rage_exp_penalty",
    [(store_character_level,":level","trp_player"),
     (val_mul,":level",-12),
     (add_xp_to_troop,":level","trp_player"),
     (assign,reg1,":level"),
       (display_message, "@You spent {reg1} experience points.",0x6495ed),     
     ]),

    ("focus_exp_penalty",
    [(store_character_level,":level","trp_player"),
     (val_mul,":level",-14),
     (add_xp_to_troop,":level","trp_player"),
     (assign,reg1,":level"),
       (display_message, "@You spent {reg1} experience points.",0x6495ed),     
     ]),
#habilidades chel fin

#hablar prisioneros chief empieza
#MORDACHAI - update whether the specified prisoner would like to join the player's party
  # script_determine_prisoner_agreed
  # Input: arg1 = troop, arg2 = troop faction relation
  # Output: "slot_troop_prisoner_agreed" is set to 1 if they agreed, or 0 if not
  #         reg0 = agreed or not
  ("determine_prisoner_agreed",
    [
      (store_script_param, ":troop", 1),
      (store_script_param, ":relation", 2),

      # upper bound = Persuasion*3 + Charisma + Leadership*3 + Honor/2 + Renown/100
      (store_attribute_level, ":charisma", "trp_player", ca_charisma),
      (store_skill_level, ":persuasion", "skl_persuasion", "trp_player"),
      (store_skill_level, ":leadership", "skl_leadership", "trp_player"),
      (val_mul, ":persuasion", 4),
      (val_mul, ":leadership", 3),
      (store_div, ":half_honor", "$player_honor", 1),#gdw 
      (troop_get_slot, ":renown_factor", "slot_troop_renown"),
      (val_div, ":renown_factor", 100),
      (assign, ":upper_bound", ":persuasion"),
      (val_add, ":upper_bound", ":leadership"),
      (val_add, ":upper_bound", ":charisma"),
      (val_add, ":upper_bound", ":half_honor"),
      (val_add, ":upper_bound", ":renown_factor"),
      (val_min, ":relation", ":upper_bound"),

      # determine their reaction (relation...upper_bound)
      (store_random_in_range, ":reaction", ":relation", ":upper_bound"),
      (assign, reg1, ":reaction"),
      (assign, reg2, ":relation"),
      (assign, reg3, ":upper_bound"),
      #(display_message, "@Prisoner Agrees Check: rolled a {reg1} out of a possible {reg2}-{reg3}"),#diagnostic only

      # record whether they agree or not
      (try_begin),
        (ge, ":reaction", 0),
          (store_random_in_range, ":rand", 0, 3),
                                          (try_begin),
                                            (eq, ":rand", 0), 
        (troop_set_slot, ":troop", "slot_troop_prisoner_agreed", 1),
                                          (else_try),
        (troop_set_slot, ":troop", "slot_troop_prisoner_agreed", 0),
          (try_end),

#        (troop_set_slot, ":troop", "slot_troop_prisoner_agreed", 1),
      (else_try),
        (troop_set_slot, ":troop", "slot_troop_prisoner_agreed", 0),
      (try_end),

      # return the results
      (troop_get_slot, reg0, ":troop", "slot_troop_prisoner_agreed"),
      #(display_message, "@Prisoner Agrees Check: "slot_troop_prisoner_agreed" = {reg0?yes:no}"),#diagnostic only
    ]
  ),
#script hablar prisioneros end
############## JEDEDIAH Q chief START #################################################

# (lvl 2-12)  600,1360, 2296, 3426, 4768, 6345, 8179, 10297, 13010, 16161, 19806, 
# (lvl 13-21) 24007, 28832, 34362, 40682, 47892, 56103, 65441, 77233, 90809
# (lvl 22-31) 106425, 124371, 144981, 168636, 195769, 226879, 262533, 303381, 350164, 412091
  # script_jq_xp_to_next_lvl
  # Input: xp points
  # Output: none
  ("jq_xp_to_next_lvl",
    [
      (store_script_param, ":jq_xpvalue", 1),
	(try_begin),
             	(lt, ":jq_xpvalue",600),
		(assign, ":jq_xpvalue2", 600),
            (else_try),
		(lt, ":jq_xpvalue",1360),
   		(assign, ":jq_xpvalue2", 1360),
            (else_try),
		(lt, ":jq_xpvalue",2296),
   		(assign, ":jq_xpvalue2", 2296),
	    (else_try),
		(lt, ":jq_xpvalue",3426),
   		(assign, ":jq_xpvalue2", 3426),
	    (else_try),
		(lt, ":jq_xpvalue",4768),
   		(assign, ":jq_xpvalue2", 4768),
	    (else_try),
		(lt, ":jq_xpvalue",6345),
   		(assign, ":jq_xpvalue2", 6345),
	    (else_try),
		(lt, ":jq_xpvalue",8179),
   		(assign, ":jq_xpvalue2", 8179),
	    (else_try),
		(lt, ":jq_xpvalue",10297),
   		(assign, ":jq_xpvalue2", 10297),
	    (else_try),
		(lt, ":jq_xpvalue",13010),
   		(assign, ":jq_xpvalue2", 13010),
	    (else_try),
		(lt, ":jq_xpvalue",16161),
   		(assign, ":jq_xpvalue2", 16161),
	    (else_try),
		(lt, ":jq_xpvalue",19806),
   		(assign, ":jq_xpvalue2", 19806),
	    (else_try),
		(lt, ":jq_xpvalue",24007),
   		(assign, ":jq_xpvalue2", 24007),
	    (else_try),
		(lt, ":jq_xpvalue",28832),
   		(assign, ":jq_xpvalue2", 28832),
	    (else_try),
		(lt, ":jq_xpvalue",34362),
   		(assign, ":jq_xpvalue2", 34362),
	    (else_try),
		(lt, ":jq_xpvalue",40682),
   		(assign, ":jq_xpvalue2", 40682),
	    (else_try),
		(lt, ":jq_xpvalue",47892),
   		(assign, ":jq_xpvalue2", 47892),
	    (else_try),
		(lt, ":jq_xpvalue",56103),
   		(assign, ":jq_xpvalue2", 56103),
	    (else_try),
		(lt, ":jq_xpvalue",65441),
   		(assign, ":jq_xpvalue2", 65441),
	    (else_try),
		(lt, ":jq_xpvalue",77233),
   		(assign, ":jq_xpvalue2", 77233),
	    (else_try),
		(lt, ":jq_xpvalue",90809),
   		(assign, ":jq_xpvalue2", 90809),
	    (else_try),
		(lt, ":jq_xpvalue",106425),
   		(assign, ":jq_xpvalue2", 106425),
	    (else_try),
		(lt, ":jq_xpvalue",124371),
   		(assign, ":jq_xpvalue2", 124371),
	    (else_try),
		(lt, ":jq_xpvalue",144981),
   		(assign, ":jq_xpvalue2", 144981),
	    (else_try),
		(lt, ":jq_xpvalue",168636),
   		(assign, ":jq_xpvalue2", 168636),
	    (else_try),
		(lt, ":jq_xpvalue",195769),
   		(assign, ":jq_xpvalue2", 195769),
	    (else_try),
		(lt, ":jq_xpvalue",226879),
   		(assign, ":jq_xpvalue2", 226879),
	    (else_try),
		(lt, ":jq_xpvalue",262533),
   		(assign, ":jq_xpvalue2", 262533),
	    (else_try),
		(lt, ":jq_xpvalue",303381),
   		(assign, ":jq_xpvalue2", 303381),
	    (else_try),
		(lt, ":jq_xpvalue",350164),
   		(assign, ":jq_xpvalue2", 350164),
	    (else_try),
		(lt, ":jq_xpvalue",412091),
   		(assign, ":jq_xpvalue2", 412091),

  						# Feel free to continue from here on. I'm just lazy...

            (try_end),
		(store_sub, reg1, ":jq_xpvalue2", ":jq_xpvalue"),		
		(str_store_string, s1, "@{reg1}"),
    ]),
  # ----------------------------------------------------------------------------------------------------------- 
  # -----------------------------------------------------------------------------------------------------------
  # script_jq_extra_stats - get extra info about the selected hero in 'Companions Overview'
  # Input: Selected hero, Morale slot nr in 'trp_temp_array_c'
  # Output: none
  ("jq_extra_stats",
    [
      	(store_script_param, ":jq_troop_no", 1),
	(store_script_param, ":jq_morl", 2),
	(assign, reg5, ":jq_morl"),
	(assign, "$jq_last_checked_hero", ":jq_troop_no"), 
      	(str_store_troop_name, s9, ":jq_troop_no"),
	(store_troop_health , reg2, ":jq_troop_no"),  
	(store_character_level, reg3, ":jq_troop_no"),
	(troop_get_slot, reg4, "trp_temp_array_c", ":jq_morl"), 
	(str_store_string, s1, "@{s9}^^^Level: {reg3}^Health: {reg2}%^Morale: {reg4}"), 
	#(str_store_string, s1, "@{s9}^^^Level: {reg3}^Health: {reg2}%^Morale: {reg4} jq_morl: {reg5}"), 
	(overlay_set_text, "$g_jq_equipment_status", s1),

    (try_for_range, ":jq_cur_slot", 0, 8),#equipment slots
	  	(troop_get_inventory_slot, reg1, ":jq_troop_no", ":jq_cur_slot"),
	 (try_begin),
	  	(lt, reg1, 1), # if item slot is empty...
	  	(str_store_string, s8, "@________________n/a________________"),
	 (else_try),	
	  	(str_store_item_name, s8, reg1),
	 (try_end),
		(try_begin),
	  	(eq, ":jq_cur_slot", 0), 
		(overlay_set_text, "$g_jq_equipment_item0", s8),
		(else_try),
	  	(eq, ":jq_cur_slot", 1), 
		(overlay_set_text, "$g_jq_equipment_item1", s8),
		(else_try),
	  	(eq, ":jq_cur_slot", 2), 
		(overlay_set_text, "$g_jq_equipment_item2", s8),
		(else_try),
	  	(eq, ":jq_cur_slot", 3), 
		(overlay_set_text, "$g_jq_equipment_item3", s8),
		(else_try),
		(eq, ":jq_cur_slot", 4), 
		(overlay_set_text, "$g_jq_equipment_item4", s8),#head
		(else_try),
		(eq, ":jq_cur_slot", 5), 
		(overlay_set_text, "$g_jq_equipment_item5", s8),#body
		(else_try),
		(eq, ":jq_cur_slot", 6), 
		(overlay_set_text, "$g_jq_equipment_item6", s8),#feet
		(else_try),
		(eq, ":jq_cur_slot", 7), 
		(overlay_set_text, "$g_jq_equipment_item7", s8),#hands
		(try_end),
    (try_end), # try-for-range-loop-end
 		(set_result_string, s8),
		 ]),
# --------------------------------------------------------------------------------------
  # script_jq_browse - browse thru party in 'extended view'
  # INPUT:
  # param1: selected hero (":dude")
  # param2: slot nr
  # Output: All
 ("jq_browse",
    [

      	(store_script_param, ":jq_troop_no", 1),
	(assign, "$jq_last_checked_hero", ":jq_troop_no"), 

	(str_store_troop_name, s9, "$jq_dude"),
	(overlay_set_text, "$jq_troop_name", s9),

	(str_store_string, s9, "@{s9} feels..."),
        (overlay_set_text, "$jq_mrlc", s9),
	(call_script, "script_npc_morale", "$jq_dude"),
	(overlay_set_text,  "$jq_feeling1", s6),
	(overlay_set_text,  "$jq_feeling2", s7),
	(overlay_set_text,  "$jq_feeling3", s8),
 	(troop_get_slot, ":home", "$jq_dude", "slot_troop_home"),
        (str_store_party_name, 21, ":home"),
	(str_store_string, s9, "@Morale: {reg0}^^Origin: {s21}"),
	(overlay_set_text,  "$jq_comphome", s9),
	(try_begin), 
        (troop_is_mounted,  "$jq_dude"),
	(str_store_string, s1, "@State: Riding"),
	(else_try),
	(str_store_string, s1, "@State: On foot"),
	(try_end), 
	(overlay_set_text,  "$jq_state", s1),

	#Draw the troop
	(overlay_set_alpha, "$jq_portrait", 0xFF),
  	(set_fixed_point_multiplier, 1000),
	(position_set_x, pos1, 1150),
        (position_set_y, pos1, 1150),
        (overlay_set_size, "$jq_portrait", pos1),
	(position_set_x, pos1, 10),
        (position_set_y, pos1, 295),
	(position_set_z, pos1, 170),
       	(overlay_set_position, "$jq_portrait", pos1),
	
		(store_attribute_level, reg1, "$jq_dude", ca_strength),
		(str_store_string, s1, "@_{reg1}_"),
		(overlay_set_text, "$jqregstr", s1),

		(store_attribute_level, reg1, "$jq_dude", ca_agility),
		(str_store_string, s1, "@_{reg1}_"),
		(overlay_set_text, "$jqregagi", s1),

		(store_attribute_level, reg1, "$jq_dude", ca_intelligence),
		(str_store_string, s1, "@_{reg1}_"),
		(overlay_set_text, "$jqregint", s1),
          	
		(store_attribute_level, reg1, "$jq_dude", ca_charisma),
		(str_store_string, s1, "@_{reg1}_"),
		(overlay_set_text, "$jqregcha", s1),

		(store_troop_health, reg1,  "$jq_dude"),  
		(str_store_string, s1, "@_{reg1}%"),
		(overlay_set_text, "$jqhealth", s1),

		(store_character_level, reg1, "$jq_dude"),
 		(str_store_string, s1, "@_{reg1}_"),
		(overlay_set_text, "$jqreglvl", s1),

		(troop_get_xp, ":jqreg", "$jq_dude"),
		(call_script, "script_jq_xp_to_next_lvl", ":jqreg"),
		(overlay_set_text, "$jqtonextlvl", s1),

		# Skills Values
       		(str_clear, s1),
	 (try_for_range_backwards, reg1, 0, 37),
		(neg|is_between, reg1, 3, 7),
		(neg|is_between, reg1, 18, 22),
		(neg|is_between, reg1, 28, 33),
		(store_skill_level, reg2, reg1, "$jq_dude"),
		(str_store_string, s1, "@{s1}^{reg2}"),
		(overlay_set_text, "$jq_allskills",  s1),	
	(try_end),

		#PROFICIENCIES #spelling contest
		(str_clear, s1),
		(store_proficiency_level,  reg1, "$jq_dude", wpt_one_handed_weapon),
		(str_store_string, s1, "@{s1}^^{reg1}"),
		(store_proficiency_level,  reg1, "$jq_dude", wpt_two_handed_weapon),
		(str_store_string, s1, "@{s1}^^{reg1}"),	
		(store_proficiency_level,  reg1, "$jq_dude", wpt_polearm),
		(str_store_string, s1, "@{s1}^^{reg1}"),
		(store_proficiency_level,  reg1, "$jq_dude", wpt_archery),
		(str_store_string, s1, "@{s1}^^{reg1}"),
		(store_proficiency_level,  reg1, "$jq_dude", wpt_crossbow),
		(str_store_string, s1, "@{s1}^^{reg1}"),
		(store_proficiency_level,  reg1, "$jq_dude", wpt_throwing),
		(str_store_string, s1, "@{s1}^^{reg1}"),
#		(store_proficiency_level,  reg1, "$jq_dude", wpt_firearm),
#		(str_store_string, s1, "@{s1}^^{reg1}"),
		(overlay_set_text, "$jq_allprofs",  s1),	
		
       (try_for_range, ":jq_cur_slot", 0, 8),#equipment slots
	  	(troop_get_inventory_slot, reg1, "$jq_dude", ":jq_cur_slot"),
	 (try_begin),
	  	(lt, reg1, 1), # if item slot is empty...
	  	(str_store_string, s8, "@n/a________________________________"),
	 (else_try),	
	  	(str_store_item_name, s8, reg1),
	 (try_end),
		(try_begin),
	  	(eq, ":jq_cur_slot", 0), 
		(overlay_set_text, "$g_jq_equipment_item0", s8),
		(else_try),
	  	(eq, ":jq_cur_slot", 1), 
		(overlay_set_text, "$g_jq_equipment_item1", s8),
		(else_try),
	  	(eq, ":jq_cur_slot", 2), 
		(overlay_set_text, "$g_jq_equipment_item2", s8),
		(else_try),
	  	(eq, ":jq_cur_slot", 3), 
		(overlay_set_text, "$g_jq_equipment_item3", s8),
		(else_try),
		(eq, ":jq_cur_slot", 4), 
		(overlay_set_text, "$g_jq_equipment_item4", s8),# head
		(else_try),
		(eq, ":jq_cur_slot", 5), 
		(overlay_set_text, "$g_jq_equipment_item5", s8),# body
		(else_try),
		(eq, ":jq_cur_slot", 6), 
		(overlay_set_text, "$g_jq_equipment_item6", s8),# feet
		(else_try),
		(eq, ":jq_cur_slot", 7), 
		(overlay_set_text, "$g_jq_equipment_item7", s8),# hands
		(try_end),
    (try_end), # try-for-range-loop-end
   	

   ]),
############## JEDEDIAH Q END #################################################

  #chief prisioneros trabajando en las minas empieza
  # Working in the mines
  ("mine_work",
   [(assign, ":party_no", "p_main_party"),
    (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
    (store_random_in_range, ":random", 0, 10),
    (try_begin),
      (le, ":random", 3),
	  (troop_set_health, "trp_player", 80),
	(else_try),
	  (eq, ":random", 4),
	  (troop_set_health, "trp_player", 70),
	  (store_random_in_range, ":random_gold", 0, 15),
	  (try_begin),
	    (le, ":random_gold", 5),
      (display_message, "@While working in the mine, you found a new salt deposit and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 10, 100),
      (troop_add_gold, "trp_player", ":random_amount"),
     (else_try),
       (eq, ":random_gold", 6),
      (display_message, "@While working in the mine, you found an iron deposit and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 50, 200),
      (troop_add_gold, "trp_player", ":random_amount"),
     (else_try),
       (eq, ":random_gold", 7),
      (display_message, "@While working in the mine, you found a silver deposit and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 75, 300),
      (troop_add_gold, "trp_player", ":random_amount"),
     (else_try),
       (eq, ":random_gold", 8 ),
      (display_message, "@While working in the mine, you found a gold deposit and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 100, 400),
      (troop_add_gold, "trp_player", ":random_amount"),
     (else_try),
       (eq, ":random_gold", 9),
      (display_message, "@While working in the mine, you found a deposit of rare minerals and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 150, 500),
      (troop_add_gold, "trp_player", ":random_amount"),
     (try_end),
    (else_try),
	  (eq, ":random", 5),
	  (troop_set_health, "trp_player", 50),
	  (display_message, "@While working in the mine, you were injured during a minor cave-in.", 0xFF0000),
	(else_try),
	  (eq, ":random", 6),
	  (troop_set_health, "trp_player", 30),
	  (display_message, "@While working in the mine, you were hurt during a cave-in.", 0xFF0000),
	(else_try),
	  (eq, ":random", 7),
	  (troop_set_health, "trp_player", 1),
	  (display_message, "@While working in the mine, you were nearly killed during a cave-in.", 0xFF0000),
	(else_try),
	  (eq, ":random", 8),
	  (try_begin),
	    (gt, ":num_stacks", 0),
	    (call_script, "script_party_wound_all_members", ":party_no"),
	    (display_message, "@While working in the mine, your party was wounded during a cave-in.", 0xFF0000),
        (call_script, "script_change_player_party_morale", -1),
	  (else_try),
	    (troop_set_health, "trp_player", 1),
	    (display_message, "@While working in the mine, you were nearly killed during a cave-in.", 0xFF0000),
	  (try_end),
	(else_try),
	  (try_begin),
	    (gt, ":num_stacks", 0),
		(store_random_in_range, ":random_deaths", 10, 21),
        (inflict_casualties_to_party_group, ":party_no", ":random_deaths", "p_temp_casualties"),
        (call_script, "script_print_casualties_to_s0", "p_temp_casualties", 0),
		(str_store_string_reg, s8, s0),
		(display_message, "@While working in the mine, a cave-in badly injured your party.", 0xFF0000),
		(display_message, "@Casualities:{s8}", 0xFF0000),
		(call_script, "script_party_wound_all_members", ":party_no"),
		(call_script, "script_change_player_party_morale", -3),
	  (else_try),
	    (troop_set_health, "trp_player", 1),
	    (display_message, "@While working in the mine, you were nearly killed during a cave-in.", 0xFF0000),
	  (try_end),
	(try_end),
  ]),
#chief, prisioneros trabajando en las minas acaba
  #trabajar en quarry
    ("mine_work2",
   [(assign, ":party_no", "p_main_party"),
    (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
    (store_random_in_range, ":random", 0, 10),
    (try_begin),
      (le, ":random", 3),
	  (troop_set_health, "trp_player", 80),
	(else_try),
	  (eq, ":random", 4),
	  (troop_set_health, "trp_player", 70),
	  (store_random_in_range, ":random_gold", 0, 15),
	  (try_begin),
	    (le, ":random_gold", 5),
      (display_message, "@While working in the quarry, you get stone and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 10, 100),
      (troop_add_gold, "trp_player", ":random_amount"),
     (else_try),
       (eq, ":random_gold", 6),
      (display_message, "@While working in the quarry, you found an iron deposit and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 50, 200),
      (troop_add_gold, "trp_player", ":random_amount"),
     (else_try),
       (eq, ":random_gold", 7),
      (display_message, "@While working in the quarry, you found a silver deposit and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 75, 300),
      (troop_add_gold, "trp_player", ":random_amount"),
     (else_try),
       (eq, ":random_gold", 8 ),
      (display_message, "@While working in the quarry, you found a gold deposit and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 100, 400),
      (troop_add_gold, "trp_player", ":random_amount"),
     (else_try),
       (eq, ":random_gold", 9),
      (display_message, "@While working in the quarry, you found a deposit of rare minerals and are rewarded for the discovery."),
      (store_random_in_range, ":random_amount", 150, 500),
      (troop_add_gold, "trp_player", ":random_amount"),
     (try_end),
    (else_try),
	  (eq, ":random", 5),
	  (troop_set_health, "trp_player", 50),
	  (display_message, "@While working in the quarry, you were injured during a minor cave-in.", 0xFF0000),
	(else_try),
	  (eq, ":random", 6),
	  (troop_set_health, "trp_player", 30),
	  (display_message, "@While working in the quarry, you were hurt during a cave-in.", 0xFF0000),
	(else_try),
	  (eq, ":random", 7),
	  (troop_set_health, "trp_player", 1),
	  (display_message, "@While working in the quarry, you were nearly killed during a cave-in.", 0xFF0000),
	(else_try),
	  (eq, ":random", 8),
	  (try_begin),
	    (gt, ":num_stacks", 0),
	    (call_script, "script_party_wound_all_members", ":party_no"),
	    (display_message, "@While working in the mine, your party was wounded during a cave-in.", 0xFF0000),
        (call_script, "script_change_player_party_morale", -2),
	  (else_try),
	    (troop_set_health, "trp_player", 1),
	    (display_message, "@While working in the mine, you were nearly killed during a cave-in.", 0xFF0000),
	  (try_end),
	(else_try),
	  (try_begin),
	    (gt, ":num_stacks", 0),
		(store_random_in_range, ":random_deaths", 10, 21),
        (inflict_casualties_to_party_group, ":party_no", ":random_deaths", "p_temp_casualties"),
        (call_script, "script_print_casualties_to_s0", "p_temp_casualties", 0),
		(str_store_string_reg, s8, s0),
		(display_message, "@While working in the quarry, a cave-in badly injured your party.", 0xFF0000),
		(display_message, "@Casualities:{s8}", 0xFF0000),
		(call_script, "script_party_wound_all_members", ":party_no"),
		(call_script, "script_change_player_party_morale", -5),
	  (else_try),
	    (troop_set_health, "trp_player", 1),
	    (display_message, "@While working in the quarry, you were nearly killed during a cave-in.", 0xFF0000),
	  (try_end),
	(try_end),
  ]),
#trabajar en quarry acaba chief
#chief flirteo con damas y otras mujeres
  #Flirt
("flirt",
    [
	 (str_clear, s20),
	 (str_clear, s21),
	 (str_store_troop_name, s21, "$g_talk_troop"),
     (store_skill_level, ":skill", "skl_persuasion", "trp_player"),
     (store_attribute_level, ":charisma", "trp_player", ca_charisma),
	 (try_begin),
	   (eq, "$flirt_action", 1),
	   (try_begin),
	     (this_or_next|ge, ":skill", 1),
		 (             ge, ":charisma", 6),
             (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 2),
		 (str_store_string, s20, "@{s21} smiles and winks back.^Your relation with {s21} increased by 2."),
	   (else_try),
		 (str_store_string, s20, "@{s21} rolls his/her eyes and looks annoyed."),
	   (try_end),
	 (else_try),
	   (eq, "$flirt_action", 2),
	   (try_begin),
	     (this_or_next|ge, ":skill", 2),
		 (             ge, ":charisma", 9),
                   (call_script, "script_troop_get_relation_with_troop", "$g_talk_troop","trp_player", 5),
		 (store_random_in_range, ":random", 0, 5),
		 (try_begin),
		   (eq, ":random", 0),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -1),
		   (str_store_string, s20, "@{s21} did not understand your joke.^Your relation with {s21} decreased by 1."),
		 (else_try),
		   (eq, ":random", 1),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 2),
		   (str_store_string, s20, "@{s21} was amused by your joke, but did not laugh.^Your relation with {s21} increased by 2."),
		 (else_try),
		   (eq, ":random", 2),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -2),
		   (str_store_string, s20, "@{s21} thought your joke was stupid.^Your relation with {s21} decreased by 2."),
		 (else_try),
		   (eq, ":random", 3),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 4),
		   (str_store_string, s20, "@{s21} laughed out loud at your joke.^Your relation with {s21} increased by 4."),
		 (else_try),
		   (eq, ":random", 4),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 6),
		   (str_store_string, s20, "@{s21} laughs and jumps.^Your relation with {s21} increased by 6."),
		 (try_end),
       (else_try),
		 (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -10),
		 (str_store_string, s20, "@{s21} was offended by your joke.^Your relation with {s21} decreased by 10. You should improve your relationship, charisma and persuasive."),
	   (try_end),
	 (else_try),
	   (eq, "$flirt_action", 3),
	   (try_begin),
	     (this_or_next|ge, ":skill", 3),
		 (             ge, ":charisma", 11),
                   (call_script, "script_troop_get_relation_with_troop", "$g_talk_troop", "trp_player",15),
		 (store_random_in_range, ":random", 0, 5),
		 (try_begin),
		   (eq, ":random", 0),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -1),
		   (str_store_string, s20, "@{s21} did not find your compliment flattering.^Your relation with {s21} decreased by 1."),
		 (else_try),
		   (eq, ":random", 1),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 4),
		   (str_store_string, s20, "@{s21} smiles and thanks you for the compliment.^Your relation with {s21} increased by 4."),
		 (else_try),
		   (eq, ":random", 2),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -2),
		   (str_store_string, s20, "@{s21} rolls his/her eyes and looks annoyed.^Your relation with {s21} decreased by 2."),
		 (else_try),
		   (eq, ":random", 3),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 6),
		   (str_store_string, s20, "@{s21} blushes noticeably, but smiles and thanks you for the compliment.^Your relation with {s21} increased by 6."),
		 (else_try),
		   (eq, ":random", 4),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 6),
		   (str_store_string, s20, "@{s21} smiles, flushed.^Your relation with {s21} increased by 6."),
		 (try_end),
       (else_try),
		 (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -15),
		 (str_store_string, s20, "@{s21} was offended by your compliment.^Your relation with {s21} decreased by 15. maybe you should improve your relationship, charisma and persuasive"),
	   (try_end),
	 (else_try),
	   (eq, "$flirt_action", 4),
	   (try_begin),
	     (this_or_next|ge, ":skill", 3),
		 (             ge, ":charisma", 13),
                   (call_script, "script_troop_get_relation_with_troop", "$g_talk_troop","trp_player", 25),
		 (store_random_in_range, ":random", 0, 5),
		 (try_begin),
		   (eq, ":random", 0),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -1),
		   (str_store_string, s20, "@{s21} pulls his/her hand away before you can kiss it.^Your relation with {s21} decreased by 1."),
		 (else_try),
		   (eq, ":random", 1),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 6),
		   (str_store_string, s20, "@{s21} allows you to kiss his/her hand but shows no noticeable reaction.^Your relation with {s21} increased by 6."),
		 (else_try),
		   (eq, ":random", 2),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -2),
		   (str_store_string, s20, "@{s21} allows you to kiss his/her hand but looks disgusted.^Your relation with {s21} decreased by 2."),
		 (else_try),
		   (eq, ":random", 3),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 8),
		   (str_store_string, s20, "@{s21} blushes noticeably when you kiss his/her hand.^Your relation with {s21} increased by 8."),
		 (else_try),
		   (eq, ":random", 4),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 10),
		   (str_store_string, s20, "@{s21} pulls his/her eyes closed, allows you to long kiss.^Your relation with {s21} increased by 10."),
		 (try_end),
       (else_try),
		 (call_script, "script_change_player_relation_with_troop", "$g_talk_troop","trp_player", -20),
		 (str_store_string, s20, "@{s21} pulls his/her hand away before you can kiss it, and slaps you.^Your relation with {s21} decreased by 4. maybe you should improve your relationship, charisma and persuasive."),
	   (try_end),
	 (else_try),
	   (eq, "$flirt_action", 5),
	   (try_begin),
	     (this_or_next|ge, ":skill", 4),
		 (             ge, ":charisma", 14),
                   (call_script, "script_troop_get_relation_with_troop", "$g_talk_troop","trp_player", 40),
		 (store_random_in_range, ":random", 0, 5),
		 (try_begin),
		   (eq, ":random", 0),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -4),
		   (str_store_string, s20, "@{s21} holds out a restraining hand and tells you to back off.^Your relation with {s21} decreased by 4."),
		 (else_try),
		   (eq, ":random", 1),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 8),
		   (str_store_string, s20, "@{s21} allows you to kiss his/her cheek but seems a bit uncomfortable.^Your relation with {s21} increased by 8."),
		 (else_try),
		   (eq, ":random", 2),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -4),
		   (str_store_string, s20, "@{s21} pushes you away and tells you to leave {s37} alone.^Your relation with {s21} decreased by 4."),
		 (else_try),
		   (eq, ":random", 3),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 10),
		   (str_store_string, s20, "@{s21} blushes noticeably when you kiss his/her cheek.^Your relation with {s21} increased by 10."),
		 (else_try),
		   (eq, ":random", 4),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 12),
		   (str_store_string, s20, "@{s21} laughs and blushes noticeably when you kiss.^Your relation with {s21} increased by 12."),
		 (try_end),
       (else_try),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -30),
		 (str_store_string, s20, "@{s21} pushes you away and slaps you.^Your relation with {s21} decreased by 30. maybe you should improve your relationship, charisma and persuasive."),
	   (try_end),
	 (else_try),
	   (eq, "$flirt_action", 6),
	   (try_begin),
	     (this_or_next|ge, ":skill", 4),
		 (             ge, ":charisma", 16),
                   (call_script, "script_troop_get_relation_with_troop", "$g_talk_troop","trp_player", 60),
		 (store_random_in_range, ":random", 0, 5),
		 (try_begin),
		   (eq, ":random", 0),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -4),
		   (str_store_string, s20, "@{s21} holds out a restraining hand and tells you to back off.^Your relation with {s21} decreased by 4."),
		 (else_try),
		   (eq, ":random", 1),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 10),
		   (str_store_string, s20, "@{s21} allows you to kiss {s37} but seems a bit uncomfortable.^Your relation with {s21} increased by 10."),
		 (else_try),
		   (eq, ":random", 2),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 12),
		   (str_store_string, s20, "@{s21} laughs and allows you to kiss {s37} alone.^Your relation with {s21} increased by 12."),
		 (else_try),
		   (eq, ":random", 3),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 14),
		   (str_store_string, s20, "@{s21} embraces you enthusiastically as you kiss he/she on the lips.^Your relation with {s21} increased by 14."),
		 (else_try),
		   (eq, ":random", 4),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 16),
		   (str_store_string, s20, "@{s21} embraces you enthusiastically as you kiss, long time.^Your relation with {s21} increased by 16."),
		 (try_end),
       (else_try),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -35),
		 (str_store_string, s20, "@{s21} holds out a restraining hand and tells you to back off.^Your relation with {s21} decreased by 35. maybe you should improve your relationship, charisma and persuasive."),
	   (try_end),
	 (else_try),
	   (eq, "$flirt_action", 7),
	   (try_begin),
	     (this_or_next|ge, ":skill", 5),
		 (             ge, ":charisma", 17),
                   (call_script, "script_troop_get_relation_with_troop", "$g_talk_troop","trp_player", 60),
		 (store_random_in_range, ":random", 0, 5),
		 (try_begin),
		   (eq, ":random", 0),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -4),
		   (str_store_string, s20, "@As you grab behind, {s21} slaps your hand away and tells you to mind your manners.^Your relation with {s21} decreased by -4."),
		 (else_try),
		   (eq, ":random", 1),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop",10),
		   (str_store_string, s20, "@As you grab behind, {s21} slaps your hand away with a smile and tells you to behave yourself.^Your relation with {s21} increased by 10."),
		 (else_try),
		   (eq, ":random", 2),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 12),
		   (str_store_string, s20, "@As you grab behind, {s21} allows you.^Your relation with {s21} increased by 12."),
		 (else_try),
		   (eq, ":random", 3),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop",14),
		   (str_store_string, s20, "@As you grab behind, {s21} smiles playfully and tells you to behave yourself or {s21}'ll have to punish you.^Your relation with {s21} increased by 14."),
		 (else_try),
		   (eq, ":random", 4),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 16),
		   (str_store_string, s20, "@As you grab behind, {s21} laughs.^Your relation with {s21} increased by 16."),
		 (try_end),
       (else_try),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -35),
		 (str_store_string, s20, "@As you grab behind, {s21} slaps your hand away and punches you in the face.^Your relation with {s21} decreased by 35. maybe you should improve your relationship, charisma and persuasive."),
	   (try_end),
	 (else_try),
	   (eq, "$flirt_action", 8),
	   (try_begin),
	     (ge, ":skill", 5),
		 (ge, ":charisma", 19),
                   (call_script, "script_troop_get_relation_with_troop", "$g_talk_troop","trp_player", 80),
		 (store_random_in_range, ":random", 0, 6),
		 (try_begin),
		   (eq, ":random", 0),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -1),
		   (str_store_string, s20, "@You try to convince {s21} to go your room with you, but {s21} tells you that she's too busy.^Your relation with {s21} decreased by 1."),
		 (else_try),
		   (eq, ":random", 1),
		   (str_store_string, s20, "@You do your best sweet-talking and convince {s21} to go your room with you.^Unfortunately, {s21} has a headache.^Your relation with {s21} remains unchanged."),
		 (else_try),
		   (eq, ":random", 2),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", -2),
		   (str_store_string, s20, "@You do your best sweet-talking and convince {s21} to go your room with you.^Unfortunately, {s21} is tired.^Your relation with {s21} decreased by 2."),
		 (else_try),
		   (eq, ":random", 3),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop", 6),
		   (str_store_string, s20, "@You do your best sweet-talking and convince {s21} to go your room with you.^{s21} was impressed with your performance, but {s21} said that you ask in a few days.^Your relation with {s21} increased by 6."),
		 (else_try),
		   (eq, ":random", 4),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop",3),
		   (str_store_string, s20, "@You do your best sweet-talking and try to convince {s21} to go your room with you,^{s21} kisses you, embraces you and tells you that better tomorrow.^Your relation with {s21} increased by 3."),
		 (else_try),
		   (eq, ":random", 5),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop",50),
		   (str_store_string, s20, "@You do your best sweet-talking and convince {s21} to go your room with you.^{s21} jump with joy and let it! Today is your day. ^Your relation with {s21} increased by 50."),
		 (try_end),
       (else_try),
		   (call_script, "script_change_player_relation_with_troop", "$g_talk_troop",-35),
		 (str_store_string, s20, "@You try to convince {s21} to go your room with you, but {s21} tells you that {s21}is offended by your advances and slaps you.^Your relation with {s21} decreased by 35. You should improve your relationship, charisma and persuasive."),
	   (try_end),
	 (try_end),
##	 (troop_set_slot,"$g_talk_troop","slot_troop_player_relation","$player_relations"),
	 (troop_set_slot, "$g_talk_troop", "slot_troop_flirted_with", 1),
    ]), 
#Flirt end
#flirteo acaba
##CC chief horse stamina y minimap
    # script_update_order_panel_map
  # Input: none
  # Output: none
  ("update_order_panel_map",
   [
    # Horse Stamina
    (get_player_agent_no, ":player_agent"),
    (agent_get_horse, ":horse_agent", ":player_agent"),
    (try_begin),
      (ge, ":horse_agent", 0),
      (agent_get_slot, ":horse_stamina", ":player_agent", "slot_agent_horse_stamina"),
      (store_agent_hit_points, ":horse_hp", ":horse_agent"),
      (assign, reg1, ":horse_stamina"),
      (assign, reg2, ":horse_hp"),
#      (overlay_set_text, "$g_presentation_obj_40", "@Horse Stamina: {reg1}/{reg2}"),
#      (overlay_set_alpha, "$g_presentation_obj_40", 0xFF),
    (else_try),
#      (overlay_set_alpha, "$g_presentation_obj_40", 0),
    (try_end),
  ]),
#CC chief horse stamina acaba
### CC chief final arbol de tropas
  ("get_troop_max_hp",
   [
    (store_script_param_1, ":troop"),

    (store_skill_level, ":skill", skl_ironflesh, ":troop"),
    (store_attribute_level, ":attrib", ":troop", ca_strength),
    (val_mul, ":skill", 2),
    (val_add, ":skill", ":attrib"),
    (val_add, ":skill", 35),
    (assign, reg0, ":skill"),
  ]),
  
  ("sell_all_prisoners",
   [
    (assign, ":total_income", 0),
    (party_get_num_prisoner_stacks, ":num_stacks", "p_main_party"),
    (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
      (party_prisoner_stack_get_troop_id, ":troop_no", "p_main_party", ":i_stack"),
      (neg|troop_is_hero, ":troop_no"),
      (party_prisoner_stack_get_size, ":stack_size", "p_main_party", ":i_stack"),
      (call_script, "script_game_get_prisoner_price", ":troop_no"),
      (assign, ":sell_price", reg0),
      (store_mul, ":stack_total_price", ":sell_price", ":stack_size"),
      (val_add, ":total_income", ":stack_total_price"),
      (party_remove_prisoners, "p_main_party", ":troop_no", ":stack_size"),
    (try_end),
    (troop_add_gold, "trp_player", ":total_income"),
  ]),
  
  ("prsnt_upgrade_tree_ready",
    [
      (store_script_param, ":faction_no", 1),
  
      ## next presentation
      (assign, "$g_presentation_next_presentation", -1),
    
      ## pre page
      (create_image_button_overlay, "$g_presentation_obj_1", "mesh_left_button_hl", "mesh_left_button_down"),
      (position_set_x, pos1, 300),
      (position_set_y, pos1, 670),
      (overlay_set_position, "$g_presentation_obj_1", pos1),
  
      ## next page
      (create_image_button_overlay, "$g_presentation_obj_2", "mesh_right_button_hl", "mesh_right_button_down"),
      (position_set_x, pos1, 656),
      (position_set_y, pos1, 670),
      (overlay_set_position, "$g_presentation_obj_2", pos1),
      
      ## pre page commom button
      (create_mesh_overlay, "$g_presentation_obj_3", "mesh_left_button"),
      (position_set_x, pos1, 300),
      (position_set_y, pos1, 670),
      (overlay_set_position, "$g_presentation_obj_3", pos1),
      
      ## next page commom button
      (create_mesh_overlay, "$g_presentation_obj_4", "mesh_right_button"),
      (position_set_x, pos1, 656),
      (position_set_y, pos1, 670),
      (overlay_set_position, "$g_presentation_obj_4", pos1),
      
      ## center button
      (create_mesh_overlay, reg1, "mesh_center_button"),
      (position_set_x, pos1, 356),
      (position_set_y, pos1, 670),
      (overlay_set_position, reg1, pos1),
  
      ## back
      (create_image_button_overlay, "$g_presentation_obj_5", "mesh_used_button", "mesh_used_button_down"),
      (position_set_x, pos1, 832),
      (position_set_y, pos1, 36),
      (overlay_set_position, "$g_presentation_obj_5", pos1),
  
      ## done
      (create_text_overlay, reg1, "@Done", tf_center_justify|tf_vertical_align_center),
      (position_set_x, pos1, 900),
      (position_set_y, pos1, 50),
      (overlay_set_position, reg1, pos1),
  
      ## faction name
      (try_begin),
        (eq, ":faction_no", "fac_kingdom_1"),
        (str_store_string, s1, "@Britons"),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_2"),
        (str_store_string, s1, "@Saxons"),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_3"),
        (str_store_string, s1, "@Picts"),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_4"),
        (str_store_string, s1, "@Angles"),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_5"),
        (str_store_string, s1, "@Irish"),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_6"),
        (str_store_string, s1, "@Jutes"),
      (else_try),
       (eq, ":faction_no", "fac_kingdom_7"),
        (str_store_string, s1, "@Mercenaries"),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_8"),
        (str_store_string, s1, "@Outlaws"),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_9"),
        (str_store_string, s1, "@Others"),
      (else_try),
        (str_store_faction_name, s1, ":faction_no"),
      (try_end),
  
      (create_text_overlay, reg1, "@{s1}", tf_center_justify|tf_vertical_align_center),
      (position_set_x, pos1, 500),
      (position_set_y, pos1, 692),
      (overlay_set_position, reg1, pos1),
  ]),
  
  ("prsnt_upgrade_tree_troop_and_name",
    [
      (store_script_param, ":slot_no", 1),
      (store_script_param, ":troop_no", 2),
      (store_script_param, ":pos_x", 3),
      (store_script_param, ":pos_y", 4),
      

      (str_store_troop_name, s1, ":troop_no"),
      (create_text_overlay, reg1, "@{s1}", tf_center_justify|tf_vertical_align_center),
      (position_set_x, pos1, 800),
      (position_set_y, pos1, 800),
      (overlay_set_size, reg1, pos1),
      (position_set_x, pos1, ":pos_x"),
      (position_set_y, pos1, ":pos_y"),
      (overlay_set_position, reg1, pos1),
      
      (val_sub, ":pos_x", 90),
      (val_add, ":pos_y", 10),
      (store_mul, ":cur_troop", ":troop_no", 2), #with weapons
      (create_image_button_overlay_with_tableau_material, reg1, -1, "tableau_game_party_window", ":cur_troop"),
      (position_set_x, pos1, 600),
      (position_set_y, pos1, 600),
      (overlay_set_size, reg1, pos1),
      (position_set_x, pos1, ":pos_x"),
      (position_set_y, pos1, ":pos_y"),
      (overlay_set_position, reg1, pos1),
      (troop_set_slot, "trp_temp_array_a", ":slot_no", reg1),
      (troop_set_slot, "trp_temp_array_b", ":slot_no", ":troop_no"),
      
  ]),
  
  ("prsnt_upgrade_tree_troop_cost",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":pos_x", 2),
      (store_script_param, ":pos_y", 3),
  
      (call_script, "script_game_get_upgrade_cost", ":troop_no"),
      
      (create_text_overlay, reg1, "@{reg0}", tf_center_justify|tf_vertical_align_center),
      (position_set_x, pos1, 800),
      (position_set_y, pos1, 800),
      (overlay_set_size, reg1, pos1),
      (position_set_x, pos1, ":pos_x"),
      (position_set_y, pos1, ":pos_y"),
      (overlay_set_position, reg1, pos1),
  ]),
  
  ("prsnt_upgrade_tree_lines",
    [
      (store_script_param, ":size_x", 1),
      (store_script_param, ":size_y", 2),
      (store_script_param, ":pos_x", 3),
      (store_script_param, ":pos_y", 4),
  
      (create_mesh_overlay, reg1, "mesh_white_plane"),
      (val_mul, ":size_x", 50),
      (val_mul, ":size_y", 50),
      (position_set_x, pos1, ":size_x"),
      (position_set_y, pos1, ":size_y"),
      (overlay_set_size, reg1, pos1),
      (position_set_x, pos1, ":pos_x"),
      (position_set_y, pos1, ":pos_y"),
      (overlay_set_position, reg1, pos1),
      (overlay_set_color, reg1, 0x000000),
  ]),
  
  ("prsnt_upgrade_tree_switch",
    [
      (store_script_param, ":prsnt_object", 1),
      (store_script_param, ":faction_no", 2),
  
      (store_sub, ":cur_presentation", ":faction_no", "fac_kingdom_1"),
      (val_add, ":cur_presentation", "prsnt_upgrade_tree_1"),
  
      (try_begin),
        (eq, ":prsnt_object", "$g_presentation_obj_1"),
        (val_sub, ":cur_presentation", 1),
        (try_begin),
          (lt, ":cur_presentation", "prsnt_upgrade_tree_1"),
          (assign, ":cur_presentation", "prsnt_upgrade_tree_9"),
        (try_end),
        (start_presentation, ":cur_presentation"),
      (else_try),
        (eq, ":prsnt_object", "$g_presentation_obj_2"),
        (val_add, ":cur_presentation", 1),
        (try_begin),
          (gt, ":cur_presentation", "prsnt_upgrade_tree_9"),
          (assign, ":cur_presentation", "prsnt_upgrade_tree_1"),
        (try_end),
        (start_presentation, ":cur_presentation"),
      (else_try),
        (eq, ":prsnt_object", "$g_presentation_obj_5"),
        (presentation_set_duration, 0),
      (try_end),
  ]),
  ("copy_inventory", 
    [
      (store_script_param_1, ":source"),
      (store_script_param_2, ":target_inv"),
  
      (troop_clear_inventory, ":target_inv"),
      (troop_get_inventory_capacity, ":inv_cap", ":source"),
      (try_for_range, ":i_slot", 0, ":inv_cap"),
        (troop_get_inventory_slot, ":item", ":source", ":i_slot"),
        (troop_set_inventory_slot, ":target_inv", ":i_slot", ":item"),
        (troop_get_inventory_slot_modifier, ":imod", ":source", ":i_slot"),
        (troop_set_inventory_slot_modifier, ":target_inv", ":i_slot", ":imod"),
        (troop_inventory_slot_get_item_amount, ":amount", ":source", ":i_slot"),
        (gt, ":amount", 0),
        (troop_inventory_slot_set_item_amount, ":target_inv", ":i_slot", ":amount"),
      (try_end),
    ]),
  ("calculate_ransom_for_party", 
    [
      (store_script_param, ":party_no", 1),
      
      (assign, ":total_ransom_cost", 0),
      (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
      (try_begin),
        (gt, ":num_stacks", 0),
        (try_for_range, ":stack_no", 0, ":num_stacks"),
          (party_stack_get_troop_id, ":troop_no", ":party_no", ":stack_no"),
          (call_script, "script_game_get_join_cost", ":troop_no"),
          (assign, ":ransom_cost", reg0),
          (val_div, ":ransom_cost", 4),
          (party_stack_get_size, ":stack_size", ":party_no", ":stack_no"),
          (val_mul, ":ransom_cost", ":stack_size"),
          (val_add, ":total_ransom_cost", ":ransom_cost"),
        (try_end),
      (try_end),
      (assign, reg0, ":total_ransom_cost"),
    ]),

  ("process_outlaws_for_party", 
    [
      (store_script_param, ":party_no", 1),
      
      (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
      (try_for_range_backwards, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":troop_no", ":party_no", ":stack_no"),
        (neg|troop_is_hero, ":troop_no"),
        (is_between, ":troop_no", outlaws_troops_begin, outlaws_troops_end),
        (party_stack_get_size, ":stack_size", ":party_no", ":stack_no"),
        (party_remove_members, ":party_no", ":troop_no", ":stack_size"),
        (party_add_prisoners, ":party_no", ":troop_no", ":stack_size"),
      (try_end),
    ]),

## CC chief acaba
#improved IA Motomataru chief

# # AI with Formations Scripts
  # script_calculate_decision_numbers by motomataru
  # Input: AI team, size relative to battle in %
  # Output: reg0 - battle presence plus level bump, reg1 - level bump (team avg level / 3)
  ("calculate_decision_numbers", [
	(store_script_param, ":team_no", 1),
	(store_script_param, ":battle_presence", 2),
	(try_begin),
		(team_get_slot, reg0, ":team_no", "slot_team_level"),
		(store_div, reg1, reg0, 3),
		(store_add, reg0, ":battle_presence", reg1),	#decision w.r.t. all enemy teams
	(try_end)
	]),
	

  # script_team_field_ranged_tactics by motomataru
  # Input: AI team, size relative to largest team in %, size relative to battle in %
  # Output: none
  ("team_field_ranged_tactics", [
	(store_script_param, ":team_no", 1),
	(store_script_param, ":rel_army_size", 2),
	(store_script_param, ":battle_presence", 3),
	(assign, ":division", grc_archers), #Pre-Many Divisions
	(assign, ":bg_pos", Archers_Pos), #Pre-Many Divisions

	(store_add, ":slot", "slot_team_d0_size", ":division"),
	(try_begin),
		(team_slot_eq, ":team_no", ":slot", 0),
		(try_begin),	#undo reversion to BP_Jockey (see below)
			(lt, "$battle_phase", BP_Fight),
			(call_script, "script_cf_any_fighting"),
			(call_script, "script_cf_count_casualties"),
			(assign, "$battle_phase", BP_Fight),
		(try_end),
	(else_try),
		(call_script, "script_battlegroup_get_position", ":bg_pos", ":team_no", ":division"),
		(call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":team_no", grc_everyone),
		(call_script, "script_point_y_toward_position", ":bg_pos", Enemy_Team_Pos),
		
		(store_add, ":slot", "slot_team_d0_closest_enemy_special_dist", ":division"),	#distance to nearest enemy infantry agent
		(team_get_slot, ":distance_to_enemy", ":team_no", ":slot"),
		(try_begin),
			(eq, ":distance_to_enemy", 0),
			(call_script, "script_get_nearest_enemy_battlegroup_location", Nearest_Enemy_Battlegroup_Pos, ":team_no", ":bg_pos"),
			(assign, ":distance_to_enemy", reg0),
		(try_end),
		
		(try_begin),	#avoid being provoked from defensive position
			(call_script, "script_cf_any_fighting"),
		(else_try),
			(ge, "$battle_phase", BP_Fight),
			# (neg|call_script, "script_cf_any_fighting"),
			(assign, "$battle_phase", BP_Jockey),
			(assign, "$clock_reset", 0),
		(try_end),
			
		(store_add, ":slot", "slot_team_d0_in_melee", ":division"),
		(team_get_slot, ":is_firing", ":team_no", ":slot"),
		(store_add, ":slot", "slot_team_d0_size", grc_infantry),
		(team_get_slot, ":num_infantry", ":team_no", ":slot"),
		
		(call_script, "script_calculate_decision_numbers", ":team_no", ":battle_presence"),
		(assign, ":decision_index", reg0),
		(assign, ":level_bump", reg1),
		(try_begin),
			(gt, ":decision_index", 86),	#outpower enemies more than 6:1?
			(team_get_movement_order, reg0, ":team_no", ":division"),
			(try_begin),
				(neq, reg0, mordr_charge),
				(team_give_order, ":team_no", ":division", mordr_charge),
			(try_end),
			
		(else_try),
			(lt, ":decision_index", 14),	#outpowered more than 6:1?
			(eq, ":num_infantry", 0),	#no infantry to delay enemy?
			(team_get_movement_order, reg0, ":team_no", ":division"),
			(try_begin),
				(neq, reg0, mordr_retreat),
				(team_give_order, ":team_no", ":division", mordr_retreat),
			(try_end),
			
		(else_try),
			(ge, "$battle_phase", BP_Jockey),
			(store_add, ":slot", "slot_team_d0_low_ammo", ":division"),
			(team_slot_ge, ":team_no", ":slot", 1),	#running out of ammo?
			(team_get_movement_order, reg0, ":team_no", ":division"),
			(try_begin),
				(neq, reg0, mordr_charge),
				(team_give_order, ":team_no", ":division", mordr_charge),
			(try_end),
			
		(else_try),
			(ge, "$battle_phase", BP_Fight),
			(eq, ":is_firing", 0),
			(gt, ":decision_index", Advance_More_Point),
			(le, ":distance_to_enemy", AI_long_range),	#closer than reposition?
			(team_give_order, ":team_no", ":division", mordr_advance),

		#hold somewhere
		(else_try),
			(store_add, ":decision_index", ":rel_army_size", ":level_bump"),	#decision w.r.t. largest enemy team
			(assign, ":move_archers", 0),
			
			(init_position, Team_Starting_Point),
			(team_get_slot, reg0, ":team_no", "slot_team_starting_x"),
			(position_set_x, Team_Starting_Point, reg0),
			(team_get_slot, reg0, ":team_no", "slot_team_starting_y"),
			(position_set_y, Team_Starting_Point, reg0),
			(position_set_z_to_ground_level, Team_Starting_Point),
					
			(try_begin),
				(eq, "$battle_phase", BP_Setup),
				(assign, ":move_archers", 1),
			(else_try),
				(ge, "$battle_phase", BP_Fight),
				(try_begin),
					(neg|is_between, ":distance_to_enemy", AI_charge_distance, AI_long_range),
					(assign, ":move_archers", 1),
				(else_try),
					(lt, ":decision_index", Hold_Point),	#probably coming from a defensive position (see below)
                                        (eq, "$formation_AI_no_defense", 0),         #player hasn't set disallow defense option?
					(eq, ":is_firing", 0),	#probably because player team has retreated
					(assign, ":move_archers", 1),
				(try_end),
			(else_try),	#jockey phase
                                (this_or_next|gt, "$formation_AI_no_defense", 0),    #player has set disallow defense option OR
				(ge, ":decision_index", Hold_Point),	#not starting in a defensive position (see below)
				(try_begin),
					(gt, ":distance_to_enemy", AI_long_range),	#enemy very far off
					(assign, ":move_archers", 1),
				(else_try),
					(call_script, "script_point_y_toward_position", Team_Starting_Point, ":bg_pos"),
					(position_get_rotation_around_z, reg0, Team_Starting_Point),
					(position_get_rotation_around_z, reg1, ":bg_pos"),
					(val_sub, reg0, reg1),
					(this_or_next|is_between, reg0, -45, 45),	#only move if within "cone of advancement" to prevent constant adjusting at border OR
					(eq, ":is_firing", 0),	#if not firing for some reason (hill in way?)
					
					(try_begin),
						(eq, ":num_infantry", 0),	#no infantry to wait for
						(assign, ":move_archers", 1),
					(else_try),
						(call_script, "script_battlegroup_get_position", Infantry_Pos, ":team_no", grc_infantry),
						(get_distance_between_positions, ":infantry_to_enemy", Infantry_Pos, Enemy_Team_Pos),
						(get_distance_between_positions, ":archers_to_enemy", ":bg_pos", Enemy_Team_Pos),
						(val_sub, ":infantry_to_enemy", ":archers_to_enemy"),
						(le, ":infantry_to_enemy", 1500),	#don't outstrip infantry when closing
						(assign, ":move_archers", 1),
					(try_end),
				(try_end),
			(try_end),
			
			(try_begin),
				(gt, ":move_archers", 0),
				(try_begin),
					(lt, ":decision_index", Hold_Point),	#outnumbered?
                                        (eq, "$formation_AI_no_defense", 0),         #player hasn't set disallow defense option?
					(lt, "$battle_phase", BP_Fight),
					(neq, ":team_no", 1),	#not attacker?
					(neq, ":team_no", 3),	#not ally of attacker?
					(store_div, ":distance_to_move", ":distance_to_enemy", 6),	#middle of rear third of battlefield
					(assign, ":hill_search_radius", ":distance_to_move"),

				(else_try),
					(try_begin),
						(ge, "$battle_phase", BP_Fight),
						(copy_position, ":bg_pos", Team_Starting_Point),
						(call_script, "script_point_y_toward_position", ":bg_pos", Enemy_Team_Pos),
						(try_begin),
							(gt, ":num_infantry", 0),
							(eq, "$formation_no_nearest_agent", 0),
							(store_add, ":slot", "slot_team_d0_closest_enemy", grc_infantry),
							(team_get_slot, ":enemy_agent_nearest_infantry", ":team_no", ":slot"),
							(agent_get_team, ":target_team", ":enemy_agent_nearest_infantry"),
							(agent_get_division, ":target_division", ":enemy_agent_nearest_infantry"),
							(call_script, "script_battlegroup_get_position", Nearest_Enemy_Battlegroup_Pos, ":target_team", ":target_division"),
							(get_distance_between_positions, ":distance_to_enemy", ":bg_pos", Nearest_Enemy_Battlegroup_Pos),
						(else_try),
							(call_script, "script_get_nearest_enemy_battlegroup_location", Nearest_Enemy_Battlegroup_Pos, ":team_no", ":bg_pos"),
							(assign, ":distance_to_enemy", reg0),
						(try_end),
					(try_end),

					(try_begin),
						(eq, "$battle_phase", BP_Setup),
						(assign, ":shot_distance", AI_long_range),
					(else_try),
						(assign, ":shot_distance", AI_firing_distance),
						(store_sub, reg1, AI_firing_distance, AI_charge_distance),
						(val_sub, reg1, 200),	#subtract two meters to prevent automatically provoking melee from forward enemy infantry
						(store_add, ":slot", "slot_team_d0_percent_throwers", ":division"),
						(team_get_slot, reg0, ":team_no", ":slot"),
						(val_mul, reg1, reg0),
						(val_div, reg1, 100),
						(val_sub, ":shot_distance", reg1),
					(try_end),

					(store_sub, ":distance_to_move", ":distance_to_enemy", ":shot_distance"),
					(store_div, ":hill_search_radius", ":shot_distance", 3),	#limit so as not to run into enemy
					(try_begin),
						(lt, "$battle_phase", BP_Fight),
						(try_begin),
							(this_or_next|eq, "$battle_phase", BP_Setup),
							(lt, ":battle_presence", Advance_More_Point),	#expect to meet halfway?
							(val_div, ":distance_to_move", 2),
						(try_end),
					(try_end),
				(try_end),

				(position_move_y, ":bg_pos", ":distance_to_move", 0),
				(try_begin),
					(lt, "$battle_phase", BP_Fight),
					(copy_position, pos1, ":bg_pos"),
					(store_div, reg0, ":hill_search_radius", 100),
					(call_script, "script_find_high_ground_around_pos1_corrected", ":bg_pos", reg0),
				(try_end),
			(try_end),

			(team_get_movement_order, reg0, ":team_no", ":division"),
			(try_begin),
				(neq, reg0, mordr_hold),
				(team_give_order, ":team_no", ":division", mordr_hold),
			(try_end),
			(team_set_order_position, ":team_no", ":division", ":bg_pos"),
		(try_end),
	(try_end)
	]),

	  
  # script_team_field_melee_tactics by motomataru #EDITED FOR SLOTS BY CABA...many divisions changes necessary
  # Input: AI team, size relative to largest team in %, size relative to battle in %
  # Output: none
  ("team_field_melee_tactics", [
	(store_script_param, ":team_no", 1),
#	(store_script_param, ":rel_army_size", 2),
	(store_script_param, ":battle_presence", 3),
	(call_script, "script_calculate_decision_numbers", ":team_no", ":battle_presence"),

	#mop up if outnumber enemies more than 6:1
	(try_begin),
		(gt, reg0, 86),
		(try_for_range, ":division", 0, 9),
		    (store_add, ":slot", "slot_team_d0_size", ":division"),
			(team_slot_ge, ":team_no", ":slot", 1),
		    (store_add, ":slot", "slot_team_d0_type", ":division"),
		    (neg|team_slot_eq, ":team_no", ":slot", sdt_archer),
			(neg|team_slot_eq, ":team_no", ":slot", sdt_skirmisher),
			(call_script, "script_formation_end", ":team_no", ":division"),
			(team_get_movement_order, reg0, ":team_no", ":division"),
			(try_begin),
				(neq, reg0, mordr_charge),
				(team_give_order, ":team_no", ":division", mordr_charge),
			(try_end),
		(try_end),

	(else_try),		
		(assign, ":num_enemies", 0),
		(try_for_range, ":enemy_team_no", 0, 4),
			(teams_are_enemies, ":enemy_team_no", ":team_no"),
			(team_get_slot, ":value", ":enemy_team_no", "slot_team_size"),
			(val_add, ":num_enemies", ":value"),
		(try_end),
		
		(gt, ":num_enemies", 0),
		(call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":team_no", grc_everyone),
		
		(store_add, ":slot", "slot_team_d0_size", grc_archers),
		(team_get_slot, ":num_archers", ":team_no", ":slot"),
		(try_begin),
			(eq, ":num_archers", 0),
			(assign, ":enemy_bg_nearest_archers_dist", Far_Away),
			(assign, ":archer_order", mordr_charge),
		(else_try),
			(call_script, "script_battlegroup_get_position", Archers_Pos, ":team_no", grc_archers),
			(call_script, "script_point_y_toward_position", Archers_Pos, Enemy_Team_Pos),
			(call_script, "script_get_nearest_enemy_battlegroup_location", pos0, ":team_no", Archers_Pos),
			(assign, ":enemy_bg_nearest_archers_dist", reg0),
			(team_get_movement_order, ":archer_order", ":team_no", grc_archers),
		(try_end),

		(store_add, ":slot", "slot_team_d0_size", grc_infantry),
		(team_get_slot, ":num_infantry", ":team_no", ":slot"),
		(try_begin),
			(eq, ":num_infantry", 0),
			(assign, ":enemy_bg_nearest_infantry_dist", Far_Away),
			(assign, ":enemy_agent_nearest_infantry_dist", Far_Away),
		(else_try),
			(call_script, "script_battlegroup_get_position", Infantry_Pos, ":team_no", grc_infantry),
			(call_script, "script_get_nearest_enemy_battlegroup_location", pos0, ":team_no", Infantry_Pos),
			(assign, ":enemy_bg_nearest_infantry_dist", reg0),
			(store_add, ":slot", "slot_team_d0_closest_enemy_dist", grc_infantry),
			(team_get_slot, ":enemy_agent_nearest_infantry_dist", ":team_no", ":slot"),
                   (eq, ":enemy_agent_nearest_infantry_dist", 0), #happens when player turns off closest agent mechanism (see mod      options)
                  (assign, ":enemy_agent_nearest_infantry_dist", ":enemy_bg_nearest_infantry_dist"),
               (try_end),

		(store_add, ":slot", "slot_team_d0_size", grc_cavalry),
		(team_get_slot, ":num_cavalry", ":team_no", ":slot"),
		(try_begin),
			(eq, ":num_cavalry", 0),
			(assign, ":enemy_bg_nearest_cavalry_dist", Far_Away),
			(assign, ":enemy_agent_nearest_cavalry_dist", Far_Away),
		(else_try),
			(call_script, "script_battlegroup_get_position", Cavalry_Pos, ":team_no", grc_cavalry),
			(call_script, "script_get_nearest_enemy_battlegroup_location", pos0, ":team_no", Cavalry_Pos),
			(assign, ":enemy_bg_nearest_cavalry_dist", reg0),
			(store_add, ":slot", "slot_team_d0_closest_enemy_dist", grc_cavalry),
			(team_get_slot, ":enemy_agent_nearest_cavalry_dist", ":team_no", ":slot"),
                  (eq, ":enemy_agent_nearest_cavalry_dist", 0),  #happens when player turns off closest agent mechanism (see mod      options)
                  (assign, ":enemy_agent_nearest_cavalry_dist", ":enemy_bg_nearest_infantry_dist"),
              (try_end),

		(try_begin),
			(lt, "$battle_phase", BP_Fight),
			(this_or_next|le, ":enemy_bg_nearest_infantry_dist", AI_charge_distance),
			(this_or_next|le, ":enemy_bg_nearest_cavalry_dist", AI_charge_distance),
			(le, ":enemy_bg_nearest_archers_dist", AI_charge_distance),
			(assign, "$battle_phase", BP_Fight),
		(else_try),
			(lt, "$battle_phase", BP_Jockey),
			(this_or_next|le, ":enemy_agent_nearest_infantry_dist", AI_long_range),
			(le, ":enemy_agent_nearest_cavalry_dist", AI_long_range),
			(assign, "$battle_phase", BP_Jockey),
		(try_end),
		
		(team_get_leader, ":team_leader", ":team_no"),
		(assign, ":place_leader_by_infantry", 0),
		
		#infantry AI
		(try_begin),
			(le, ":num_infantry", 0),
			(assign, ":infantry_order", ":archer_order"),
			
			#deal with mounted heroes that team_give_order() treats as infantry   #CABA...could change their division?
			(team_get_movement_order, reg0, ":team_no", grc_infantry),
			(try_begin),
				(neq, reg0, ":infantry_order"),
				(team_give_order, ":team_no", grc_infantry, ":infantry_order"),
			(try_end),
			(try_begin),
				(gt, ":num_archers", 0),
				(copy_position, pos1, Archers_Pos),
				(position_move_y, pos1, 1000, 0),
				(team_set_order_position, ":team_no", grc_infantry, pos1),
			(else_try),
				(team_set_order_position, ":team_no", grc_infantry, Cavalry_Pos),
			(try_end),

		(else_try),
            (try_begin),
                      (eq, "$formation_no_nearest_agent", 0),
                      (store_add, ":slot", "slot_team_d0_closest_enemy", grc_infantry),
                      (team_get_slot, ":enemy_agent_nearest_infantry", ":team_no", ":slot"),
                      
                  (else_try),    #player has turned off closest agent      mechanism (see mod options)
                      (assign, ":enemy_agent_nearest_infantry", -1),
                      (try_for_agents, ":enemy_agent"),
                          (agent_is_alive, ":enemy_agent"),
                          (agent_is_human, ":enemy_agent"),
                          (agent_get_group, ":enemy_agent_nearest_infantry_team", ":enemy_agent"),
                          (teams_are_enemies, ":enemy_agent_nearest_infantry_team", ":team_no"),
                          (agent_slot_eq, ":enemy_agent", "slot_agent_is_running_away", 0),
                          
                          (try_begin),
                              (eq, ":enemy_agent_nearest_infantry", -1),
                              (assign, ":enemy_agent_nearest_infantry", ":enemy_agent"),
                          (else_try),
                              (agent_get_position, pos0, ":enemy_agent"),
                              (get_distance_between_positions, ":new_distance", pos0, Infantry_Pos),
                              (agent_get_position, pos0, ":enemy_agent_nearest_infantry"),
                              (get_distance_between_positions, ":old_distance", pos0, Infantry_Pos),
                              (lt, ":new_distance", ":old_distance"),
                              (assign, ":enemy_agent_nearest_infantry", ":enemy_agent"),
                          (try_end),
                      (try_end),
                  (try_end),
                        (agent_get_position, Nearest_Enemy_Troop_Pos, ":enemy_agent_nearest_infantry"),
			(agent_get_team, ":enemy_agent_nearest_infantry_team", ":enemy_agent_nearest_infantry"),
			(agent_get_division, ":enemy_agent_nearest_infantry_div", ":enemy_agent_nearest_infantry"),
			
			(assign, ":sum_level_enemy_infantry", 0),
			(try_for_range, ":enemy_team_no", 0, 4),
				(teams_are_enemies, ":enemy_team_no", ":team_no"),
				(try_for_range, ":enemy_division", 0, 9),
					(store_add, ":slot", "slot_team_d0_type", ":enemy_division"),
					(team_get_slot, ":value", ":enemy_team_no", ":slot"),
					(this_or_next|eq, ":value", sdt_polearm),
					(eq, ":value", sdt_infantry),
					(store_add, ":slot", "slot_team_d0_size", ":enemy_division"),
					(team_get_slot, ":value", ":enemy_team_no", ":slot"),
					(store_add, ":slot", "slot_team_d0_level", ":enemy_division"),
					(team_get_slot, reg0, ":enemy_team_no", ":slot"),
					(val_mul, ":value", reg0),
					(val_add, ":sum_level_enemy_infantry", ":value"),
				(try_end),
			(try_end),
		
			(store_mul, ":percent_level_enemy_infantry", ":sum_level_enemy_infantry", 100),
			(val_div, ":percent_level_enemy_infantry", ":num_enemies"),
			(try_begin),
				(teams_are_enemies, ":team_no", "$fplayer_team_no"),
				(assign, ":combined_level", 0),
				(assign, ":combined_team_size", 0),
				(assign, ":combined_num_infantry", ":num_infantry"),
			(else_try),
				(store_add, ":slot", "slot_team_d0_level", grc_infantry),
		        (team_get_slot, ":combined_level", "$fplayer_team_no", ":slot"),
		        (team_get_slot, ":combined_team_size", "$fplayer_team_no", "slot_team_size"),
				(store_add, ":slot", "slot_team_d0_size", grc_infantry),
				(team_get_slot, ":combined_num_infantry", "$fplayer_team_no", ":slot"),
				(val_add, ":combined_num_infantry", ":num_infantry"),
			(try_end),
			(store_mul, ":percent_level_infantry", ":combined_num_infantry", 100),
			(store_add, ":slot", "slot_team_d0_level", grc_infantry),
			(team_get_slot, ":level_infantry", ":team_no", ":slot"),
			(val_add, ":combined_level", ":level_infantry"),
			(val_mul, ":percent_level_infantry", ":combined_level"),
			(team_get_slot, reg0, ":team_no", "slot_team_size"),
			(val_add, ":combined_team_size", reg0),
			(val_div, ":percent_level_infantry", ":combined_team_size"),

			(assign, ":infantry_order", mordr_charge),
			(try_begin),	#enemy far away AND ranged not charging
				(gt, ":enemy_bg_nearest_archers_dist", AI_charge_distance),
				(gt, ":enemy_agent_nearest_infantry_dist", AI_charge_distance),
				(neq, ":archer_order", mordr_charge),
				(try_begin),	#fighting not started OR not enough infantry
					(this_or_next|le, "$battle_phase", BP_Jockey),
					(lt, ":percent_level_infantry", ":percent_level_enemy_infantry"),
					(assign, ":infantry_order", mordr_hold),
				(try_end),
			(try_end),

			# bum rush enemy archers?
			(try_begin),
				(le, ":level_infantry", AI_Poor_Troop_Level),
				(store_add, ":slot", "slot_team_d0_type", ":enemy_agent_nearest_infantry_div"),
				(this_or_next|team_slot_eq, ":enemy_agent_nearest_infantry_team", ":enemy_agent_nearest_infantry_div", sdt_archer),
				(team_slot_eq, ":enemy_agent_nearest_infantry_team", ":enemy_agent_nearest_infantry_div", sdt_skirmisher),
				(get_distance_between_positions, reg0, Infantry_Pos, Nearest_Enemy_Troop_Pos),
				(le, reg0, AI_charge_distance),
				(call_script, "script_formation_end", ":team_no", grc_infantry),
				(team_get_movement_order, reg0, ":team_no", grc_infantry),
				(try_begin),
					(neq, reg0, mordr_charge),
					(team_give_order, ":team_no", grc_infantry, mordr_charge),
				(try_end),
				
      (else_try), #TML charge routine. F123 - Submod -> 1.41 (WAAAAAAGH)
        (get_distance_between_positions, reg0, Infantry_Pos, Nearest_Enemy_Troop_Pos),
        (this_or_next|le, ":enemy_bg_nearest_infantry_dist", 1500), # Start charge if enemy infantry formation is close
        (this_or_next|le, ":enemy_bg_nearest_archers_dist", 1500), # Start charge if enemy archer group is close.
        (le, reg0, 800), # Start charge if any enemies are really close.
        (call_script, "script_formation_end", ":team_no", grc_infantry),
				(team_get_movement_order, reg0, ":team_no", grc_infantry),
        (team_give_order, ":team_no", grc_infantry, mordr_hold_fire), # Hold fire while charging to keep infantry together.
				(try_begin),
					(neq, reg0, mordr_charge),
					(team_give_order, ":team_no", grc_infantry, mordr_charge),
				(try_end),  #TML charge routine end
			#else attempt to make formation somewhere
			(else_try),
				(store_add, ":slot", "slot_team_d0_formation", grc_infantry),
				(team_get_slot, ":infantry_formation", ":team_no", ":slot"),
				(team_get_leader, ":enemy_leader", ":enemy_agent_nearest_infantry_team"),
				
				#consider new formation
				(try_begin),
					(store_add, ":slot", "slot_team_d0_in_melee", grc_infantry),
				    (this_or_next|eq, ":infantry_formation", formation_none),
				    (this_or_next|eq, ":infantry_formation", formation_default),
					(team_slot_eq, ":team_no", ":slot", 0),

					(call_script, "script_get_default_formation", ":team_no"),
					(assign, ":infantry_formation", reg0),
					(agent_get_class, ":enemy_nearest_troop_class", ":enemy_agent_nearest_infantry"), 
					#(team_get_leader, ":enemy_leader", ":enemy_agent_nearest_infantry_team"),
					
					(assign, ":num_enemy_cavalry", 0),
					(try_for_range, ":enemy_team_no", 0, 4),
						(teams_are_enemies, ":enemy_team_no", ":team_no"),
						(team_get_slot, ":value", ":enemy_team_no", "slot_team_num_cavalry"),
						(val_add, ":num_enemy_cavalry", ":value"),
					(try_end),					
					
					(store_mul, ":percent_enemy_cavalry", ":num_enemy_cavalry", 100),
					(val_div, ":percent_enemy_cavalry", ":num_enemies"),
					(try_begin),
						(neq, ":infantry_formation", formation_none),
						(try_begin),
							(gt, ":percent_enemy_cavalry", 66),
                                              (assign, ":infantry_formation", formation_square),
						(else_try),
							(neq, ":enemy_nearest_troop_class", grc_cavalry),
							(neq, ":enemy_nearest_troop_class", grc_archers),
							(neq, ":enemy_agent_nearest_infantry", ":enemy_leader"),
							(ge, ":num_infantry", 21),
							(store_add, ":slot", "slot_team_d0_size", ":enemy_agent_nearest_infantry_div"),
							(team_get_slot, reg0, ":enemy_agent_nearest_infantry_team", ":slot"),
							(gt, reg0, ":num_infantry"),	#got fewer troops?
							(store_add, ":slot", "slot_team_d0_armor", grc_infantry),
							(team_get_slot, ":average_armor", ":team_no", ":slot"),
							(store_add, ":slot", "slot_team_d0_armor", ":enemy_agent_nearest_infantry_div"),
							(team_get_slot, reg0, ":enemy_agent_nearest_infantry_team", ":slot"),
							(gt, ":average_armor", reg0),	#got better armor?
							(assign, ":infantry_formation", formation_wedge),
        						(else_try),
			#(gt, ":num_infantry", AI_Max_Size_Oblong_Formations),  #TML Removed #this. Giant shield walls ahoy! F123 - Submod -> 1.41 (MORE WAAAAAGH)
							#(assign, ":infantry_formation", formation_square),
						(try_end),
					(try_end),
				(try_end),	#consider new formation
				
				(try_begin),
					(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_infantry, ":infantry_formation"),
					(store_add, ":slot", "slot_team_d0_formation", grc_infantry),
					(team_set_slot, ":team_no", ":slot", ":infantry_formation"),
					
					#adjust spacing for long swung weapons
					(store_add, ":slot", "slot_team_d0_swung_weapon_length", grc_infantry),
					(team_get_slot, ":spacing", ":team_no", ":slot"),
				                    (val_add, ":spacing", 25),    #rounding for      50cm
                                                    (val_div, ":spacing", 50),
					(store_add, ":slot", "slot_team_d0_formation_space", grc_infantry),
					(team_set_slot, ":team_no", ":slot", ":spacing"),

					(assign, ":place_leader_by_infantry", 1),
					
				(else_try),
					(call_script, "script_formation_end", ":team_no", grc_infantry),
					(team_get_movement_order, reg0, ":team_no", grc_infantry),
					(try_begin),
						(neq, reg0, ":infantry_order"),
						(team_give_order, ":team_no", grc_infantry, ":infantry_order"),
					(try_end),
					(eq, ":infantry_order", mordr_hold),
					(assign, ":place_leader_by_infantry", 1),
				(try_end),

				#hold near archers?
				(try_begin),
					(eq, ":infantry_order", mordr_hold),
					(gt, ":num_archers", 0),
					# (copy_position, pos1, Archers_Pos),
					(team_get_order_position, pos1, ":team_no", grc_archers),	#anticipate archers
					(position_move_x, pos1, -100, 0),
					(try_begin),
						(this_or_next|eq, ":enemy_agent_nearest_infantry_div", grc_cavalry),
						(gt, ":percent_level_infantry", ":percent_level_enemy_infantry"),
						(call_script, "script_battlegroup_dist_center_to_front", ":team_no", grc_infantry),	#make sure to clear archers
						(store_mul, ":distance_to_move", reg0, 2),
						(val_add, ":distance_to_move", 1000),
						(position_move_y, pos1, ":distance_to_move", 0),	#move ahead of archers in anticipation of charges
					(else_try),
						(position_move_y, pos1, -1000, 0),
					(try_end),

                #obtain destination
                    (else_try),
                        (assign, ":target_division", -1),
                        (try_begin),
                            (store_add, ":slot", "slot_team_d0_in_melee", grc_infantry),
                            (team_slot_eq, ":team_no", ":slot", 0),       #not engaged?
                            (gt, ":enemy_bg_nearest_archers_dist", AI_charge_distance),    #don't have to protect archers?
                            # (lt, ":percent_enemy_cavalry", 100),       #non-cavalry exist? MOTO next command tests
                            
                            #prefer non-cavalry target (that infantry    can catch)
                            (store_add, ":slot", "slot_team_d0_closest_enemy_special_dist", grc_infantry),
                            (team_get_slot, ":distance_to_enemy_troop", ":team_no", ":slot"),
                            (gt, ":distance_to_enemy_troop", 0),
                            (store_add, ":slot", "slot_team_d0_closest_enemy_special", grc_infantry),
                            (team_get_slot, ":enemy_nearest_non_cav_agent", ":team_no", ":slot"),
                            (agent_get_position, pos60, ":enemy_nearest_non_cav_agent"),
                            (agent_get_team, ":enemy_non_cav_team", ":enemy_nearest_non_cav_agent"),
                            (team_get_leader, reg0, ":enemy_non_cav_team"),
                            (try_begin),
                                (eq, ":enemy_nearest_non_cav_agent", reg0),    #team leader?
                                (assign, ":distance_to_enemy_group", Far_Away),
                            (else_try),
                                (agent_get_division, ":target_division", ":enemy_nearest_non_cav_agent"),
                                (store_add, ":slot", "slot_team_d0_target_team", grc_infantry),
                                (team_set_slot, ":team_no", ":slot", ":enemy_non_cav_team"),
                                (store_add, ":slot", "slot_team_d0_target_division", grc_infantry),
                                (team_set_slot, ":team_no", ":slot", ":target_division"),
                                (call_script, "script_battlegroup_get_attack_destination", pos1, ":team_no", grc_infantry, ":enemy_non_cav_team", ":target_division"),
                            (call_script, "script_get_distance_to_battlegroup", ":enemy_non_cav_team", ":target_division", Infantry_Pos),
                                  (assign, ":distance_to_enemy_group", reg0),
                        (try_end),
                            
                        #chase nearest target
                        (else_try),
                            (assign, ":distance_to_enemy_troop", ":enemy_agent_nearest_infantry_dist"),
                            (copy_position, pos60, Nearest_Enemy_Troop_Pos),
                            (try_begin),
                                (eq, ":enemy_agent_nearest_infantry", ":enemy_leader"),
                                (assign, ":distance_to_enemy_group", Far_Away),
                            (else_try),
                                (assign, ":target_division", ":enemy_agent_nearest_infantry_div"),
                                (store_add, ":slot", "slot_team_d0_target_team", grc_infantry),
                                (team_set_slot, ":team_no", ":slot", ":enemy_agent_nearest_infantry_team"),
                                (store_add, ":slot", "slot_team_d0_target_division", grc_infantry),
                                (team_set_slot, ":team_no", ":slot", ":target_division"),
                                (call_script, "script_battlegroup_get_attack_destination", pos1, ":team_no", grc_infantry, ":enemy_agent_nearest_infantry_team",    ":target_division"),
                            (call_script, "script_get_distance_to_battlegroup", ":enemy_agent_nearest_infantry_team", ":target_division",      Infantry_Pos),
                                  (assign, ":distance_to_enemy_group", reg0),
                        (try_end),
                        (try_end),
        


					#reassemble if too scattered
					(try_begin),
						(call_script, "script_get_distance_to_battlegroup", ":team_no", grc_infantry, pos60),	#we're using enemy troop as a reference
						(val_sub, reg0, ":distance_to_enemy_troop"),
						(gt, reg0, 1500),	#division center too far from where it should be (probably because of reinforcing troops)
						(position_copy_origin, pos1, Infantry_Pos),	#gather at average position
						(call_script, "script_battlegroup_dist_center_to_front", ":team_no", grc_infantry),
						(assign, ":distance_to_move", reg0),
						(store_mul, reg0, 350, formation_reform_interval),
						(val_add, ":distance_to_move", reg0),	#one interval movement
						(position_move_y, pos1, ":distance_to_move"),	#keep rear moving forward

                     #attack leader if is closest troop
                          (else_try),
                              (eq, ":target_division", -1),
                        (position_copy_origin, pos1, pos60),
                              (call_script, "script_point_y_toward_position", Infantry_Pos, pos1),
                              (position_copy_rotation, pos1, Infantry_Pos),
        
                          #move no farther than nearest troop if its      unit is far off
                    (else_try),
                        (call_script, "script_battlegroup_dist_center_to_front", ":team_no", grc_infantry),
                        (val_add, ":distance_to_enemy_troop", reg0),	#distance to center of bg from nearest edge
                        (store_sub, reg0, ":distance_to_enemy_group", ":distance_to_enemy_troop"),
                        (gt, reg0, AI_charge_distance),
						(position_copy_origin, pos1, Infantry_Pos),
						(position_move_y, pos1, ":distance_to_enemy_troop"),
                
                
					#shift dead player troops right to clear allies when both attacking the same enemy battlegroup
					(else_try),
                        (eq, ":team_no", "$fplayer_team_no"),
                        (store_add, ":ally_team", "$fplayer_team_no", 2),
                        (neg|teams_are_enemies, ":ally_team", "$fplayer_team_no"),
                        (store_add, ":slot", "slot_team_d0_size", grc_infantry),
                        (team_slot_ge, ":ally_team", ":slot", 1),
                        (store_add, ":slot", "slot_team_d0_target_team", grc_infantry),
                        (team_get_slot, ":target_team", "$fplayer_team_no", ":slot"),
                        (team_slot_eq, ":ally_team", ":slot", ":target_team"),
                        (store_add, ":slot", "slot_team_d0_target_division", grc_infantry),
                        (team_slot_eq, ":ally_team", ":slot", ":target_division"),
                        (call_script, "script_battlegroup_get_position", pos0, ":ally_team", grc_infantry),
                        (get_distance_between_positions, ":distance_to_ally", Infantry_Pos, pos0),
                        (lt, ":distance_to_ally", ":distance_to_enemy_group"),    #shift only when not in melee to avoid rotation
                        (call_script, "script_battlegroup_get_action_radius", ":ally_team", grc_infantry),    #move larger group less to maintain center
                        (val_div, reg0, 2),	#function returns length of bg
                        (position_move_x, pos1, reg0),

                    #shift allies left to clear dead player troops when both attacking the same enemy battlegroup
                    (else_try),
                        (main_hero_fallen),
                        (eq, AI_Replace_Dead_Player, 1),
                        (neq, ":team_no", "$fplayer_team_no"),
                        (neg|teams_are_enemies, ":team_no", "$fplayer_team_no"),
                        (store_add, ":slot", "slot_team_d0_size", grc_infantry),
                        (team_slot_ge, "$fplayer_team_no", ":slot", 1),
                        (store_add, ":slot", "slot_team_d0_target_team", grc_infantry),
                        (team_get_slot, ":target_team", "$fplayer_team_no", ":slot"),
                        (team_slot_eq, ":team_no", ":slot", ":target_team"),
                        (store_add, ":slot", "slot_team_d0_target_division", grc_infantry),
                        (team_slot_eq, "$fplayer_team_no", ":slot", ":target_division"),
                        (call_script, "script_battlegroup_get_position", pos0, "$fplayer_team_no", grc_infantry),
                        (get_distance_between_positions, ":distance_to_ally", Infantry_Pos, pos0),
                        (lt, ":distance_to_ally", ":distance_to_enemy_group"),    #shift only when not in melee to avoid rotation
                        (call_script, "script_battlegroup_get_action_radius", "$fplayer_team_no", grc_infantry),    #move larger group less to maintain center
                        (val_div, reg0, -2),	#function returns length of bg
                        (position_move_x, pos1, reg0),
                    (try_end),
				(try_end),	#obtain destination

				(call_script, "script_set_formation_destination", ":team_no", grc_infantry, pos1),
				
				(try_begin),
					(store_add, ":slot", "slot_team_d0_formation", grc_infantry),
					(neg|team_slot_eq, ":team_no", ":slot", formation_none),
					(call_script, "script_get_centering_amount", ":infantry_formation", ":num_infantry", ":spacing"),
					(position_move_x, pos1, reg0),
					(call_script, "script_form_infantry", ":team_no", grc_infantry, ":team_leader", ":spacing", 0, ":infantry_formation"),
				(try_end),
			(try_end),	#attempt to make formation somewhere
		(try_end),		
		
		#cavalry AI
		(try_begin),
			(gt, ":num_cavalry", 0),

			#get distance to nearest enemy battlegroup(s)
			(store_add, ":slot", "slot_team_d0_armor", grc_cavalry),
			(team_get_slot, ":average_armor", ":team_no", ":slot"),
			(assign, ":nearest_threat_distance", Far_Away),
			(assign, ":nearest_target_distance", Far_Away),
			(assign, ":num_targets", 0),
			(try_for_range, ":enemy_team_no", 0, 4),
				(team_slot_ge, ":enemy_team_no", "slot_team_size", 1),
				(teams_are_enemies, ":enemy_team_no", ":team_no"),
				(try_for_range, ":enemy_division", 0, 9),
					(store_add, ":slot", "slot_team_d0_size", ":enemy_division"),
					(team_get_slot, ":size_enemy_battle_group", ":enemy_team_no", ":slot"),
					(gt, ":size_enemy_battle_group", 0),
					(call_script, "script_battlegroup_get_position", pos0, ":enemy_team_no", ":enemy_division"),
					(get_distance_between_positions, ":distance_of_enemy", Cavalry_Pos, pos0),
					(try_begin),	#threat or target?
						(store_add, ":slot", "slot_team_d0_weapon_length", ":enemy_division"),
						(team_get_slot, reg0, ":enemy_team_no", ":slot"),
						(assign, ":decision_index", reg0),
						(store_add, ":slot", "slot_team_d0_armor", ":enemy_division"),
						(team_get_slot, reg0, ":enemy_team_no", ":slot"),
						(val_mul, ":decision_index", reg0),
						(val_mul, ":decision_index", ":size_enemy_battle_group"),
						(val_div, ":decision_index", ":average_armor"),
						(val_div, ":decision_index", ":num_cavalry"),
						(try_begin),
							(neq, ":enemy_division", grc_cavalry),
							(val_div, ":decision_index", 2),	#double count cavalry vs. foot soldiers
						(try_end),
						(gt, ":decision_index", 100),
						(try_begin),
							(gt, ":nearest_threat_distance", ":distance_of_enemy"),
							(copy_position, Nearest_Threat_Pos, pos0),
							(assign, ":nearest_threat_distance", ":distance_of_enemy"),
						(try_end),
					(else_try),
						(val_add, ":num_targets", 1),
						(gt, ":nearest_target_distance", ":distance_of_enemy"),
						(copy_position, Nearest_Target_Pos, pos0),
						(assign, ":nearest_target_distance", ":distance_of_enemy"),
						(store_add, ":slot", "slot_team_d0_target_team", grc_cavalry),
						(team_set_slot, ":team_no", ":slot", ":enemy_team_no"),
						(store_add, ":slot", "slot_team_d0_target_division", grc_cavalry),
						(team_set_slot, ":team_no", ":slot", ":enemy_division"),
					(try_end),
				(try_end),
			(try_end),
			(try_begin),
				(eq, ":nearest_threat_distance", Far_Away),
				(assign, ":nearest_target_guarded", 0),
			(else_try),
				(eq, ":nearest_target_distance", Far_Away),
				(assign, ":nearest_target_guarded", 1),
			(else_try),
				(get_distance_between_positions, reg0, Nearest_Target_Pos, Nearest_Threat_Pos),
				(store_div, reg1, AI_charge_distance, 2),
				(try_begin),	#ignore target too close to threat
					(le, reg0, reg1),
					(assign, ":nearest_target_guarded", 1),
				(else_try),
					(assign, ":nearest_target_guarded", 0),
				(try_end),
			(try_end),

			(assign, ":cavalry_order", mordr_charge), ##CABA HERE
			(try_begin),
				(teams_are_enemies, ":team_no", 0),
				(neg|team_slot_ge, 1, "slot_team_reinforcement_stage", AI_Max_Reinforcements),
				(neg|team_slot_eq, 1, "slot_team_reinforcement_stage", "$attacker_reinforcement_stage"),
				(assign, ":cavalry_order", mordr_hold),
			(else_try),
				(teams_are_enemies, ":team_no", 1),
				(neg|team_slot_ge, 0, "slot_team_reinforcement_stage", AI_Max_Reinforcements),
				(neg|team_slot_eq, 0, "slot_team_reinforcement_stage", "$defender_reinforcement_stage"),
				(assign, ":cavalry_order", mordr_hold),
			(else_try),
				(neq, ":infantry_order", mordr_charge),
				(try_begin),
					(le, "$battle_phase", BP_Jockey),
					(assign, ":cavalry_order", mordr_hold),
				(else_try),
					(eq, ":nearest_target_distance", Far_Away),
					(try_begin),
						(eq, ":num_archers", 0),
						(assign, ":distance_to_archers", 0),
					(else_try),
						(get_distance_between_positions, ":distance_to_archers", Cavalry_Pos, Archers_Pos),
					(try_end),
					(try_begin),
						(this_or_next|gt, ":enemy_agent_nearest_cavalry_dist", AI_charge_distance),
						(gt, ":distance_to_archers", AI_charge_distance),
						(assign, ":cavalry_order", mordr_hold),
					(try_end),
				(try_end),
			(try_end),

			(try_begin),
				(eq, ":team_no", 0),
				(assign, ":cav_destination", Team0_Cavalry_Destination),
			(else_try),
				(eq, ":team_no", 1),
				(assign, ":cav_destination", Team1_Cavalry_Destination),
			(else_try),
				(eq, ":team_no", 2),
				(assign, ":cav_destination", Team2_Cavalry_Destination),
			(else_try),
				(eq, ":team_no", 3),
				(assign, ":cav_destination", Team3_Cavalry_Destination),
			(try_end),
			(store_add, ":slot", "slot_team_d0_percent_ranged", grc_cavalry),
			(team_get_slot, reg0, ":team_no", ":slot"),
			
			#horse archers don't use wedge
			(try_begin),
				(ge, reg0, 50),
				(call_script, "script_formation_end", ":team_no", grc_cavalry),
				(try_begin),
					(eq, ":num_archers", 0),
					(team_get_movement_order, reg0, ":team_no", grc_cavalry),
					(try_begin),
						(neq, reg0, mordr_charge),
						(team_give_order, ":team_no", grc_cavalry, mordr_charge),
					(try_end),
				(else_try),
					(team_get_movement_order, reg0, ":team_no", grc_cavalry),
					(try_begin),
						(neq, reg0, ":cavalry_order"),
						(team_give_order, ":team_no", grc_cavalry, ":cavalry_order"),
					(try_end),
					(copy_position, ":cav_destination", Archers_Pos),
					(position_move_y, ":cav_destination", -500, 0),
					(team_set_order_position, ":team_no", grc_cavalry, ":cav_destination"),
				(try_end),
				
			#close in with no unguarded target farther off, free fight
			(else_try),
				(eq, ":cavalry_order", mordr_charge),
				(this_or_next|eq, ":num_archers", 0),
				(le, ":enemy_agent_nearest_cavalry_dist", AI_charge_distance),
				(try_begin),
					(eq, ":num_targets", 1),
					(eq, ":nearest_target_guarded", 0),
					(gt, ":nearest_target_distance", ":nearest_threat_distance"),
					(assign, reg0, 0),
				(else_try),
					(ge, ":num_targets", 2),
					(eq, ":nearest_target_guarded", 1),
					(assign, reg0, 0),
				(else_try),
					(assign, reg0, 1),
				(try_end),
				(eq, reg0, 1),
				(call_script, "script_formation_end", ":team_no", grc_cavalry),
				(team_get_movement_order, reg0, ":team_no", grc_cavalry),
				(try_begin),
					(neq, reg0, mordr_charge),
					(team_give_order, ":team_no", grc_cavalry, mordr_charge),
				(try_end),

			#grand charge if target closer than threat AND not guarded
			(else_try),
				(lt, ":nearest_target_distance", ":nearest_threat_distance"),
				(eq, ":nearest_target_guarded", 0),
				(call_script, "script_formation_end", ":team_no", grc_cavalry),
				(team_get_movement_order, reg0, ":team_no", grc_cavalry),
				(try_begin),
					(neq, reg0, mordr_hold),
					(team_give_order, ":team_no", grc_cavalry, mordr_hold),
				(try_end),
				
				#lead archers up to firing point
				(try_begin),
					(gt, ":nearest_target_distance", AI_firing_distance),
					(eq, ":cavalry_order", mordr_hold),
					(try_begin),
						(eq, ":num_archers", 0),
						(copy_position, ":cav_destination", Cavalry_Pos),	#must be reinforcements, so gather at average position
					(else_try),						
						(copy_position, ":cav_destination", Archers_Pos),
						(position_move_y, ":cav_destination", AI_charge_distance, 0),
					(try_end),
					
				#then CHARRRRGE!
				(else_try),
					(copy_position, ":cav_destination", Cavalry_Pos),
					(call_script, "script_point_y_toward_position", ":cav_destination", Nearest_Target_Pos),
					(position_move_y, ":cav_destination", ":nearest_target_distance", 0),
				(try_end),
				(team_set_order_position, ":team_no", grc_cavalry, ":cav_destination"),
				
			#make a wedge somewhere
			(else_try),
				(try_begin),
					(eq, ":cavalry_order", mordr_charge),
					(neq, ":nearest_target_distance", Far_Away),
					(copy_position, ":cav_destination", Cavalry_Pos),
					(call_script, "script_point_y_toward_position", ":cav_destination", Nearest_Target_Pos),
					(position_move_y, ":cav_destination", ":nearest_target_distance", 0),
					(position_move_y, ":cav_destination", AI_charge_distance, 0),	#charge on through to the other side
				(else_try),
					(neq, ":cavalry_order", mordr_charge),
					(eq, ":num_archers", 0),
					(copy_position, ":cav_destination", Cavalry_Pos),	#must be reinforcements, so gather at average position
				(else_try),
					(copy_position, ":cav_destination", Archers_Pos),	#hold near archers
					(position_move_x, ":cav_destination", 500, 0),
					(position_move_y, ":cav_destination", -1000, 0),
				(try_end),
				
				#move around threat in the way to destination
				(try_begin),
					(neq, ":nearest_threat_distance", Far_Away),
					(call_script, "script_point_y_toward_position", Cavalry_Pos, Nearest_Threat_Pos),
					(call_script, "script_point_y_toward_position", Nearest_Threat_Pos, ":cav_destination"),
					(position_get_rotation_around_z, reg0, Cavalry_Pos),
					(position_get_rotation_around_z, reg1, Nearest_Threat_Pos),
					(store_sub, ":rotation_diff", reg0, reg1),
					(try_begin),
						(lt, ":rotation_diff", -180),
						(val_add, ":rotation_diff", 360),
					(else_try),
						(gt, ":rotation_diff", 180),
						(val_sub, ":rotation_diff", 360),
					(try_end),
					
					(try_begin),
						(is_between, ":rotation_diff", -135, 136),
						(copy_position, ":cav_destination", Cavalry_Pos),
						(assign, ":distance_to_move", AI_firing_distance),
						(try_begin),	#target is left of threat
							(is_between, ":rotation_diff", -135, 0),
							(val_mul, ":distance_to_move", -1),
						(try_end),
						(position_move_x, ":cav_destination", ":distance_to_move", 0),
						(store_sub, ":distance_to_move", ":nearest_threat_distance", AI_firing_distance),
						(position_move_y, ":cav_destination", ":distance_to_move", 0),
						(call_script, "script_point_y_toward_position", ":cav_destination", Cavalry_Pos),
						(position_rotate_z, ":cav_destination", 180),
					(try_end),
				(try_end),
				(get_scene_boundaries, pos0, pos1),
				(position_get_x, reg0, ":cav_destination"),
				(position_get_x, reg1, pos0),
				(val_max, reg0, reg1),
				(position_get_x, reg1, pos1),
				(val_min, reg0, reg1),
				(position_set_x, ":cav_destination", reg0),
				(position_get_y, reg0, ":cav_destination"),
				(position_get_y, reg1, pos0),
				(val_max, reg0, reg1),
				(position_get_y, reg1, pos1),
				(val_min, reg0, reg1),
				(position_set_y, ":cav_destination", reg0),
				(position_set_z_to_ground_level, ":cav_destination"),
				
				(try_begin),
					(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_cavalry, formation_wedge),
					(copy_position, pos1, ":cav_destination"),
					(call_script, "script_form_cavalry", ":team_no", grc_cavalry, ":team_leader", 0, 0),
					(store_add, ":slot", "slot_team_d0_formation", grc_cavalry),
					(team_set_slot, ":team_no", ":slot", formation_wedge),
					# (team_give_order, ":team_no", grc_cavalry, mordr_hold),
				(else_try),
					(call_script, "script_formation_end", ":team_no", grc_cavalry),
					(team_get_movement_order, reg0, ":team_no", grc_cavalry),
					(try_begin),
						(neq, reg0, ":cavalry_order"),
						(team_give_order, ":team_no", grc_cavalry, ":cavalry_order"),
					(try_end),
				(try_end),
				(call_script, "script_set_formation_destination", ":team_no", grc_cavalry, ":cav_destination"),
			(try_end),
		(try_end),

		#place leader
		(try_begin),
			(ge, ":team_leader", 0),
			(agent_is_alive, ":team_leader"),
			(agent_slot_eq, ":team_leader", "slot_agent_is_running_away", 0),
			(try_begin),
				(le, ":num_infantry", 0),
				(try_begin),
					(this_or_next|le, ":num_archers", 0),
					(eq, ":archer_order", mordr_retreat),
					
					(assign, ":more_reinforcements", 1),
					(try_begin),
						(teams_are_enemies, ":team_no", 0),
						(team_slot_ge, 1, "slot_team_reinforcement_stage", AI_Max_Reinforcements),
						(assign, ":more_reinforcements", 0),
					(else_try),
						(teams_are_enemies, ":team_no", 1),
						(team_slot_ge, 0, "slot_team_reinforcement_stage", AI_Max_Reinforcements),
						(assign, ":more_reinforcements", 0),
					(try_end),
					(eq, ":more_reinforcements", 0),
					
					(agent_clear_scripted_mode, ":team_leader"),
					(agent_start_running_away, ":team_leader"),
					(agent_set_slot, ":team_leader",  "slot_agent_is_running_away", 1),
				(else_try),
					(eq, ":archer_order", mordr_charge),
					(agent_clear_scripted_mode, ":team_leader"),
				(else_try),
					(copy_position, pos1, Archers_Pos),
					(position_move_y, pos1, -1000, 0),
					(agent_set_scripted_destination, ":team_leader", pos1, 1),
				(try_end),
			(else_try),
				(neq, ":place_leader_by_infantry", 0),
				(call_script, "script_battlegroup_get_position", pos1, ":team_no", grc_infantry),
				(team_get_order_position, pos0, ":team_no", grc_infantry),
				(call_script, "script_point_y_toward_position", pos1, pos0),
				(call_script, "script_battlegroup_get_action_radius", ":team_no", grc_infantry),
				(val_div, reg0, 2),	#bring to edge of battlegroup
				(position_move_x, pos1, reg0, 0),
				(position_move_x, pos1, 100, 0),
				(agent_set_scripted_destination, ":team_leader", pos1, 1),
			(else_try),
				(agent_clear_scripted_mode, ":team_leader"),
			(try_end),
		(try_end),
	(try_end)
	]),
	  
  # script_field_tactics by motomataru
  # Input: flag 1 to include ranged
  # Output: none
  ("field_tactics", [
	(store_script_param, ":include_ranged", 1),
	
	(assign, ":largest_team_size", 0),
	(assign, ":battle_size", 0),
	(try_for_range, ":ai_team", 0, 4),
	    (team_get_slot, ":team_size", ":ai_team", "slot_team_size"),
		(gt, ":team_size", 0),
	    (team_get_slot, ":team_cav_size", ":ai_team", "slot_team_num_cavalry"),
		(store_add, ":team_adj_size", ":team_size", ":team_cav_size"),	#double count cavalry to capture effect on battlefield
		(val_add, ":battle_size", ":team_adj_size"),
		
		(try_begin),
		    (neq, ":ai_team", "$fplayer_team_no"),
			(neg|teams_are_enemies, ":ai_team", "$fplayer_team_no"),
			(team_get_slot, ":player_team_adj_size", "$fplayer_team_no", "slot_team_adj_size"),
			(val_add, ":team_adj_size", ":player_team_adj_size"),	#ally team takes player team into account
			(team_set_slot, "$fplayer_team_no", "slot_team_adj_size", ":team_adj_size"),	#and vice versa
		(try_end),
		(team_set_slot, ":ai_team", "slot_team_adj_size", ":team_adj_size"),
		
	    (lt, ":largest_team_size", ":team_adj_size"),
		(assign, ":largest_team_size", ":team_adj_size"),
	(try_end),

	#apply tactics to every AI team
    (set_show_messages, 1),#gdw
	(try_for_range, ":ai_team", 0, 4),
		(team_get_slot, ":ai_team_size", ":ai_team", "slot_team_adj_size"),
		(gt, ":ai_team_size", 0),
		
		(assign, ":do_it", 0),
		(try_begin),
			(neq, ":ai_team", "$fplayer_team_no"),
			(assign, ":do_it", 1),
		(else_try),
			(main_hero_fallen),    #have AI take over for mods with post-player battle action
			(eq, AI_Replace_Dead_Player, 1),
			(assign, ":do_it", 1),
		(try_end),
		(eq, ":do_it", 1),
		
		(team_get_slot, ":ai_faction", ":ai_team", "slot_team_faction"),
		(try_begin),
			(this_or_next|eq, AI_for_kingdoms_only, 0),
			(this_or_next|eq, ":ai_faction", "fac_deserters"),	#deserters have military training
			(this_or_next|eq, ":ai_faction", "fac_mountain_bandits"),	#scoti, frank and dena pirates have military training Chief anade
			(is_between, ":ai_faction", kingdoms_begin, kingdoms_end),
			(val_mul, ":ai_team_size", 100),
			(store_div, ":team_percentage", ":ai_team_size", ":largest_team_size"),
			(store_div, ":team_battle_presence", ":ai_team_size", ":battle_size"),
			(try_begin),
				(eq, ":include_ranged", 1),
				(try_begin),
					(store_mod, ":team_phase", ":ai_team", 2),
					(eq, ":team_phase", 0),
					(assign, ":time_slice", 0),
				(else_try),
					(store_div, ":time_slice", Reform_Trigger_Modulus, 2),
				(try_end),

				(store_mod, reg0, "$ranged_clock", Reform_Trigger_Modulus),
                         (this_or_next|eq, reg0, ":time_slice"),
                        (eq, "$battle_phase", BP_Setup),
                  (call_script, "script_team_field_ranged_tactics", ":ai_team", ":team_percentage", ":team_battle_presence"),
			(try_end),
				
			(try_begin),
				(neg|main_hero_fallen),
				(store_add, ":slot", "slot_team_d0_target_team", grc_infantry),
				(team_slot_eq, ":ai_team", ":slot", "$fplayer_team_no"),
				(store_add, ":slot", "slot_team_d0_target_division", grc_infantry),
				(team_get_slot, ":enemy_division", ":ai_team", ":slot"),
				(store_add, ":slot", "slot_team_d0_size", ":enemy_division"),
				(team_slot_ge, "$fplayer_team_no", ":slot", 1),
				(store_add, ":slot", "slot_team_d0_fclock", ":enemy_division"),
				(team_get_slot, ":fclock", "$fplayer_team_no", ":slot"),
				(store_mod, reg0, ":fclock", Reform_Trigger_Modulus),
				(store_div, ":time_slice", Reform_Trigger_Modulus, 2),
			(else_try),
				(store_mod, reg0, "$ranged_clock", Reform_Trigger_Modulus),
				(store_mod, ":team_phase", ":ai_team", 2),
				(eq, ":team_phase", 0),
				(assign, ":time_slice", 0),
			(else_try),
				(store_div, ":time_slice", Reform_Trigger_Modulus, 2),
			(try_end),

			(eq, reg0, ":time_slice"),
			(call_script, "script_team_field_melee_tactics", ":ai_team", ":team_percentage", ":team_battle_presence"),
		(try_end),
	(try_end),
    (set_show_messages, 1),

	# (try_begin),
		# (eq, ":include_ranged", 1), 	  
		# (assign, "$prev_casualties", "$cur_casualties"),
	# (try_end)
	]),

	
# # Utilities used by AI by motomataru

  # script_find_high_ground_around_pos1_corrected by motomataru
  # Input:	arg1: destination position
  #			arg2: search_radius (in meters)
  #			pos1 should hold center_position_no
  # Output:	destination contains highest ground within a <search_radius> meter square around pos1
  # Also uses position registers: pos0
  ("find_high_ground_around_pos1_corrected", [
	(store_script_param, ":destination_pos", 1),
	(store_script_param, ":search_radius", 2),
	(assign, ":fixed_point_multiplier", 1),
	(convert_to_fixed_point, ":fixed_point_multiplier"),
	(set_fixed_point_multiplier, 1),
	
	(position_get_x, ":o_x", pos1),
	(position_get_y, ":o_y", pos1),
	(store_sub, ":min_x", ":o_x", ":search_radius"),
	(store_sub, ":min_y", ":o_y", ":search_radius"),
	(store_add, ":max_x", ":o_x", ":search_radius"),
	(store_add, ":max_y", ":o_y", ":search_radius"),
	
	(get_scene_boundaries, ":destination_pos", pos0),
	(position_get_x, ":scene_min_x", ":destination_pos"),
	(position_get_x, ":scene_max_x", pos0),
	(position_get_y, ":scene_min_y", ":destination_pos"),
	(position_get_y, ":scene_max_y", pos0),
	(val_max, ":min_x", ":scene_min_x"),
	(val_max, ":min_y", ":scene_min_y"),
	(val_min, ":max_x", ":scene_max_x"),
	(val_min, ":max_y", ":scene_max_y"),

	(assign, ":highest_pos_z", -100),
	(copy_position, ":destination_pos", pos1),
	(init_position, pos0),

	(try_for_range, ":i_x", ":min_x", ":max_x"),
		(try_for_range, ":i_y", ":min_y", ":max_y"),
			(position_set_x, pos0, ":i_x"),
			(position_set_y, pos0, ":i_y"),
			(position_set_z_to_ground_level, pos0),
			(position_get_z, ":cur_pos_z", pos0),
			(try_begin),
				(gt, ":cur_pos_z", ":highest_pos_z"),
				(copy_position, ":destination_pos", pos0),
				(assign, ":highest_pos_z", ":cur_pos_z"),
			(try_end),
		(try_end),
	(try_end),
	
	(set_fixed_point_multiplier, ":fixed_point_multiplier"),
  ]),
  
  
  # script_cf_count_casualties by motomataru
  # Input: none
  # Output: evalates T/F, reg0 num casualties
  ("cf_count_casualties", [
    (assign, ":num_casualties", 0),
	(try_for_agents,":cur_agent"),
	    (try_begin),
			(this_or_next|agent_is_wounded, ":cur_agent"),
			(this_or_next|agent_slot_eq, ":cur_agent", "slot_agent_is_running_away", 1),
			(neg|agent_is_alive, ":cur_agent"),
			(val_add, ":num_casualties", 1),
		(try_end),
	(try_end),
	(assign, reg0, ":num_casualties"),
	(gt, ":num_casualties", 0)
	]),
	
	
  # script_cf_any_fighting by motomataru
  # Input: none
  # Output: evalates T/F
  ("cf_any_fighting", [
	(assign, ":any_fighting", 0),
	(try_for_range, ":team", 0, 4),
		(team_slot_ge, ":team", "slot_team_size", 1),
		(eq, ":any_fighting", 0),
		(assign, ":num_divs", 9),
		(try_for_range, ":division", 0, ":num_divs"),
			(store_add, ":slot", "slot_team_d0_in_melee", ":division"),
			(team_slot_ge, ":team", ":slot", 1),
			(assign, ":any_fighting", 1),
			(assign, ":num_divs", 0),
		(try_end),
	(try_end),
	
	#lag this check to be sure
	(store_mission_timer_c, ":time_stamp"),
	(try_begin),	#time lag
		(gt, ":any_fighting", 0),
		(assign, "$teams_last_fighting", ":time_stamp"),
	(try_end),
	(assign, ":fighting_finished", formation_reform_interval),
	(val_max, ":fighting_finished", 5),
	(val_add, ":fighting_finished", "$teams_last_fighting"),
	(gt, ":fighting_finished", ":time_stamp"),
	]),
	
	
  # script_get_nearest_enemy_battlegroup_location by motomataru
  # Input: destination position, fron team, from position
  # Output:	destination position, reg0 with distance
  # Run script_store_battlegroup_data before calling!
  ("get_nearest_enemy_battlegroup_location", [
	(store_script_param, ":bgposition", 1),
	(store_script_param, ":team_no", 2),
	(store_script_param, ":from_pos", 3),
	(assign, ":distance_to_nearest_enemy_battlegoup", Far_Away),
	(try_for_range, ":enemy_team_no", 0, 4),
		(team_slot_ge, ":enemy_team_no", "slot_team_size", 1),
		(teams_are_enemies, ":enemy_team_no", ":team_no"),
		(try_for_range, ":enemy_division", 0, 9),
			(store_add, ":slot", "slot_team_d0_size", ":enemy_division"),
			(team_slot_ge, ":enemy_team_no", ":slot", 1),
			(call_script, "script_battlegroup_get_position", pos0, ":enemy_team_no", ":enemy_division"),
			(get_distance_between_positions, reg0, pos0, ":from_pos"),
			(try_begin),
				(gt, ":distance_to_nearest_enemy_battlegoup", reg0),
				(assign, ":distance_to_nearest_enemy_battlegoup", reg0),
				(copy_position, ":bgposition", pos0),
			(try_end),
		(try_end),
	(try_end),
	(assign, reg0, ":distance_to_nearest_enemy_battlegoup")
  ]),

###chief improved AI acaba#############
###############################formations motomataru Chief##############
# #Formations Scripts	  
  # script_division_reset_places by motomataru
  # Input: none
  # Output: none
  # Resets globals for placing divisions around player for script_battlegroup_place_around_leader
  ("division_reset_places", [
	(assign, "$next_cavalry_place", formation_minimum_spacing_horse_width),	#first spot RIGHT of the player
	(assign, "$next_archer_place", 1000),	#first spot 10m FRONT of the player
	(assign, "$next_infantry_place", -1 * formation_minimum_spacing_horse_width),	#first spot LEFT of the player
  ]),
   
  # script_battlegroup_place_around_leader by motomataru
  # Input: team, division
  # Output: pos61 division position
  ("battlegroup_place_around_leader", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(team_get_leader, ":fleader", ":fteam"),
	(try_begin),
		(gt, ":fleader", -1),	#any team members left?
		
		(store_sub, ":player_division", "$formation_player_in_division", 1),
		(try_begin),
			(eq, ":player_division", ":fdivision"),
			(assign, ":first_member_is_player", 1),
		(else_try),
			(assign, ":first_member_is_player", 0),
		(try_end),

		(agent_get_position, pos1, ":fleader"),
		(try_begin),
			(eq, "$formation_autorotate", 1),
			(call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":fteam", grc_everyone),
			(neq, reg0, 0),	#more than 0 enemies still alive?
			(call_script, "script_point_y_toward_position", pos1, Enemy_Team_Pos),
		(try_end),

		(store_add, ":slot", "slot_team_d0_type", ":fdivision"),
		(team_get_slot, ":sd_type", ":fteam", ":slot"),
		(store_add, ":slot", "slot_team_d0_size", ":fdivision"),
		(team_get_slot, ":num_troops", ":fteam", ":slot"),
		(store_add, ":slot", "slot_team_d0_formation", ":fdivision"),
		(team_get_slot, ":fformation", ":fteam", ":slot"),
		(store_add, ":slot", "slot_team_d0_formation_space", ":fdivision"),
		(team_get_slot, ":formation_extra_spacing", ":fteam", ":slot"),
		
		#handle memorized placement
		(try_begin),
			(eq, ":first_member_is_player", 0),
			(store_add, ":slot", "slot_faction_d0_mem_relative_x_flag", ":fdivision"),
			(faction_get_slot, ":value", "fac_player_faction", ":slot"),	#only used for player now
			(neq, ":value", 0),
			
			(position_move_x, pos1, ":value", 0),
			(store_add, ":slot", "slot_faction_d0_mem_relative_y", ":fdivision"),
			(faction_get_slot, ":value", "fac_player_faction", ":slot"),	#only used for player now
			(position_move_y, pos1, ":value", 0),
			(copy_position, pos61, pos1),
			(try_begin),
				(neq, ":fformation", formation_none),
				(try_begin),
					(this_or_next|eq, ":sd_type", sdt_cavalry),
					(eq, ":sd_type", sdt_harcher),
					(call_script, "script_form_cavalry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", 0),
				(else_try),
					(eq, ":sd_type", sdt_archer),
					(call_script, "script_get_centering_amount", formation_default, ":num_troops", ":formation_extra_spacing"),
					(val_mul, reg0, -1),
					(position_move_x, pos1, reg0, 0),
					(call_script, "script_form_archers", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", 0, ":fformation"),
				(else_try),
					(call_script, "script_get_centering_amount", ":fformation", ":num_troops", ":formation_extra_spacing"),
					(position_move_x, pos1, reg0, 0),
					(call_script, "script_form_infantry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", 0, ":fformation"),
				(try_end),
			(try_end),
			
		#default placement per division type
		(else_try),
			(this_or_next|eq, ":sd_type", sdt_cavalry),
			(eq, ":sd_type", sdt_harcher),
			(try_begin),
				(eq, ":first_member_is_player", 0),
				(position_move_x, pos1, "$next_cavalry_place", 0),
			(try_end),
			
			(try_begin),	#handle Native's way of doing things
				(eq, ":fformation", formation_none),
				(try_begin),
					(ge, ":formation_extra_spacing", 0),
					(store_mul, ":troop_space", ":formation_extra_spacing", 133),
					(val_add, ":troop_space", 160),
				(else_try),	#handle Native multi-ranks
					(assign, ":troop_space", 200),
					(val_mul, ":formation_extra_spacing", -1),
					(val_add, ":formation_extra_spacing", 1),
					(val_div, ":num_troops", ":formation_extra_spacing"),
				(try_end),
				(store_mul, ":formation_width", ":num_troops", ":troop_space"),
				(store_div, reg0, ":formation_width", 2),
				(position_move_x, pos1, reg0, 0),	#cavalry set up RIGHT of leader
				(copy_position, pos61, pos1),
			(else_try),
				(store_mul, ":troop_space", ":formation_extra_spacing", 50),
				(val_add, ":troop_space", formation_minimum_spacing_horse_width),
				(convert_to_fixed_point, ":num_troops"),
				(store_sqrt, ":formation_width", ":num_troops"),
				(val_mul, ":formation_width", ":troop_space"),
				(convert_from_fixed_point, ":formation_width"),
				(val_sub, ":formation_width", ":troop_space"),
				(store_div, reg0, ":formation_width", 2),
				(position_move_x, pos1, reg0, 0),	#cavalry set up RIGHT of leader
				(copy_position, pos61, pos1),
				(call_script, "script_form_cavalry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", ":first_member_is_player"),
			(try_end),
			
			(try_begin),
				(eq, ":first_member_is_player", 0),
				(val_add, "$next_cavalry_place", ":formation_width"),
				(val_add, "$next_cavalry_place", formation_minimum_spacing_horse_width),
			(try_end),

		(else_try),
			(eq, ":sd_type", sdt_archer),
			(try_begin),
				(eq, ":first_member_is_player", 0),
				(position_move_y, pos1, "$next_archer_place"),	#archers set up FRONT of leader
				(val_add, "$next_archer_place", 500),	#next archers 5m FRONT of these
			(try_end),
			(copy_position, pos61, pos1),
			(try_begin),
				(neq, ":fformation", formation_none),
				(call_script, "script_get_centering_amount", formation_default, ":num_troops", ":formation_extra_spacing"),
				(val_mul, reg0, -1),
				(position_move_x, pos1, reg0, 0),
				(call_script, "script_form_archers", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", ":first_member_is_player", ":fformation"),
			(try_end),
			
		(else_try),
			(eq, ":sd_type", sdt_skirmisher),
			(try_begin),
				(eq, ":first_member_is_player", 0),
				(position_move_y, pos1, "$next_archer_place"),	#skirmishers set up FRONT of leader
				(val_add, "$next_archer_place", 500),	#next archers 5m FRONT of these
			(try_end),
			(copy_position, pos61, pos1),
			(try_begin),
				(neq, ":fformation", formation_none),
				(call_script, "script_get_centering_amount", ":fformation", ":num_troops", ":formation_extra_spacing"),
				(position_move_x, pos1, reg0, 0),
				(call_script, "script_form_infantry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", ":first_member_is_player", ":fformation"),
			(try_end),
			
		(else_try),
			(try_begin),
				(eq, ":first_member_is_player", 0),
				(position_move_x, pos1, "$next_infantry_place", 0),
			(try_end),
			(copy_position, pos61, pos1),
			
			(try_begin),	#handle Native's way of doing things
				(eq, ":fformation", formation_none),
				(try_begin),
					(ge, ":formation_extra_spacing", 0),
					(store_mul, ":troop_space", ":formation_extra_spacing", 75),	#Native minimum spacing not consistent but less than this
					(val_add, ":troop_space", 100),
				(else_try),	#handle Native multi-ranks
					(assign, ":troop_space", 150),
					(val_mul, ":formation_extra_spacing", -1),
					(val_add, ":formation_extra_spacing", 1),
					(val_div, ":num_troops", ":formation_extra_spacing"),
				(try_end),
				(store_mul, ":formation_width", ":num_troops", ":troop_space"),
				(store_div, reg0, ":formation_width", 2),
				(val_mul, reg0, -1),	#infantry set up LEFT of leader
				(position_move_x, pos61, reg0, 0),
			(else_try),
				(call_script, "script_form_infantry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", ":first_member_is_player", ":fformation"),
				(call_script, "script_get_centering_amount", ":fformation", ":num_troops", ":formation_extra_spacing"),
				(store_mul, ":formation_width", 2, reg0),
				(store_mul, ":troop_space", ":formation_extra_spacing", 50),
				(val_add, ":troop_space", formation_minimum_spacing),
				(val_add, ":formation_width", ":troop_space"),
				(val_mul, reg0, -1),	#infantry set up LEFT of leader
				(position_move_x, pos61, reg0, 0),
			(try_end),
			
			(try_begin),
				(eq, ":first_member_is_player", 0),
				(val_sub, "$next_infantry_place", ":formation_width"),	#next infantry 1m LEFT of these
				(val_sub, "$next_infantry_place", 100),
			(try_end),
		(try_end),
		
		(store_add, ":slot", "slot_team_d0_move_order", ":fdivision"),
		(team_set_slot, ":fteam", ":slot", mordr_hold),
		(set_show_messages, 1),#gdw
		(team_get_movement_order, reg0, ":fteam", ":fdivision"),
		(try_begin),
			(neq, reg0, mordr_hold),
			(team_give_order, ":fteam", ":fdivision", mordr_hold),
		(try_end),
		(call_script, "script_set_formation_destination", ":fteam", ":fdivision", pos61),
		#(set_show_messages, 1),
	(try_end),
  ]),
  
  # script_form_cavalry by motomataru
  # Input: (pos1), team, division, agent number of team leader, spacing, flag TRUE to include team leader in formation
  # Output: none
  # Form in wedge, (now not) excluding horse archers
  # Creates formation starting at pos1
  ("form_cavalry", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(store_script_param, ":fleader", 3),
	(store_script_param, ":formation_extra_spacing", 4),
	(store_script_param, ":include_leader", 5),
	(store_mul, ":extra_space", ":formation_extra_spacing", 50),
	(store_add, ":x_distance", formation_minimum_spacing_horse_width, ":extra_space"),
	(store_add, ":y_distance", formation_minimum_spacing_horse_length, ":extra_space"),
	(assign, ":max_level", 0),
	(try_for_agents, ":agent"),
		(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
		(agent_get_troop_id, ":troop_id", ":agent"),
		(store_character_level, ":troop_level", ":troop_id"),
		(gt, ":troop_level", ":max_level"),
		(assign, ":max_level", ":troop_level"),
	(end_try),
	(assign, ":column", 1),
	(assign, ":rank_dimension", 1),
	(store_mul, ":neg_y_distance", ":y_distance", -1),
	(store_mul, ":neg_x_distance", ":x_distance", -1),
	(store_div, ":wedge_adj", ":x_distance", 2),
	(store_div, ":neg_wedge_adj", ":neg_x_distance", 2),
	(assign, ":form_left", 1),
	(try_begin),
		(eq, ":include_leader", 0),
		(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
		(team_set_slot, ":fteam", ":slot", -1),
	(else_try),	#after leader, move to next position (copied from below)
        (team_set_slot, ":fteam", ":slot", ":fleader"),
		(try_begin),
			(eq, ":form_left", 1),
			(position_move_x, pos1, ":neg_x_distance", 0),
		(else_try),
			(position_move_x, pos1, ":x_distance", 0),
		(try_end),
		(val_add, ":column", 1),
		(gt, ":column", ":rank_dimension"),
		(position_move_y, pos1, ":neg_y_distance", 0),
		(try_begin),
			(neq, ":form_left", 1),
			(assign, ":form_left", 1),
			(position_move_x, pos1, ":neg_wedge_adj", 0),
		(else_try),
			(assign, ":form_left", 0),
			(position_move_x, pos1, ":wedge_adj", 0),
		(try_end),			
		(assign, ":column", 1),
		(val_add, ":rank_dimension", 1),
	(try_end),
	
	(val_add, ":max_level", 1),
	(try_for_range_backwards, ":rank_level", 0, ":max_level"),	#put troops with highest exp in front
		(try_for_agents, ":agent"),
			(agent_get_troop_id, ":troop_id", ":agent"),
			(store_character_level, ":troop_level", ":troop_id"),
			(eq, ":troop_level", ":rank_level"),				
			(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
			(agent_set_scripted_destination, ":agent", pos1, 1),
			(try_begin),	#First Agent
				(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
				(neg|team_slot_ge, ":fteam", ":slot", 0),
				(team_set_slot, ":fteam", ":slot", ":agent"),
			(try_end),
			(try_begin),
				(eq, ":form_left", 1),
				(position_move_x, pos1, ":neg_x_distance", 0),
			(else_try),
				(position_move_x, pos1, ":x_distance", 0),
			(try_end),
			(val_add, ":column", 1),
			(gt, ":column", ":rank_dimension"),
			(position_move_y, pos1, ":neg_y_distance", 0),
			(try_begin),
				(neq, ":form_left", 1),
				(assign, ":form_left", 1),
				(position_move_x, pos1, ":neg_wedge_adj", 0),
			(else_try),
				(assign, ":form_left", 0),
				(position_move_x, pos1, ":wedge_adj", 0),
			(try_end),			
			(assign, ":column", 1),
			(val_add, ":rank_dimension", 1),
		(end_try),
	(end_try),
  ]),
	   
  # script_form_archers by motomataru
  # Input: (pos1), team, division, agent number of team leader, spacing, flag TRUE to include team leader in formation, formation
  # Output: none
  # Form in line, staggered if formation = formation_ranks
  # Creates formation starting at pos1
  ("form_archers", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(store_script_param, ":fleader", 3),
	(store_script_param, ":formation_extra_spacing", 4),
	(store_script_param, ":include_leader", 5),
	(store_script_param, ":archers_formation", 6),
	(store_mul, ":extra_space", ":formation_extra_spacing", 50),
	(store_add, ":distance", formation_minimum_spacing, ":extra_space"),		#minimum distance between troops
	(assign, ":total_move_y", 0),	#staggering variable	
	(try_begin),
		(eq, ":include_leader", 0),
		(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
		(team_set_slot, ":fteam", ":slot", -1),
	(else_try),	#after leader, move to next position (copied from below)
		(team_set_slot, ":fteam", ":slot", ":fleader"),
		(position_move_x, pos1, ":distance", 0),
		(try_begin),
			(eq, ":archers_formation", formation_ranks),
			(val_add, ":total_move_y", 75),
			(try_begin),
				(le, ":total_move_y", 150),
				(position_move_y, pos1, 95, 0),##gdw from 75 to move them out front
			(else_try),
				(position_move_y, pos1, -150, 0),
				(assign, ":total_move_y", 0),
			(try_end),
		(try_end),
	(try_end),
	
	(try_for_agents, ":agent"),
		(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
		(agent_set_scripted_destination, ":agent", pos1, 1),
		(try_begin),	#First Agent
			(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
			(neg|team_slot_ge, ":fteam", ":slot", 0),
			(team_set_slot, ":fteam", ":slot", ":agent"),
		(try_end),
		(position_move_x, pos1, ":distance", 0),
		(try_begin),
			(eq, ":archers_formation", formation_ranks),
			(val_add, ":total_move_y", 75),
			(try_begin),
				(le, ":total_move_y", 150),
				(position_move_y, pos1, 75, 0),
			(else_try),
				(position_move_y, pos1, -150, 0),
				(assign, ":total_move_y", 0),
			(try_end),
		(try_end),
	(try_end),
  ]),
  # script_troop_default_division MOTO chief from VC gdw
  # Input: troop_id, flag 0 for expanded divisions
  # Output: reg0 default division
  ("troop_default_division", [(store_script_param, ":troop_no", 1),
      (store_script_param, ":flag_0_for_expanded", 2),
      
      (assign, ":target_division", grc_infantry),
      (troop_get_inventory_capacity, ":inv_cap", ":troop_no"),
      
      (try_begin),
        (troop_is_guarantee_horse, ":troop_no"),
        (assign, ":has_horse", 0),
        (try_for_range, reg0, 0, ":inv_cap"),
          (troop_get_inventory_slot, ":item", ":troop_no", reg0),
          (gt, ":item", 0),
          (item_get_type, reg1, ":item"),
          (eq, reg1, itp_type_horse),
          (assign, ":has_horse", 1),
        (try_end),
        (neq, ":has_horse", 0),
        (assign, ":target_division", grc_cavalry),
        
        (try_begin),
          (eq, ":flag_0_for_expanded", 0),
          (try_for_range, reg0, 0, ":inv_cap"),
            (troop_get_inventory_slot, ":item", ":troop_no", reg0),
            (call_script, "script_cf_is_weapon_ranged", ":item", 1),
            (assign, ":target_division", sdt_harcher),
          (try_end),
        (try_end),
        
      (else_try),
        (troop_is_guarantee_ranged, ":troop_no"),
        (assign, ":has_ranged", 0),
        (try_for_range, reg0, 0, ":inv_cap"),
          (troop_get_inventory_slot, ":item", ":troop_no", reg0),
          (call_script, "script_cf_is_weapon_ranged", ":item", 1),
          # (item_get_max_ammo, reg1, ":item"), returns 1 for slings, etc.
          # (neg|is_between, reg1, 1, minimum_ranged_ammo), #more than two to
          # throw on a charge?
          (item_get_type, reg1, ":item"),
          (try_begin),
            (this_or_next | eq, reg1, itp_type_thrown),
            (eq, reg1, itp_type_pistol),
            (eq, ":flag_0_for_expanded", 0),
            (neq, ":target_division", grc_archers),
            (assign, ":target_division", sdt_skirmisher),
          (else_try),
            (assign, ":target_division", grc_archers),
          (try_end),
          (assign, ":has_ranged", 1),
        (try_end),
        (neq, ":has_ranged", 0),
        
      (else_try),
        (eq, ":flag_0_for_expanded", 0),
        (try_for_range, reg0, 0, ":inv_cap"),
          (troop_get_inventory_slot, ":item", ":troop_no", reg0),
          (call_script, "script_cf_is_thrusting_weapon", ":item"),
          (item_get_type, reg1, ":item"),
          (eq, reg1, itp_type_polearm),
          (assign, ":target_division", sdt_polearm),
        (try_end),
      (try_end),
      
      (assign, reg0, ":target_division"),]),
	   
  # script_form_infantry by motomataru
  # Input: (pos1), team, division, agent number of team leader, spacing, flag TRUE to include team leader in formation, formation
  # Output: none
  # If input "formation" is formation_default, will select a formation based on faction
  # Creates formation starting at pos1
  ("form_infantry", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(store_script_param, ":fleader", 3),
	(store_script_param, ":formation_extra_spacing", 4),
	(store_script_param, ":include_leader", 5),
	(store_script_param, ":infantry_formation", 6),
	(store_mul, ":extra_space", ":formation_extra_spacing", 50),
	(store_add, ":distance", formation_minimum_spacing, ":extra_space"),		#minimum distance between troops	
	(store_mul, ":neg_distance", ":distance", -1),
	(store_add, ":slot", "slot_team_d0_size", ":fdivision"),
	(team_get_slot, ":num_troops", ":fteam", ":slot"),
	(try_begin),
		(eq, ":infantry_formation", formation_default),
		(call_script, "script_get_default_formation", ":fteam"),
		(assign, ":infantry_formation", reg0),
	(try_end),
	(team_get_weapon_usage_order, ":weapon_order", ":fteam", ":fdivision"),
	(team_get_hold_fire_order, ":fire_order", ":fteam", ":fdivision"),
	(assign, ":reform_interval_thousandths", formation_reform_interval, 1000),
	(assign, ":form_left", 1),
	(assign, ":column", 1),
	(assign, ":rank", 1),

	(try_begin),
		(eq, ":infantry_formation", formation_square),
		(convert_to_fixed_point, ":num_troops"),
		(store_sqrt, ":square_dimension", ":num_troops"),
		(convert_from_fixed_point, ":square_dimension"),
		(val_add, ":square_dimension", 1),
		(try_begin),
			(eq, ":include_leader", 0),
			(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
			(team_set_slot, ":fteam", ":slot", -1),
		(else_try),	#after leader, move to next position (copied from below)
            (team_set_slot, ":fteam", ":slot", ":fleader"),
                        (try_begin),
				(eq, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(position_move_x, pos1, ":distance", 0),
			(try_end),
			(val_add, ":column", 1),
			(gt, ":column", ":square_dimension"),
			(position_move_y, pos1, ":neg_distance", 0),
			(try_begin),
				(neq, ":form_left", 1),
				(assign, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(assign, ":form_left", 0),
				(position_move_x, pos1, ":distance", 0),
			(try_end),			
			(assign, ":column", 1),		
			(val_add, ":rank", 1),
		(try_end),

		(try_for_agents, ":agent"),
			(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
			#(call_script, "script_switch_to_noswing_weapons", ":agent"),
			(call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank"),
			(try_begin),
				(eq, formation_reequip, 1),
				(eq, ":weapon_order", wordr_use_any_weapon),
				(try_begin),
					(this_or_next|eq, ":rank", 1),
					(this_or_next|ge, ":rank", ":square_dimension"),
					(this_or_next|eq, ":column", 1),
					(ge, ":column", ":square_dimension"),
					(call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
					(agent_set_slot, ":agent", "slot_agent_inside_formation", 0),
				(else_try),
					(agent_get_slot, ":closest_enemy", ":agent", "slot_agent_nearest_enemy_agent"),
					(try_begin),
						(neq, ":closest_enemy", -1),
						(agent_get_position, pos0, ":closest_enemy"),
						(get_distance_between_positions, ":enemy_distance", pos0, pos1),
						(le, ":enemy_distance", ":distance"),	#enemy closer than friends?
						(call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
					(else_try),
						(call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
					(try_end),
					(agent_set_slot, ":agent", "slot_agent_inside_formation", 1),
					(agent_set_defend_action, ":agent", -2, ":reform_interval_thousandths"),
				(try_end),
			(try_end),
			(try_begin),
				(eq, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(position_move_x, pos1, ":distance", 0),
			(try_end),
			(val_add, ":column", 1),
			(gt, ":column", ":square_dimension"),
			(position_move_y, pos1, ":neg_distance", 0),
			(try_begin),
				(neq, ":form_left", 1),
				(assign, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(assign, ":form_left", 0),
				(position_move_x, pos1, ":distance", 0),
			(try_end),			
			(assign, ":column", 1),		
			(val_add, ":rank", 1),
		(end_try),
		
	(else_try),
		(eq, ":infantry_formation", formation_wedge),
		(assign, ":max_level", 0),
		(try_for_agents, ":agent"),
			(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
			#(call_script, "script_switch_to_noswing_weapons", ":agent"),
			(agent_get_troop_id, ":troop_id", ":agent"),
			(store_character_level, ":troop_level", ":troop_id"),
			(gt, ":troop_level", ":max_level"),
			(assign, ":max_level", ":troop_level"),
		(end_try),
		
###############################		
		(assign, ":rank_dimension", 1),
		(store_div, ":wedge_adj", ":distance", 2),
		(store_div, ":neg_wedge_adj", ":neg_distance", 2),
		(try_begin),
			(eq, ":include_leader", 0),
			(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
			(team_set_slot, ":fteam", ":slot", -1),
		(else_try),	#after leader, move to next position (copied from below)
            (team_set_slot, ":fteam", ":slot", ":fleader"),
			(try_begin),
				(eq, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(position_move_x, pos1, ":distance", 0),
			(try_end),
			(val_add, ":column", 1),
			(gt, ":column", ":rank_dimension"),
			(position_move_y, pos1, ":neg_distance", 0),
			(try_begin),
				(neq, ":form_left", 1),
				(assign, ":form_left", 1),
				(position_move_x, pos1, ":neg_wedge_adj", 0),
			(else_try),
				(assign, ":form_left", 0),
				(position_move_x, pos1, ":wedge_adj", 0),
			(try_end),			
			(assign, ":column", 1),
			(val_add, ":rank_dimension", 1),
		(try_end),
		##################
		(val_add, ":max_level", 1),
		(try_for_range_backwards, ":rank_level", 0, ":max_level"),	#put troops with highest exp in front
			(try_for_agents, ":agent"),
				(agent_get_troop_id, ":troop_id", ":agent"),
				(store_character_level, ":troop_level", ":troop_id"),
				(eq, ":troop_level", ":rank_level"),				
				(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
				(call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank_dimension"),
				(try_begin),
					(eq, formation_reequip, 1),
					(eq, ":weapon_order", wordr_use_any_weapon),
					(try_begin),
						(this_or_next|eq, ":column", 1),
						(ge, ":column", ":rank_dimension"),
						(call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
						(agent_set_slot, ":agent", "slot_agent_inside_formation", 0),
					(else_try),
						(agent_get_slot, ":closest_enemy", ":agent", "slot_agent_nearest_enemy_agent"),
						(try_begin),
							(neq, ":closest_enemy", -1),
							(agent_get_position, pos0, ":closest_enemy"),
							(get_distance_between_positions, ":enemy_distance", pos0, pos1),
							(le, ":enemy_distance", ":distance"),	#enemy closer than friends?
							(call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
						(else_try),
							(call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
						(try_end),
						(agent_set_slot, ":agent", "slot_agent_inside_formation", 1),
						(agent_set_defend_action, ":agent", -2, ":reform_interval_thousandths"),
					(try_end),
				(try_end),
				(try_begin),
					(eq, ":form_left", 1),
					(position_move_x, pos1, ":neg_distance", 0),
				(else_try),
					(position_move_x, pos1, ":distance", 0),
				(try_end),
				(val_add, ":column", 1),
				(gt, ":column", ":rank_dimension"),
				(position_move_y, pos1, ":neg_distance", 0),
				(try_begin),
					(neq, ":form_left", 1),
					(assign, ":form_left", 1),
					(position_move_x, pos1, ":neg_wedge_adj", 0),
				(else_try),
					(assign, ":form_left", 0),
					(position_move_x, pos1, ":wedge_adj", 0),
				(try_end),			
				(assign, ":column", 1),
				(val_add, ":rank_dimension", 1),
			(end_try),
		(end_try),
		
	(else_try),
		(eq, ":infantry_formation", formation_ranks),
		(store_div, ":rank_dimension", ":num_troops", 3),		#basic three ranks
		(val_add, ":rank_dimension", 1),		
		(assign, ":max_level", 0),
		(try_for_agents, ":agent"),
			(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
			#(call_script, "script_switch_to_noswing_weapons", ":agent"),
			(agent_get_troop_id, ":troop_id", ":agent"),
			(store_character_level, ":troop_level", ":troop_id"),
			(gt, ":troop_level", ":max_level"),
			(assign, ":max_level", ":troop_level"),
		(end_try),

		(try_begin),
			(eq, ":include_leader", 0),
			(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
			(team_set_slot, ":fteam", ":slot", -1),
		(else_try),	#after leader, move to next position (copied from below)
            (team_set_slot, ":fteam", ":slot", ":fleader"),
			(try_begin),
				(eq, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(position_move_x, pos1, ":distance", 0),
			(try_end),
			(val_add, ":column", 1),

			(gt, ":column", ":rank_dimension"),	#next rank?
			(position_move_y, pos1, ":neg_distance", 0),
			(try_begin),
				(neq, ":form_left", 1),
				(assign, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(assign, ":form_left", 0),
				(position_move_x, pos1, ":distance", 0),
			(try_end),			
			(assign, ":column", 1),
			(val_add, ":rank", 1),
		(try_end),
		
		(val_add, ":max_level", 1),
		(try_for_range_backwards, ":rank_level", 0, ":max_level"),	#put troops with highest exp in front
			(try_for_agents, ":agent"),
				(agent_get_troop_id, ":troop_id", ":agent"),
				(store_character_level, ":troop_level", ":troop_id"),
				(eq, ":troop_level", ":rank_level"),				
				(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
				(call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank"),
				(try_begin),
					(eq, formation_reequip, 1),
					(eq, ":weapon_order", wordr_use_any_weapon),
					(try_begin),
						(eq, ":rank", 1),
						(call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
						(agent_set_slot, ":agent", "slot_agent_inside_formation", 0),
					(else_try),
						(agent_get_slot, ":closest_enemy", ":agent", "slot_agent_nearest_enemy_agent"),
						(try_begin),
							(neq, ":closest_enemy", -1),
							(agent_get_position, pos0, ":closest_enemy"),
							(get_distance_between_positions, ":enemy_distance", pos0, pos1),
							(le, ":enemy_distance", ":distance"),	#enemy closer than friends?
							(call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
						(else_try),
							(call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
						(try_end),
						(agent_set_slot, ":agent", "slot_agent_inside_formation", 1),
						(agent_set_defend_action, ":agent", -2, ":reform_interval_thousandths"),
					(try_end),
				(try_end),
				(try_begin),
					(eq, ":form_left", 1),
					(position_move_x, pos1, ":neg_distance", 0),
				(else_try),
					(position_move_x, pos1, ":distance", 0),
				(try_end),
				(val_add, ":column", 1),

				(gt, ":column", ":rank_dimension"),	#next rank?
				(position_move_y, pos1, ":neg_distance", 0),
				(try_begin),
					(neq, ":form_left", 1),
					(assign, ":form_left", 1),
					(position_move_x, pos1, ":neg_distance", 0),
				(else_try),
					(assign, ":form_left", 0),
					(position_move_x, pos1, ":distance", 0),
				(try_end),			
				(assign, ":column", 1),
				(val_add, ":rank", 1),
			(end_try),
		(end_try),
		
	(else_try),
		(eq, ":infantry_formation", formation_shield),
		(store_div, ":rank_dimension", ":num_troops", 3),		#basic three ranks
		(val_add, ":rank_dimension", 1),
		(try_begin),
			(eq, ":include_leader", 0),
			(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
			(team_set_slot, ":fteam", ":slot", -1),
		(else_try),	#after leader, move to next position (copied from below)
            (team_set_slot, ":fteam", ":slot", ":fleader"),
			(try_begin),
				(eq, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(position_move_x, pos1, ":distance", 0),
			(try_end),
			(val_add, ":column", 1),
			
			(gt, ":column", ":rank_dimension"),	#next rank?
			(position_move_y, pos1, ":neg_distance", 0),
			(try_begin),
				(neq, ":form_left", 1),
				(assign, ":form_left", 1),
				(position_move_x, pos1, ":neg_distance", 0),
			(else_try),
				(assign, ":form_left", 0),
				(position_move_x, pos1, ":distance", 0),
			(try_end),			
			(assign, ":column", 1),
			(val_add, ":rank", 1),
		(try_end),
		
		(assign, ":first_second_rank_agent", -1),
		(assign, ":min_len_non_shielded", -1),
		(try_for_range, ":weap_group", 0, 4),
			(store_mul, ":min_len", ":weap_group", Third_Max_Weapon_Length),
			(store_add, ":max_len", ":min_len", Third_Max_Weapon_Length),
			(try_begin),
				(gt, ":min_len_non_shielded", -1),	#looped through agents at least once since rank 2
				(assign, ":min_len_non_shielded", ":min_len"),
			(try_end),
			(try_for_agents, ":agent"),
				(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
				#(call_script, "script_switch_to_noswing_weapons", ":agent"),
				(agent_get_wielded_item, ":agent_weapon", ":agent", 0),
				(try_begin),
					(gt, ":agent_weapon", "itm_no_item"),
					(item_get_slot, ":weapon_length", ":agent_weapon", "slot_item_length"),
				(else_try),
					(assign, ":weapon_length", 0),
				(try_end),
				(try_begin),
					(gt, ":rank", 1),
					(try_begin),
						(eq, ":first_second_rank_agent", ":agent"),	#looped through agents at least once since rank 2
						(assign, ":min_len_non_shielded", ":min_len"),
					(else_try),
						(eq, ":first_second_rank_agent", -1),
						(assign, ":first_second_rank_agent", ":agent"),
					(try_end),
					(eq, formation_reequip, 1),
					(eq, ":weapon_order", wordr_use_any_weapon),
					(ge, ":weapon_length", ":min_len"),	#avoid reequipping agents that are already in formation
					(eq, ":min_len_non_shielded", -1),	#haven't looped through agents at least once since rank 2
					(agent_get_slot, ":closest_enemy", ":agent", "slot_agent_nearest_enemy_agent"),
					(try_begin),
						(neq, ":closest_enemy", -1),
						(agent_get_position, pos0, ":closest_enemy"),
						(get_distance_between_positions, ":enemy_distance", pos0, pos1),
						(le, ":enemy_distance", ":distance"),	#enemy closer than friends?
						(call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
					(else_try),
						(call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
					(try_end),
					(agent_set_slot, ":agent", "slot_agent_inside_formation", 1),
					(agent_set_defend_action, ":agent", -2, ":reform_interval_thousandths"),
					(agent_get_wielded_item, ":agent_weapon", ":agent", 0),
					(try_begin),
						(gt, ":agent_weapon", "itm_no_item"),
						(item_get_slot, ":weapon_length", ":agent_weapon", "slot_item_length"),
					(else_try),
						(assign, ":weapon_length", 0),
					(try_end),
				(try_end),
				
				(assign, ":form_up", 0),
				(agent_get_wielded_item, ":agent_shield", ":agent", 1),
				(try_begin),
					(gt, ":agent_shield", "itm_no_item"),
					(item_get_type, reg0, ":agent_shield"),
					(eq, reg0, itp_type_shield),
					(try_begin),
						(is_between, ":weapon_length", ":min_len", ":max_len"),
						(assign, ":form_up", 1),
					(try_end),
				(else_try),
					(this_or_next|gt, ":rank", 1),
					(gt, ":weap_group", 2),
					(is_between, ":weapon_length", ":min_len_non_shielded", ":max_len"),
					(assign, ":form_up", 1),
				(try_end),

				(eq, ":form_up", 1),
				(call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank"),
				(try_begin),
					(eq, formation_reequip, 1),
					(eq, ":weapon_order", wordr_use_any_weapon),
					(eq, ":rank", 1),
					(call_script, "script_equip_best_melee_weapon", ":agent", 1, 0, ":fire_order"),	#best weapon, force shield
					(agent_set_slot, ":agent", "slot_agent_inside_formation", 0),
				(try_end),
				(try_begin),
					(eq, ":form_left", 1),
					(position_move_x, pos1, ":neg_distance", 0),
				(else_try),
					(position_move_x, pos1, ":distance", 0),
				(try_end),
				(val_add, ":column", 1),
				
				(gt, ":column", ":rank_dimension"),	#next rank?
				(position_move_y, pos1, ":neg_distance", 0),
				(try_begin),
					(neq, ":form_left", 1),
					(assign, ":form_left", 1),
					(position_move_x, pos1, ":neg_distance", 0),
				(else_try),
					(assign, ":form_left", 0),
					(position_move_x, pos1, ":distance", 0),
				(try_end),			
				(assign, ":column", 1),
				(val_add, ":rank", 1),
			(try_end),
		(try_end),
	(try_end),

	#calculate percent in place from counts from section above (see script_formation_process_agent_move)
	(store_add, ":slot", "slot_team_d0_size", ":fdivision"),
	(team_get_slot, ":num_troops", ":fteam", ":slot"),
	(store_add, ":slot", "slot_team_d0_percent_in_place", ":fdivision"),
	(team_get_slot, reg0, ":fteam", ":slot"),
	(val_mul, reg0, 100),
	(val_div, reg0, ":num_troops"),
	(team_set_slot, ":fteam", ":slot", reg0),
  ]),
	   
  # script_get_default_formation by motomataru
  # Input: team id
  # Output: reg0 default formation
  ("get_default_formation", [
	(store_script_param, ":fteam", 1),
	(team_get_slot, ":ffaction", ":fteam", "slot_team_faction"),
	(try_begin),
	    (this_or_next|eq, ":ffaction", "fac_player_supporters_faction"),
		(eq, ":ffaction", "fac_player_faction"),
		(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		(assign, ":ffaction", "$players_kingdom"),
	(try_end),

		#assign default formation chief cambiado
		(try_begin),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_1"),	#Centware
			(assign, reg0, formation_ranks),	#Representing shieldwall historic choice
			#gdw was shield now ranks for testing
		(else_try),
			(eq, ":ffaction", "fac_kingdom_2"),	#Sussex
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_3"),	#Essex
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_4"),	#East Englas
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_5"),	#Gewissae
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_6"),	#Hwicce
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_7"),	#Glastenic
			(assign, reg0, formation_ranks),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_8"),	#Dumnonia
			(assign, reg0, formation_ranks),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_9"),	#Mierce
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_10"),	#Ynys Manaw
			(assign, reg0, formation_ranks),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_11"),	#Pengwern
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_12"),	#Goutodin
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_13"),	#Bernacia
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_14"),	#Lindisware
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_15"),	#Rheged
			(assign, reg0, formation_ranks),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_16"),	#Crafu
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_17"),	#Connaught
			(assign, reg0, formation_ranks),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_18"),	#Alt Clut
			(assign, reg0, formation_ranks),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_19"),	#Dal Riata
			(assign, reg0, formation_ranks),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_20"),	#Picts
			(assign, reg0, formation_square),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_21"),	#Ceredigion
			(assign, reg0, formation_ranks),	#Historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_22"),	#Powys
			(assign, reg0, formation_shield),	#Representing phalanx historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_23"),	#Gwynedd
			(assign, reg0, formation_shield),	#Representing shieldwall historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_24"),	#Dyfed
			(assign, reg0, formation_ranks),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_25"),	#Brycheiniog
			(assign, reg0, formation_shield),	#Historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_26"),	#Gwent
			(assign, reg0, formation_shield),	#Representing phalanx historic choice
		(else_try),
			(eq, ":ffaction", "fac_kingdom_27"),	#Laigin
			(assign, reg0, formation_ranks),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_28"),	#Desmumu
			(assign, reg0, formation_ranks),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_29"),	#Ulaid
			(assign, reg0, formation_ranks),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_30"),	#Ui Neill
			(assign, reg0, formation_ranks),
		(else_try),
			(eq, ":ffaction", "fac_kingdom_31"),	#Airgialla
			(assign, reg0, formation_ranks),
		(else_try),
	    	(eq, ":ffaction", "fac_player_supporters_faction"),
	    	(assign, reg0, formation_ranks),
	    (else_try),
	    	(eq, ":ffaction", "fac_player_faction"),
	    	(assign, reg0, formation_ranks),
		(else_try),
			(assign, reg0, formation_none),	#riffraff don't use formations
		(try_end),
#chief modificado acaba
  ]),
   # script_cf_is_thrusting_weapon by motomataru
  # Input: item
  # Output: T/F
  ("cf_is_thrusting_weapon", [
	(store_script_param, ":item", 1),
	(is_between, ":item", weapons_begin, weapons_end),
	#(item_get_slot, ":thrust_damage", ":item", "slot_item_thrust_damage"),
	(item_get_thrust_damage,":thrust_damage", ":item"),
	#(item_get_slot, ":swing_damage", ":item", "slot_item_swing_damage"),
	(item_get_swing_damage,":swing_damage", ":item"),
	(val_mul, ":thrust_damage", 5),	#it seems thrusts connect faster than swings (as they should) although the animations seem to take the same time #gdw was 3/2
	(val_div, ":thrust_damage", 3),	#factor this in with approximation 2*PI/4 (distance swing must travel vs. thrust) This ignores length, which creates too large a differential. This is a happy medium.
	(ge, ":thrust_damage", ":swing_damage"),
  ]),#gdw70915 i increased mul to 12 hoping to get noswing to work no help
#gdw70915 i increased mul to 12 hoping to get noswing to work no help
	# script_cf_is_weapon_ranged by motomataru
  # Input: weapon ID, flag 0/1 to consider thrown weapons
  # Output: T/F
  ("cf_is_weapon_ranged", [(store_script_param, ":weapon", 1),
      (store_script_param, ":include_thrown", 2),
      
      (assign, ":test_val", 0),
      (try_begin),
        (ge, ":weapon", 0),
        (item_get_type, ":type", ":weapon"),
        (try_begin),
          (this_or_next | eq, ":type", itp_type_bow),
          (this_or_next | eq, ":type", itp_type_crossbow),
          (this_or_next | eq, ":type", itp_type_pistol),
          (eq, ":type", itp_type_musket),
          (assign, ":test_val", 1),
        (else_try),
          (eq, ":type", itp_type_thrown),
          (neq, ":include_thrown", 0),
          (assign, ":test_val", 1),
        (try_end),
      (try_end),
      
      (neq, ":test_val", 0),]),
  # script_switch_to_noswing_weapons by motomataru
  # Input: agent
  # Output: none
  ("switch_to_noswing_weapons", [
	(store_script_param, ":agent", 1),
	(try_for_range, ":item_slot", ek_item_0, ek_head),
		(agent_get_item_slot, ":item", ":agent", ":item_slot"),
		(call_script, "script_cf_is_thrusting_weapon", ":item"),
		(item_get_slot, ":noswing_version", ":item", "slot_item_alternate"),
		(agent_unequip_item, ":agent", ":item", ":item_slot"),	#assumes first ek_* are the weapons
		(agent_equip_item, ":agent", ":noswing_version", ":item_slot"),	#assumes first ek_* are the weapons'
	#(else_try),#gdw test no work 80115
	#team_get_hold_fire_order
		#(call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
	(try_end),
  ]),
  
  # script_switch_from_noswing_weapons by motomataru
  # Input: agent
  # Output: none
  ("switch_from_noswing_weapons", [
	(store_script_param, ":agent", 1),
	(try_for_range, ":item_slot", ek_item_0, ek_head),
		(agent_get_item_slot, ":item", ":agent", ":item_slot"),
		(gt, ":item", "itm_items_end"),
		(item_get_slot, ":original_version", ":item", "slot_item_alternate"),
		(agent_unequip_item, ":agent", ":item", ":item_slot"),	#assumes first ek_* are the weapons
		(agent_equip_item, ":agent", ":original_version", ":item_slot"),	#assumes first ek_* are the weapons
	(else_try),
			(agent_is_non_player, ":agent"),
			(agent_get_group, ":team", ":agent"),
			(gt, ":team", -1),	#not a MP spectator
			(call_script, "script_agent_fix_division", ":agent"), #Division fix
			(agent_get_class, reg0, ":agent"),
			(eq, reg0, grc_infantry),	#set up for possible shield wall
			(agent_get_division, ":division", ":agent"),
			(team_get_hold_fire_order, ":fire_order", ":team", ":division"),
			(call_script, "script_equip_best_melee_weapon", ":agent", 1, 0, ":fire_order"),	#best weapon, force shield
	(try_end),
  ]),
  # script_formation_process_agent_move by motomataru
  # Input: (pos1), team, division, agent, which rank of formation agent is in
  # Output: (pos1) may change to reference first agent's anticipated position
  # This function sets scripted destination and performs other tasks related to making the formation look nice on the move (and more)
  ("formation_process_agent_move", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(store_script_param, ":agent", 3),
	(store_script_param, ":rank", 4),
	
	(agent_set_scripted_destination, ":agent", pos1, 1),
	
	(agent_get_position, Current_Pos, ":agent"),
	(get_distance_between_positions, ":distance_to_go", Current_Pos, pos1),

	(store_add, ":slot", "slot_team_d0_speed_limit", ":fdivision"),
	(team_get_slot, ":speed_limit", ":fteam", ":slot"),
	
	(agent_get_speed, Speed_Pos, ":agent"),
	(position_transform_position_to_parent, Temp_Pos, Current_Pos, Speed_Pos),
	(call_script, "script_point_y_toward_position", Current_Pos, Temp_Pos),	#get direction of travel
	(store_mul, ":expected_travel", reg0, formation_reform_interval),
	(store_div, ":speed", ":expected_travel", Km_Per_Hour_To_Cm),

	#First Agent
	(try_begin),
		(store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),
		(neg|team_slot_ge, ":fteam", ":slot", 0),
		(team_set_slot, ":fteam", ":slot", ":agent"),
		
		(try_begin),	#reset speed when first member stopped
			(le, ":speed", 5),	#minimum observed speed
			(store_add, ":slot", "slot_team_d0_speed_limit", ":fdivision"),
			(team_set_slot, ":fteam", ":slot", Top_Speed),
			(agent_set_speed_limit, ":agent", Top_Speed),
			
		(else_try),	#first member in motion
			(val_mul, ":speed", 2),	#after terrain & encumbrance, agents tend to move about half their speed limit
			(try_begin),	#speed up if everyone caught up
				(store_add, ":slot", "slot_team_d0_percent_in_place", ":fdivision"),
				(team_slot_ge, ":fteam", ":slot", 100),
				(try_begin),
					(ge, ":speed", ":speed_limit"),
					(val_add, ":speed_limit", 1),
				(try_end),
			(else_try),	#else slow down
				(val_min, ":speed_limit", ":speed"),
				(val_sub, ":speed_limit", 1),
				(val_max, ":speed_limit", 5),	#minimum observed speed
			(try_end),
			
			#build formation from first agent
			(store_add, ":slot", "slot_team_d0_prev_first_member", ":fdivision"),
			(team_slot_eq, ":fteam", ":slot", ":agent"),	#looking at same first member as last call?
			
                  (call_script, "script_battlegroup_get_position", Temp_Pos, ":fteam", ":fdivision"),
                  (get_distance_between_positions, ":distance_from_group", Current_Pos, Temp_Pos),
                  (call_script, "script_battlegroup_get_action_radius", ":fteam", ":fdivision"),
                  (val_div, reg0, 2),    #function returns length of bg
                  (val_sub, ":distance_from_group", reg0),
                  (lt, ":distance_from_group", 2000),    #within 20m of      rest of division?

                        (store_mul, ":expected_travel", ":speed_limit", Km_Per_Hour_To_Cm),
			(lt, ":expected_travel", ":distance_to_go"),	#more than one call from destination?

			(store_add, ":slot", "slot_team_d0_speed_limit", ":fdivision"),
			(team_set_slot, ":fteam", ":slot", ":speed_limit"),
			(agent_set_speed_limit, ":agent", ":speed_limit"),
			
			(copy_position, Temp_Pos, Current_Pos),
			(call_script, "script_point_y_toward_position", Temp_Pos, pos1),
			(position_move_y, Temp_Pos, ":expected_travel", 0),	#anticipate where first member will be next
			(position_copy_rotation, Temp_Pos, pos1),	#conserve destination facing of formation
			(copy_position, pos1, Temp_Pos),	#reference the rest of the formation to first member's anticipated position
		(try_end),

		(store_add, ":slot", "slot_team_d0_percent_in_place", ":fdivision"),
		(team_set_slot, ":fteam", ":slot", 1),	#reinit: always count first member as having arrived
		(store_add, ":slot", "slot_team_d0_prev_first_member", ":fdivision"),
		(team_set_slot, ":fteam", ":slot", ":agent"),

	#Not First Agent
	(else_try),
		(try_begin),
			(le, ":speed", 0),
			(assign, ":speed_limit", Top_Speed),
		(else_try),
			(neg|position_is_behind_position, pos1, Current_Pos),
			(store_div, ":speed_limit", ":distance_to_go", Km_Per_Hour_To_Cm),
			(val_max, ":speed_limit", 1),
		(else_try),
			(store_add, ":slot", "slot_team_d0_in_melee", ":fdivision"),
			(team_slot_eq, ":fteam", ":slot", 0),
			(assign, ":speed_limit", 1),
		(else_try),
			(assign, ":speed_limit", Top_Speed),
		(try_end),
		(agent_set_speed_limit, ":agent", ":speed_limit"),
		(try_begin),
			(this_or_next|le, ":speed", 0),	#reached previous destination or blocked OR
			(this_or_next|lt, ":speed_limit", Top_Speed),	#destination within reach OR
			(position_is_behind_position, pos1, Current_Pos),	#agent ahead of formation
			(store_add, ":slot", "slot_team_d0_percent_in_place", ":fdivision"),
			(team_get_slot, reg0, ":fteam", ":slot"),
			(val_add, reg0, 1),
			(team_set_slot, ":fteam", ":slot", reg0),
		(try_end),
	(try_end),

	#Housekeeping
	(try_begin),
		(eq, ":rank", 1),
		(agent_set_slot, ":agent", "slot_agent_in_first_rank", 1),
     	(else_try),
		(agent_set_slot, ":agent", "slot_agent_in_first_rank", 0),
	(try_end),
  ]),

  # script_equip_best_melee_weapon by motomataru
  # Input: agent id, flag to force shield, flag to force for length ALONE, current fire order
  # Output: none
  ("equip_best_melee_weapon", [
	(store_script_param, ":agent", 1),
	(store_script_param, ":force_shield", 2),
	(store_script_param, ":force_length", 3),
	(store_script_param, ":fire_order", 4),

	#priority items
	(assign, ":shield", "itm_no_item"),
	(assign, ":weapon", "itm_no_item"),
	(try_for_range, ":item_slot", ek_item_0, ek_head),
		(agent_get_item_slot, ":item", ":agent", ":item_slot"),
		(gt, ":item", "itm_no_item"),
		(item_get_type, ":weapon_type", ":item"),
		(try_begin),
			(eq, ":weapon_type", itp_type_shield),
			(assign, ":shield", ":item"),
		(else_try),
			(eq, ":weapon_type", itp_type_thrown),
			(eq, ":fire_order", aordr_fire_at_will),
			# (agent_get_ammo, ":ammo", ":agent", 0),	#assume infantry would have no other kind of ranged weapon
			# (gt, ":ammo", 0),
			(assign, ":weapon", ":item"),	#use thrown weapons first
		(try_end),
	(try_end),
	#select weapon
	(try_begin),
		(eq, ":weapon", "itm_no_item"),
		(assign, ":cur_score", 0),
		(try_for_range, ":item_slot", ek_item_0, ek_head),
			(agent_get_item_slot, ":item", ":agent", ":item_slot"),
			(gt, ":item", "itm_no_item"),
			(item_get_type, ":weapon_type", ":item"),
			(neq, ":weapon_type", itp_type_shield),

			(item_get_slot, reg0, ":item", "slot_item_needs_two_hands"),
			(this_or_next|eq, reg0, 0),
			(this_or_next|eq, ":force_shield", 0),
			(eq, ":shield", "itm_no_item"),
			
			(try_begin),#equipping longest item for the formation
				(neq, ":force_length", 0),
				(item_get_slot, ":item_length", ":item", "slot_item_length"),
				(try_begin),
					(lt, ":cur_score", ":item_length"),
					(assign, ":cur_score", ":item_length"),
					(assign, ":weapon", ":item"),
				(try_end),
			(else_try),
				(assign, ":imod", imodbit_plain),
				(agent_get_troop_id, ":troop_id", ":agent"),
				(try_begin),    #only heroes have item modifications
					(troop_is_hero, ":troop_id"),
					(try_for_range, ":troop_item_slot",  ek_item_0, ek_head),    # heroes have only 4 possible weapons (equipped)
						(troop_get_inventory_slot, reg0, ":troop_id", ":troop_item_slot"),  #Find Item Slot with same item ID as Equipped Weapon
						(eq, reg0, ":item"),
						(troop_get_inventory_slot_modifier, ":imod", ":troop_id", ":troop_item_slot"),
					(try_end),
				(try_end), 

				(call_script, "script_get_item_score_with_imod", ":item", ":imod"),
				(lt, ":cur_score", reg0),
				(assign, ":cur_score", reg0),
				(assign, ":weapon", ":item"),
			 (try_end),
		(try_end),
	(try_end),
 	(agent_get_wielded_item, reg0, ":agent", 0),
	(try_begin),
		(neq, reg0, ":weapon"),
		(try_begin),
			(gt, ":shield", "itm_no_item"),
			(agent_get_wielded_item, reg0, ":agent", 1),
			(neq, reg0, ":shield"),	#reequipping secondary will UNequip (from experience)
			(agent_set_wielded_item, ":agent", ":shield"),
		(try_end),
		(gt, ":weapon", "itm_no_item"),
		(agent_set_wielded_item, ":agent", ":weapon"),
	(try_end),
  ]),
# 	(try_begin),
 #       (gt, "$cheat_mode", 0),
 #       (display_message, "@{!}DEBUG -- itemscore: {reg0}"),
 #       (assign, reg10, ":item_damage"),
 #       (display_message, "@{!}DEBUG -- itemdamage: {reg10}"), 
	# (try_end),
	#equip selected items if needed
  # script_formation_current_position by motomataru
  # Input: destination position (not pos0), team, division
  # Output: in destination position
  # As opposed to script_battlegroup_get_position, this obtains target rotation
  ("formation_current_position", [
	(store_script_param, ":fposition", 1),
	(store_script_param, ":fteam", 2),
	(store_script_param, ":fdivision", 3),
	(call_script, "script_battlegroup_get_position", ":fposition", ":fteam", ":fdivision"),
	(call_script, "script_get_formation_destination", pos0, ":fteam", ":fdivision"),
	(position_copy_rotation, ":fposition", pos0),
	(call_script, "script_battlegroup_dist_center_to_front", ":fteam", ":fdivision"),
	(position_move_y, ":fposition", reg0, 0),
  ]),

  # script_get_centering_amount by motomataru
  # Input: formation type, number of troops, extra spacing
  #        Use formation type formation_default to use script for archer line
  # Output: reg0 number of centimeters to adjust x-position to center formation
  ("get_centering_amount", [
	(store_script_param, ":troop_formation", 1),
	(store_script_param, ":num_troops", 2),
	(store_script_param, ":extra_spacing", 3),
	(store_mul, ":troop_space", ":extra_spacing", 50),
	(val_add, ":troop_space", formation_minimum_spacing),
	(assign, reg0, 0),
	(try_begin),
		(eq, ":troop_formation", formation_square),
		(convert_to_fixed_point, ":num_troops"),
		(store_sqrt, reg0, ":num_troops"),
		(convert_from_fixed_point, reg0),
		(val_mul, reg0, ":troop_space"),
		# (val_sub, reg0, ":troop_space"),	MOTO not needed because column added in script_form_infantry
	(else_try),
		(this_or_next|eq, ":troop_formation", formation_ranks),
		(eq, ":troop_formation", formation_shield),
		(store_div, reg0, ":num_troops", 3),
		(try_begin),
			(store_mod, reg1, ":num_troops", 3),
			(eq, reg1, 0),
			(val_sub, reg0, 1),
		(try_end),
		(val_mul, reg0, ":troop_space"),
	(else_try),
		(eq, ":troop_formation", formation_default),	#assume these are archers in a line
		(store_mul, reg0, ":num_troops", ":troop_space"),
	(try_end),
	(val_div, reg0, 2),
  ]),

  # script_formation_end
  # Input: team, division
  # Output: none
  ("formation_end", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(try_begin),
		(store_add, ":slot", "slot_team_d0_formation", ":fdivision"),
		(neg|team_slot_eq, ":fteam", ":slot", formation_none),
		(team_set_slot, ":fteam", ":slot", formation_none),
		(team_get_leader, ":leader", ":fteam"),
		
		(try_for_agents, ":agent"),
			(agent_is_alive, ":agent"),
			(agent_is_human, ":agent"),
			(agent_get_group, ":team", ":agent"),
			(eq, ":team", ":fteam"),
			(neq, ":leader", ":agent"),
			(agent_get_division, ":bgdivision", ":agent"),
			(eq, ":bgdivision", ":fdivision"),
			(agent_clear_scripted_mode, ":agent"),
			#(call_script, "script_switch_from_noswing_weapons", ":agent"),
			(agent_set_speed_limit, ":agent", 100),
			(agent_set_slot, ":agent", "slot_agent_in_first_rank", 0),
			(agent_set_slot, ":agent", "slot_agent_inside_formation", 0),
		(try_end),
		
		(try_begin),
			(eq, ":fteam", "$fplayer_team_no"),
			(store_add, ":slot", "slot_team_d0_formation_space", ":fdivision"),
			(team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
			
			#adjust for differences between the two systems of spreading out
			(set_show_messages, 1),#gdw
			(try_begin),
				(gt, ":div_spacing", 3),
				(assign, ":div_spacing", 2),	#Native maximum spread out
			(else_try),
				(gt, ":div_spacing", 0),
				(team_give_order, "$fplayer_team_no", ":fdivision", mordr_stand_closer),
				(try_begin),
					(gt, ":div_spacing", 1),
					(assign, ":div_spacing", 1),
				(else_try),
					(assign, ":div_spacing", 0),
				(try_end),
			(try_end),
			#(set_show_messages, 1),
			(team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),
		(try_end),
	(try_end),
  ]),

  # script_formation_move_position by motomataru
  # Input: team, division, formation current position, (1 to advance or -1 to withdraw or 0 to redirect)
  # Output: pos1 (offset for centering)
  ("formation_move_position", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(store_script_param, ":fcurrentpos", 3),
	(store_script_param, ":direction", 4),
	(copy_position, pos1, ":fcurrentpos"),
	(call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":fteam", grc_everyone),
	(try_begin),
		(neq, reg0, 0),	#more than 0 enemies still alive?
		(copy_position, pos1, ":fcurrentpos"),	#restore current formation "position"
		(call_script, "script_point_y_toward_position", pos1, Enemy_Team_Pos),	#record angle from center to enemy
		(assign, ":distance_to_enemy", reg0),
		(call_script, "script_get_formation_destination", pos61, ":fteam", ":fdivision"),
		(get_distance_between_positions, ":move_amount", pos1, pos61),	#distance already moving from previous orders
		(val_add, ":move_amount", 1000),
		(try_begin),
			(gt, ":direction", 0),	#moving forward?
			(gt, ":move_amount", ":distance_to_enemy"),
			(assign, ":move_amount", ":distance_to_enemy"),
		(try_end),
		(val_mul, ":move_amount", ":direction"),
		(position_move_y, pos1, ":move_amount", 0),
		(try_begin),
			(lt, ":distance_to_enemy", 1000),	#less than a move away?
			(position_copy_rotation, pos1, pos61),	#avoid rotating formation
		(try_end),
		(call_script, "script_set_formation_destination", ":fteam", ":fdivision", pos1),
		(store_add, ":slot", "slot_team_d0_size", ":fdivision"),
		(team_get_slot, ":num_troops", ":fteam", ":slot"),
		(store_add, ":slot", "slot_team_d0_formation_space", ":fdivision"),
		(team_get_slot, ":formation_extra_spacing", ":fteam", ":slot"),
		(try_begin),
			(store_add, ":slot", "slot_team_d0_type", ":fdivision"),
			(neg|team_slot_eq, ":fteam", ":slot", sdt_archer),
			(store_add, ":slot", "slot_team_d0_formation", ":fdivision"),
			(team_get_slot, ":fformation", ":fteam", ":slot"),
			(call_script, "script_get_centering_amount", ":fformation", ":num_troops", ":formation_extra_spacing"),
		(else_try),
			(call_script, "script_get_centering_amount", formation_default, ":num_troops", ":formation_extra_spacing"),
			(val_mul, reg0, -1),
		(try_end),
		(position_move_x, pos1, reg0, 0),
	(try_end),
  ]),

  # script_set_formation_destination by motomataru
  # Input: team, troop class, position
  # Kluge around buggy *_order_position functions for teams 0-3
  ("set_formation_destination", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(store_script_param, ":fposition", 3),
	
	(position_get_x, ":x", ":fposition"),
	(position_get_y, ":y", ":fposition"),
	(position_get_rotation_around_z, ":zrot", ":fposition"),
	
	(store_add, ":slot", "slot_team_d0_destination_x", ":fdivision"),
	(team_set_slot, ":fteam", ":slot", ":x"),	
	(store_add, ":slot", "slot_team_d0_destination_y", ":fdivision"),
	(team_set_slot, ":fteam", ":slot", ":y"),	
	(store_add, ":slot", "slot_team_d0_destination_zrot", ":fdivision"),
	(team_set_slot, ":fteam", ":slot", ":zrot"),
	
	(team_set_order_position, ":fteam", ":fdivision", ":fposition"),
  ]),	

  # script_get_formation_destination by motomataru
  # Input: position, team, troop class
  # Output: input position (pos0 used)
  # Kluge around buggy *_order_position functions for teams 0-3
  ("get_formation_destination", [
	(store_script_param, ":fposition", 1),
	(store_script_param, ":fteam", 2),
	(store_script_param, ":fdivision", 3),
	(init_position, ":fposition"),
	# (try_begin),
	    #(is_between, ":fteam", 0, 4), #Caba - this will always pass MOTO except in mods with more than four teams (eg SWC arena) but now obsolete by other limits
		(store_add, ":slot", "slot_team_d0_destination_x", ":fdivision"),
		(team_get_slot, ":x", ":fteam", ":slot"),
		(store_add, ":slot", "slot_team_d0_destination_y", ":fdivision"),
		(team_get_slot, ":y", ":fteam", ":slot"),
		(store_add, ":slot", "slot_team_d0_destination_zrot", ":fdivision"),
		(team_get_slot, ":zrot", ":fteam", ":slot"),
		
		(position_set_x, ":fposition", ":x"),
		(position_set_y, ":fposition", ":y"),
		(position_rotate_z, ":fposition", ":zrot"),
	# (else_try), 
		# (store_add, ":slot", "slot_team_d0_first_member", ":fdivision"),	#only defined for divisions in formation
		# (team_get_slot, reg0, ":fteam", ":slot"),
		# (try_begin),	  # "launder" team_get_order_position shutting down position_move_x
			# (gt, reg0, -1),
			# (team_get_order_position, ":fposition", ":fteam", ":fdivision"),
			# (agent_get_position, pos0, reg0),
			# (agent_set_position, reg0, ":fposition"),
			# (agent_get_position, ":fposition", reg0),
			# (agent_set_position, reg0, pos0),
		# (try_end),
	# (try_end),
	(position_set_z_to_ground_level, ":fposition"),
  ]),	

  # script_cf_battlegroup_valid_formation by Caba'drin
  # Input: team, division, formation
  # Output: reg0: troop count/1 if too few troops/0 if wrong type
  ("cf_battlegroup_valid_formation", [
    (store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(store_script_param, ":fformation", 3),
	
	(assign, ":valid_type", 0),
	(store_add, ":slot", "slot_team_d0_type", ":fdivision"),
	(team_get_slot, ":sd_type", ":fteam", ":slot"),
	(try_begin), #Eventually make this more complex with the sub-divisions
		(this_or_next|eq, ":sd_type", sdt_cavalry),
		(eq, ":sd_type", sdt_harcher),
		(assign, ":size_minimum", formation_min_cavalry_troops),
		(try_begin),
			(eq, ":fformation", formation_wedge),
			(assign, ":valid_type", 1),
		(try_end),
	(else_try),
		(eq, ":sd_type", sdt_archer),
		(assign, ":size_minimum", formation_min_foot_troops),
		(try_begin),
			(this_or_next|eq, ":fformation", formation_ranks),
			(eq, ":fformation", formation_default),
			(assign, ":valid_type", 1),
		(try_end),
	(else_try),
		(assign, ":size_minimum", formation_min_foot_troops),
		(neq, ":fformation", formation_none),
		(assign, ":valid_type", 1), #all types valid
	(try_end),
	
	(try_begin),
	    (eq, ":valid_type", 0),
		(assign, ":num_troops", 0),
	(else_try),
		(store_add, ":slot", "slot_team_d0_size", ":fdivision"),
	    (team_get_slot, ":num_troops", ":fteam", ":slot"),
	    (lt, ":num_troops", ":size_minimum"),
		(assign, ":num_troops", 1),
	(try_end),
	
	(assign, reg0, ":num_troops"),
	(gt, ":num_troops", 1)
  ]),

  # script_cf_valid_formation_member by motomataru #CABA - Modified for Classify_agent phase out
  # Input: team, division, agent number of team leader, test agent
  # Output: failure indicates agent is not member of formation
  ("cf_valid_formation_member", [
	(store_script_param, ":fteam", 1),
	(store_script_param, ":fdivision", 2),
	(store_script_param, ":fleader", 3),
	(store_script_param, ":agent", 4),
	(neq, ":fleader", ":agent"),
	(agent_get_division, ":bgdivision", ":agent"),
	(eq, ":bgdivision", ":fdivision"),
	(agent_get_group, ":team", ":agent"),
	(eq, ":team", ":fteam"),
	(agent_is_alive, ":agent"),
	(agent_is_human, ":agent"),
	(agent_slot_eq, ":agent", "slot_agent_is_running_away", 0),
  ]),

# #Player team formations functions
  # script_player_attempt_formation
  # Inputs:	arg1: division
  #			arg2: formation identifier (formation_*)
  #         arg3: flag 1 to form at current location (rather than next to player)
  # Output: none
  ("player_attempt_formation", [
	(store_script_param, ":fdivision", 1),
	(store_script_param, ":fformation", 2),
	# todo: Fix "player_attempt_formation": ":form_on_spot" not being used.
	#(store_script_param, ":form_on_spot", 3),
	(set_fixed_point_multiplier, 100),
	(try_begin),
		(eq, ":fformation", formation_ranks),
		(str_store_string, s1, "@ranks"),
	(else_try),
		(eq, ":fformation", formation_shield),
		(str_store_string, s1, "@shield wall"),
	(else_try),
		(eq, ":fformation", formation_wedge),
		(str_store_string, s1, "@wedge"),
	(else_try),
		(eq, ":fformation", formation_square),
		(str_store_string, s1, "@square"),
	(else_try),
		(str_store_string, s1, "@up"),
	(try_end),
	(str_store_class_name, s2, ":fdivision"),

	(try_begin),
		(call_script, "script_cf_battlegroup_valid_formation", "$fplayer_team_no", ":fdivision", ":fformation"),
		(try_begin),	#new formation?
			(store_add, ":slot", "slot_team_d0_formation", ":fdivision"),
			(neg|team_slot_eq, "$fplayer_team_no", ":slot", ":fformation"),
			(team_set_slot, "$fplayer_team_no", ":slot", ":fformation"),
			(display_message, "@{!}{s2} forming {s1}."),
			(store_add, ":slot", "slot_team_d0_formation_space", ":fdivision"),
			(team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
			
			#bring unformed divisions into sync with formations' minimum
			(set_show_messages, 1),#gdw
			(assign, reg0, ":div_spacing"),
			(try_for_range, reg1, reg0, formation_start_spread_out),	#spread out for ease of forming up	
				(team_give_order, "$fplayer_team_no", ":fdivision", mordr_spread_out),
				(val_add, ":div_spacing", 1),
			(try_end),
			#(set_show_messages, 1),
			(team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),
		(try_end),
		
	(else_try),
		(assign, ":return_val", reg0),
		(call_script, "script_formation_end", "$fplayer_team_no", ":fdivision"),
		(neq, ":fformation", formation_none),
		(try_begin),
			(gt, ":return_val", 0),
			(display_message, "@Not enough troops in {s2} to form {s1}, but holding."),
		(else_try),
			(store_add, ":slot", "slot_team_d0_type", ":fdivision"),
			(team_get_slot, reg0, "$fplayer_team_no", ":slot"),
			(call_script, "script_str_store_division_type_name", s3, reg0),
			(display_message, "@{!}{s2} is an {s3} division and cannot form {s1}, so is holding."),
		(try_end),
	(try_end),
	
	# (try_begin),
	# 	(eq, ":form_on_spot", 0),
	# 	(call_script, "script_battlegroup_place_around_leader", "$fplayer_team_no", ":fdivision"),
	# (try_end),
  ]),

  # script_str_store_division_type_name by motomataru
  # Input:	destination, division type (sdt_*)
  # Output: none
  ("str_store_division_type_name", [
	(store_script_param, ":str_reg", 1),
	(store_script_param, ":division_type", 2),
	(try_begin),
		(eq, ":division_type", sdt_infantry),
		(str_store_string, ":str_reg", "@infantry"),
	(else_try),
		(eq, ":division_type", sdt_archer),
		(str_store_string, ":str_reg", "@archer"),
	(else_try),
		(eq, ":division_type", sdt_cavalry),
		(str_store_string, ":str_reg", "@cavalry"),
	(else_try),
		(eq, ":division_type", sdt_polearm),
		(str_store_string, ":str_reg", "@polearm"),
	(else_try),
		(eq, ":division_type", sdt_skirmisher),
		(str_store_string, ":str_reg", "@skirmisher"),
	(else_try),
		(eq, ":division_type", sdt_harcher),
		(str_store_string, ":str_reg", "@mounted archer"),
	(else_try),
		(eq, ":division_type", sdt_support),
		(str_store_string, ":str_reg", "@support"),
	(else_try),
		(eq, ":division_type", sdt_bodyguard),
		(str_store_string, ":str_reg", "@bodyguard"),
	(else_try),
		(str_store_string, ":str_reg", "@undetermined type of"),
	(try_end),
  ]),
  
  # script_player_order_formations by motomataru
  # Inputs:	arg1: order to formation (mordr_*)
  # Output: none
  ("player_order_formations", [
	(store_script_param, ":forder", 1),
	(set_fixed_point_multiplier, 100),
	
	(try_begin), #On hold, any formations reform in new location		
		(eq, ":forder", mordr_hold),
		(call_script, "script_division_reset_places"),
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_target_team", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", -1),
			(store_add, ":slot", "slot_team_d0_size", ":division"),	#apply to all divisions (not just formations)
			(team_slot_ge, "$fplayer_team_no", ":slot", 1),
			(store_add, ":slot", "slot_team_d0_fclock", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", 1),
			(store_add, ":slot", "slot_team_d0_formation", ":division"),
			(team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
			(call_script, "script_player_attempt_formation", ":division", ":formation", 0),
		(try_end),
		
	(else_try),	#Follow is hold	repeated frequently
		(eq, ":forder", mordr_follow),
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_target_team", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", -1),
			(store_add, ":slot", "slot_team_d0_size", ":division"),	#apply to all divisions (not just formations)
			(team_slot_ge, "$fplayer_team_no", ":slot", 1),
			
			(store_add, ":slot", "slot_team_d0_formation", ":division"),	#update formations
			(team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
			(call_script, "script_player_attempt_formation", ":division", ":formation", 0),

			(store_add, ":slot", "slot_team_d0_move_order", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", ":forder"),
		(try_end),
		
	(else_try),	#charge or retreat ends formation
		(this_or_next|eq, ":forder", mordr_charge),
		(eq, ":forder", mordr_retreat),
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_target_team", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", -1),
			(store_add, ":slot", "slot_team_d0_move_order", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", ":forder"),
			
			(store_add, ":slot", "slot_team_d0_formation", ":division"),
			(neg|team_slot_eq, "$fplayer_team_no", ":slot", formation_none),
			(call_script, "script_formation_end", "$fplayer_team_no", ":division"),
			
			(store_add, ":slot", "slot_team_d0_type", ":division"),
			(store_add, reg0, ":division", 1),
			(try_begin),
			    (this_or_next|team_slot_eq, "$fplayer_team_no", ":slot", sdt_infantry),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_polearm),
				(display_message, "@Division {reg0}: infantry formation disassembled."),
			(else_try),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
				(display_message, "@Division {reg0}: archer formation disassembled."),
			(else_try),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_skirmisher),
				(display_message, "@Division {reg0}: skirmisher formation disassembled."),
			(else_try),
				(this_or_next|team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
				(display_message, "@Division {reg0}: cavalry formation disassembled."),
			(else_try),
				(display_message, "@Division {reg0}: formation disassembled."),			
			(try_end),
		(try_end),
		
	(else_try),	#dismount ends formation
		(eq, ":forder", mordr_dismount),
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_formation", ":division"),
			(neg|team_slot_eq, "$fplayer_team_no", ":slot", formation_none),
			(try_begin),
				(store_add, ":slot", "slot_team_d0_type", ":division"),
				(this_or_next|team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
				(call_script, "script_formation_end", "$fplayer_team_no", ":division"),
				(display_message, "@Cavalry formation disassembled."),
				
			(else_try),	#address bug that cavalry in scripted mode won't dismount
				(try_for_agents, ":agent"),
					(agent_is_alive, ":agent"),
					(agent_is_human, ":agent"),
					(agent_get_group, ":team", ":agent"),
					(eq, ":team", "$fplayer_team_no"),
					(neq, "$fplayer_agent_no", ":agent"),
					(agent_get_division, ":bgdivision", ":agent"),
					(eq, ":bgdivision", ":division"),
					(agent_clear_scripted_mode, ":agent"),
					(agent_set_speed_limit, ":agent", 100),
				(try_end),
			(try_end),
        (try_end),
			
	(else_try), 
		(eq, ":forder", mordr_advance),
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_target_team", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", -1),
			(store_add, ":slot", "slot_team_d0_move_order", ":division"),
			(team_get_slot, ":prev_order", "$fplayer_team_no", ":slot"),	
			(team_set_slot, "$fplayer_team_no", ":slot", ":forder"),	
			
			(store_add, ":slot", "slot_team_d0_formation", ":division"),
			(team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
			(neq, ":formation", formation_none),
			
			(store_add, ":slot", "slot_team_d0_fclock", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", 1),
			
			(call_script, "script_formation_current_position", pos63, "$fplayer_team_no", ":division"),
			(try_begin),
				(neq, ":prev_order", mordr_advance),
				(call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", pos63),
			(try_end),
			(call_script, "script_formation_move_position", "$fplayer_team_no", ":division", pos63, 1),

			(store_add, ":slot", "slot_team_d0_formation_space", ":division"),
			(team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
			(store_add, ":slot", "slot_team_d0_type", ":division"),
			(try_begin),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
				(call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":formation"),
			(else_try),
			    (this_or_next|team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
				(call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0),
			(else_try),
				(call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":formation"),
			(try_end),
        (try_end),			

	(else_try),
		(eq, ":forder", mordr_fall_back),
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_target_team", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", -1),
			(store_add, ":slot", "slot_team_d0_move_order", ":division"),
			(team_get_slot, ":prev_order", "$fplayer_team_no", ":slot"),	
			(team_set_slot, "$fplayer_team_no", ":slot", ":forder"),	
			
			(store_add, ":slot", "slot_team_d0_formation", ":division"),
			(team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
			(neq, ":formation", formation_none),
			
			(store_add, ":slot", "slot_team_d0_fclock", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", 1),
			
			(call_script, "script_formation_current_position", pos63, "$fplayer_team_no", ":division"),
			(try_begin),
				(neq, ":prev_order", mordr_fall_back),
				(call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", pos63),
			(try_end),
			(call_script, "script_formation_move_position", "$fplayer_team_no", ":division", pos63, -1),			

			(store_add, ":slot", "slot_team_d0_formation_space", ":division"),
			(team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
			(store_add, ":slot", "slot_team_d0_type", ":division"),
			(try_begin),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
				(call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":formation"),
			(else_try),
			    (this_or_next|team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
				(call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0),
			(else_try),
				(call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":formation"),
			(try_end),
        (try_end),		

	(else_try),
		(eq, ":forder", mordr_stand_closer),		
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_formation_space", ":division"),
			(team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
			(gt, ":div_spacing", -3),	#Native formations go down to four ranks
			(val_sub, ":div_spacing", 1),
			(team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),
			
			(store_add, ":slot", "slot_team_d0_formation", ":division"),
			(team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
			(neq, ":formation", formation_none),
			
			(store_add, ":slot", "slot_team_d0_fclock", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", 1),
			
			(try_begin),	#bring unformed divisions into sync with formations' minimum
				(lt, ":div_spacing", 0),
				(set_show_messages, 0),
				(assign, reg0, ":div_spacing"),
				(try_for_range, reg1, reg0, 0),
					(team_give_order, "$fplayer_team_no", ":division", mordr_spread_out),
					(val_add, ":div_spacing", 1),
				(try_end),
				(set_show_messages, 1),
				(store_add, ":slot", "slot_team_d0_formation_space", ":division"),
				(team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),
				
			(else_try),
				(call_script, "script_get_formation_destination", pos1, "$fplayer_team_no", ":division"),
				(try_begin),
					(store_add, ":slot", "slot_team_d0_first_member", ":division"),
					(team_slot_eq, "$fplayer_team_no", ":slot", "$fplayer_agent_no"),
					(assign, ":first_member_is_player", 1),
				(else_try),
					(assign, ":first_member_is_player", 0),
				(try_end),
				(store_add, ":slot", "slot_team_d0_type", ":division"),
				(try_begin),
					(team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
					(store_add, ":slot", "slot_team_d0_size", ":division"),
					(team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
					(call_script, "script_get_centering_amount", formation_default, ":troop_count", ":div_spacing"),
					(val_mul, reg0, -1),
					(position_move_x, pos1, reg0),				
					(call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
				(else_try),
					(this_or_next|team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
					(team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
					(call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player"),
				(else_try),
					(store_add, ":slot", "slot_team_d0_size", ":division"),
					(team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
					(call_script, "script_get_centering_amount", ":formation", ":troop_count", ":div_spacing"),
					(position_move_x, pos1, reg0),
					(call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
				(try_end),
			(try_end),
		(try_end),

	(else_try),
		(eq, ":forder", mordr_spread_out),
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_formation", ":division"),
			(team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
			(store_add, ":slot", "slot_team_d0_formation_space", ":division"),
			(team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
			(try_begin),
				(this_or_next|neq, ":formation", formation_none),
				(lt, ":div_spacing", 2),	#Native maxes at 2
				(val_add, ":div_spacing", 1),
			(try_end),
			(team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),
			
			(neq, ":formation", formation_none),
			
			(store_add, ":slot", "slot_team_d0_fclock", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", 1),

			#bring unformed divisions into sync with formations' minimum
			(set_show_messages, 0),
			(assign, reg0, ":div_spacing"),
			(try_for_range, reg1, reg0, 1),
				(team_give_order, "$fplayer_team_no", ":division", mordr_spread_out),
				(val_add, ":div_spacing", 1),
			(try_end),
			(set_show_messages, 1),
			(store_add, ":slot", "slot_team_d0_formation_space", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),

			(call_script, "script_get_formation_destination", pos1, "$fplayer_team_no", ":division"),
			(try_begin),
				(store_add, ":slot", "slot_team_d0_first_member", ":division"),
				(team_slot_eq, "$fplayer_team_no", ":slot", "$fplayer_agent_no"),
				(assign, ":first_member_is_player", 1),
			(else_try),
				(assign, ":first_member_is_player", 0),
			(try_end),
			(store_add, ":slot", "slot_team_d0_type", ":division"),
			(try_begin),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
			    (store_add, ":slot", "slot_team_d0_size", ":division"),
	            (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
			    (call_script, "script_get_centering_amount", formation_default, ":troop_count", ":div_spacing"),
			    (val_mul, reg0, -1),
			    (position_move_x, pos1, reg0),				
				(call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
			(else_try),
			    (this_or_next|team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
				(call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player"),
			(else_try),
				(store_add, ":slot", "slot_team_d0_size", ":division"),
	            (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
				(call_script, "script_get_centering_amount", ":formation", ":troop_count", ":div_spacing"),
			    (position_move_x, pos1, reg0),
				(call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"), 
			(try_end),
		(try_end),

	(else_try),
		(eq, ":forder", mordr_stand_ground),
		(try_for_range, ":division", 0, 9),
		    (class_is_listening_order, "$fplayer_team_no", ":division"),
			(store_add, ":slot", "slot_team_d0_target_team", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", -1),
			(store_add, ":slot", "slot_team_d0_move_order", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", ":forder"),	
			
			(store_add, ":slot", "slot_team_d0_formation", ":division"),
			(team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
			(neq, ":formation", formation_none),
			
			(store_add, ":slot", "slot_team_d0_fclock", ":division"),
			(team_set_slot, "$fplayer_team_no", ":slot", 1),
			
			(call_script, "script_formation_current_position", pos63, "$fplayer_team_no", ":division"),
			(copy_position, pos1, pos63),		
			(store_add, ":slot", "slot_team_d0_formation_space", ":division"),
			(team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
			
			(try_begin),
				(store_add, ":slot", "slot_team_d0_first_member", ":division"),
				(team_slot_eq, "$fplayer_team_no", ":slot", "$fplayer_agent_no"),
				(assign, ":first_member_is_player", 1),
			(else_try),
				(assign, ":first_member_is_player", 0),
			(try_end),
			(store_add, ":slot", "slot_team_d0_type", ":division"),
			(try_begin),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
			    (store_add, ":slot", "slot_team_d0_size", ":division"),
	            (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
			    (call_script, "script_get_centering_amount", formation_default, ":troop_count", ":div_spacing"),
			    (val_mul, reg0, -1),
			    (position_move_x, pos1, reg0),				
				(call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
			(else_try),
			    (this_or_next|team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
				(team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
				(call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player"),
			(else_try),
				(store_add, ":slot", "slot_team_d0_size", ":division"),
	            (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),	
				(call_script, "script_get_centering_amount", ":formation", ":troop_count", ":div_spacing"),
			    (position_move_x, pos1, reg0),
				(call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
			(try_end),
			(call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", pos63),
		(try_end),			
	(try_end)
  ]),

  
# #Utilities used by formations
  # script_point_y_toward_position by motomataru
  # Input: from position, to position
  # Output: reg0 fixed point distance
  ("point_y_toward_position", [
	(store_script_param, ":from_position", 1),
	(store_script_param, ":to_position", 2),
	(position_get_x, ":dist_x_to_cosine", ":to_position"),
	(position_get_x, ":from_coord", ":from_position"),
	(val_sub, ":dist_x_to_cosine", ":from_coord"),
	(store_mul, ":sum_square", ":dist_x_to_cosine", ":dist_x_to_cosine"),
	(position_get_y, ":dist_y_to_sine", ":to_position"),
	(position_get_y, ":from_coord", ":from_position"),
	(val_sub, ":dist_y_to_sine", ":from_coord"),
	(store_mul, reg0, ":dist_y_to_sine", ":dist_y_to_sine"),
	(val_add, ":sum_square", reg0),
	(convert_from_fixed_point, ":sum_square"),
	(store_sqrt, ":distance_between", ":sum_square"),
	(try_begin),
		(gt, ":distance_between", 0),
		(convert_to_fixed_point, ":dist_x_to_cosine"),
		(val_div, ":dist_x_to_cosine", ":distance_between"),
		(convert_to_fixed_point, ":dist_y_to_sine"),
		(val_div, ":dist_y_to_sine", ":distance_between"),
		(try_begin),
			(lt, ":dist_x_to_cosine", 0),
			(assign, ":bound_a", 90),
			(assign, ":bound_b", 270),
			(assign, ":theta", 180),
		(else_try),
			(assign, ":bound_a", 90),
			(assign, ":bound_b", -90),
			(assign, ":theta", 0),
		(try_end),
		(assign, ":sine_theta", 0),	#avoid error on compile
		(convert_to_fixed_point, ":theta"),
		(convert_to_fixed_point, ":bound_a"),
		(convert_to_fixed_point, ":bound_b"),
		(try_for_range, reg0, 0, 6),	#precision 90/2exp6 (around 2 degrees)
			(store_sin, ":sine_theta", ":theta"),
			(try_begin),
				(gt, ":sine_theta", ":dist_y_to_sine"),
				(assign, ":bound_a", ":theta"),
			(else_try),
				(lt, ":sine_theta", ":dist_y_to_sine"),
				(assign, ":bound_b", ":theta"),
			(try_end),
			(store_add, ":angle_sum", ":bound_b", ":bound_a"),
			(store_div, ":theta", ":angle_sum", 2),
		(try_end),
		(convert_from_fixed_point, ":theta"),
		(position_get_rotation_around_z, reg0, ":from_position"),
		(val_sub, ":theta", reg0),
		(val_sub, ":theta", 90),	#point y-axis at destination
		(position_rotate_z, ":from_position", ":theta"),
	(try_end),
	
	(assign, reg0, ":distance_between"),
  ]),

  #script_agent_fix_division by Caba'drin
  #Input: agent_id
  #Output: nothing (agent divisions changed, slot set) 
  #To fix AI troop divisions from the engine applying player's party divisions on all agents
  #This is called after agent_reassign_team, so can safely assume correct team is set
  ("agent_fix_division",
   [
    (store_script_param_1, ":agent"),	
	(agent_set_slot, ":agent", "slot_agent_new_division", -1),
	(get_player_agent_no, ":player"),	#after_mission_start triggers are called after spawn, so globals can't be used yet
	
	(try_begin),
	    (ge, ":player", 0),
		(neq, ":agent", ":player"),
		(agent_is_human, ":agent"),
		(agent_get_group, ":player_team", ":player"),
		(agent_get_group, ":team", ":agent"),
		(this_or_next|main_hero_fallen),
		(neq, ":team", ":player_team"),
		(agent_get_troop_id, ":troop", ":agent"),
		(try_begin),
			(troop_is_guarantee_horse, ":troop"),
			(assign, ":target_division", grc_cavalry),
		(else_try),
			(troop_is_guarantee_ranged, ":troop"),
			(assign, ":target_division", grc_archers),
		(else_try),
			(assign, ":target_division", grc_infantry),		
		(try_end),
		(agent_get_division, ":division", ":agent"),
		(neq, ":division", ":target_division"),
		(agent_set_division, ":agent", ":target_division"),
		(agent_set_slot, ":agent", "slot_agent_new_division", ":target_division"),
	(try_end),
   ]),
  
  # script_store_battlegroup_type by Caba'drin
  # Input: team, division
  # Output: reg0 and "slot_team_dx_type" with sdt_* value
  # Automatically called from store_battlegroup_data
  ("store_battlegroup_type", [
	(store_script_param_1, ":fteam"),
	(store_script_param_2, ":fdivision"),

	(assign, ":count_infantry", 0),
	(assign, ":count_archer", 0),
	(assign, ":count_cavalry", 0),
	(assign, ":count_harcher", 0),
	(assign, ":count_polearms", 0),
	(assign, ":count_skirmish", 0),
	(assign, ":count_support", 0),
	(assign, ":count_bodyguard", 0),	

	(team_get_leader, ":leader", ":fteam"),
	
	(try_for_agents, ":cur_agent"),
		(call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":leader", ":cur_agent"),
		(agent_get_troop_id, ":cur_troop", ":cur_agent"),
		(agent_get_ammo, ":cur_ammo", ":cur_agent", 0),
		
		(try_begin),
			(neg|troop_is_hero, ":cur_troop"),
			(try_begin), #Cavalry	
				(agent_get_horse, reg0, ":cur_agent"),
				(ge, reg0, 0),
				(try_begin),				
					(gt, ":cur_ammo", 0),
					(val_add, ":count_harcher", 1),
				(else_try),
					(val_add, ":count_cavalry", 1),
				(try_end),
			(else_try), #Archers
				(gt, ":cur_ammo", 0),
				#use when troops are equipped with ranged at start of battle
				(agent_get_class, ":bgclass", ":cur_agent"),
				(eq, ":bgclass", grc_archers),
				#end use when troops equipped with ranged at start of battle
				(assign, ":end", ek_head),
				(try_for_range, ":i", ek_item_0, ":end"),
					(agent_get_item_slot, ":item", ":cur_agent", ":i"),
					(gt, ":item", 0),
					(item_get_type, ":weapontype", ":item"),
					(is_between, ":weapontype", itp_type_bow, itp_type_thrown),  # bow or crossbow
					(assign, ":end", ek_item_0), #loop Break
				(try_end),
				(try_begin),
					(eq, ":end", ek_head), #failed to find bow or crossbow
					(val_add, ":count_skirmish", 1),
				(else_try),
					(val_add, ":count_archer", 1),
				(try_end),
			(else_try), #Infantry
				(assign, ":end", ek_head),
				(try_for_range, ":i", ek_item_0, ":end"),
					
          (agent_get_item_slot, ":item", ":cur_agent", ":i"),
          (gt, ":item", 0),
					#(call_script, "script_cf_is_thrusting_weapon", ":item"),##gdwthis keeps causing opcode errors: 2718: line no.2.......and: at script:of is_thrusting_weapon
					(item_get_type, ":weapontype", ":item"),
					(is_between, ":weapontype", itp_type_two_handed_wpn, itp_type_arrows),#greater than or equal to lower bound and less than upper bound
          (assign, ":end", ek_item_0), #loop Break
				(try_end),
				(try_begin),
					(eq, ":end", ek_head), #failed to find a polearm
					(val_add, ":count_infantry", 1),
				(else_try),
					(val_add, ":count_polearms", 1),
				(try_end),			    
			(try_end),
		(else_try), #Heroes
			(assign, ":support_skills", 0), #OPEN TO SUGGESTIONS HERE    ?skl_trade, skl_spotting, skl_pathfinding, skl_tracking?
			(store_skill_level, reg0, skl_engineer, ":cur_troop"),
			(val_add, ":support_skills", reg0),
			(store_skill_level, reg0, skl_first_aid, ":cur_troop"),
			(val_add, ":support_skills", reg0),
			(store_skill_level, reg0, skl_surgery, ":cur_troop"),
			(val_add, ":support_skills", reg0),
			(store_skill_level, reg0, skl_wound_treatment, ":cur_troop"),
			(val_add, ":support_skills", reg0),
			(try_begin),
				(gt, ":support_skills", 5),
				(val_add, ":count_support", 1),
			(else_try),
				(val_add, ":count_bodyguard", 1),
			(try_end),		
		(try_end), #Regular v Hero		
	(try_end), #Agent Loop	
		
	#Do Comparisons With Counts, set ":div_type"
	(assign, ":slot", "slot_team_d0_type"),
	(team_set_slot, scratch_team, ":slot", ":count_infantry"),
	(val_add, ":slot", 1),
	(team_set_slot, scratch_team, ":slot", ":count_archer"),
	(val_add, ":slot", 1),
	(team_set_slot, scratch_team, ":slot", ":count_cavalry"),
	(val_add, ":slot", 1),
	(team_set_slot, scratch_team, ":slot", ":count_polearms"),
	(val_add, ":slot", 1),
	(team_set_slot, scratch_team, ":slot", ":count_skirmish"),
	(val_add, ":slot", 1),
	(team_set_slot, scratch_team, ":slot", ":count_harcher"),
	(val_add, ":slot", 1),
	(team_set_slot, scratch_team, ":slot", ":count_support"),
	(val_add, ":slot", 1),
	(team_set_slot, scratch_team, ":slot", ":count_bodyguard"),

	(assign, ":count_to_beat", 0),
	(assign, ":count_total", 0),
	(try_for_range, ":type", sdt_infantry, sdt_infantry + 8), #only 8 sdt_types at the moment
		(store_add, ":slot", "slot_team_d0_type", ":type"),
		(team_get_slot, ":count", scratch_team, ":slot"),
		(val_add, ":count_total", ":count"),
		(lt, ":count_to_beat", ":count"),
		(assign, ":count_to_beat", ":count"),
		(assign, ":div_type", ":type"),
	(try_end),
	
	(val_mul, ":count_to_beat", 2),
	(try_begin),
		(lt, ":count_to_beat", ":count_total"), #Less than half of this division
		(assign, ":count_to_beat", 0),
		(assign, ":div_type", -1),
		(try_for_range, ":type", sdt_infantry, sdt_infantry + 3), #check main types for a majority
			(store_add, ":slot", "slot_team_d0_type", ":type"),
			(team_get_slot, ":count", scratch_team, ":slot"),
			(val_add, ":slot", 3),	#subtype is three more than main type
			(team_get_slot, reg0, scratch_team, ":slot"),
			(val_add, ":count", reg0),
			(lt, ":count_to_beat", ":count"),
			(assign, ":count_to_beat", ":count"),
			(assign, ":div_type", ":type"),
		(try_end),
	
		(val_mul, ":count_to_beat", 2),
		(lt, ":count_to_beat", ":count_total"), #Less than half of this division
		(assign, ":div_type", sdt_unknown), #Or 0
	(try_end),
	
	#hard-code traditional infantry division (avoid player confusion for mods which arm troops with ranged at start of battle)
	(try_begin),
		(eq, ":fdivision", grc_infantry),
		(neq, ":div_type", sdt_polearm),
		(assign, ":div_type", sdt_infantry),
	(try_end),
		
	(store_add, ":slot", "slot_team_d0_type", ":fdivision"),
	(team_set_slot, ":fteam", ":slot", ":div_type"),
	(assign, reg0, ":div_type"),
  ]),

  # script_store_battlegroup_data by motomataru #EDITED TO SLOTS FOR MANY DIVISIONS BY CABA'DRIN
  # Input: none
  # Output: sets positions and globals to track data on ALL groups in a battle
  # Globals used: pos1, reg0, reg1, #CABA - NO LONGER USED: positions 24-45
  ("store_battlegroup_data", [
	(assign, ":team0_leader", 0),
	(assign, ":team0_x_leader", 0),
	(assign, ":team0_y_leader", 0),
	(assign, ":team0_level_leader", 0),
	(assign, ":team1_leader", 0),
	(assign, ":team1_x_leader", 0),
	(assign, ":team1_y_leader", 0),
	(assign, ":team1_level_leader", 0),
	(assign, ":team2_leader", 0),
	(assign, ":team2_x_leader", 0),
	(assign, ":team2_y_leader", 0),
	(assign, ":team2_level_leader", 0),
	(assign, ":team3_leader", 0),
	(assign, ":team3_x_leader", 0),
	(assign, ":team3_y_leader", 0),
	(assign, ":team3_level_leader", 0),
	
	#Team Slots reset every mission, like agent slots, but just to be sure for when it gets called during the mission
	(try_for_range, ":slot", "slot_team_reset_stats_begin", "slot_team_reset_stats_end"),
		(try_for_range, ":team", 0, 4),
			(team_set_slot, ":team", ":slot", 0),
		(try_end),
	(try_end),

	(try_for_agents, ":cur_agent"),
		(agent_is_alive, ":cur_agent"),      
		(agent_is_human, ":cur_agent"), 
		(agent_slot_eq, ":cur_agent", "slot_agent_is_running_away", 0),
		(agent_get_group, ":bgteam", ":cur_agent"),
		(agent_get_division, ":bgdivision", ":cur_agent"),
		(agent_get_class, ":agent_class", ":cur_agent"),
		(try_begin),
                        (agent_is_non_player, ":cur_agent"),
			(eq, ":agent_class", grc_infantry),	#Native has transferred this agent to infantry
			(store_add, ":slot", "slot_team_d0_type", ":bgdivision"),
			(team_get_slot, ":bgtype", ":bgteam", ":slot"),
			(this_or_next|eq, ":bgtype", sdt_cavalry),	#but still assigned to horsed division
			(eq, ":bgtype", sdt_harcher),
			(agent_set_slot, ":cur_agent", "slot_agent_new_division", grc_infantry),	#reassign to general infantry division
			(agent_set_division, ":cur_agent", grc_infantry),			
		(else_try),	#Maintain any changed divisions (apparently agents get switched back)
                        (agent_is_non_player, ":cur_agent"),
			(agent_slot_ge, ":cur_agent", "slot_agent_new_division", 0),
			(neg|agent_slot_eq, ":cur_agent", "slot_agent_new_division", ":bgdivision"),
			(agent_get_slot, ":bgdivision", ":cur_agent", "slot_agent_new_division"),
			(agent_set_division, ":cur_agent", ":bgdivision"),
		(try_end),
		(agent_get_troop_id, ":cur_troop", ":cur_agent"),
		(try_begin),
			(game_in_multiplayer_mode),
			(try_begin),
				(is_between, ":cur_troop", multiplayer_troops_begin, multiplayer_troops_end),	#it's a player
				(assign, ":bgdivision", -1),
			(try_end),
		(else_try),
			(team_get_leader, ":leader", ":bgteam"),
		    (eq, ":leader", ":cur_agent"),
			(assign, ":bgdivision", -1),
		(try_end),
		(store_character_level, ":cur_level", ":cur_troop"),
		(agent_get_ammo, ":cur_ammo", ":cur_agent", 0),
		
		#get weapon characteristics
		(assign, ":cur_weapon_type", 0),
		(assign, ":cur_weapon_length", 0),
		(assign, ":cur_swung_weapon_length", 0),
		(agent_get_wielded_item, ":cur_weapon", ":cur_agent", 0),
		(try_begin),
			(is_between, ":cur_weapon", weapons_begin, weapons_end),
			(neg|is_between, ":cur_weapon", estandartes_begin, estandartes_end),	#MOTO these not really weapons
			(item_get_slot, ":cur_weapon_length", ":cur_weapon", "slot_item_length"),

			(item_get_slot, reg0, ":cur_weapon", "slot_item_thrust_damage"),
			(item_slot_ge, ":cur_weapon", "slot_item_swing_damage", reg0),
			(assign, ":cur_swung_weapon_length", ":cur_weapon_length"),
		(try_end),
		
		#add up armor
		(assign, ":cur_avg_armor", 0),
		(try_for_range, ":item_slot", ek_head, ek_horse),
			(agent_get_item_slot, ":armor", ":cur_agent", ":item_slot"),
			(gt, ":armor", "itm_no_item"),
			(item_get_slot, reg0, ":armor", "slot_item_head_armor"),
			(val_add, ":cur_avg_armor", reg0),
			(item_get_slot, reg0, ":armor", "slot_item_body_armor"),
			(val_add, ":cur_avg_armor", reg0),
			(item_get_slot, reg0, ":armor", "slot_item_leg_armor"),
			(val_add, ":cur_avg_armor", reg0),
		(try_end),
		(agent_get_wielded_item, ":armor", ":cur_agent", 1),	#include shield
		(try_begin),
			(gt, ":armor", "itm_no_item"),
			(item_get_type, ":item_type", ":armor"),
			(eq, ":item_type", itp_type_shield),
			(item_get_slot, reg0, ":armor", "slot_item_body_armor"),
			(val_add, ":cur_avg_armor", reg0),
		(try_end),
		(val_div, ":cur_avg_armor", 3),	#average the zones (head, body, leg)
		
        #average with horse armor for mounted agents
              (agent_get_horse, ":cur_horse", ":cur_agent"),
              (try_begin),
                  (gt, ":cur_horse", -1),
                  (agent_get_item_id, ":itm_horse", ":cur_horse"),
                  (gt, ":itm_horse", "itm_no_item"),
                  (item_get_slot, reg0, ":itm_horse", "slot_item_horse_armor"),
                  (val_add, ":cur_avg_armor", reg0),
                  (val_div, ":cur_avg_armor", 2),
              (try_end),

                (agent_get_position, pos1, ":cur_agent"),
		(position_get_x, ":x_value", pos1),
		(position_get_y, ":y_value", pos1),
		(try_begin),
		    (eq, ":bgdivision", -1), #Leaders
			(try_begin),
				(eq, ":bgteam", 0),
				(assign, ":team0_leader", 1),
				(assign, ":team0_x_leader", ":x_value"),
				(assign, ":team0_y_leader", ":y_value"),
				(assign, ":team0_level_leader", ":cur_level"),
			(else_try),
				(eq, ":bgteam", 1),
				(assign, ":team1_leader", 1),
				(assign, ":team1_x_leader", ":x_value"),
				(assign, ":team1_y_leader", ":y_value"),
				(assign, ":team1_level_leader", ":cur_level"),
			(else_try),
				(eq, ":bgteam", 2),
				(assign, ":team2_leader", 1),
				(assign, ":team2_x_leader", ":x_value"),
				(assign, ":team2_y_leader", ":y_value"),
				(assign, ":team2_level_leader", ":cur_level"),
			(else_try),
				(eq, ":bgteam", 3),
				(assign, ":team3_leader", 1),
				(assign, ":team3_x_leader", ":x_value"),
				(assign, ":team3_y_leader", ":y_value"),
				(assign, ":team3_level_leader", ":cur_level"),
			(try_end),
		(else_try),
			# (agent_get_ammo, reg0, ":cur_agent", 1),	#Division in Melee
			(try_begin),
				# (le, reg0, 0),	#not wielding ranged weapon?
				(agent_get_attack_action, reg0, ":cur_agent"),
				(gt, reg0, 0),
				(store_add, ":slot", "slot_team_d0_in_melee", ":bgdivision"),
				(team_get_slot, reg0, ":bgteam", ":slot"),
				(val_add, reg0, 1),
				(team_set_slot, ":bgteam", ":slot", reg0),
			(try_end),
			
			(store_add, ":slot", "slot_team_d0_size", ":bgdivision"), #Division Count
			(team_get_slot, ":value", ":bgteam", ":slot"),
			(val_add, ":value", 1),
			(team_set_slot, ":bgteam", ":slot", ":value"),
			
			(try_begin),
				(gt, ":cur_ammo", 0),
				(store_add, ":slot", "slot_team_d0_percent_ranged", ":bgdivision"), #Division Percentage are Archers
				(team_get_slot, ":value", ":bgteam", ":slot"),
				(val_add, ":value", 1),
				(team_set_slot, ":bgteam", ":slot", ":value"),
			(else_try),
				(store_add, ":slot", "slot_team_d0_low_ammo", ":bgdivision"), #Division Running out of Ammo Flag
				(team_set_slot, ":bgteam", ":slot", 1),
			(try_end),
			
			(try_begin),
				(eq, ":cur_weapon_type", itp_type_thrown),
				(store_add, ":slot", "slot_team_d0_percent_throwers", ":bgdivision"), #Division Percentage are Throwers
				(team_get_slot, ":value", ":bgteam", ":slot"),
				(val_add, ":value", 1),
				(team_set_slot, ":bgteam", ":slot", ":value"),
			(try_end),
			
			(store_add, ":slot", "slot_team_d0_level", ":bgdivision"), #Division Level
			(team_get_slot, ":value", ":bgteam", ":slot"),
			(val_add, ":value", ":cur_level"),
			(team_set_slot, ":bgteam", ":slot", ":value"),
			
			(store_add, ":slot", "slot_team_d0_weapon_length", ":bgdivision"), #Division Weapon Length
			(team_get_slot, ":value", ":bgteam", ":slot"),
			(val_add, ":value", ":cur_weapon_length"),
			(team_set_slot, ":bgteam", ":slot", ":value"),
			
			(store_add, ":slot", "slot_team_d0_swung_weapon_length", ":bgdivision"), #Division Swung Weapon Length
			(team_get_slot, ":value", ":bgteam", ":slot"),
			(try_begin),
				(lt, ":value", ":cur_swung_weapon_length"),
				(team_set_slot, ":bgteam", ":slot", ":cur_swung_weapon_length"),
			(try_end),
			
			(store_add, ":slot", "slot_team_d0_armor", ":bgdivision"), #Division Armor
			(team_get_slot, ":value", ":bgteam", ":slot"),
			(val_add, ":value", ":cur_avg_armor"),
			(team_set_slot, ":bgteam", ":slot", ":value"),
			
			(try_begin),	#Division First Rank Weapon Length
				(agent_slot_ge, ":cur_agent", "slot_agent_in_first_rank", 1),
				(store_add, ":slot", "slot_team_d0_front_weapon_length", ":bgdivision"),
				(team_get_slot, ":value", ":bgteam", ":slot"),
				(val_add, ":value", ":cur_weapon_length"),
				(team_set_slot, ":bgteam", ":slot", ":value"),
				(store_add, ":slot", "slot_team_d0_front_agents", ":bgdivision"),
				(team_get_slot, ":value", ":bgteam", ":slot"),
				(val_add, ":value", 1),
				(team_set_slot, ":bgteam", ":slot", ":value"),
			(try_end),
			
			(store_add, ":slot", "slot_team_d0_avg_x", ":bgdivision"), #Position X
			(team_get_slot, ":value", ":bgteam", ":slot"),
			(val_add, ":value", ":x_value"),
			(team_set_slot, ":bgteam", ":slot", ":value"),
			
			(store_add, ":slot", "slot_team_d0_avg_y", ":bgdivision"), #Position Y
			(team_get_slot, ":value", ":bgteam", ":slot"),
			(val_add, ":value", ":y_value"),
			(team_set_slot, ":bgteam", ":slot", ":value"),
		(try_end), #Leader vs Regular
		
		(try_begin),
			(eq, ":agent_class", grc_archers),
			(team_get_slot, ":value", ":bgteam", "slot_team_num_archers"),
			(val_add, ":value", 1),
			(team_set_slot, ":bgteam", "slot_team_num_archers", ":value"),
			
		(else_try),
			(eq, ":agent_class", grc_cavalry),
			(team_get_slot, ":value", ":bgteam", "slot_team_num_cavalry"),
			(val_add, ":value", 1),
			(team_set_slot, ":bgteam", "slot_team_num_cavalry", ":value"),
			
		(else_try),
			(eq, ":agent_class", grc_infantry),
			(team_get_slot, ":value", ":bgteam", "slot_team_num_infantry"),
			(val_add, ":value", 1),
			(team_set_slot, ":bgteam", "slot_team_num_infantry", ":value"),
		(try_end),
		
		#find nearest enemy agent
		(agent_set_slot, ":cur_agent", "slot_agent_nearest_enemy_agent", -1),
        (try_begin),
                  (eq, "$formation_no_nearest_agent", 0),
                  (try_for_agents, ":enemy_agent"),
                      (agent_is_alive, ":enemy_agent"),
                      (agent_is_human, ":enemy_agent"),
                      (agent_get_group, ":enemy_team_no", ":enemy_agent"),
                      (teams_are_enemies, ":enemy_team_no", ":bgteam"),
                      (agent_slot_eq, ":enemy_agent", "slot_agent_is_running_away", 0),
                      
                      (try_begin),
                          (agent_get_slot, ":closest_enemy", ":cur_agent", "slot_agent_nearest_enemy_agent"),
                          (eq, ":closest_enemy", -1),
                          (agent_set_slot, ":cur_agent", "slot_agent_nearest_enemy_agent", ":enemy_agent"),
                          
                      (else_try),
                          (agent_get_position, pos0, ":enemy_agent"),
                          (get_distance_between_positions, ":new_distance", pos0, pos1),
                          (agent_get_position, pos0, ":closest_enemy"),
                          (get_distance_between_positions, ":old_distance", pos0, pos1),
                          (lt, ":new_distance", ":old_distance"),
                          (agent_set_slot, ":cur_agent", "slot_agent_nearest_enemy_agent", ":enemy_agent"),
                      (try_end),
                  (try_end),
		(try_end),
		
		#exploit closest agent data
		(try_begin),
			(agent_get_slot, ":closest_enemy", ":cur_agent", "slot_agent_nearest_enemy_agent"),
			(neq, ":closest_enemy", -1),
			(agent_get_position, pos0, ":closest_enemy"),
			(get_distance_between_positions, ":closest_distance", pos0, pos1),
			
			#check target of AI agent behavior
			(try_begin),
				(agent_is_non_player, ":cur_agent"),
				
				(agent_ai_get_behavior_target, ":cur_targeted_agent", ":cur_agent"),
				(neq, ":closest_enemy", ":cur_targeted_agent"),
				
				(this_or_next|neg|agent_is_non_player, ":closest_enemy"),	#AI can always sense player behind them (balancing factor, dedicated to Idibil)
				(neg|position_is_behind_position, pos0, pos1),
				
				(lt, ":closest_distance", 2000),	#Assuming rethink is expensive, don't bother beyond 20m
				
				(store_add, ":slot", "slot_team_d0_formation", ":bgdivision"),
				(this_or_next|eq, formation_rethink_for_formations_only, 0),
				(neg|team_slot_eq, ":bgteam", ":slot", formation_none),
				
				(agent_force_rethink, ":cur_agent"),
			(try_end),

			#update division information
			(try_begin),
				(ge, ":bgdivision", 0),	#not leaders
				
				(try_begin),
					(lt, ":closest_distance", 350),
					(agent_get_division, reg0, ":closest_enemy"),
					(store_add, ":slot", "slot_team_d0_enemy_supporting_melee", reg0),
					(agent_get_group, reg0, ":closest_enemy"),
					(team_get_slot, ":value", reg0, ":slot"),
					(val_add, ":value", 1),
					(team_set_slot, reg0, ":slot", ":value"),
				(try_end),
				
				(store_add, ":slot", "slot_team_d0_closest_enemy_dist", ":bgdivision"),
				(team_get_slot, ":old_distance", ":bgteam", ":slot"),
				(try_begin),
					(this_or_next|eq, ":old_distance", 0),
					(lt, ":closest_distance", ":old_distance"),
					(team_set_slot, ":bgteam", ":slot", ":closest_distance"),
					(store_add, ":slot", "slot_team_d0_closest_enemy", ":bgdivision"),
					(team_set_slot, ":bgteam", ":slot", ":closest_enemy"),
				(try_end),
				
				(assign, ":doit", 0),
				(agent_get_class, ":enemy_agent_class", ":closest_enemy"),
				(store_add, ":slot", "slot_team_d0_type", ":bgdivision"),
				(team_get_slot, ":value", ":bgteam", ":slot"),
				
				#AI infantry division tracks non-infantry to preferably chase
				(try_begin),
					(this_or_next|eq, ":value", sdt_polearm),
					(eq, ":value", sdt_infantry),
					(neq, ":enemy_agent_class", grc_cavalry),
					(assign, ":doit", 1),
					
				#AI archer division tracks infantry to avoid
				(else_try),
					(this_or_next|eq, ":value", sdt_archer),
					(eq, ":value", sdt_skirmisher),
					(eq, ":enemy_agent_class", grc_infantry),
					(assign, ":doit", 1),
				(try_end),
				
				(eq, ":doit", 1),
				(store_add, ":slot", "slot_team_d0_closest_enemy_special_dist", ":bgdivision"),
				(team_get_slot, ":old_distance", ":bgteam", ":slot"),
				(try_begin),
					(this_or_next|eq, ":old_distance", 0),
					(lt, ":closest_distance", ":old_distance"),
					(team_set_slot, ":bgteam", ":slot", ":closest_distance"),
					(store_add, ":slot", "slot_team_d0_closest_enemy_special", ":bgdivision"),
					(team_set_slot, ":bgteam", ":slot", ":closest_enemy"),
				(try_end),
			(try_end),	#update division info
		(try_end),	#exploit closest agent data
	(try_end), #Agent Loop

	#calculate team sizes, sum positions; within calculate battle group averages
	(try_for_range, ":team", 0, 4),
	    (assign, ":team_size", 0),
		(assign, ":team_level", 0),
		(assign, ":team_x", 0),
		(assign, ":team_y", 0),
		
	    (try_for_range, ":division", 0, 9),
		    #sum for team averages
		    (store_add, ":slot", "slot_team_d0_size", ":division"),
		    (team_get_slot, ":division_size", ":team", ":slot"),
			(gt, ":division_size", 0),
			(val_add, ":team_size", ":division_size"),
			
			(store_add, ":slot", "slot_team_d0_level", ":division"),
		    (team_get_slot, ":division_level", ":team", ":slot"),
			(val_add, ":team_level", ":division_level"),
			
			(store_add, ":slot", "slot_team_d0_avg_x", ":division"),
		    (team_get_slot, ":division_x", ":team", ":slot"),
			(val_add, ":team_x", ":division_x"),
			
			(store_add, ":slot", "slot_team_d0_avg_y", ":division"),
		    (team_get_slot, ":division_y", ":team", ":slot"),
			(val_add, ":team_y", ":division_y"),
			
            #calculate battle group averages
			(store_add, ":slot", "slot_team_d0_level", ":division"),
			(val_div, ":division_level", ":division_size"),			
			(team_set_slot, ":team", ":slot", ":division_level"),
			
			(store_add, ":slot", "slot_team_d0_percent_ranged", ":division"),
			(team_get_slot, ":value", ":team", ":slot"),
			(val_mul, ":value", 100),
			(val_div, ":value", ":division_size"), 
			(team_set_slot, ":team", ":slot", ":value"),	

			(store_add, ":slot", "slot_team_d0_percent_throwers", ":division"),
			(team_get_slot, ":value", ":team", ":slot"),
			(val_mul, ":value", 100),
			(val_div, ":value", ":division_size"), 
			(team_set_slot, ":team", ":slot", ":value"),	
		
			(store_add, ":slot", "slot_team_d0_weapon_length", ":division"),
		    (team_get_slot, ":value", ":team", ":slot"),
			(val_div, ":value", ":division_size"),
			(team_set_slot, ":team", ":slot", ":value"),
			
			# (store_add, ":slot", "slot_team_d0_swung_weapon_length", ":division"),	MOTO systematic testing shows best to use max swung weapon length as basis for formation spacing
		    # (team_get_slot, ":value", ":team", ":slot"),
			# (val_div, ":value", ":division_size"),
			# (team_set_slot, ":team", ":slot", ":value"),
			
			(store_add, ":slot", "slot_team_d0_front_agents", ":division"),
			(team_get_slot, reg0, ":team", ":slot"),
			(try_begin),
				(gt, reg0, 0),
				(store_add, ":slot", "slot_team_d0_front_weapon_length", ":division"),
				(team_get_slot, ":value", ":team", ":slot"),
				(val_div, ":value", reg0),
				(team_set_slot, ":team", ":slot", ":value"),
			(try_end),
			
			(store_add, ":slot", "slot_team_d0_avg_x", ":division"),
			(val_div, ":division_x", ":division_size"),
		    (team_set_slot, ":team", ":slot", ":division_x"),
			
			(store_add, ":slot", "slot_team_d0_avg_y", ":division"),
			(val_div, ":division_y", ":division_size"),
		    (team_set_slot, ":team", ":slot", ":division_y"),
			
			(store_add, ":slot", "slot_team_d0_type", ":division"),
			(team_get_slot, reg0, ":team", ":slot"),
			(try_begin),
				(neg|is_between, reg0, 0, 8),	#TODO reset on reinforcements
                (call_script, "script_store_battlegroup_type", ":team", ":division"),
			(try_end),
		(try_end), #Division Loop
		
		#Team Leader Additions
		(try_begin),
		    (eq, ":team", 0),
			(val_add, ":team_size", ":team0_leader"),
			(val_add, ":team_level", ":team0_level_leader"),
			(val_add, ":team_x", ":team0_x_leader"),
			(val_add, ":team_y", ":team0_y_leader"),
		(else_try),
		    (eq, ":team", 1),
			(val_add, ":team_size", ":team1_leader"),
			(val_add, ":team_level", ":team1_level_leader"),
			(val_add, ":team_x", ":team1_x_leader"),
			(val_add, ":team_y", ":team1_y_leader"),
		(else_try),
			(eq, ":team", 2),
			(val_add, ":team_size", ":team2_leader"),
			(val_add, ":team_level", ":team2_level_leader"),
			(val_add, ":team_x", ":team2_x_leader"),
			(val_add, ":team_y", ":team2_y_leader"),
		(else_try),
			(eq, ":team", 3),
			(val_add, ":team_size", ":team3_leader"),
			(val_add, ":team_level", ":team3_level_leader"),
			(val_add, ":team_x", ":team3_x_leader"),
			(val_add, ":team_y", ":team3_y_leader"),		
		(try_end),
		
		#calculate team averages 
		(gt, ":team_size", 0),
		(team_set_slot, ":team", "slot_team_size", ":team_size"),
		(val_div, ":team_level", ":team_size"),
		(team_set_slot, ":team", "slot_team_level", ":team_level"),
			
		(val_div, ":team_x", ":team_size"),
		(team_set_slot, ":team", "slot_team_avg_x", ":team_x"),
		(val_div, ":team_y", ":team_size"),
		(team_set_slot, ":team", "slot_team_avg_y", ":team_y"),
	(try_end), #Team Loop
	]),

  # script_battlegroup_get_position by motomataru #CABA - EDITED TO USE SLOTS, NOT STORED POS NUMBERS
  # Input: destination position, team, division
  # Output:	battle group position
  #			average team position if "troop class" input NOT set to 0-8
  # NB: Assumes that battle groups beyond 2 are PLAYER team
  ("battlegroup_get_position", [
	(store_script_param, ":bgposition", 1),
	(store_script_param, ":bgteam", 2),
	(store_script_param, ":bgdivision", 3),
	
	(assign, ":x", 0),
	(assign, ":y", 0),
	(init_position, ":bgposition"),
	(try_begin),
		(neg|is_between, ":bgdivision", 0, 9),
		(team_slot_ge, ":bgteam", "slot_team_size", 1),
		(team_get_slot, ":x", ":bgteam", "slot_team_avg_x"),
		(team_get_slot, ":y", ":bgteam", "slot_team_avg_y"),
	(else_try),
		(is_between, ":bgdivision", 0, 9),
		(store_add, ":slot", "slot_team_d0_size", ":bgdivision"),
		(team_slot_ge, ":bgteam", ":slot", 1),
		
		(store_add, ":slot", "slot_team_d0_avg_x", ":bgdivision"),
		(team_get_slot, ":x", ":bgteam", ":slot"),
		
		(store_add, ":slot", "slot_team_d0_avg_y", ":bgdivision"),
		(team_get_slot, ":y", ":bgteam", ":slot"),
	(try_end),
	(position_set_x, ":bgposition", ":x"),
	(position_set_y, ":bgposition", ":y"),
	(position_set_z_to_ground_level, ":bgposition"),
  ]),	
 
  # script_battlegroup_get_attack_destination by motomataru
  # Input: destination position, team, division, target team, target division
  # Output:	melee position against target battlegroup
  ("battlegroup_get_attack_destination", [
	(store_script_param, ":bgposition", 1),
	(store_script_param, ":bgteam", 2),
	(store_script_param, ":bgdivision", 3),
	(store_script_param, ":enemy_team", 4),
	(store_script_param, ":enemy_division", 5),
	
	(store_add, ":slot", "slot_team_d0_formation", ":bgdivision"),
	(team_get_slot, ":bgformation", ":bgteam", ":slot"),
	(try_begin),
		(eq, ":bgformation", formation_none),
		(call_script, "script_battlegroup_get_position", ":bgposition", ":bgteam", ":bgdivision"),
	(else_try),
		(call_script, "script_formation_current_position", ":bgposition", ":bgteam", ":bgdivision"),
	(try_end),
	
	#distance to enemy center
	(store_add, ":slot", "slot_team_d0_formation", ":enemy_division"),
	(team_get_slot, ":enemy_formation", ":enemy_team", ":slot"),
	(call_script, "script_battlegroup_get_position", Enemy_Team_Pos, ":enemy_team", ":enemy_division"),	
	(get_distance_between_positions, ":distance_to_move", ":bgposition", Enemy_Team_Pos),
	
	(call_script, "script_battlegroup_get_action_radius", ":bgteam", ":bgdivision"),
	(assign, ":bgwidth", reg0),
	(call_script, "script_battlegroup_get_action_radius", ":enemy_team", ":enemy_division"),
	(store_add, ":combined_width", ":bgwidth", reg0),
	
	(assign, ":min_radius", reg0),
	(val_min, ":min_radius", ":bgwidth"),
	(val_div, ":min_radius", 2),	#function returns length of bg

	(try_begin),
		(neq, ":bgformation", formation_none),	#in formation AND
		(le, ":distance_to_move", ":combined_width"),	#close to enemy
		(store_mul, reg0, -350, formation_reform_interval),	#back up one move (to avoid wild swings / reversals on overruns)
		(position_move_y, ":bgposition", reg0),
		(get_distance_between_positions, ":distance_to_move", ":bgposition", Enemy_Team_Pos),
	(try_end),
	
	#subtract enemy center to edge-of-contact (determined by minimum half-width between the two battlegroups)
	(call_script, "script_get_distance_to_battlegroup", ":enemy_team", ":enemy_division", ":bgposition"),
	(store_mul, ":angle_adjusted_half_depth", ":min_radius", reg2),	#reg2 is cosine glancing angle, FP
	(convert_from_fixed_point, ":angle_adjusted_half_depth"),
	(try_begin),
		(neq, ":enemy_formation", formation_wedge),
		(call_script, "script_battlegroup_dist_center_to_front", ":enemy_team", ":enemy_division"),
		(val_max, ":angle_adjusted_half_depth", reg0),
	(try_end),
	(val_sub, ":distance_to_move", ":angle_adjusted_half_depth"),

	#modify by bg center to edge-of-contact, if needed
	(call_script, "script_battlegroup_dist_center_to_front", ":bgteam", ":bgdivision"),
	(assign, ":bg_half_depth", reg0),
	(try_begin),
		(eq, ":bgformation", formation_none),
		(val_sub, ":distance_to_move", ":bg_half_depth"),	#position from script_battlegroup_get_position is in middle of bg
	(else_try),
		(eq, ":bgformation", formation_wedge),
		(call_script, "script_battlegroup_dist_center_to_front", ":enemy_team", ":enemy_division"),
		(val_add, ":distance_to_move", reg0),	#move in from nearest edge found by script_get_distance_to_battlegroup
		(val_add, ":distance_to_move", ":bg_half_depth"),	#drive wedge through target formation!
	(try_end),
	
	#modify by speed differentialgdw081715
# 	(try_begin),
# 		(neq, ":enemy_formation", formation_none),
# 		(neq, ":enemy_formation", formation_default),
# 		(store_add, ":slot", "slot_team_d0_first_member", ":enemy_division"),
# 		(team_get_slot, reg0, ":enemy_team", ":slot"),
# 	(try_begin),
# (eq, reg0, -1),
# (assign, reg1, ":enemy_team"),
# (assign, reg2, ":enemy_division"),
# (assign, reg3, ":enemy_formation"),
# (display_debug_message, "@script_battlegroup_get_attack_destination: bad first agent team {reg1} division {reg2} formation {reg3}"),
# (assign, ":enemy_formation_speed", 0),
# (else_try),
# 		(agent_get_speed, Speed_Pos, reg0),
# 		(init_position, Temp_Pos),
# 		(get_distance_between_positions, ":enemy_formation_speed", Speed_Pos, Temp_Pos),
# 		(val_mul, ":enemy_formation_speed", formation_reform_interval),	#calculate distance to next call
# (try_end),
 ##commond error:At script: battlegroup_get_attack_destination. At script: battlegroup_get_attack_destination. SCRIPT WARNING ON OPCODE 1689: Invalid Agent ID: 0; LINE NO: 64:
  # todo: fix "battlegroup_get_attack_destination": `:enemy_formation_speed` not used.
		#(try_begin),
		#	(position_is_behind_position, ":bgposition", Enemy_Team_Pos),	#attacking from rear?
		#	(val_add, ":distance_to_move", ":enemy_formation_speed"),	#catch up to anticipated position
		#(else_try),	#attacking enemy formation from front
		#	(store_add, ":slot", "slot_team_d0_in_melee", ":bgdivision"),
		#	(team_slot_eq, ":bgteam", ":slot", 0),
		#	(val_sub, ":distance_to_move", ":enemy_formation_speed"),	#avoid overrunning enemy
		#(try_end),
	#(try_end),

	(store_add, ":slot", "slot_team_d0_front_weapon_length", ":bgdivision"),
	(team_get_slot, ":striking_distance", ":bgteam", ":slot"),
	(val_sub, ":distance_to_move", ":striking_distance"),
	
	(call_script, "script_point_y_toward_position", ":bgposition", Enemy_Team_Pos),
	(position_move_y, ":bgposition", ":distance_to_move"),
  ]),
 
  # script_battlegroup_dist_center_to_front by motomataru
  # Input: team, division
  # Output:	reg0 distance to front of battlegroup from center in cm
  ("battlegroup_dist_center_to_front", [
	(store_script_param, ":bgteam", 1),
	(store_script_param, ":bgdivision", 2),

	(assign, ":depth", 0),
	(store_add, ":slot", "slot_team_d0_formation_space", ":bgdivision"),
	(team_get_slot, ":spacing", ":bgteam", ":slot"),
	(store_add, ":slot", "slot_team_d0_formation", ":bgdivision"),
	(team_get_slot, ":bgformation", ":bgteam", ":slot"),
	
	(try_begin),
		(eq, ":bgformation", formation_none),
		(try_begin),
			(lt, ":spacing", 0),	#Native multi-ranks?
			(store_mul, ":depth", ":spacing", -1),
			(val_mul, ":depth", 100),
		(try_end),
		
	(else_try),	#three-rank formations
		(store_mul, ":row_depth", ":spacing", 50),
		(val_add, ":row_depth", formation_minimum_spacing),
		
		(this_or_next|eq, ":bgformation", formation_ranks),
		(eq, ":bgformation", formation_shield),
		(store_mul, ":depth", ":row_depth", 2),
		
	(else_try),
		(store_add, ":slot", "slot_team_d0_size", ":bgdivision"),
		(team_get_slot, ":size_enemy_battlegroup", ":bgteam", ":slot"),
		(convert_to_fixed_point, ":size_enemy_battlegroup"),
		(store_sqrt, ":columns", ":size_enemy_battlegroup"),
		
		(eq, ":bgformation", formation_square),
		(convert_from_fixed_point, ":columns"),
		(val_add, ":columns", 1),	#see script_form_infantry
		(store_div, ":rows", ":size_enemy_battlegroup", ":columns"),
		(store_mul, ":depth", ":row_depth", ":rows"),
		(convert_from_fixed_point, ":depth"),
		(val_sub, ":depth", ":row_depth"),
		
	(else_try),
		(eq, ":bgformation", formation_wedge),
		(store_mul, ":depth", ":row_depth", ":columns"),	#approximation
		(convert_from_fixed_point, ":depth"),
	(try_end),
	
	(try_begin),
		(neq, ":bgformation", formation_wedge),
		(store_div, reg0, ":depth", 2),
	(else_try),
		(store_mul, reg0, ":depth", 2),	#another approximation (height - inner radius)
		(val_div, reg0, 3),
	(try_end),
  ]),	
 
  # script_battlegroup_get_action_radius by motomataru
  # Input: team, division
  # Output:	reg0 radius of battlegroup's "zone of control" (now length of battlegroup in cm)
  ("battlegroup_get_action_radius", [
	(store_script_param, ":bgteam", 1),
	(store_script_param, ":bgdivision", 2),

	(store_add, ":slot", "slot_team_d0_size", ":bgdivision"),
	(team_get_slot, ":size_battlegroup", ":bgteam", ":slot"),
	(store_add, ":slot", "slot_team_d0_formation", ":bgdivision"),
	(team_get_slot, ":formation", ":bgteam", ":slot"),
	(store_add, ":slot", "slot_team_d0_type", ":bgdivision"),
	(team_get_slot, ":div_type", ":bgteam", ":slot"),
	(store_add, ":slot", "slot_team_d0_formation_space", ":bgdivision"),
	(team_get_slot, ":spacing", ":bgteam", ":slot"),
	
	(try_begin),
		(this_or_next|eq, ":div_type", sdt_archer),
		(eq, ":formation", formation_none),
		(try_begin),
			(ge, ":spacing", 0),
			(store_mul, ":troop_space", ":spacing", 75),	#Native minimum spacing not consistent but around this
			(val_add, ":troop_space", 100),
		(else_try),	#handle Native multi-ranks
			(assign, ":troop_space", 150),
			(val_mul, ":spacing", -1),
			(val_add, ":spacing", 1),
			(val_div, ":size_battlegroup", ":spacing"),
		(try_end),
		(store_mul, ":formation_width", ":size_battlegroup", ":troop_space"),
		(store_div, reg0, ":formation_width", 2),
	(else_try),
		(eq, ":formation", formation_wedge),
		(call_script, "script_get_centering_amount", formation_square, ":size_battlegroup", ":spacing"),
		(val_mul, reg0, 7),
		(val_div, reg0, 6),
	(else_try),
(try_begin),
(lt, ":spacing", 0),
(assign, reg0, ":bgteam"),
(assign, reg1, ":bgdivision"),
(assign, reg2, ":formation"),
(display_message, "@battlegroup_get_action_radius: negative radius for team {reg0} division {reg1} formation {reg2}"),
(try_end),
		(call_script, "script_get_centering_amount", ":formation", ":size_battlegroup", ":spacing"),
	(try_end),
	
	(val_mul, reg0, 2),
  ]),	
 
  # script_team_get_position_of_enemies by motomataru
  # Input: destination position, team, troop class/division
  # Output: destination position: average position if reg0 > 0
  #			reg0: number of enemies
  # Run script_store_battlegroup_data before calling!
  ("team_get_position_of_enemies", [
	(store_script_param, ":enemy_position", 1),
	(store_script_param, ":team_no", 2),
	(store_script_param, ":troop_type", 3),
	(assign, ":pos_x", 0),
	(assign, ":pos_y", 0),
	(assign, ":total_size", 0),
	(try_begin),
		(neq, ":troop_type", grc_everyone),
		(assign, ":closest_distance", Far_Away),
		(call_script, "script_battlegroup_get_position", Temp_Pos, ":team_no", grc_everyone),
	(try_end),
	
	(try_for_range, ":other_team", 0, 4),
		(teams_are_enemies, ":other_team", ":team_no"),
		(try_begin),
			(eq, ":troop_type", grc_everyone),
			(team_get_slot, ":team_size", ":other_team", "slot_team_size"),
			(try_begin),
				(gt, ":team_size", 0),
				(call_script, "script_battlegroup_get_position", ":enemy_position", ":other_team", grc_everyone),
				(position_get_x, reg0, ":enemy_position"),
				(val_mul, reg0, ":team_size"),
				(val_add, ":pos_x", reg0),
				(position_get_y, reg0, ":enemy_position"),
				(val_mul, reg0, ":team_size"),
				(val_add, ":pos_y", reg0),
			(try_end),
		(else_try),	#for multiple divisions, should find the CLOSEST of a given type
			(assign, ":team_size", 0),
			(try_for_range, ":enemy_battle_group", 0, 9),
				(store_add, ":slot", "slot_team_d0_size", ":enemy_battle_group"),
	            (team_get_slot, ":troop_count", ":other_team", ":slot"),
				(gt, ":troop_count", 0),
				(store_add, ":slot", "slot_team_d0_type", ":enemy_battle_group"),
				(team_get_slot, ":bg_type", ":other_team", ":slot"),
				(store_sub, ":bg_root_type", ":bg_type", 3), #subtype is three more than main type
				(this_or_next|eq, ":bg_type", ":troop_type"),
				(eq, ":bg_root_type", ":troop_type"),
				(val_add, ":team_size", ":troop_count"),
				(call_script, "script_battlegroup_get_position", ":enemy_position", ":other_team", ":enemy_battle_group"),
				(get_distance_between_positions, reg0, Temp_Pos, ":enemy_position"),
				(lt, reg0, ":closest_distance"),
				(assign, ":closest_distance", reg0),
				(position_get_x, ":pos_x", ":enemy_position"),
				(position_get_y, ":pos_y", ":enemy_position"),
			(try_end),
		(try_end),
		(val_add, ":total_size", ":team_size"),
	(try_end),
	
	(try_begin),
		(eq, ":total_size", 0),
		(init_position, ":enemy_position"),
	(else_try),
	    (eq, ":troop_type", grc_everyone),
		(val_div, ":pos_x", ":total_size"),
		(position_set_x, ":enemy_position", ":pos_x"),
		(val_div, ":pos_y", ":total_size"),
		(position_set_y, ":enemy_position", ":pos_y"),
		(position_set_z_to_ground_level, ":enemy_position"),
	(else_try),
		(position_set_x, ":enemy_position", ":pos_x"),
		(position_set_y, ":enemy_position", ":pos_y"),
		(position_set_z_to_ground_level, ":enemy_position"),
	(try_end),

	(assign, reg0, ":total_size"),
  ]),

  # script_get_distance_to_battlegroup by motomataru
  # Gets distance from "from position" to the theoretical nearest side of the battlegroup, accounting for rotation of battlegroup
  # Input: bg team, bg division, from position
  # Output: reg2 abs (cos (BG direction - 90 - direction from "from position")) fixed point
  #         reg1 BG radius x reg2 in cms
  #         reg0 distance in cms between BG position and "from position" minus reg1 (could be negative)
  # Uses pos0, pos61
  ("get_distance_to_battlegroup", [
	(store_script_param, ":bgteam", 1),
	(store_script_param, ":bgdivision", 2),
	(store_script_param, ":from_pos", 3),
	
	(store_add, ":slot", "slot_team_d0_formation", ":bgdivision"),
	(team_get_slot, ":bgformation", ":bgteam", ":slot"),
	(call_script, "script_battlegroup_get_action_radius", ":bgteam", ":bgdivision"),
	(store_div, ":radius", reg0, 2),	#function returns length of bg
	(assign, ":min_cos_theta", 1),
	(convert_to_fixed_point, ":min_cos_theta"),
	(try_begin),
		(eq, ":bgformation", formation_wedge),
		(val_mul, ":min_cos_theta", 58),	#relation inscribed circle radius to half side: 1 / sqrt 3
		(val_div, ":min_cos_theta", 100),
	(else_try),
		(gt, ":radius", 0),
		(call_script, "script_battlegroup_dist_center_to_front", ":bgteam", ":bgdivision"),
		(val_mul, ":min_cos_theta", reg0),
		(val_div, ":min_cos_theta", ":radius"),
	(else_try),
		(assign, ":min_cos_theta", 0),
	(try_end),
	
	#acquire rotations
	(call_script, "script_battlegroup_get_position", pos0, ":bgteam", ":bgdivision"),
	(try_begin),
		(neq, ":bgformation", formation_none),
		(neq, ":bgformation", formation_default),
		(call_script, "script_get_formation_destination", pos61, ":bgteam", ":bgdivision"),
		(position_copy_rotation, pos0, pos61),
	(try_end),
	
	(copy_position, pos61, ":from_pos"),
	(call_script, "script_point_y_toward_position", pos61, pos0),
	(assign, ":distance_to_battlegroup", reg0),
	
	#calculate difference from center of bg
	(get_angle_between_positions, ":theta", pos61, pos0),
	(val_sub, ":theta", 9000),
	(store_cos, ":cos_theta", ":theta"),
	(val_abs, ":cos_theta"),
	(val_max, ":cos_theta", ":min_cos_theta"),	#doing depth considerations this way allows calling func to use angle; it also avoids Pythagorean calcs
	
	(store_mul, reg1, ":radius", ":cos_theta"),
	(convert_from_fixed_point, reg1),
	(val_sub, ":distance_to_battlegroup", reg1),
	(assign, reg0, ":distance_to_battlegroup"),
	(assign, reg2, ":cos_theta"),
  ]),
  
# Autoloot improved by rubik begin
  # # Autoloot improved by rubik end chief

# # M&B Standard AI with changes for formations #CABA - OK; Need expansion when new AI divisions to work with
  # script_formation_battle_tactic_init_aux
  # Input: team_no, battle_tactic
  # Output: none
  ("formation_battle_tactic_init_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
      (team_get_leader, ":ai_leader", ":team_no"),
      (try_begin),
        (eq, ":battle_tactic", btactic_hold),
        (agent_get_position, pos1, ":ai_leader"),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30),
        (copy_position, pos1, pos52),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30), # call again just in case we are not at peak point.
        (copy_position, pos1, pos52),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30), # call again just in case we are not at peak point.
        (team_give_order, ":team_no", grc_everyone, mordr_hold),
        (team_set_order_position, ":team_no", grc_everyone, pos52),
        (team_give_order, ":team_no", grc_archers, mordr_advance),
        (team_give_order, ":team_no", grc_archers, mordr_advance),
      (else_try),
        (eq, ":battle_tactic", btactic_follow_leader),
        (team_get_leader, ":ai_leader", ":team_no"),
        (ge, ":ai_leader", 0),
        (agent_set_speed_limit, ":ai_leader", 8),
        (agent_get_position, pos60, ":ai_leader"),
        (team_give_order, ":team_no", grc_everyone, mordr_hold),
        (team_set_order_position, ":team_no", grc_everyone, pos60),
      (try_end),
# formations additions chief
	  (call_script, "script_division_reset_places"),
	  (call_script, "script_get_default_formation", ":team_no"),
	  (assign, ":fformation", reg0),
	  
	  (try_begin),
		(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_infantry, ":fformation"),
		(store_add, ":slot", "slot_team_d0_formation", grc_infantry),
		(team_set_slot, ":team_no", ":slot", ":fformation"),
		(store_add, ":slot", "slot_team_d0_formation_space", grc_infantry),
		(team_set_slot, ":team_no", ":slot", 0),
	  (else_try),
		(call_script, "script_formation_end", ":team_no", grc_infantry),
	  (try_end),
	  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_infantry),
	  
	  (try_begin),
		(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_archers, formation_default),
		(store_add, ":slot", "slot_team_d0_formation", grc_archers),
		(team_set_slot, ":team_no", ":slot", formation_default),
		(store_add, ":slot", "slot_team_d0_formation_space", grc_archers),
		(team_set_slot, ":team_no", ":slot", 2),
	  (else_try),
		(call_script, "script_formation_end", ":team_no", grc_archers),
	  (try_end),
	  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_archers),
	  
	  (try_begin),
		(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_cavalry, formation_wedge),
		(store_add, ":slot", "slot_team_d0_formation", grc_cavalry),
		(team_set_slot, ":team_no", ":slot", formation_wedge),
		(store_add, ":slot", "slot_team_d0_formation_space", grc_cavalry),
		(team_set_slot, ":team_no", ":slot", 0),
	  (else_try),
		(call_script, "script_formation_end", ":team_no", grc_cavalry),
	  (try_end),
	  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_cavalry),
	  
	  (team_give_order, ":team_no", grc_archers, mordr_spread_out),
	  (team_give_order, ":team_no", grc_archers, mordr_spread_out),
# end formations additions chief
  ]),
  
  # script_formation_battle_tactic_apply_aux #CABA - OK; Need expansion when new AI divisions to work with
  # Input: team_no, battle_tactic
  # Output: battle_tactic
  ("formation_battle_tactic_apply_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
      (store_mission_timer_a, ":mission_time"),
      (try_begin),
        (eq, ":battle_tactic", btactic_hold),
        (copy_position, pos1, pos52),
        (call_script, "script_get_closest3_distance_of_enemies_at_pos1", ":team_no", 1),
        (assign, ":avg_dist", reg0),
        (assign, ":min_dist", reg1),
        (try_begin),
          (this_or_next|lt, ":min_dist", 1000),
          (lt, ":avg_dist", 4000),
          (assign, ":battle_tactic", 0),
		  (call_script, "script_formation_end", ":team_no", grc_infantry),	#formations chief
		  (call_script, "script_formation_end", ":team_no", grc_archers),	#formations chief
		  (call_script, "script_formation_end", ":team_no", grc_cavalry),	#formations chief
          (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (try_end),
      (else_try),
        (eq, ":battle_tactic", btactic_follow_leader),
        (team_get_leader, ":ai_leader", ":team_no"),
        (try_begin),
          (agent_is_alive, ":ai_leader"),
          (agent_set_speed_limit, ":ai_leader", 9),
          (call_script, "script_team_get_average_position_of_enemies", ":team_no"),
          (copy_position, pos60, pos0),
          (ge, ":ai_leader", 0),
          (agent_get_position, pos61, ":ai_leader"),
          (position_transform_position_to_local, pos62, pos61, pos60), #pos62 = vector to enemy w.r.t leader
          (position_normalize_origin, ":distance_to_enemy", pos62),
          (convert_from_fixed_point, ":distance_to_enemy"),
          (assign, reg17, ":distance_to_enemy"),
          (position_get_x, ":dir_x", pos62),
          (position_get_y, ":dir_y", pos62),
          (val_mul, ":dir_x", 23),
          (val_mul, ":dir_y", 23), #move 23 meters
          (position_set_x, pos62, ":dir_x"),
          (position_set_y, pos62, ":dir_y"),
        
          (position_transform_position_to_parent, pos63, pos61, pos62), #pos63 is 23m away from leader in the direction of the enemy.
          (position_set_z_to_ground_level, pos63),
        
          (team_give_order, ":team_no", grc_everyone, mordr_hold),
          (team_set_order_position, ":team_no", grc_everyone, pos63),
#formations code chief chief
		  (call_script, "script_point_y_toward_position", pos63, pos60),
		  (agent_get_position, pos49, ":ai_leader"),
		  (agent_set_position, ":ai_leader", pos63),	#fake out script_battlegroup_place_around_leader
		  (call_script, "script_division_reset_places"),
		  (call_script, "script_get_default_formation", ":team_no"),
		  (assign, ":fformation", reg0),
		  
		  (try_begin),
			(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_infantry, ":fformation"),
			(store_add, ":slot", "slot_team_d0_formation", grc_infantry),
			(team_set_slot, ":team_no", ":slot", ":fformation"),
			(store_add, ":slot", "slot_team_d0_formation_space", grc_infantry),
			(team_set_slot, ":team_no", ":slot", 0),
		  (else_try),
			(call_script, "script_formation_end", ":team_no", grc_infantry),
		  (try_end),
		  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_infantry),
		  
		  (try_begin),
			(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_archers, formation_default),
			(store_add, ":slot", "slot_team_d0_formation", grc_archers),
			(team_set_slot, ":team_no", ":slot", formation_default),
			(store_add, ":slot", "slot_team_d0_formation_space", grc_archers),
			(team_set_slot, ":team_no", ":slot", 2),
		  (else_try),
			(call_script, "script_formation_end", ":team_no", grc_archers),
		  (try_end),
		  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_archers),
		  
		  (try_begin),
			(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_cavalry, formation_wedge),
			(store_add, ":slot", "slot_team_d0_formation", grc_cavalry),
			(team_set_slot, ":team_no", ":slot", formation_wedge),
			(store_add, ":slot", "slot_team_d0_formation_space", grc_cavalry),
			(team_set_slot, ":team_no", ":slot", 0),
		  (else_try),
			(call_script, "script_formation_end", ":team_no", grc_cavalry),
		  (try_end),
		  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_cavalry),
	  
		  (agent_set_position, ":ai_leader", pos49),
#end formations code chief
          (agent_get_position, pos1, ":ai_leader"),
          (try_begin),
            (lt, ":distance_to_enemy", 50),
            (ge, ":mission_time", 30),
            (assign, ":battle_tactic", 0),
			(call_script, "script_formation_end", ":team_no", grc_infantry),	#formations chief
			(call_script, "script_formation_end", ":team_no", grc_archers),	#formations chief
			(call_script, "script_formation_end", ":team_no", grc_cavalry),	#formations chief
            (team_give_order, ":team_no", grc_everyone, mordr_charge),
            (agent_set_speed_limit, ":ai_leader", 60),
          (try_end),
        (else_try),
          (assign, ":battle_tactic", 0),
		  (call_script, "script_formation_end", ":team_no", grc_infantry),	#formations chief
		  (call_script, "script_formation_end", ":team_no", grc_archers),	#formations chief
		  (call_script, "script_formation_end", ":team_no", grc_cavalry),	#formations chief
          (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (try_end),
      (try_end),
      
      (try_begin), # charge everyone after a while
        (neq, ":battle_tactic", 0),
        (ge, ":mission_time", 300),
        (assign, ":battle_tactic", 0),
		(call_script, "script_formation_end", ":team_no", grc_infantry),	#formations chief
		(call_script, "script_formation_end", ":team_no", grc_archers),	#formations chief
		(call_script, "script_formation_end", ":team_no", grc_cavalry),	#formations chief
        (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (team_get_leader, ":ai_leader", ":team_no"),
        (agent_set_speed_limit, ":ai_leader", 60),
      (try_end),
      (assign, reg0, ":battle_tactic"),
  ]),
  
  # Replacement script for battle_tactic_init_aux to switch between using
  # M&B Standard AI with changes for formations and original based on
  # NOTE: original script "battle_tactic_init_aux" should be renamed to "orig_battle_tactic_init_aux"
  # constant formation_native_ai_use_formation ( 0: original, 1: use formation )
  # script_battle_tactic_init_aux
  # Input: team_no, battle_tactic
  # Output: none
  ("battle_tactic_apply_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
	  (try_begin),
		(eq, formation_native_ai_use_formation, 1),
		(call_script, "script_formation_battle_tactic_apply_aux", ":team_no", ":battle_tactic"),
	  (else_try),
		(call_script, "script_orig_battle_tactic_apply_aux", ":team_no", ":battle_tactic"),
	  (try_end),
		(assign, "$g_fire_arrow_mode_enemy", 0), #fire arrow chief
      ]),

  ("battle_tactic_init_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
	  (try_begin),
		(eq, formation_native_ai_use_formation, 1),
		(call_script, "script_formation_battle_tactic_init_aux", ":team_no", ":battle_tactic"),
	  (else_try),
		(call_script, "script_orig_battle_tactic_init_aux", ":team_no", ":battle_tactic"),
	  (try_end),
		(assign, "$g_fire_arrow_mode_enemy", 1), #fire arrow chief
   ]),

  ("heal_long_term_wounds",
    [
				(try_begin),
					(eq,"$wound_type",1), #Slight - Cut Arm
					(display_message,"@Your cut arm finally heals."),
					(troop_raise_attribute,"trp_player",ca_strength,1),
				(else_try),
					(eq,"$wound_type",2), #Slight - Cut Torso
					(display_message,"@The cut on your torso finally heals."),
					(troop_raise_attribute,"trp_player",ca_strength,1),
					(troop_raise_attribute,"trp_player",ca_agility,1),
				(else_try),
					(eq,"$wound_type",3), #Slight - Blow to Head
					(display_message,"@Your thoughts clear."),
					(troop_raise_attribute,"trp_player",ca_intelligence,1),
				(else_try),
					(eq,"$wound_type",4), #Slight - Blow to Leg
					(display_message,"@Your leg finally heals."),
					(troop_raise_attribute,"trp_player",ca_agility,1),
				(else_try),
					(eq,"$wound_type",5), #Severe - Broken Arm
					(display_message,"@Your broken arm finally heals."),
					(troop_raise_attribute,"trp_player",ca_strength,3),
					(troop_raise_skill, "trp_player",skl_power_strike,1),
					(troop_raise_skill, "trp_player",skl_power_draw,1),
				(else_try),
					(eq,"$wound_type",6), #Severe - Broken Rib
					(display_message,"@Your broken rib finally heals."),
					(troop_raise_attribute,"trp_player",ca_strength,2),
					(troop_raise_attribute,"trp_player",ca_agility,2),
					(troop_raise_skill, "trp_player",skl_ironflesh,1),
				(else_try),
					(eq,"$wound_type",7), #Severe - Heavy Blow to Head
					(display_message,"@Your headache is finally gone."),
					(troop_raise_attribute,"trp_player",ca_intelligence,2),
					(troop_raise_skill, "trp_player",skl_leadership,1),
					(troop_raise_skill, "trp_player",skl_tactics,1),
				(else_try),
					(eq,"$wound_type",8), #Severe - Broken Leg
					(display_message,"@Your broken leg finally heals."),
					(troop_raise_attribute,"trp_player",ca_agility,3),
					(troop_raise_skill, "trp_player",skl_riding,1),
					(troop_raise_skill, "trp_player",skl_athletics,1),
				(try_end),
			(assign,"$wound_type",0),
			(assign,"$heal_day",0)
		]
	),
("restore_hitpoints",
  [(store_script_param, ":player_no", 1),
#       (store_script_param, ":event_type", 2),
# (eq,":sound","snd_horn"),
      
        (player_get_agent_id, ":agent",":player_no"),##At script: restore_hitpoints. At script: restore_hitpoints. At script: restore_hitpoints. SCRIPT WARNING ON OPCODE 406: Invalid Player ID: 0; LINE NO: 1: 
       #       (agent_get_position,pos6,":player_agent"),
       #               (play_sound, "snd_horn"),
       #             (agent_get_team, ":wielder_team", ":player_agent"),
       #              (agent_set_animation, ":player_agent", "anim_tekst"),
       # (assign, ":heal_count", 0),
       (try_for_agents,":agent"),
        #  (agent_is_alive,":agent"),    
        # (agent_get_team, ":target_team", ":agent"),
        #  (eq, ":target_team", ":wielder_team"),
         #(neq,":agent",":player_agent"),
         #(agent_set_slot,":agent", "slot_agent_has_been_healed", 0), #chief
         # (agent_get_position,pos4,":agent"),
         # (get_distance_between_positions,":dist",pos6,pos4),
         # (le,":dist",3500),
         #(agent_get_slot, ":healed", ":agent", "slot_agent_has_been_healed"),
        # (eq, ":healed", 0),
         (store_agent_hit_points, ":cur_hp",":agent",0),
         # (assign, reg1, ":cur_hp"), 
         #  (display_message,"original hitpoints {reg1}",0x6495ed),
          (try_begin),
              (lt,":cur_hp",100),
              (assign, reg4, ":cur_hp"),
              (store_agent_hit_points, ":cur_hit_points",":agent",1),
              (val_add,":cur_hit_points",15),
              (agent_set_hit_points,":agent",":cur_hit_points",1),
              (assign, ":cur_hit_points",reg2),
      (display_message,"@{!}DEBUG wounded troop recovers 15 hitpoints to total {reg2}",0x6495ed),
      (agent_play_sound, ":agent", "snd_man_victory"),
              # (agent_set_slot,":agent", "slot_agent_has_been_healed", 1),
              # (val_add, ":heal_count", 1),
         #(display_message, "@You heal."),
    # (store_script_param, ":agent", 1),
    #(play_sound,"snd_horn"),
    #(try_for_agents,":agent"),
    # (agent_is_alive,":agent"),
    # (agent_is_human,":agent"),
    # (agent_is_ally,":agent"),
#     (store_agent_hit_points,":hp",":agent",0),
#     (assign,  ":hp", reg0,), 
#     (display_message,"@{!}DEBUG -- current hitpoints are {reg0}"),
#     #(assign,reg0, ":hp"),
#     #(display_message,"wounded troop recovers 14 hitpoints",0x6495ed),
# ##       (try_begin),
# ##       (agent_set_animation, ":troop", "anim_horn_blow"),
# ###                           (agent_set_animation, ":agent", "anim_cheer"),
# ##       (try_end),
#
#        (val_add,":hp",14),
#        #(assign,reg1, 14),
#        (agent_set_hit_points,":agent",":hp",0),    
#        (assign, reg1, ":hp"), 
#        (agent_play_sound, ":agent", "snd_man_victory"),
#        #(display_message,"wounded troop recovers 14 hitpoints to {reg1}",0x6495ed),
#        (display_message,"@{!}DEBUG -- new hitpoints are {reg1}"),
       (try_end),          
      (try_end), 
       #(assign,reg1,":recovery"),
       
    #     (try_begin),from {reg0}hitpoints to total of {reg0}
    #  (gt, "$cheat_mode", 0),
    # # (display_message, "@{!}DEBUG -- partypathfinding: {reg7}"), 
    #  (display_message, "@{!}DEBUG -- Urpathfindingriding speedmultiplier: {reg9}"),     
    # (try_end),     
]),
("log_item_score_for_weapons",
  	[
  	# (store_script_param, ":item", 1),
   #  (store_script_param, ":imod", 2),
   #  (item_get_type, ":type", ":item"),  
    #(eq, ":item", 0),
	(assign, ":cur_score", 0),
	(assign, ":weapon", 0),
	(assign, ":imod", 0),

  	(try_for_range, ":item", "itm_club_stick", "itm_wessexbanner9"),
  	(eq, reg0, ":item"),
		(call_script, "script_get_item_score_with_imod", ":item", ":imod"),

		(lt, ":cur_score", reg0),
		(assign, ":cur_score", reg0),
		(assign, ":weapon", ":item"),
		(assign, reg2, ":weapon"),
		#(try_begin),
				#(gt, "$cheat_mode", 0),
			(display_debug_message, "@{!}DEBUG -- weapon: {reg2}"),
			(display_debug_message, "@{!}DEBUG -- itemscoreitem: {reg1}"),
			(display_debug_message, "@{!}DEBUG -- itemscore: {reg0}"),
			(display_debug_message, "@{!}DEBUG -- itemdamage: {reg10}"), 
		#(try_end),
	 (try_end),
   ]),
 # agent_get_item_slot_modifier = 3301 #(agent_get_item_slot_modifier, <destination>, <agent_no>, <item_slot_no>), #Stores <agent_no>'s <item_slot_no> modifier into <destination>
# 	(try_begin),
# 		(eq, ":weapon", "itm_no_item"),
# 		(assign, ":cur_score", 0),
# 		(try_for_range, ":item_slot", ek_item_0, ek_head),
# 			(agent_get_item_slot, ":item", ":agent", ":item_slot"),
# 			(gt, ":item", "itm_no_item"),
# 			(item_get_type, ":weapon_type", ":item"),
# 			(neq, ":weapon_type", itp_type_shield),

# 			(item_get_slot, reg0, ":item", "slot_item_needs_two_hands"),
# 			(this_or_next|eq, reg0, 0),
# 			(this_or_next|eq, ":force_shield", 0),
# 			(eq, ":shield", "itm_no_item"),
			
# 			(try_begin),#equipping longest item for the formation
# 				(neq, ":force_length", 0),
# 				(item_get_slot, ":item_length", ":item", "slot_item_length"),
# 				(try_begin),
# 					(lt, ":cur_score", ":item_length"),
# 					(assign, ":cur_score", ":item_length"),
# 					(assign, ":weapon", ":item"),
# 				(try_end),
# 			(else_try),
# 				(assign, ":imod", imodbit_plain),
# 				(agent_get_troop_id, ":troop_id", ":agent"),
# 				(try_begin),    #only heroes have item modifications
# 					(troop_is_hero, ":troop_id"),
# 					(try_for_range, ":troop_item_slot",  ek_item_0, ek_head),    # heroes have only 4 possible weapons (equipped)
# 						(troop_get_inventory_slot, reg0, ":troop_id", ":troop_item_slot"),  #Find Item Slot with same item ID as Equipped Weapon
# 						(eq, reg0, ":item"),
# 						(troop_get_inventory_slot_modifier, ":imod", ":troop_id", ":troop_item_slot"),
# 					(try_end),
# 				(try_end), 

# 				(call_script, "script_get_item_score_with_imod", ":item", ":imod"),
# 				(lt, ":cur_score", reg0),
# 				(assign, ":cur_score", reg0),
# 				(assign, ":weapon", ":item"),
# 			 (try_end),
# 		(try_end),
# 	(try_end),
#  	(agent_get_wielded_item, reg0, ":agent", 0),
# 	(try_begin),
# 		(neq, reg0, ":weapon"),
# 		(try_begin),
# 			(gt, ":shield", "itm_no_item"),
# 			(agent_get_wielded_item, reg0, ":agent", 1),
# 			(neq, reg0, ":shield"),	#reequipping secondary will UNequip (from experience)
# 			(agent_set_wielded_item, ":agent", ":shield"),
# 		(try_end),
# 		(gt, ":weapon", "itm_no_item"),
# 		(agent_set_wielded_item, ":agent", ":weapon"),
# 	(try_end),
#   ]),
#   Replacement script for battle_tactic_init_aux to switch between using
#   M&B Standard AI with changes for formations and original based on
#   NOTE: original script "battle_tactic_apply_aux" should be renamed to "orig_battle_tactic_apply_aux"
#   constant formation_native_ai_use_formation ( 0: original, 1: use formation )
#   script_battle_tactic_apply_aux
#   Input: team_no, battle_tactic
#   Output: battle_tactic

#script_game_missile_dives_into_water
# Called each time a missile dives into water
# INPUT
# script param 1 = missile item no
# script param 2 = missile item modifier
# script param 3 = launcher item no
# script param 4 = launcher item modifier
# script param 5 = shooter agent no
# script param 6 = missile no
# pos1 = water impact position and rotation
# ("game_missile_dives_into_water", [
#    (store_script_param, ":missile_item_no", 1),
#    (store_script_param, ":missile_item_modifier", 2),
#    (store_script_param, ":launcher_item_no", 3),
#    (store_script_param, ":launcher_item_modifier", 4),
#    (store_script_param, ":shooter_agent_no", 5),
#    (store_script_param, ":missile_no", 6),
# ]),

] \
+ multiplayer.scripts \
+ economy.scripts \
+ enterprise.scripts \
+ tournaments.scripts \
+ game_start.scripts \
+ notes.scripts \
+ companions.scripts \
+ caravans.scripts \
+ villages.scripts \
+ diplomacy.scripts \
+ mission_template_triggers.scripts \
+ battle.scripts \
+ patrols.scripts \
+ constable.scripts \
